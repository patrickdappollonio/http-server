var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.mermaid = factory());
})(this, function() {
  "use strict";
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getAugmentedNamespace(n) {
    var f = n.default;
    if (typeof f == "function") {
      var a2 = function() {
        return f.apply(this, arguments);
      };
      a2.prototype = f.prototype;
    } else
      a2 = {};
    Object.defineProperty(a2, "__esModule", { value: true });
    Object.keys(n).forEach(function(k2) {
      var d = Object.getOwnPropertyDescriptor(n, k2);
      Object.defineProperty(a2, k2, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k2];
        }
      });
    });
    return a2;
  }
  function commonjsRequire(path2) {
    throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }
  var moment_min = { exports: {} };
  (function(module3, exports2) {
    !function(e, t) {
      module3.exports = t();
    }(commonjsGlobal, function() {
      var H;
      function f() {
        return H.apply(null, arguments);
      }
      function a2(e3) {
        return e3 instanceof Array || "[object Array]" === Object.prototype.toString.call(e3);
      }
      function F(e3) {
        return null != e3 && "[object Object]" === Object.prototype.toString.call(e3);
      }
      function c2(e3, t4) {
        return Object.prototype.hasOwnProperty.call(e3, t4);
      }
      function L(e3) {
        if (Object.getOwnPropertyNames)
          return 0 === Object.getOwnPropertyNames(e3).length;
        for (var t4 in e3)
          if (c2(e3, t4))
            return;
        return 1;
      }
      function o(e3) {
        return void 0 === e3;
      }
      function u2(e3) {
        return "number" == typeof e3 || "[object Number]" === Object.prototype.toString.call(e3);
      }
      function V(e3) {
        return e3 instanceof Date || "[object Date]" === Object.prototype.toString.call(e3);
      }
      function G(e3, t4) {
        for (var n2 = [], s3 = e3.length, i2 = 0; i2 < s3; ++i2)
          n2.push(t4(e3[i2], i2));
        return n2;
      }
      function E2(e3, t4) {
        for (var n2 in t4)
          c2(t4, n2) && (e3[n2] = t4[n2]);
        return c2(t4, "toString") && (e3.toString = t4.toString), c2(t4, "valueOf") && (e3.valueOf = t4.valueOf), e3;
      }
      function l(e3, t4, n2, s3) {
        return Pt(e3, t4, n2, s3, true).utc();
      }
      function m2(e3) {
        return null == e3._pf && (e3._pf = { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidEra: null, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], era: null, meridiem: null, rfc2822: false, weekdayMismatch: false }), e3._pf;
      }
      function A5(e3) {
        if (null == e3._isValid) {
          var t4 = m2(e3), n2 = j.call(t4.parsedDateParts, function(e4) {
            return null != e4;
          }), n2 = !isNaN(e3._d.getTime()) && t4.overflow < 0 && !t4.empty && !t4.invalidEra && !t4.invalidMonth && !t4.invalidWeekday && !t4.weekdayMismatch && !t4.nullInput && !t4.invalidFormat && !t4.userInvalidated && (!t4.meridiem || t4.meridiem && n2);
          if (e3._strict && (n2 = n2 && 0 === t4.charsLeftOver && 0 === t4.unusedTokens.length && void 0 === t4.bigHour), null != Object.isFrozen && Object.isFrozen(e3))
            return n2;
          e3._isValid = n2;
        }
        return e3._isValid;
      }
      function I(e3) {
        var t4 = l(NaN);
        return null != e3 ? E2(m2(t4), e3) : m2(t4).userInvalidated = true, t4;
      }
      var j = Array.prototype.some || function(e3) {
        for (var t4 = Object(this), n2 = t4.length >>> 0, s3 = 0; s3 < n2; s3++)
          if (s3 in t4 && e3.call(this, t4[s3], s3, t4))
            return true;
        return false;
      }, Z = f.momentProperties = [], z = false;
      function $(e3, t4) {
        var n2, s3, i2, r2 = Z.length;
        if (o(t4._isAMomentObject) || (e3._isAMomentObject = t4._isAMomentObject), o(t4._i) || (e3._i = t4._i), o(t4._f) || (e3._f = t4._f), o(t4._l) || (e3._l = t4._l), o(t4._strict) || (e3._strict = t4._strict), o(t4._tzm) || (e3._tzm = t4._tzm), o(t4._isUTC) || (e3._isUTC = t4._isUTC), o(t4._offset) || (e3._offset = t4._offset), o(t4._pf) || (e3._pf = m2(t4)), o(t4._locale) || (e3._locale = t4._locale), 0 < r2)
          for (n2 = 0; n2 < r2; n2++)
            o(i2 = t4[s3 = Z[n2]]) || (e3[s3] = i2);
        return e3;
      }
      function q(e3) {
        $(this, e3), this._d = new Date(null != e3._d ? e3._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), false === z && (z = true, f.updateOffset(this), z = false);
      }
      function h(e3) {
        return e3 instanceof q || null != e3 && null != e3._isAMomentObject;
      }
      function B2(e3) {
        false === f.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e3);
      }
      function e(r2, a3) {
        var o2 = true;
        return E2(function() {
          if (null != f.deprecationHandler && f.deprecationHandler(null, r2), o2) {
            for (var e3, t4, n2 = [], s3 = arguments.length, i2 = 0; i2 < s3; i2++) {
              if (e3 = "", "object" == typeof arguments[i2]) {
                for (t4 in e3 += "\n[" + i2 + "] ", arguments[0])
                  c2(arguments[0], t4) && (e3 += t4 + ": " + arguments[0][t4] + ", ");
                e3 = e3.slice(0, -2);
              } else
                e3 = arguments[i2];
              n2.push(e3);
            }
            B2(r2 + "\nArguments: " + Array.prototype.slice.call(n2).join("") + "\n" + new Error().stack), o2 = false;
          }
          return a3.apply(this, arguments);
        }, a3);
      }
      var J = {};
      function Q(e3, t4) {
        null != f.deprecationHandler && f.deprecationHandler(e3, t4), J[e3] || (B2(t4), J[e3] = true);
      }
      function d(e3) {
        return "undefined" != typeof Function && e3 instanceof Function || "[object Function]" === Object.prototype.toString.call(e3);
      }
      function X3(e3, t4) {
        var n2, s3 = E2({}, e3);
        for (n2 in t4)
          c2(t4, n2) && (F(e3[n2]) && F(t4[n2]) ? (s3[n2] = {}, E2(s3[n2], e3[n2]), E2(s3[n2], t4[n2])) : null != t4[n2] ? s3[n2] = t4[n2] : delete s3[n2]);
        for (n2 in e3)
          c2(e3, n2) && !c2(t4, n2) && F(e3[n2]) && (s3[n2] = E2({}, s3[n2]));
        return s3;
      }
      function K2(e3) {
        null != e3 && this.set(e3);
      }
      f.suppressDeprecationWarnings = false, f.deprecationHandler = null;
      var ee = Object.keys || function(e3) {
        var t4, n2 = [];
        for (t4 in e3)
          c2(e3, t4) && n2.push(t4);
        return n2;
      };
      function r(e3, t4, n2) {
        var s3 = "" + Math.abs(e3);
        return (0 <= e3 ? n2 ? "+" : "" : "-") + Math.pow(10, Math.max(0, t4 - s3.length)).toString().substr(1) + s3;
      }
      var te = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ne = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, se = {}, ie = {};
      function s2(e3, t4, n2, s3) {
        var i2 = "string" == typeof s3 ? function() {
          return this[s3]();
        } : s3;
        e3 && (ie[e3] = i2), t4 && (ie[t4[0]] = function() {
          return r(i2.apply(this, arguments), t4[1], t4[2]);
        }), n2 && (ie[n2] = function() {
          return this.localeData().ordinal(i2.apply(this, arguments), e3);
        });
      }
      function re2(e3, t4) {
        return e3.isValid() ? (t4 = ae(t4, e3.localeData()), se[t4] = se[t4] || function(s3) {
          for (var e4, i2 = s3.match(te), t5 = 0, r2 = i2.length; t5 < r2; t5++)
            ie[i2[t5]] ? i2[t5] = ie[i2[t5]] : i2[t5] = (e4 = i2[t5]).match(/\[[\s\S]/) ? e4.replace(/^\[|\]$/g, "") : e4.replace(/\\/g, "");
          return function(e6) {
            for (var t6 = "", n2 = 0; n2 < r2; n2++)
              t6 += d(i2[n2]) ? i2[n2].call(e6, s3) : i2[n2];
            return t6;
          };
        }(t4), se[t4](e3)) : e3.localeData().invalidDate();
      }
      function ae(e3, t4) {
        var n2 = 5;
        function s3(e4) {
          return t4.longDateFormat(e4) || e4;
        }
        for (ne.lastIndex = 0; 0 <= n2 && ne.test(e3); )
          e3 = e3.replace(ne, s3), ne.lastIndex = 0, --n2;
        return e3;
      }
      var oe = {};
      function t(e3, t4) {
        var n2 = e3.toLowerCase();
        oe[n2] = oe[n2 + "s"] = oe[t4] = e3;
      }
      function _2(e3) {
        return "string" == typeof e3 ? oe[e3] || oe[e3.toLowerCase()] : void 0;
      }
      function ue(e3) {
        var t4, n2, s3 = {};
        for (n2 in e3)
          c2(e3, n2) && (t4 = _2(n2)) && (s3[t4] = e3[n2]);
        return s3;
      }
      var le = {};
      function n(e3, t4) {
        le[e3] = t4;
      }
      function he(e3) {
        return e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0;
      }
      function y2(e3) {
        return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
      }
      function g(e3) {
        var e3 = +e3, t4 = 0;
        return t4 = 0 != e3 && isFinite(e3) ? y2(e3) : t4;
      }
      function de(t4, n2) {
        return function(e3) {
          return null != e3 ? (fe(this, t4, e3), f.updateOffset(this, n2), this) : ce(this, t4);
        };
      }
      function ce(e3, t4) {
        return e3.isValid() ? e3._d["get" + (e3._isUTC ? "UTC" : "") + t4]() : NaN;
      }
      function fe(e3, t4, n2) {
        e3.isValid() && !isNaN(n2) && ("FullYear" === t4 && he(e3.year()) && 1 === e3.month() && 29 === e3.date() ? (n2 = g(n2), e3._d["set" + (e3._isUTC ? "UTC" : "") + t4](n2, e3.month(), We(n2, e3.month()))) : e3._d["set" + (e3._isUTC ? "UTC" : "") + t4](n2));
      }
      var i = /\d/, w2 = /\d\d/, me = /\d{3}/, _e = /\d{4}/, ye = /[+-]?\d{6}/, p = /\d\d?/, ge = /\d\d\d\d?/, we = /\d\d\d\d\d\d?/, pe = /\d{1,3}/, ke = /\d{1,4}/, ve = /[+-]?\d{1,6}/, Me = /\d+/, De = /[+-]?\d+/, Se = /Z|[+-]\d\d:?\d\d/gi, Ye = /Z|[+-]\d\d(?::?\d\d)?/gi, k2 = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
      function v(e3, n2, s3) {
        be[e3] = d(n2) ? n2 : function(e4, t4) {
          return e4 && s3 ? s3 : n2;
        };
      }
      function Oe(e3, t4) {
        return c2(be, e3) ? be[e3](t4._strict, t4._locale) : new RegExp(M2(e3.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e4, t5, n2, s3, i2) {
          return t5 || n2 || s3 || i2;
        })));
      }
      function M2(e3) {
        return e3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var be = {}, xe = {};
      function D2(e3, n2) {
        var t4, s3, i2 = n2;
        for ("string" == typeof e3 && (e3 = [e3]), u2(n2) && (i2 = function(e4, t5) {
          t5[n2] = g(e4);
        }), s3 = e3.length, t4 = 0; t4 < s3; t4++)
          xe[e3[t4]] = i2;
      }
      function Te(e3, i2) {
        D2(e3, function(e4, t4, n2, s3) {
          n2._w = n2._w || {}, i2(e4, n2._w, n2, s3);
        });
      }
      var S, Y3 = 0, O = 1, b = 2, x2 = 3, T = 4, N = 5, Ne = 6, Pe = 7, Re = 8;
      function We(e3, t4) {
        if (isNaN(e3) || isNaN(t4))
          return NaN;
        var n2 = (t4 % (n2 = 12) + n2) % n2;
        return e3 += (t4 - n2) / 12, 1 == n2 ? he(e3) ? 29 : 28 : 31 - n2 % 7 % 2;
      }
      S = Array.prototype.indexOf || function(e3) {
        for (var t4 = 0; t4 < this.length; ++t4)
          if (this[t4] === e3)
            return t4;
        return -1;
      }, s2("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      }), s2("MMM", 0, 0, function(e3) {
        return this.localeData().monthsShort(this, e3);
      }), s2("MMMM", 0, 0, function(e3) {
        return this.localeData().months(this, e3);
      }), t("month", "M"), n("month", 8), v("M", p), v("MM", p, w2), v("MMM", function(e3, t4) {
        return t4.monthsShortRegex(e3);
      }), v("MMMM", function(e3, t4) {
        return t4.monthsRegex(e3);
      }), D2(["M", "MM"], function(e3, t4) {
        t4[O] = g(e3) - 1;
      }), D2(["MMM", "MMMM"], function(e3, t4, n2, s3) {
        s3 = n2._locale.monthsParse(e3, s3, n2._strict);
        null != s3 ? t4[O] = s3 : m2(n2).invalidMonth = e3;
      });
      var Ce = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Ue = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), He = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Fe = k2, Le = k2;
      function Ve(e3, t4) {
        var n2;
        if (e3.isValid()) {
          if ("string" == typeof t4) {
            if (/^\d+$/.test(t4))
              t4 = g(t4);
            else if (!u2(t4 = e3.localeData().monthsParse(t4)))
              return;
          }
          n2 = Math.min(e3.date(), We(e3.year(), t4)), e3._d["set" + (e3._isUTC ? "UTC" : "") + "Month"](t4, n2);
        }
      }
      function Ge(e3) {
        return null != e3 ? (Ve(this, e3), f.updateOffset(this, true), this) : ce(this, "Month");
      }
      function Ee() {
        function e3(e4, t5) {
          return t5.length - e4.length;
        }
        for (var t4, n2 = [], s3 = [], i2 = [], r2 = 0; r2 < 12; r2++)
          t4 = l([2e3, r2]), n2.push(this.monthsShort(t4, "")), s3.push(this.months(t4, "")), i2.push(this.months(t4, "")), i2.push(this.monthsShort(t4, ""));
        for (n2.sort(e3), s3.sort(e3), i2.sort(e3), r2 = 0; r2 < 12; r2++)
          n2[r2] = M2(n2[r2]), s3[r2] = M2(s3[r2]);
        for (r2 = 0; r2 < 24; r2++)
          i2[r2] = M2(i2[r2]);
        this._monthsRegex = new RegExp("^(" + i2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n2.join("|") + ")", "i");
      }
      function Ae(e3) {
        return he(e3) ? 366 : 365;
      }
      s2("Y", 0, 0, function() {
        var e3 = this.year();
        return e3 <= 9999 ? r(e3, 4) : "+" + e3;
      }), s2(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      }), s2(0, ["YYYY", 4], 0, "year"), s2(0, ["YYYYY", 5], 0, "year"), s2(0, ["YYYYYY", 6, true], 0, "year"), t("year", "y"), n("year", 1), v("Y", De), v("YY", p, w2), v("YYYY", ke, _e), v("YYYYY", ve, ye), v("YYYYYY", ve, ye), D2(["YYYYY", "YYYYYY"], Y3), D2("YYYY", function(e3, t4) {
        t4[Y3] = 2 === e3.length ? f.parseTwoDigitYear(e3) : g(e3);
      }), D2("YY", function(e3, t4) {
        t4[Y3] = f.parseTwoDigitYear(e3);
      }), D2("Y", function(e3, t4) {
        t4[Y3] = parseInt(e3, 10);
      }), f.parseTwoDigitYear = function(e3) {
        return g(e3) + (68 < g(e3) ? 1900 : 2e3);
      };
      var Ie = de("FullYear", true);
      function je(e3, t4, n2, s3, i2, r2, a3) {
        var o2;
        return e3 < 100 && 0 <= e3 ? (o2 = new Date(e3 + 400, t4, n2, s3, i2, r2, a3), isFinite(o2.getFullYear()) && o2.setFullYear(e3)) : o2 = new Date(e3, t4, n2, s3, i2, r2, a3), o2;
      }
      function Ze(e3) {
        var t4;
        return e3 < 100 && 0 <= e3 ? ((t4 = Array.prototype.slice.call(arguments))[0] = e3 + 400, t4 = new Date(Date.UTC.apply(null, t4)), isFinite(t4.getUTCFullYear()) && t4.setUTCFullYear(e3)) : t4 = new Date(Date.UTC.apply(null, arguments)), t4;
      }
      function ze(e3, t4, n2) {
        n2 = 7 + t4 - n2;
        return n2 - (7 + Ze(e3, 0, n2).getUTCDay() - t4) % 7 - 1;
      }
      function $e(e3, t4, n2, s3, i2) {
        var r2, t4 = 1 + 7 * (t4 - 1) + (7 + n2 - s3) % 7 + ze(e3, s3, i2), n2 = t4 <= 0 ? Ae(r2 = e3 - 1) + t4 : t4 > Ae(e3) ? (r2 = e3 + 1, t4 - Ae(e3)) : (r2 = e3, t4);
        return { year: r2, dayOfYear: n2 };
      }
      function qe(e3, t4, n2) {
        var s3, i2, r2 = ze(e3.year(), t4, n2), r2 = Math.floor((e3.dayOfYear() - r2 - 1) / 7) + 1;
        return r2 < 1 ? s3 = r2 + P(i2 = e3.year() - 1, t4, n2) : r2 > P(e3.year(), t4, n2) ? (s3 = r2 - P(e3.year(), t4, n2), i2 = e3.year() + 1) : (i2 = e3.year(), s3 = r2), { week: s3, year: i2 };
      }
      function P(e3, t4, n2) {
        var s3 = ze(e3, t4, n2), t4 = ze(e3 + 1, t4, n2);
        return (Ae(e3) - s3 + t4) / 7;
      }
      s2("w", ["ww", 2], "wo", "week"), s2("W", ["WW", 2], "Wo", "isoWeek"), t("week", "w"), t("isoWeek", "W"), n("week", 5), n("isoWeek", 5), v("w", p), v("ww", p, w2), v("W", p), v("WW", p, w2), Te(["w", "ww", "W", "WW"], function(e3, t4, n2, s3) {
        t4[s3.substr(0, 1)] = g(e3);
      });
      function Be(e3, t4) {
        return e3.slice(t4, 7).concat(e3.slice(0, t4));
      }
      s2("d", 0, "do", "day"), s2("dd", 0, 0, function(e3) {
        return this.localeData().weekdaysMin(this, e3);
      }), s2("ddd", 0, 0, function(e3) {
        return this.localeData().weekdaysShort(this, e3);
      }), s2("dddd", 0, 0, function(e3) {
        return this.localeData().weekdays(this, e3);
      }), s2("e", 0, 0, "weekday"), s2("E", 0, 0, "isoWeekday"), t("day", "d"), t("weekday", "e"), t("isoWeekday", "E"), n("day", 11), n("weekday", 11), n("isoWeekday", 11), v("d", p), v("e", p), v("E", p), v("dd", function(e3, t4) {
        return t4.weekdaysMinRegex(e3);
      }), v("ddd", function(e3, t4) {
        return t4.weekdaysShortRegex(e3);
      }), v("dddd", function(e3, t4) {
        return t4.weekdaysRegex(e3);
      }), Te(["dd", "ddd", "dddd"], function(e3, t4, n2, s3) {
        s3 = n2._locale.weekdaysParse(e3, s3, n2._strict);
        null != s3 ? t4.d = s3 : m2(n2).invalidWeekday = e3;
      }), Te(["d", "e", "E"], function(e3, t4, n2, s3) {
        t4[s3] = g(e3);
      });
      var Je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Qe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Xe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ke = k2, et = k2, tt = k2;
      function nt() {
        function e3(e4, t5) {
          return t5.length - e4.length;
        }
        for (var t4, n2, s3, i2 = [], r2 = [], a3 = [], o2 = [], u3 = 0; u3 < 7; u3++)
          s3 = l([2e3, 1]).day(u3), t4 = M2(this.weekdaysMin(s3, "")), n2 = M2(this.weekdaysShort(s3, "")), s3 = M2(this.weekdays(s3, "")), i2.push(t4), r2.push(n2), a3.push(s3), o2.push(t4), o2.push(n2), o2.push(s3);
        i2.sort(e3), r2.sort(e3), a3.sort(e3), o2.sort(e3), this._weekdaysRegex = new RegExp("^(" + o2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + a3.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + i2.join("|") + ")", "i");
      }
      function st() {
        return this.hours() % 12 || 12;
      }
      function it(e3, t4) {
        s2(e3, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), t4);
        });
      }
      function rt(e3, t4) {
        return t4._meridiemParse;
      }
      s2("H", ["HH", 2], 0, "hour"), s2("h", ["hh", 2], 0, st), s2("k", ["kk", 2], 0, function() {
        return this.hours() || 24;
      }), s2("hmm", 0, 0, function() {
        return "" + st.apply(this) + r(this.minutes(), 2);
      }), s2("hmmss", 0, 0, function() {
        return "" + st.apply(this) + r(this.minutes(), 2) + r(this.seconds(), 2);
      }), s2("Hmm", 0, 0, function() {
        return "" + this.hours() + r(this.minutes(), 2);
      }), s2("Hmmss", 0, 0, function() {
        return "" + this.hours() + r(this.minutes(), 2) + r(this.seconds(), 2);
      }), it("a", true), it("A", false), t("hour", "h"), n("hour", 13), v("a", rt), v("A", rt), v("H", p), v("h", p), v("k", p), v("HH", p, w2), v("hh", p, w2), v("kk", p, w2), v("hmm", ge), v("hmmss", we), v("Hmm", ge), v("Hmmss", we), D2(["H", "HH"], x2), D2(["k", "kk"], function(e3, t4, n2) {
        e3 = g(e3);
        t4[x2] = 24 === e3 ? 0 : e3;
      }), D2(["a", "A"], function(e3, t4, n2) {
        n2._isPm = n2._locale.isPM(e3), n2._meridiem = e3;
      }), D2(["h", "hh"], function(e3, t4, n2) {
        t4[x2] = g(e3), m2(n2).bigHour = true;
      }), D2("hmm", function(e3, t4, n2) {
        var s3 = e3.length - 2;
        t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3)), m2(n2).bigHour = true;
      }), D2("hmmss", function(e3, t4, n2) {
        var s3 = e3.length - 4, i2 = e3.length - 2;
        t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3, 2)), t4[N] = g(e3.substr(i2)), m2(n2).bigHour = true;
      }), D2("Hmm", function(e3, t4, n2) {
        var s3 = e3.length - 2;
        t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3));
      }), D2("Hmmss", function(e3, t4, n2) {
        var s3 = e3.length - 4, i2 = e3.length - 2;
        t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3, 2)), t4[N] = g(e3.substr(i2));
      });
      k2 = de("Hours", true);
      var at, ot = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Ce, monthsShort: Ue, week: { dow: 0, doy: 6 }, weekdays: Je, weekdaysMin: Xe, weekdaysShort: Qe, meridiemParse: /[ap]\.?m?\.?/i }, R = {}, ut = {};
      function lt(e3) {
        return e3 && e3.toLowerCase().replace("_", "-");
      }
      function ht(e3) {
        for (var t4, n2, s3, i2, r2 = 0; r2 < e3.length; ) {
          for (t4 = (i2 = lt(e3[r2]).split("-")).length, n2 = (n2 = lt(e3[r2 + 1])) ? n2.split("-") : null; 0 < t4; ) {
            if (s3 = dt(i2.slice(0, t4).join("-")))
              return s3;
            if (n2 && n2.length >= t4 && function(e4, t5) {
              for (var n3 = Math.min(e4.length, t5.length), s4 = 0; s4 < n3; s4 += 1)
                if (e4[s4] !== t5[s4])
                  return s4;
              return n3;
            }(i2, n2) >= t4 - 1)
              break;
            t4--;
          }
          r2++;
        }
        return at;
      }
      function dt(t4) {
        var e3;
        if (void 0 === R[t4] && true && module3 && module3.exports && null != t4.match("^[^/\\\\]*$"))
          try {
            e3 = at._abbr, commonjsRequire("./locale/" + t4), ct(e3);
          } catch (e4) {
            R[t4] = null;
          }
        return R[t4];
      }
      function ct(e3, t4) {
        return e3 && ((t4 = o(t4) ? mt(e3) : ft(e3, t4)) ? at = t4 : "undefined" != typeof console && console.warn && console.warn("Locale " + e3 + " not found. Did you forget to load it?")), at._abbr;
      }
      function ft(e3, t4) {
        if (null === t4)
          return delete R[e3], null;
        var n2, s3 = ot;
        if (t4.abbr = e3, null != R[e3])
          Q("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s3 = R[e3]._config;
        else if (null != t4.parentLocale)
          if (null != R[t4.parentLocale])
            s3 = R[t4.parentLocale]._config;
          else {
            if (null == (n2 = dt(t4.parentLocale)))
              return ut[t4.parentLocale] || (ut[t4.parentLocale] = []), ut[t4.parentLocale].push({ name: e3, config: t4 }), null;
            s3 = n2._config;
          }
        return R[e3] = new K2(X3(s3, t4)), ut[e3] && ut[e3].forEach(function(e4) {
          ft(e4.name, e4.config);
        }), ct(e3), R[e3];
      }
      function mt(e3) {
        var t4;
        if (!(e3 = e3 && e3._locale && e3._locale._abbr ? e3._locale._abbr : e3))
          return at;
        if (!a2(e3)) {
          if (t4 = dt(e3))
            return t4;
          e3 = [e3];
        }
        return ht(e3);
      }
      function _t(e3) {
        var t4 = e3._a;
        return t4 && -2 === m2(e3).overflow && (t4 = t4[O] < 0 || 11 < t4[O] ? O : t4[b] < 1 || t4[b] > We(t4[Y3], t4[O]) ? b : t4[x2] < 0 || 24 < t4[x2] || 24 === t4[x2] && (0 !== t4[T] || 0 !== t4[N] || 0 !== t4[Ne]) ? x2 : t4[T] < 0 || 59 < t4[T] ? T : t4[N] < 0 || 59 < t4[N] ? N : t4[Ne] < 0 || 999 < t4[Ne] ? Ne : -1, m2(e3)._overflowDayOfYear && (t4 < Y3 || b < t4) && (t4 = b), m2(e3)._overflowWeeks && -1 === t4 && (t4 = Pe), m2(e3)._overflowWeekday && -1 === t4 && (t4 = Re), m2(e3).overflow = t4), e3;
      }
      var yt = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, gt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, wt = /Z|[+-]\d\d(?::?\d\d)?/, pt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], kt = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], vt = /^\/?Date\((-?\d+)/i, Mt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Dt = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
      function St(e3) {
        var t4, n2, s3, i2, r2, a3, o2 = e3._i, u3 = yt.exec(o2) || gt.exec(o2), o2 = pt.length, l2 = kt.length;
        if (u3) {
          for (m2(e3).iso = true, t4 = 0, n2 = o2; t4 < n2; t4++)
            if (pt[t4][1].exec(u3[1])) {
              i2 = pt[t4][0], s3 = false !== pt[t4][2];
              break;
            }
          if (null == i2)
            e3._isValid = false;
          else {
            if (u3[3]) {
              for (t4 = 0, n2 = l2; t4 < n2; t4++)
                if (kt[t4][1].exec(u3[3])) {
                  r2 = (u3[2] || " ") + kt[t4][0];
                  break;
                }
              if (null == r2)
                return void (e3._isValid = false);
            }
            if (s3 || null == r2) {
              if (u3[4]) {
                if (!wt.exec(u3[4]))
                  return void (e3._isValid = false);
                a3 = "Z";
              }
              e3._f = i2 + (r2 || "") + (a3 || ""), Tt(e3);
            } else
              e3._isValid = false;
          }
        } else
          e3._isValid = false;
      }
      function Yt(e3, t4, n2, s3, i2, r2) {
        e3 = [function(e4) {
          e4 = parseInt(e4, 10);
          {
            if (e4 <= 49)
              return 2e3 + e4;
            if (e4 <= 999)
              return 1900 + e4;
          }
          return e4;
        }(e3), Ue.indexOf(t4), parseInt(n2, 10), parseInt(s3, 10), parseInt(i2, 10)];
        return r2 && e3.push(parseInt(r2, 10)), e3;
      }
      function Ot(e3) {
        var t4, n2, s3, i2, r2 = Mt.exec(e3._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
        r2 ? (t4 = Yt(r2[4], r2[3], r2[2], r2[5], r2[6], r2[7]), n2 = r2[1], s3 = t4, i2 = e3, n2 && Qe.indexOf(n2) !== new Date(s3[0], s3[1], s3[2]).getDay() ? (m2(i2).weekdayMismatch = true, i2._isValid = false) : (e3._a = t4, e3._tzm = (n2 = r2[8], s3 = r2[9], i2 = r2[10], n2 ? Dt[n2] : s3 ? 0 : 60 * (((n2 = parseInt(i2, 10)) - (s3 = n2 % 100)) / 100) + s3), e3._d = Ze.apply(null, e3._a), e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), m2(e3).rfc2822 = true)) : e3._isValid = false;
      }
      function bt(e3, t4, n2) {
        return null != e3 ? e3 : null != t4 ? t4 : n2;
      }
      function xt(e3) {
        var t4, n2, s3, i2, r2, a3, o2, u3, l2, h2, d2, c3 = [];
        if (!e3._d) {
          for (s3 = e3, i2 = new Date(f.now()), n2 = s3._useUTC ? [i2.getUTCFullYear(), i2.getUTCMonth(), i2.getUTCDate()] : [i2.getFullYear(), i2.getMonth(), i2.getDate()], e3._w && null == e3._a[b] && null == e3._a[O] && (null != (i2 = (s3 = e3)._w).GG || null != i2.W || null != i2.E ? (u3 = 1, l2 = 4, r2 = bt(i2.GG, s3._a[Y3], qe(W(), 1, 4).year), a3 = bt(i2.W, 1), ((o2 = bt(i2.E, 1)) < 1 || 7 < o2) && (h2 = true)) : (u3 = s3._locale._week.dow, l2 = s3._locale._week.doy, d2 = qe(W(), u3, l2), r2 = bt(i2.gg, s3._a[Y3], d2.year), a3 = bt(i2.w, d2.week), null != i2.d ? ((o2 = i2.d) < 0 || 6 < o2) && (h2 = true) : null != i2.e ? (o2 = i2.e + u3, (i2.e < 0 || 6 < i2.e) && (h2 = true)) : o2 = u3), a3 < 1 || a3 > P(r2, u3, l2) ? m2(s3)._overflowWeeks = true : null != h2 ? m2(s3)._overflowWeekday = true : (d2 = $e(r2, a3, o2, u3, l2), s3._a[Y3] = d2.year, s3._dayOfYear = d2.dayOfYear)), null != e3._dayOfYear && (i2 = bt(e3._a[Y3], n2[Y3]), (e3._dayOfYear > Ae(i2) || 0 === e3._dayOfYear) && (m2(e3)._overflowDayOfYear = true), h2 = Ze(i2, 0, e3._dayOfYear), e3._a[O] = h2.getUTCMonth(), e3._a[b] = h2.getUTCDate()), t4 = 0; t4 < 3 && null == e3._a[t4]; ++t4)
            e3._a[t4] = c3[t4] = n2[t4];
          for (; t4 < 7; t4++)
            e3._a[t4] = c3[t4] = null == e3._a[t4] ? 2 === t4 ? 1 : 0 : e3._a[t4];
          24 === e3._a[x2] && 0 === e3._a[T] && 0 === e3._a[N] && 0 === e3._a[Ne] && (e3._nextDay = true, e3._a[x2] = 0), e3._d = (e3._useUTC ? Ze : je).apply(null, c3), r2 = e3._useUTC ? e3._d.getUTCDay() : e3._d.getDay(), null != e3._tzm && e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), e3._nextDay && (e3._a[x2] = 24), e3._w && void 0 !== e3._w.d && e3._w.d !== r2 && (m2(e3).weekdayMismatch = true);
        }
      }
      function Tt(e3) {
        if (e3._f === f.ISO_8601)
          St(e3);
        else if (e3._f === f.RFC_2822)
          Ot(e3);
        else {
          e3._a = [], m2(e3).empty = true;
          for (var t4, n2, s3, i2, r2, a3 = "" + e3._i, o2 = a3.length, u3 = 0, l2 = ae(e3._f, e3._locale).match(te) || [], h2 = l2.length, d2 = 0; d2 < h2; d2++)
            n2 = l2[d2], (t4 = (a3.match(Oe(n2, e3)) || [])[0]) && (0 < (s3 = a3.substr(0, a3.indexOf(t4))).length && m2(e3).unusedInput.push(s3), a3 = a3.slice(a3.indexOf(t4) + t4.length), u3 += t4.length), ie[n2] ? (t4 ? m2(e3).empty = false : m2(e3).unusedTokens.push(n2), s3 = n2, r2 = e3, null != (i2 = t4) && c2(xe, s3) && xe[s3](i2, r2._a, r2, s3)) : e3._strict && !t4 && m2(e3).unusedTokens.push(n2);
          m2(e3).charsLeftOver = o2 - u3, 0 < a3.length && m2(e3).unusedInput.push(a3), e3._a[x2] <= 12 && true === m2(e3).bigHour && 0 < e3._a[x2] && (m2(e3).bigHour = void 0), m2(e3).parsedDateParts = e3._a.slice(0), m2(e3).meridiem = e3._meridiem, e3._a[x2] = function(e4, t5, n3) {
            if (null == n3)
              return t5;
            return null != e4.meridiemHour ? e4.meridiemHour(t5, n3) : null != e4.isPM ? ((e4 = e4.isPM(n3)) && t5 < 12 && (t5 += 12), t5 = e4 || 12 !== t5 ? t5 : 0) : t5;
          }(e3._locale, e3._a[x2], e3._meridiem), null !== (o2 = m2(e3).era) && (e3._a[Y3] = e3._locale.erasConvertYear(o2, e3._a[Y3])), xt(e3), _t(e3);
        }
      }
      function Nt(e3) {
        var t4, n2, s3, i2 = e3._i, r2 = e3._f;
        if (e3._locale = e3._locale || mt(e3._l), null === i2 || void 0 === r2 && "" === i2)
          return I({ nullInput: true });
        if ("string" == typeof i2 && (e3._i = i2 = e3._locale.preparse(i2)), h(i2))
          return new q(_t(i2));
        if (V(i2))
          e3._d = i2;
        else if (a2(r2))
          !function(e4) {
            var t5, n3, s4, i3, r3, a3, o2 = false, u3 = e4._f.length;
            if (0 === u3)
              return m2(e4).invalidFormat = true, e4._d = new Date(NaN);
            for (i3 = 0; i3 < u3; i3++)
              r3 = 0, a3 = false, t5 = $({}, e4), null != e4._useUTC && (t5._useUTC = e4._useUTC), t5._f = e4._f[i3], Tt(t5), A5(t5) && (a3 = true), r3 = (r3 += m2(t5).charsLeftOver) + 10 * m2(t5).unusedTokens.length, m2(t5).score = r3, o2 ? r3 < s4 && (s4 = r3, n3 = t5) : (null == s4 || r3 < s4 || a3) && (s4 = r3, n3 = t5, a3 && (o2 = true));
            E2(e4, n3 || t5);
          }(e3);
        else if (r2)
          Tt(e3);
        else if (o(r2 = (i2 = e3)._i))
          i2._d = new Date(f.now());
        else
          V(r2) ? i2._d = new Date(r2.valueOf()) : "string" == typeof r2 ? (n2 = i2, null !== (t4 = vt.exec(n2._i)) ? n2._d = new Date(+t4[1]) : (St(n2), false === n2._isValid && (delete n2._isValid, Ot(n2), false === n2._isValid && (delete n2._isValid, n2._strict ? n2._isValid = false : f.createFromInputFallback(n2))))) : a2(r2) ? (i2._a = G(r2.slice(0), function(e4) {
            return parseInt(e4, 10);
          }), xt(i2)) : F(r2) ? (t4 = i2)._d || (s3 = void 0 === (n2 = ue(t4._i)).day ? n2.date : n2.day, t4._a = G([n2.year, n2.month, s3, n2.hour, n2.minute, n2.second, n2.millisecond], function(e4) {
            return e4 && parseInt(e4, 10);
          }), xt(t4)) : u2(r2) ? i2._d = new Date(r2) : f.createFromInputFallback(i2);
        return A5(e3) || (e3._d = null), e3;
      }
      function Pt(e3, t4, n2, s3, i2) {
        var r2 = {};
        return true !== t4 && false !== t4 || (s3 = t4, t4 = void 0), true !== n2 && false !== n2 || (s3 = n2, n2 = void 0), (F(e3) && L(e3) || a2(e3) && 0 === e3.length) && (e3 = void 0), r2._isAMomentObject = true, r2._useUTC = r2._isUTC = i2, r2._l = n2, r2._i = e3, r2._f = t4, r2._strict = s3, (i2 = new q(_t(Nt(i2 = r2))))._nextDay && (i2.add(1, "d"), i2._nextDay = void 0), i2;
      }
      function W(e3, t4, n2, s3) {
        return Pt(e3, t4, n2, s3, false);
      }
      f.createFromInputFallback = e("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e3) {
        e3._d = new Date(e3._i + (e3._useUTC ? " UTC" : ""));
      }), f.ISO_8601 = function() {
      }, f.RFC_2822 = function() {
      };
      ge = e("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var e3 = W.apply(null, arguments);
        return this.isValid() && e3.isValid() ? e3 < this ? this : e3 : I();
      }), we = e("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var e3 = W.apply(null, arguments);
        return this.isValid() && e3.isValid() ? this < e3 ? this : e3 : I();
      });
      function Rt(e3, t4) {
        var n2, s3;
        if (!(t4 = 1 === t4.length && a2(t4[0]) ? t4[0] : t4).length)
          return W();
        for (n2 = t4[0], s3 = 1; s3 < t4.length; ++s3)
          t4[s3].isValid() && !t4[s3][e3](n2) || (n2 = t4[s3]);
        return n2;
      }
      var Wt = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
      function Ct(e3) {
        var e3 = ue(e3), t4 = e3.year || 0, n2 = e3.quarter || 0, s3 = e3.month || 0, i2 = e3.week || e3.isoWeek || 0, r2 = e3.day || 0, a3 = e3.hour || 0, o2 = e3.minute || 0, u3 = e3.second || 0, l2 = e3.millisecond || 0;
        this._isValid = function(e4) {
          var t5, n3, s4 = false, i3 = Wt.length;
          for (t5 in e4)
            if (c2(e4, t5) && (-1 === S.call(Wt, t5) || null != e4[t5] && isNaN(e4[t5])))
              return false;
          for (n3 = 0; n3 < i3; ++n3)
            if (e4[Wt[n3]]) {
              if (s4)
                return false;
              parseFloat(e4[Wt[n3]]) !== g(e4[Wt[n3]]) && (s4 = true);
            }
          return true;
        }(e3), this._milliseconds = +l2 + 1e3 * u3 + 6e4 * o2 + 1e3 * a3 * 60 * 60, this._days = +r2 + 7 * i2, this._months = +s3 + 3 * n2 + 12 * t4, this._data = {}, this._locale = mt(), this._bubble();
      }
      function Ut(e3) {
        return e3 instanceof Ct;
      }
      function Ht(e3) {
        return e3 < 0 ? -1 * Math.round(-1 * e3) : Math.round(e3);
      }
      function Ft(e3, n2) {
        s2(e3, 0, 0, function() {
          var e4 = this.utcOffset(), t4 = "+";
          return e4 < 0 && (e4 = -e4, t4 = "-"), t4 + r(~~(e4 / 60), 2) + n2 + r(~~e4 % 60, 2);
        });
      }
      Ft("Z", ":"), Ft("ZZ", ""), v("Z", Ye), v("ZZ", Ye), D2(["Z", "ZZ"], function(e3, t4, n2) {
        n2._useUTC = true, n2._tzm = Vt(Ye, e3);
      });
      var Lt = /([\+\-]|\d\d)/gi;
      function Vt(e3, t4) {
        var t4 = (t4 || "").match(e3);
        return null === t4 ? null : 0 === (t4 = 60 * (e3 = ((t4[t4.length - 1] || []) + "").match(Lt) || ["-", 0, 0])[1] + g(e3[2])) ? 0 : "+" === e3[0] ? t4 : -t4;
      }
      function Gt(e3, t4) {
        var n2;
        return t4._isUTC ? (t4 = t4.clone(), n2 = (h(e3) || V(e3) ? e3 : W(e3)).valueOf() - t4.valueOf(), t4._d.setTime(t4._d.valueOf() + n2), f.updateOffset(t4, false), t4) : W(e3).local();
      }
      function Et(e3) {
        return -Math.round(e3._d.getTimezoneOffset());
      }
      function At() {
        return !!this.isValid() && (this._isUTC && 0 === this._offset);
      }
      f.updateOffset = function() {
      };
      var It = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, jt = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function C3(e3, t4) {
        var n2, s3 = e3, i2 = null;
        return Ut(e3) ? s3 = { ms: e3._milliseconds, d: e3._days, M: e3._months } : u2(e3) || !isNaN(+e3) ? (s3 = {}, t4 ? s3[t4] = +e3 : s3.milliseconds = +e3) : (i2 = It.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: 0, d: g(i2[b]) * n2, h: g(i2[x2]) * n2, m: g(i2[T]) * n2, s: g(i2[N]) * n2, ms: g(Ht(1e3 * i2[Ne])) * n2 }) : (i2 = jt.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: Zt(i2[2], n2), M: Zt(i2[3], n2), w: Zt(i2[4], n2), d: Zt(i2[5], n2), h: Zt(i2[6], n2), m: Zt(i2[7], n2), s: Zt(i2[8], n2) }) : null == s3 ? s3 = {} : "object" == typeof s3 && ("from" in s3 || "to" in s3) && (t4 = function(e4, t5) {
          var n3;
          if (!e4.isValid() || !t5.isValid())
            return { milliseconds: 0, months: 0 };
          t5 = Gt(t5, e4), e4.isBefore(t5) ? n3 = zt(e4, t5) : ((n3 = zt(t5, e4)).milliseconds = -n3.milliseconds, n3.months = -n3.months);
          return n3;
        }(W(s3.from), W(s3.to)), (s3 = {}).ms = t4.milliseconds, s3.M = t4.months), i2 = new Ct(s3), Ut(e3) && c2(e3, "_locale") && (i2._locale = e3._locale), Ut(e3) && c2(e3, "_isValid") && (i2._isValid = e3._isValid), i2;
      }
      function Zt(e3, t4) {
        e3 = e3 && parseFloat(e3.replace(",", "."));
        return (isNaN(e3) ? 0 : e3) * t4;
      }
      function zt(e3, t4) {
        var n2 = {};
        return n2.months = t4.month() - e3.month() + 12 * (t4.year() - e3.year()), e3.clone().add(n2.months, "M").isAfter(t4) && --n2.months, n2.milliseconds = +t4 - +e3.clone().add(n2.months, "M"), n2;
      }
      function $t(s3, i2) {
        return function(e3, t4) {
          var n2;
          return null === t4 || isNaN(+t4) || (Q(i2, "moment()." + i2 + "(period, number) is deprecated. Please use moment()." + i2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), n2 = e3, e3 = t4, t4 = n2), qt(this, C3(e3, t4), s3), this;
        };
      }
      function qt(e3, t4, n2, s3) {
        var i2 = t4._milliseconds, r2 = Ht(t4._days), t4 = Ht(t4._months);
        e3.isValid() && (s3 = null == s3 || s3, t4 && Ve(e3, ce(e3, "Month") + t4 * n2), r2 && fe(e3, "Date", ce(e3, "Date") + r2 * n2), i2 && e3._d.setTime(e3._d.valueOf() + i2 * n2), s3 && f.updateOffset(e3, r2 || t4));
      }
      C3.fn = Ct.prototype, C3.invalid = function() {
        return C3(NaN);
      };
      Ce = $t(1, "add"), Je = $t(-1, "subtract");
      function Bt(e3) {
        return "string" == typeof e3 || e3 instanceof String;
      }
      function Jt(e3) {
        return h(e3) || V(e3) || Bt(e3) || u2(e3) || function(t4) {
          var e4 = a2(t4), n2 = false;
          e4 && (n2 = 0 === t4.filter(function(e6) {
            return !u2(e6) && Bt(t4);
          }).length);
          return e4 && n2;
        }(e3) || function(e4) {
          var t4, n2, s3 = F(e4) && !L(e4), i2 = false, r2 = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], a3 = r2.length;
          for (t4 = 0; t4 < a3; t4 += 1)
            n2 = r2[t4], i2 = i2 || c2(e4, n2);
          return s3 && i2;
        }(e3) || null == e3;
      }
      function Qt(e3, t4) {
        if (e3.date() < t4.date())
          return -Qt(t4, e3);
        var n2 = 12 * (t4.year() - e3.year()) + (t4.month() - e3.month()), s3 = e3.clone().add(n2, "months"), t4 = t4 - s3 < 0 ? (t4 - s3) / (s3 - e3.clone().add(n2 - 1, "months")) : (t4 - s3) / (e3.clone().add(1 + n2, "months") - s3);
        return -(n2 + t4) || 0;
      }
      function Xt(e3) {
        return void 0 === e3 ? this._locale._abbr : (null != (e3 = mt(e3)) && (this._locale = e3), this);
      }
      f.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", f.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      Xe = e("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e3) {
        return void 0 === e3 ? this.localeData() : this.locale(e3);
      });
      function Kt() {
        return this._locale;
      }
      var en = 126227808e5;
      function tn(e3, t4) {
        return (e3 % t4 + t4) % t4;
      }
      function nn(e3, t4, n2) {
        return e3 < 100 && 0 <= e3 ? new Date(e3 + 400, t4, n2) - en : new Date(e3, t4, n2).valueOf();
      }
      function sn(e3, t4, n2) {
        return e3 < 100 && 0 <= e3 ? Date.UTC(e3 + 400, t4, n2) - en : Date.UTC(e3, t4, n2);
      }
      function rn(e3, t4) {
        return t4.erasAbbrRegex(e3);
      }
      function an() {
        for (var e3 = [], t4 = [], n2 = [], s3 = [], i2 = this.eras(), r2 = 0, a3 = i2.length; r2 < a3; ++r2)
          t4.push(M2(i2[r2].name)), e3.push(M2(i2[r2].abbr)), n2.push(M2(i2[r2].narrow)), s3.push(M2(i2[r2].name)), s3.push(M2(i2[r2].abbr)), s3.push(M2(i2[r2].narrow));
        this._erasRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t4.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e3.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + n2.join("|") + ")", "i");
      }
      function on(e3, t4) {
        s2(0, [e3, e3.length], 0, t4);
      }
      function un(e3, t4, n2, s3, i2) {
        var r2;
        return null == e3 ? qe(this, s3, i2).year : (r2 = P(e3, s3, i2), function(e4, t5, n3, s4, i3) {
          e4 = $e(e4, t5, n3, s4, i3), t5 = Ze(e4.year, 0, e4.dayOfYear);
          return this.year(t5.getUTCFullYear()), this.month(t5.getUTCMonth()), this.date(t5.getUTCDate()), this;
        }.call(this, e3, t4 = r2 < t4 ? r2 : t4, n2, s3, i2));
      }
      s2("N", 0, 0, "eraAbbr"), s2("NN", 0, 0, "eraAbbr"), s2("NNN", 0, 0, "eraAbbr"), s2("NNNN", 0, 0, "eraName"), s2("NNNNN", 0, 0, "eraNarrow"), s2("y", ["y", 1], "yo", "eraYear"), s2("y", ["yy", 2], 0, "eraYear"), s2("y", ["yyy", 3], 0, "eraYear"), s2("y", ["yyyy", 4], 0, "eraYear"), v("N", rn), v("NN", rn), v("NNN", rn), v("NNNN", function(e3, t4) {
        return t4.erasNameRegex(e3);
      }), v("NNNNN", function(e3, t4) {
        return t4.erasNarrowRegex(e3);
      }), D2(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e3, t4, n2, s3) {
        s3 = n2._locale.erasParse(e3, s3, n2._strict);
        s3 ? m2(n2).era = s3 : m2(n2).invalidEra = e3;
      }), v("y", Me), v("yy", Me), v("yyy", Me), v("yyyy", Me), v("yo", function(e3, t4) {
        return t4._eraYearOrdinalRegex || Me;
      }), D2(["y", "yy", "yyy", "yyyy"], Y3), D2(["yo"], function(e3, t4, n2, s3) {
        var i2;
        n2._locale._eraYearOrdinalRegex && (i2 = e3.match(n2._locale._eraYearOrdinalRegex)), n2._locale.eraYearOrdinalParse ? t4[Y3] = n2._locale.eraYearOrdinalParse(e3, i2) : t4[Y3] = parseInt(e3, 10);
      }), s2(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      }), s2(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      }), on("gggg", "weekYear"), on("ggggg", "weekYear"), on("GGGG", "isoWeekYear"), on("GGGGG", "isoWeekYear"), t("weekYear", "gg"), t("isoWeekYear", "GG"), n("weekYear", 1), n("isoWeekYear", 1), v("G", De), v("g", De), v("GG", p, w2), v("gg", p, w2), v("GGGG", ke, _e), v("gggg", ke, _e), v("GGGGG", ve, ye), v("ggggg", ve, ye), Te(["gggg", "ggggg", "GGGG", "GGGGG"], function(e3, t4, n2, s3) {
        t4[s3.substr(0, 2)] = g(e3);
      }), Te(["gg", "GG"], function(e3, t4, n2, s3) {
        t4[s3] = f.parseTwoDigitYear(e3);
      }), s2("Q", 0, "Qo", "quarter"), t("quarter", "Q"), n("quarter", 7), v("Q", i), D2("Q", function(e3, t4) {
        t4[O] = 3 * (g(e3) - 1);
      }), s2("D", ["DD", 2], "Do", "date"), t("date", "D"), n("date", 9), v("D", p), v("DD", p, w2), v("Do", function(e3, t4) {
        return e3 ? t4._dayOfMonthOrdinalParse || t4._ordinalParse : t4._dayOfMonthOrdinalParseLenient;
      }), D2(["D", "DD"], b), D2("Do", function(e3, t4) {
        t4[b] = g(e3.match(p)[0]);
      });
      ke = de("Date", true);
      s2("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), t("dayOfYear", "DDD"), n("dayOfYear", 4), v("DDD", pe), v("DDDD", me), D2(["DDD", "DDDD"], function(e3, t4, n2) {
        n2._dayOfYear = g(e3);
      }), s2("m", ["mm", 2], 0, "minute"), t("minute", "m"), n("minute", 14), v("m", p), v("mm", p, w2), D2(["m", "mm"], T);
      var ln, _e = de("Minutes", false), ve = (s2("s", ["ss", 2], 0, "second"), t("second", "s"), n("second", 15), v("s", p), v("ss", p, w2), D2(["s", "ss"], N), de("Seconds", false));
      for (s2("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      }), s2(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      }), s2(0, ["SSS", 3], 0, "millisecond"), s2(0, ["SSSS", 4], 0, function() {
        return 10 * this.millisecond();
      }), s2(0, ["SSSSS", 5], 0, function() {
        return 100 * this.millisecond();
      }), s2(0, ["SSSSSS", 6], 0, function() {
        return 1e3 * this.millisecond();
      }), s2(0, ["SSSSSSS", 7], 0, function() {
        return 1e4 * this.millisecond();
      }), s2(0, ["SSSSSSSS", 8], 0, function() {
        return 1e5 * this.millisecond();
      }), s2(0, ["SSSSSSSSS", 9], 0, function() {
        return 1e6 * this.millisecond();
      }), t("millisecond", "ms"), n("millisecond", 16), v("S", pe, i), v("SS", pe, w2), v("SSS", pe, me), ln = "SSSS"; ln.length <= 9; ln += "S")
        v(ln, Me);
      function hn(e3, t4) {
        t4[Ne] = g(1e3 * ("0." + e3));
      }
      for (ln = "S"; ln.length <= 9; ln += "S")
        D2(ln, hn);
      ye = de("Milliseconds", false), s2("z", 0, 0, "zoneAbbr"), s2("zz", 0, 0, "zoneName");
      i = q.prototype;
      function dn(e3) {
        return e3;
      }
      i.add = Ce, i.calendar = function(e3, t4) {
        1 === arguments.length && (arguments[0] ? Jt(arguments[0]) ? (e3 = arguments[0], t4 = void 0) : function(e4) {
          for (var t5 = F(e4) && !L(e4), n3 = false, s3 = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i2 = 0; i2 < s3.length; i2 += 1)
            n3 = n3 || c2(e4, s3[i2]);
          return t5 && n3;
        }(arguments[0]) && (t4 = arguments[0], e3 = void 0) : t4 = e3 = void 0);
        var e3 = e3 || W(), n2 = Gt(e3, this).startOf("day"), n2 = f.calendarFormat(this, n2) || "sameElse", t4 = t4 && (d(t4[n2]) ? t4[n2].call(this, e3) : t4[n2]);
        return this.format(t4 || this.localeData().calendar(n2, this, W(e3)));
      }, i.clone = function() {
        return new q(this);
      }, i.diff = function(e3, t4, n2) {
        var s3, i2, r2;
        if (!this.isValid())
          return NaN;
        if (!(s3 = Gt(e3, this)).isValid())
          return NaN;
        switch (i2 = 6e4 * (s3.utcOffset() - this.utcOffset()), t4 = _2(t4)) {
          case "year":
            r2 = Qt(this, s3) / 12;
            break;
          case "month":
            r2 = Qt(this, s3);
            break;
          case "quarter":
            r2 = Qt(this, s3) / 3;
            break;
          case "second":
            r2 = (this - s3) / 1e3;
            break;
          case "minute":
            r2 = (this - s3) / 6e4;
            break;
          case "hour":
            r2 = (this - s3) / 36e5;
            break;
          case "day":
            r2 = (this - s3 - i2) / 864e5;
            break;
          case "week":
            r2 = (this - s3 - i2) / 6048e5;
            break;
          default:
            r2 = this - s3;
        }
        return n2 ? r2 : y2(r2);
      }, i.endOf = function(e3) {
        var t4, n2;
        if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
          return this;
        switch (n2 = this._isUTC ? sn : nn, e3) {
          case "year":
            t4 = n2(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            t4 = n2(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            t4 = n2(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            t4 = n2(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            t4 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            t4 = n2(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            t4 = this._d.valueOf(), t4 += 36e5 - tn(t4 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
            break;
          case "minute":
            t4 = this._d.valueOf(), t4 += 6e4 - tn(t4, 6e4) - 1;
            break;
          case "second":
            t4 = this._d.valueOf(), t4 += 1e3 - tn(t4, 1e3) - 1;
            break;
        }
        return this._d.setTime(t4), f.updateOffset(this, true), this;
      }, i.format = function(e3) {
        return e3 = e3 || (this.isUtc() ? f.defaultFormatUtc : f.defaultFormat), e3 = re2(this, e3), this.localeData().postformat(e3);
      }, i.from = function(e3, t4) {
        return this.isValid() && (h(e3) && e3.isValid() || W(e3).isValid()) ? C3({ to: this, from: e3 }).locale(this.locale()).humanize(!t4) : this.localeData().invalidDate();
      }, i.fromNow = function(e3) {
        return this.from(W(), e3);
      }, i.to = function(e3, t4) {
        return this.isValid() && (h(e3) && e3.isValid() || W(e3).isValid()) ? C3({ from: this, to: e3 }).locale(this.locale()).humanize(!t4) : this.localeData().invalidDate();
      }, i.toNow = function(e3) {
        return this.to(W(), e3);
      }, i.get = function(e3) {
        return d(this[e3 = _2(e3)]) ? this[e3]() : this;
      }, i.invalidAt = function() {
        return m2(this).overflow;
      }, i.isAfter = function(e3, t4) {
        return e3 = h(e3) ? e3 : W(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() > e3.valueOf() : e3.valueOf() < this.clone().startOf(t4).valueOf());
      }, i.isBefore = function(e3, t4) {
        return e3 = h(e3) ? e3 : W(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() < e3.valueOf() : this.clone().endOf(t4).valueOf() < e3.valueOf());
      }, i.isBetween = function(e3, t4, n2, s3) {
        return e3 = h(e3) ? e3 : W(e3), t4 = h(t4) ? t4 : W(t4), !!(this.isValid() && e3.isValid() && t4.isValid()) && (("(" === (s3 = s3 || "()")[0] ? this.isAfter(e3, n2) : !this.isBefore(e3, n2)) && (")" === s3[1] ? this.isBefore(t4, n2) : !this.isAfter(t4, n2)));
      }, i.isSame = function(e3, t4) {
        var e3 = h(e3) ? e3 : W(e3);
        return !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() === e3.valueOf() : (e3 = e3.valueOf(), this.clone().startOf(t4).valueOf() <= e3 && e3 <= this.clone().endOf(t4).valueOf()));
      }, i.isSameOrAfter = function(e3, t4) {
        return this.isSame(e3, t4) || this.isAfter(e3, t4);
      }, i.isSameOrBefore = function(e3, t4) {
        return this.isSame(e3, t4) || this.isBefore(e3, t4);
      }, i.isValid = function() {
        return A5(this);
      }, i.lang = Xe, i.locale = Xt, i.localeData = Kt, i.max = we, i.min = ge, i.parsingFlags = function() {
        return E2({}, m2(this));
      }, i.set = function(e3, t4) {
        if ("object" == typeof e3)
          for (var n2 = function(e4) {
            var t5, n3 = [];
            for (t5 in e4)
              c2(e4, t5) && n3.push({ unit: t5, priority: le[t5] });
            return n3.sort(function(e6, t6) {
              return e6.priority - t6.priority;
            }), n3;
          }(e3 = ue(e3)), s3 = n2.length, i2 = 0; i2 < s3; i2++)
            this[n2[i2].unit](e3[n2[i2].unit]);
        else if (d(this[e3 = _2(e3)]))
          return this[e3](t4);
        return this;
      }, i.startOf = function(e3) {
        var t4, n2;
        if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
          return this;
        switch (n2 = this._isUTC ? sn : nn, e3) {
          case "year":
            t4 = n2(this.year(), 0, 1);
            break;
          case "quarter":
            t4 = n2(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            t4 = n2(this.year(), this.month(), 1);
            break;
          case "week":
            t4 = n2(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            t4 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            t4 = n2(this.year(), this.month(), this.date());
            break;
          case "hour":
            t4 = this._d.valueOf(), t4 -= tn(t4 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
            break;
          case "minute":
            t4 = this._d.valueOf(), t4 -= tn(t4, 6e4);
            break;
          case "second":
            t4 = this._d.valueOf(), t4 -= tn(t4, 1e3);
            break;
        }
        return this._d.setTime(t4), f.updateOffset(this, true), this;
      }, i.subtract = Je, i.toArray = function() {
        var e3 = this;
        return [e3.year(), e3.month(), e3.date(), e3.hour(), e3.minute(), e3.second(), e3.millisecond()];
      }, i.toObject = function() {
        var e3 = this;
        return { years: e3.year(), months: e3.month(), date: e3.date(), hours: e3.hours(), minutes: e3.minutes(), seconds: e3.seconds(), milliseconds: e3.milliseconds() };
      }, i.toDate = function() {
        return new Date(this.valueOf());
      }, i.toISOString = function(e3) {
        if (!this.isValid())
          return null;
        var t4 = (e3 = true !== e3) ? this.clone().utc() : this;
        return t4.year() < 0 || 9999 < t4.year() ? re2(t4, e3 ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : d(Date.prototype.toISOString) ? e3 ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", re2(t4, "Z")) : re2(t4, e3 ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }, i.inspect = function() {
        if (!this.isValid())
          return "moment.invalid(/* " + this._i + " */)";
        var e3, t4 = "moment", n2 = "";
        return this.isLocal() || (t4 = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", n2 = "Z"), t4 = "[" + t4 + '("]', e3 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", this.format(t4 + e3 + "-MM-DD[T]HH:mm:ss.SSS" + (n2 + '[")]'));
      }, "undefined" != typeof Symbol && null != Symbol.for && (i[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      }), i.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, i.toString = function() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }, i.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, i.valueOf = function() {
        return this._d.valueOf() - 6e4 * (this._offset || 0);
      }, i.creationData = function() {
        return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
      }, i.eraName = function() {
        for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
          if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
            return t4[n2].name;
          if (t4[n2].until <= e3 && e3 <= t4[n2].since)
            return t4[n2].name;
        }
        return "";
      }, i.eraNarrow = function() {
        for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
          if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
            return t4[n2].narrow;
          if (t4[n2].until <= e3 && e3 <= t4[n2].since)
            return t4[n2].narrow;
        }
        return "";
      }, i.eraAbbr = function() {
        for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
          if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
            return t4[n2].abbr;
          if (t4[n2].until <= e3 && e3 <= t4[n2].since)
            return t4[n2].abbr;
        }
        return "";
      }, i.eraYear = function() {
        for (var e3, t4, n2 = this.localeData().eras(), s3 = 0, i2 = n2.length; s3 < i2; ++s3)
          if (e3 = n2[s3].since <= n2[s3].until ? 1 : -1, t4 = this.clone().startOf("day").valueOf(), n2[s3].since <= t4 && t4 <= n2[s3].until || n2[s3].until <= t4 && t4 <= n2[s3].since)
            return (this.year() - f(n2[s3].since).year()) * e3 + n2[s3].offset;
        return this.year();
      }, i.year = Ie, i.isLeapYear = function() {
        return he(this.year());
      }, i.weekYear = function(e3) {
        return un.call(this, e3, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }, i.isoWeekYear = function(e3) {
        return un.call(this, e3, this.isoWeek(), this.isoWeekday(), 1, 4);
      }, i.quarter = i.quarters = function(e3) {
        return null == e3 ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e3 - 1) + this.month() % 3);
      }, i.month = Ge, i.daysInMonth = function() {
        return We(this.year(), this.month());
      }, i.week = i.weeks = function(e3) {
        var t4 = this.localeData().week(this);
        return null == e3 ? t4 : this.add(7 * (e3 - t4), "d");
      }, i.isoWeek = i.isoWeeks = function(e3) {
        var t4 = qe(this, 1, 4).week;
        return null == e3 ? t4 : this.add(7 * (e3 - t4), "d");
      }, i.weeksInYear = function() {
        var e3 = this.localeData()._week;
        return P(this.year(), e3.dow, e3.doy);
      }, i.weeksInWeekYear = function() {
        var e3 = this.localeData()._week;
        return P(this.weekYear(), e3.dow, e3.doy);
      }, i.isoWeeksInYear = function() {
        return P(this.year(), 1, 4);
      }, i.isoWeeksInISOWeekYear = function() {
        return P(this.isoWeekYear(), 1, 4);
      }, i.date = ke, i.day = i.days = function(e3) {
        if (!this.isValid())
          return null != e3 ? this : NaN;
        var t4, n2, s3 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != e3 ? (t4 = e3, n2 = this.localeData(), e3 = "string" != typeof t4 ? t4 : isNaN(t4) ? "number" == typeof (t4 = n2.weekdaysParse(t4)) ? t4 : null : parseInt(t4, 10), this.add(e3 - s3, "d")) : s3;
      }, i.weekday = function(e3) {
        if (!this.isValid())
          return null != e3 ? this : NaN;
        var t4 = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == e3 ? t4 : this.add(e3 - t4, "d");
      }, i.isoWeekday = function(e3) {
        return this.isValid() ? null != e3 ? (t4 = e3, n2 = this.localeData(), n2 = "string" == typeof t4 ? n2.weekdaysParse(t4) % 7 || 7 : isNaN(t4) ? null : t4, this.day(this.day() % 7 ? n2 : n2 - 7)) : this.day() || 7 : null != e3 ? this : NaN;
        var t4, n2;
      }, i.dayOfYear = function(e3) {
        var t4 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == e3 ? t4 : this.add(e3 - t4, "d");
      }, i.hour = i.hours = k2, i.minute = i.minutes = _e, i.second = i.seconds = ve, i.millisecond = i.milliseconds = ye, i.utcOffset = function(e3, t4, n2) {
        var s3, i2 = this._offset || 0;
        if (!this.isValid())
          return null != e3 ? this : NaN;
        if (null == e3)
          return this._isUTC ? i2 : Et(this);
        if ("string" == typeof e3) {
          if (null === (e3 = Vt(Ye, e3)))
            return this;
        } else
          Math.abs(e3) < 16 && !n2 && (e3 *= 60);
        return !this._isUTC && t4 && (s3 = Et(this)), this._offset = e3, this._isUTC = true, null != s3 && this.add(s3, "m"), i2 !== e3 && (!t4 || this._changeInProgress ? qt(this, C3(e3 - i2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, f.updateOffset(this, true), this._changeInProgress = null)), this;
      }, i.utc = function(e3) {
        return this.utcOffset(0, e3);
      }, i.local = function(e3) {
        return this._isUTC && (this.utcOffset(0, e3), this._isUTC = false, e3 && this.subtract(Et(this), "m")), this;
      }, i.parseZone = function() {
        var e3;
        return null != this._tzm ? this.utcOffset(this._tzm, false, true) : "string" == typeof this._i && (null != (e3 = Vt(Se, this._i)) ? this.utcOffset(e3) : this.utcOffset(0, true)), this;
      }, i.hasAlignedHourOffset = function(e3) {
        return !!this.isValid() && (e3 = e3 ? W(e3).utcOffset() : 0, (this.utcOffset() - e3) % 60 == 0);
      }, i.isDST = function() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }, i.isLocal = function() {
        return !!this.isValid() && !this._isUTC;
      }, i.isUtcOffset = function() {
        return !!this.isValid() && this._isUTC;
      }, i.isUtc = At, i.isUTC = At, i.zoneAbbr = function() {
        return this._isUTC ? "UTC" : "";
      }, i.zoneName = function() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }, i.dates = e("dates accessor is deprecated. Use date instead.", ke), i.months = e("months accessor is deprecated. Use month instead", Ge), i.years = e("years accessor is deprecated. Use year instead", Ie), i.zone = e("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(e3, t4) {
        return null != e3 ? (this.utcOffset(e3 = "string" != typeof e3 ? -e3 : e3, t4), this) : -this.utcOffset();
      }), i.isDSTShifted = e("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
        if (!o(this._isDSTShifted))
          return this._isDSTShifted;
        var e3, t4 = {};
        return $(t4, this), (t4 = Nt(t4))._a ? (e3 = (t4._isUTC ? l : W)(t4._a), this._isDSTShifted = this.isValid() && 0 < function(e4, t5, n2) {
          for (var s3 = Math.min(e4.length, t5.length), i2 = Math.abs(e4.length - t5.length), r2 = 0, a3 = 0; a3 < s3; a3++)
            (n2 && e4[a3] !== t5[a3] || !n2 && g(e4[a3]) !== g(t5[a3])) && r2++;
          return r2 + i2;
        }(t4._a, e3.toArray())) : this._isDSTShifted = false, this._isDSTShifted;
      });
      w2 = K2.prototype;
      function cn(e3, t4, n2, s3) {
        var i2 = mt(), s3 = l().set(s3, t4);
        return i2[n2](s3, e3);
      }
      function fn(e3, t4, n2) {
        if (u2(e3) && (t4 = e3, e3 = void 0), e3 = e3 || "", null != t4)
          return cn(e3, t4, n2, "month");
        for (var s3 = [], i2 = 0; i2 < 12; i2++)
          s3[i2] = cn(e3, i2, n2, "month");
        return s3;
      }
      function mn(e3, t4, n2, s3) {
        t4 = ("boolean" == typeof e3 ? u2(t4) && (n2 = t4, t4 = void 0) : (t4 = e3, e3 = false, u2(n2 = t4) && (n2 = t4, t4 = void 0)), t4 || "");
        var i2, r2 = mt(), a3 = e3 ? r2._week.dow : 0, o2 = [];
        if (null != n2)
          return cn(t4, (n2 + a3) % 7, s3, "day");
        for (i2 = 0; i2 < 7; i2++)
          o2[i2] = cn(t4, (i2 + a3) % 7, s3, "day");
        return o2;
      }
      w2.calendar = function(e3, t4, n2) {
        return d(e3 = this._calendar[e3] || this._calendar.sameElse) ? e3.call(t4, n2) : e3;
      }, w2.longDateFormat = function(e3) {
        var t4 = this._longDateFormat[e3], n2 = this._longDateFormat[e3.toUpperCase()];
        return t4 || !n2 ? t4 : (this._longDateFormat[e3] = n2.match(te).map(function(e4) {
          return "MMMM" === e4 || "MM" === e4 || "DD" === e4 || "dddd" === e4 ? e4.slice(1) : e4;
        }).join(""), this._longDateFormat[e3]);
      }, w2.invalidDate = function() {
        return this._invalidDate;
      }, w2.ordinal = function(e3) {
        return this._ordinal.replace("%d", e3);
      }, w2.preparse = dn, w2.postformat = dn, w2.relativeTime = function(e3, t4, n2, s3) {
        var i2 = this._relativeTime[n2];
        return d(i2) ? i2(e3, t4, n2, s3) : i2.replace(/%d/i, e3);
      }, w2.pastFuture = function(e3, t4) {
        return d(e3 = this._relativeTime[0 < e3 ? "future" : "past"]) ? e3(t4) : e3.replace(/%s/i, t4);
      }, w2.set = function(e3) {
        var t4, n2;
        for (n2 in e3)
          c2(e3, n2) && (d(t4 = e3[n2]) ? this[n2] = t4 : this["_" + n2] = t4);
        this._config = e3, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }, w2.eras = function(e3, t4) {
        for (var n2, s3 = this._eras || mt("en")._eras, i2 = 0, r2 = s3.length; i2 < r2; ++i2) {
          switch (typeof s3[i2].since) {
            case "string":
              n2 = f(s3[i2].since).startOf("day"), s3[i2].since = n2.valueOf();
              break;
          }
          switch (typeof s3[i2].until) {
            case "undefined":
              s3[i2].until = 1 / 0;
              break;
            case "string":
              n2 = f(s3[i2].until).startOf("day").valueOf(), s3[i2].until = n2.valueOf();
              break;
          }
        }
        return s3;
      }, w2.erasParse = function(e3, t4, n2) {
        var s3, i2, r2, a3, o2, u3 = this.eras();
        for (e3 = e3.toUpperCase(), s3 = 0, i2 = u3.length; s3 < i2; ++s3)
          if (r2 = u3[s3].name.toUpperCase(), a3 = u3[s3].abbr.toUpperCase(), o2 = u3[s3].narrow.toUpperCase(), n2)
            switch (t4) {
              case "N":
              case "NN":
              case "NNN":
                if (a3 === e3)
                  return u3[s3];
                break;
              case "NNNN":
                if (r2 === e3)
                  return u3[s3];
                break;
              case "NNNNN":
                if (o2 === e3)
                  return u3[s3];
                break;
            }
          else if (0 <= [r2, a3, o2].indexOf(e3))
            return u3[s3];
      }, w2.erasConvertYear = function(e3, t4) {
        var n2 = e3.since <= e3.until ? 1 : -1;
        return void 0 === t4 ? f(e3.since).year() : f(e3.since).year() + (t4 - e3.offset) * n2;
      }, w2.erasAbbrRegex = function(e3) {
        return c2(this, "_erasAbbrRegex") || an.call(this), e3 ? this._erasAbbrRegex : this._erasRegex;
      }, w2.erasNameRegex = function(e3) {
        return c2(this, "_erasNameRegex") || an.call(this), e3 ? this._erasNameRegex : this._erasRegex;
      }, w2.erasNarrowRegex = function(e3) {
        return c2(this, "_erasNarrowRegex") || an.call(this), e3 ? this._erasNarrowRegex : this._erasRegex;
      }, w2.months = function(e3, t4) {
        return e3 ? (a2(this._months) ? this._months : this._months[(this._months.isFormat || He).test(t4) ? "format" : "standalone"])[e3.month()] : a2(this._months) ? this._months : this._months.standalone;
      }, w2.monthsShort = function(e3, t4) {
        return e3 ? (a2(this._monthsShort) ? this._monthsShort : this._monthsShort[He.test(t4) ? "format" : "standalone"])[e3.month()] : a2(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
      }, w2.monthsParse = function(e3, t4, n2) {
        var s3, i2;
        if (this._monthsParseExact)
          return function(e4, t5, n3) {
            var s4, i3, r2, e4 = e4.toLocaleLowerCase();
            if (!this._monthsParse)
              for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s4 = 0; s4 < 12; ++s4)
                r2 = l([2e3, s4]), this._shortMonthsParse[s4] = this.monthsShort(r2, "").toLocaleLowerCase(), this._longMonthsParse[s4] = this.months(r2, "").toLocaleLowerCase();
            return n3 ? "MMM" === t5 ? -1 !== (i3 = S.call(this._shortMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._longMonthsParse, e4)) ? i3 : null : "MMM" === t5 ? -1 !== (i3 = S.call(this._shortMonthsParse, e4)) || -1 !== (i3 = S.call(this._longMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._longMonthsParse, e4)) || -1 !== (i3 = S.call(this._shortMonthsParse, e4)) ? i3 : null;
          }.call(this, e3, t4, n2);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s3 = 0; s3 < 12; s3++) {
          if (i2 = l([2e3, s3]), n2 && !this._longMonthsParse[s3] && (this._longMonthsParse[s3] = new RegExp("^" + this.months(i2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s3] = new RegExp("^" + this.monthsShort(i2, "").replace(".", "") + "$", "i")), n2 || this._monthsParse[s3] || (i2 = "^" + this.months(i2, "") + "|^" + this.monthsShort(i2, ""), this._monthsParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "MMMM" === t4 && this._longMonthsParse[s3].test(e3))
            return s3;
          if (n2 && "MMM" === t4 && this._shortMonthsParse[s3].test(e3))
            return s3;
          if (!n2 && this._monthsParse[s3].test(e3))
            return s3;
        }
      }, w2.monthsRegex = function(e3) {
        return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee.call(this), e3 ? this._monthsStrictRegex : this._monthsRegex) : (c2(this, "_monthsRegex") || (this._monthsRegex = Le), this._monthsStrictRegex && e3 ? this._monthsStrictRegex : this._monthsRegex);
      }, w2.monthsShortRegex = function(e3) {
        return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee.call(this), e3 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (c2(this, "_monthsShortRegex") || (this._monthsShortRegex = Fe), this._monthsShortStrictRegex && e3 ? this._monthsShortStrictRegex : this._monthsShortRegex);
      }, w2.week = function(e3) {
        return qe(e3, this._week.dow, this._week.doy).week;
      }, w2.firstDayOfYear = function() {
        return this._week.doy;
      }, w2.firstDayOfWeek = function() {
        return this._week.dow;
      }, w2.weekdays = function(e3, t4) {
        return t4 = a2(this._weekdays) ? this._weekdays : this._weekdays[e3 && true !== e3 && this._weekdays.isFormat.test(t4) ? "format" : "standalone"], true === e3 ? Be(t4, this._week.dow) : e3 ? t4[e3.day()] : t4;
      }, w2.weekdaysMin = function(e3) {
        return true === e3 ? Be(this._weekdaysMin, this._week.dow) : e3 ? this._weekdaysMin[e3.day()] : this._weekdaysMin;
      }, w2.weekdaysShort = function(e3) {
        return true === e3 ? Be(this._weekdaysShort, this._week.dow) : e3 ? this._weekdaysShort[e3.day()] : this._weekdaysShort;
      }, w2.weekdaysParse = function(e3, t4, n2) {
        var s3, i2;
        if (this._weekdaysParseExact)
          return function(e4, t5, n3) {
            var s4, i3, r2, e4 = e4.toLocaleLowerCase();
            if (!this._weekdaysParse)
              for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s4 = 0; s4 < 7; ++s4)
                r2 = l([2e3, 1]).day(s4), this._minWeekdaysParse[s4] = this.weekdaysMin(r2, "").toLocaleLowerCase(), this._shortWeekdaysParse[s4] = this.weekdaysShort(r2, "").toLocaleLowerCase(), this._weekdaysParse[s4] = this.weekdays(r2, "").toLocaleLowerCase();
            return n3 ? "dddd" === t5 ? -1 !== (i3 = S.call(this._weekdaysParse, e4)) ? i3 : null : "ddd" === t5 ? -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : "dddd" === t5 ? -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : "ddd" === t5 ? -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) ? i3 : null;
          }.call(this, e3, t4, n2);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s3 = 0; s3 < 7; s3++) {
          if (i2 = l([2e3, 1]).day(s3), n2 && !this._fullWeekdaysParse[s3] && (this._fullWeekdaysParse[s3] = new RegExp("^" + this.weekdays(i2, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s3] = new RegExp("^" + this.weekdaysShort(i2, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s3] = new RegExp("^" + this.weekdaysMin(i2, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s3] || (i2 = "^" + this.weekdays(i2, "") + "|^" + this.weekdaysShort(i2, "") + "|^" + this.weekdaysMin(i2, ""), this._weekdaysParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "dddd" === t4 && this._fullWeekdaysParse[s3].test(e3))
            return s3;
          if (n2 && "ddd" === t4 && this._shortWeekdaysParse[s3].test(e3))
            return s3;
          if (n2 && "dd" === t4 && this._minWeekdaysParse[s3].test(e3))
            return s3;
          if (!n2 && this._weekdaysParse[s3].test(e3))
            return s3;
        }
      }, w2.weekdaysRegex = function(e3) {
        return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (c2(this, "_weekdaysRegex") || (this._weekdaysRegex = Ke), this._weekdaysStrictRegex && e3 ? this._weekdaysStrictRegex : this._weekdaysRegex);
      }, w2.weekdaysShortRegex = function(e3) {
        return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (c2(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = et), this._weekdaysShortStrictRegex && e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
      }, w2.weekdaysMinRegex = function(e3) {
        return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (c2(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = tt), this._weekdaysMinStrictRegex && e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
      }, w2.isPM = function(e3) {
        return "p" === (e3 + "").toLowerCase().charAt(0);
      }, w2.meridiem = function(e3, t4, n2) {
        return 11 < e3 ? n2 ? "pm" : "PM" : n2 ? "am" : "AM";
      }, ct("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e3) {
        var t4 = e3 % 10;
        return e3 + (1 === g(e3 % 100 / 10) ? "th" : 1 == t4 ? "st" : 2 == t4 ? "nd" : 3 == t4 ? "rd" : "th");
      } }), f.lang = e("moment.lang is deprecated. Use moment.locale instead.", ct), f.langData = e("moment.langData is deprecated. Use moment.localeData instead.", mt);
      var _n = Math.abs;
      function yn(e3, t4, n2, s3) {
        t4 = C3(t4, n2);
        return e3._milliseconds += s3 * t4._milliseconds, e3._days += s3 * t4._days, e3._months += s3 * t4._months, e3._bubble();
      }
      function gn(e3) {
        return e3 < 0 ? Math.floor(e3) : Math.ceil(e3);
      }
      function wn(e3) {
        return 4800 * e3 / 146097;
      }
      function pn(e3) {
        return 146097 * e3 / 4800;
      }
      function kn(e3) {
        return function() {
          return this.as(e3);
        };
      }
      pe = kn("ms"), me = kn("s"), Ce = kn("m"), we = kn("h"), ge = kn("d"), Je = kn("w"), k2 = kn("M"), _e = kn("Q"), ve = kn("y");
      function vn(e3) {
        return function() {
          return this.isValid() ? this._data[e3] : NaN;
        };
      }
      var ye = vn("milliseconds"), ke = vn("seconds"), Ie = vn("minutes"), w2 = vn("hours"), Mn = vn("days"), Dn = vn("months"), Sn = vn("years");
      var Yn2 = Math.round, On = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
      function bn(e3, t4, n2, s3) {
        var i2 = C3(e3).abs(), r2 = Yn2(i2.as("s")), a3 = Yn2(i2.as("m")), o2 = Yn2(i2.as("h")), u3 = Yn2(i2.as("d")), l2 = Yn2(i2.as("M")), h2 = Yn2(i2.as("w")), i2 = Yn2(i2.as("y")), r2 = (r2 <= n2.ss ? ["s", r2] : r2 < n2.s && ["ss", r2]) || a3 <= 1 && ["m"] || a3 < n2.m && ["mm", a3] || o2 <= 1 && ["h"] || o2 < n2.h && ["hh", o2] || u3 <= 1 && ["d"] || u3 < n2.d && ["dd", u3];
        return (r2 = (r2 = null != n2.w ? r2 || h2 <= 1 && ["w"] || h2 < n2.w && ["ww", h2] : r2) || l2 <= 1 && ["M"] || l2 < n2.M && ["MM", l2] || i2 <= 1 && ["y"] || ["yy", i2])[2] = t4, r2[3] = 0 < +e3, r2[4] = s3, function(e4, t5, n3, s4, i3) {
          return i3.relativeTime(t5 || 1, !!n3, e4, s4);
        }.apply(null, r2);
      }
      var xn = Math.abs;
      function Tn(e3) {
        return (0 < e3) - (e3 < 0) || +e3;
      }
      function Nn() {
        if (!this.isValid())
          return this.localeData().invalidDate();
        var e3, t4, n2, s3, i2, r2, a3, o2 = xn(this._milliseconds) / 1e3, u3 = xn(this._days), l2 = xn(this._months), h2 = this.asSeconds();
        return h2 ? (e3 = y2(o2 / 60), t4 = y2(e3 / 60), o2 %= 60, e3 %= 60, n2 = y2(l2 / 12), l2 %= 12, s3 = o2 ? o2.toFixed(3).replace(/\.?0+$/, "") : "", i2 = Tn(this._months) !== Tn(h2) ? "-" : "", r2 = Tn(this._days) !== Tn(h2) ? "-" : "", a3 = Tn(this._milliseconds) !== Tn(h2) ? "-" : "", (h2 < 0 ? "-" : "") + "P" + (n2 ? i2 + n2 + "Y" : "") + (l2 ? i2 + l2 + "M" : "") + (u3 ? r2 + u3 + "D" : "") + (t4 || e3 || o2 ? "T" : "") + (t4 ? a3 + t4 + "H" : "") + (e3 ? a3 + e3 + "M" : "") + (o2 ? a3 + s3 + "S" : "")) : "P0D";
      }
      var U = Ct.prototype;
      return U.isValid = function() {
        return this._isValid;
      }, U.abs = function() {
        var e3 = this._data;
        return this._milliseconds = _n(this._milliseconds), this._days = _n(this._days), this._months = _n(this._months), e3.milliseconds = _n(e3.milliseconds), e3.seconds = _n(e3.seconds), e3.minutes = _n(e3.minutes), e3.hours = _n(e3.hours), e3.months = _n(e3.months), e3.years = _n(e3.years), this;
      }, U.add = function(e3, t4) {
        return yn(this, e3, t4, 1);
      }, U.subtract = function(e3, t4) {
        return yn(this, e3, t4, -1);
      }, U.as = function(e3) {
        if (!this.isValid())
          return NaN;
        var t4, n2, s3 = this._milliseconds;
        if ("month" === (e3 = _2(e3)) || "quarter" === e3 || "year" === e3)
          switch (t4 = this._days + s3 / 864e5, n2 = this._months + wn(t4), e3) {
            case "month":
              return n2;
            case "quarter":
              return n2 / 3;
            case "year":
              return n2 / 12;
          }
        else
          switch (t4 = this._days + Math.round(pn(this._months)), e3) {
            case "week":
              return t4 / 7 + s3 / 6048e5;
            case "day":
              return t4 + s3 / 864e5;
            case "hour":
              return 24 * t4 + s3 / 36e5;
            case "minute":
              return 1440 * t4 + s3 / 6e4;
            case "second":
              return 86400 * t4 + s3 / 1e3;
            case "millisecond":
              return Math.floor(864e5 * t4) + s3;
            default:
              throw new Error("Unknown unit " + e3);
          }
      }, U.asMilliseconds = pe, U.asSeconds = me, U.asMinutes = Ce, U.asHours = we, U.asDays = ge, U.asWeeks = Je, U.asMonths = k2, U.asQuarters = _e, U.asYears = ve, U.valueOf = function() {
        return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN;
      }, U._bubble = function() {
        var e3 = this._milliseconds, t4 = this._days, n2 = this._months, s3 = this._data;
        return 0 <= e3 && 0 <= t4 && 0 <= n2 || e3 <= 0 && t4 <= 0 && n2 <= 0 || (e3 += 864e5 * gn(pn(n2) + t4), n2 = t4 = 0), s3.milliseconds = e3 % 1e3, e3 = y2(e3 / 1e3), s3.seconds = e3 % 60, e3 = y2(e3 / 60), s3.minutes = e3 % 60, e3 = y2(e3 / 60), s3.hours = e3 % 24, t4 += y2(e3 / 24), n2 += e3 = y2(wn(t4)), t4 -= gn(pn(e3)), e3 = y2(n2 / 12), n2 %= 12, s3.days = t4, s3.months = n2, s3.years = e3, this;
      }, U.clone = function() {
        return C3(this);
      }, U.get = function(e3) {
        return e3 = _2(e3), this.isValid() ? this[e3 + "s"]() : NaN;
      }, U.milliseconds = ye, U.seconds = ke, U.minutes = Ie, U.hours = w2, U.days = Mn, U.weeks = function() {
        return y2(this.days() / 7);
      }, U.months = Dn, U.years = Sn, U.humanize = function(e3, t4) {
        if (!this.isValid())
          return this.localeData().invalidDate();
        var n2 = false, s3 = On;
        return "object" == typeof e3 && (t4 = e3, e3 = false), "boolean" == typeof e3 && (n2 = e3), "object" == typeof t4 && (s3 = Object.assign({}, On, t4), null != t4.s && null == t4.ss && (s3.ss = t4.s - 1)), e3 = this.localeData(), t4 = bn(this, !n2, s3, e3), n2 && (t4 = e3.pastFuture(+this, t4)), e3.postformat(t4);
      }, U.toISOString = Nn, U.toString = Nn, U.toJSON = Nn, U.locale = Xt, U.localeData = Kt, U.toIsoString = e("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Nn), U.lang = Xe, s2("X", 0, 0, "unix"), s2("x", 0, 0, "valueOf"), v("x", De), v("X", /[+-]?\d+(\.\d{1,3})?/), D2("X", function(e3, t4, n2) {
        n2._d = new Date(1e3 * parseFloat(e3));
      }), D2("x", function(e3, t4, n2) {
        n2._d = new Date(g(e3));
      }), f.version = "2.29.4", H = W, f.fn = i, f.min = function() {
        return Rt("isBefore", [].slice.call(arguments, 0));
      }, f.max = function() {
        return Rt("isAfter", [].slice.call(arguments, 0));
      }, f.now = function() {
        return Date.now ? Date.now() : +new Date();
      }, f.utc = l, f.unix = function(e3) {
        return W(1e3 * e3);
      }, f.months = function(e3, t4) {
        return fn(e3, t4, "months");
      }, f.isDate = V, f.locale = ct, f.invalid = I, f.duration = C3, f.isMoment = h, f.weekdays = function(e3, t4, n2) {
        return mn(e3, t4, n2, "weekdays");
      }, f.parseZone = function() {
        return W.apply(null, arguments).parseZone();
      }, f.localeData = mt, f.isDuration = Ut, f.monthsShort = function(e3, t4) {
        return fn(e3, t4, "monthsShort");
      }, f.weekdaysMin = function(e3, t4, n2) {
        return mn(e3, t4, n2, "weekdaysMin");
      }, f.defineLocale = ft, f.updateLocale = function(e3, t4) {
        var n2, s3;
        return null != t4 ? (s3 = ot, null != R[e3] && null != R[e3].parentLocale ? R[e3].set(X3(R[e3]._config, t4)) : (t4 = X3(s3 = null != (n2 = dt(e3)) ? n2._config : s3, t4), null == n2 && (t4.abbr = e3), (s3 = new K2(t4)).parentLocale = R[e3], R[e3] = s3), ct(e3)) : null != R[e3] && (null != R[e3].parentLocale ? (R[e3] = R[e3].parentLocale, e3 === ct() && ct(e3)) : null != R[e3] && delete R[e3]), R[e3];
      }, f.locales = function() {
        return ee(R);
      }, f.weekdaysShort = function(e3, t4, n2) {
        return mn(e3, t4, n2, "weekdaysShort");
      }, f.normalizeUnits = _2, f.relativeTimeRounding = function(e3) {
        return void 0 === e3 ? Yn2 : "function" == typeof e3 && (Yn2 = e3, true);
      }, f.relativeTimeThreshold = function(e3, t4) {
        return void 0 !== On[e3] && (void 0 === t4 ? On[e3] : (On[e3] = t4, "s" === e3 && (On.ss = t4 - 1), true));
      }, f.calendarFormat = function(e3, t4) {
        return (e3 = e3.diff(t4, "days", true)) < -6 ? "sameElse" : e3 < -1 ? "lastWeek" : e3 < 0 ? "lastDay" : e3 < 1 ? "sameDay" : e3 < 2 ? "nextDay" : e3 < 7 ? "nextWeek" : "sameElse";
      }, f.prototype = i, f.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, f;
    });
  })(moment_min);
  const moment = moment_min.exports;
  const LEVELS = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5
  };
  const log$3 = {
    trace: (..._args) => {
    },
    debug: (..._args) => {
    },
    info: (..._args) => {
    },
    warn: (..._args) => {
    },
    error: (..._args) => {
    },
    fatal: (..._args) => {
    }
  };
  const setLogLevel$1 = function(level = "fatal") {
    let numericLevel = LEVELS.fatal;
    if (typeof level === "string") {
      level = level.toLowerCase();
      if (level in LEVELS) {
        numericLevel = LEVELS[level];
      }
    } else if (typeof level === "number") {
      numericLevel = level;
    }
    log$3.trace = () => {
    };
    log$3.debug = () => {
    };
    log$3.info = () => {
    };
    log$3.warn = () => {
    };
    log$3.error = () => {
    };
    log$3.fatal = () => {
    };
    if (numericLevel <= LEVELS.fatal) {
      log$3.fatal = console.error ? console.error.bind(console, format$1("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", format$1("FATAL"));
    }
    if (numericLevel <= LEVELS.error) {
      log$3.error = console.error ? console.error.bind(console, format$1("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", format$1("ERROR"));
    }
    if (numericLevel <= LEVELS.warn) {
      log$3.warn = console.warn ? console.warn.bind(console, format$1("WARN"), "color: orange") : console.log.bind(console, `\x1B[33m`, format$1("WARN"));
    }
    if (numericLevel <= LEVELS.info) {
      log$3.info = console.info ? console.info.bind(console, format$1("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", format$1("INFO"));
    }
    if (numericLevel <= LEVELS.debug) {
      log$3.debug = console.debug ? console.debug.bind(console, format$1("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format$1("DEBUG"));
    }
    if (numericLevel <= LEVELS.trace) {
      log$3.trace = console.debug ? console.debug.bind(console, format$1("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format$1("TRACE"));
    }
  };
  const format$1 = (level) => {
    const time2 = moment().format("ss.SSS");
    return `%c${time2} : ${level} : `;
  };
  var dist$1 = {};
  Object.defineProperty(dist$1, "__esModule", { value: true });
  var sanitizeUrl_1 = dist$1.sanitizeUrl = void 0;
  var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
  var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
  var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
  var urlSchemeRegex = /^([^:]+):/gm;
  var relativeFirstCharacters = [".", "/"];
  function isRelativeUrlWithoutProtocol(url) {
    return relativeFirstCharacters.indexOf(url[0]) > -1;
  }
  function decodeHtmlCharacters(str) {
    return str.replace(htmlEntitiesRegex, function(match, dec) {
      return String.fromCharCode(dec);
    });
  }
  function sanitizeUrl(url) {
    var sanitizedUrl = decodeHtmlCharacters(url || "").replace(ctrlCharactersRegex, "").trim();
    if (!sanitizedUrl) {
      return "about:blank";
    }
    if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
      return sanitizedUrl;
    }
    var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
    if (!urlSchemeParseResults) {
      return sanitizedUrl;
    }
    var urlScheme = urlSchemeParseResults[0];
    if (invalidProtocolRegex.test(urlScheme)) {
      return "about:blank";
    }
    return sanitizedUrl;
  }
  sanitizeUrl_1 = dist$1.sanitizeUrl = sanitizeUrl;
  function ascending$3(a2, b) {
    return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function descending$2(a2, b) {
    return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending$3;
      compare2 = (d, x2) => ascending$3(f(d), x2);
      delta = (d, x2) => f(d) - x2;
    } else {
      compare1 = f === ascending$3 || f === descending$2 ? f : zero$1;
      compare2 = f;
      delta = f;
    }
    function left2(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a2, x2, lo = 0, hi = a2.length) {
      if (lo < hi) {
        if (compare1(x2, x2) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a2[mid], x2) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a2, x2, lo = 0, hi = a2.length) {
      const i = left2(a2, x2, lo, hi - 1);
      return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero$1() {
    return 0;
  }
  function number$3(x2) {
    return x2 === null ? NaN : +x2;
  }
  function* numbers(values, valueof) {
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }
  const ascendingBisect = bisector(ascending$3);
  const bisectRight = ascendingBisect.right;
  const bisectLeft = ascendingBisect.left;
  const bisectCenter = bisector(number$3).center;
  const bisect = bisectRight;
  function blur(values, r) {
    if (!((r = +r) >= 0))
      throw new RangeError("invalid r");
    let length2 = values.length;
    if (!((length2 = Math.floor(length2)) >= 0))
      throw new RangeError("invalid length");
    if (!length2 || !r)
      return values;
    const blur3 = blurf(r);
    const temp = values.slice();
    blur3(values, temp, 0, length2, 1);
    blur3(temp, values, 0, length2, 1);
    blur3(values, temp, 0, length2, 1);
    return values;
  }
  const blur2 = Blur2(blurf);
  const blurImage = Blur2(blurfImage);
  function Blur2(blur3) {
    return function(data, rx, ry = rx) {
      if (!((rx = +rx) >= 0))
        throw new RangeError("invalid rx");
      if (!((ry = +ry) >= 0))
        throw new RangeError("invalid ry");
      let { data: values, width: width2, height: height2 } = data;
      if (!((width2 = Math.floor(width2)) >= 0))
        throw new RangeError("invalid width");
      if (!((height2 = Math.floor(height2 !== void 0 ? height2 : values.length / width2)) >= 0))
        throw new RangeError("invalid height");
      if (!width2 || !height2 || !rx && !ry)
        return data;
      const blurx = rx && blur3(rx);
      const blury = ry && blur3(ry);
      const temp = values.slice();
      if (blurx && blury) {
        blurh(blurx, temp, values, width2, height2);
        blurh(blurx, values, temp, width2, height2);
        blurh(blurx, temp, values, width2, height2);
        blurv(blury, values, temp, width2, height2);
        blurv(blury, temp, values, width2, height2);
        blurv(blury, values, temp, width2, height2);
      } else if (blurx) {
        blurh(blurx, values, temp, width2, height2);
        blurh(blurx, temp, values, width2, height2);
        blurh(blurx, values, temp, width2, height2);
      } else if (blury) {
        blurv(blury, values, temp, width2, height2);
        blurv(blury, temp, values, width2, height2);
        blurv(blury, values, temp, width2, height2);
      }
      return data;
    };
  }
  function blurh(blur3, T, S, w2, h) {
    for (let y2 = 0, n = w2 * h; y2 < n; ) {
      blur3(T, S, y2, y2 += w2, 1);
    }
  }
  function blurv(blur3, T, S, w2, h) {
    for (let x2 = 0, n = w2 * h; x2 < w2; ++x2) {
      blur3(T, S, x2, x2 + n, w2);
    }
  }
  function blurfImage(radius) {
    const blur3 = blurf(radius);
    return (T, S, start2, stop, step) => {
      start2 <<= 2, stop <<= 2, step <<= 2;
      blur3(T, S, start2 + 0, stop + 0, step);
      blur3(T, S, start2 + 1, stop + 1, step);
      blur3(T, S, start2 + 2, stop + 2, step);
      blur3(T, S, start2 + 3, stop + 3, step);
    };
  }
  function blurf(radius) {
    const radius0 = Math.floor(radius);
    if (radius0 === radius)
      return bluri(radius);
    const t = radius - radius0;
    const w2 = 2 * radius + 1;
    return (T, S, start2, stop, step) => {
      if (!((stop -= step) >= start2))
        return;
      let sum2 = radius0 * S[start2];
      const s0 = step * radius0;
      const s1 = s0 + step;
      for (let i = start2, j = start2 + s0; i < j; i += step) {
        sum2 += S[Math.min(stop, i)];
      }
      for (let i = start2, j = stop; i <= j; i += step) {
        sum2 += S[Math.min(stop, i + s0)];
        T[i] = (sum2 + t * (S[Math.max(start2, i - s1)] + S[Math.min(stop, i + s1)])) / w2;
        sum2 -= S[Math.max(start2, i - s0)];
      }
    };
  }
  function bluri(radius) {
    const w2 = 2 * radius + 1;
    return (T, S, start2, stop, step) => {
      if (!((stop -= step) >= start2))
        return;
      let sum2 = radius * S[start2];
      const s2 = step * radius;
      for (let i = start2, j = start2 + s2; i < j; i += step) {
        sum2 += S[Math.min(stop, i)];
      }
      for (let i = start2, j = stop; i <= j; i += step) {
        sum2 += S[Math.min(stop, i + s2)];
        T[i] = sum2 / w2;
        sum2 -= S[Math.max(start2, i - s2)];
      }
    };
  }
  function count$1(values, valueof) {
    let count2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count2;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          ++count2;
        }
      }
    }
    return count2;
  }
  function length$4(array2) {
    return array2.length | 0;
  }
  function empty$2(length2) {
    return !(length2 > 0);
  }
  function arrayify(values) {
    return typeof values !== "object" || "length" in values ? values : Array.from(values);
  }
  function reducer(reduce2) {
    return (values) => reduce2(...values);
  }
  function cross$3(...values) {
    const reduce2 = typeof values[values.length - 1] === "function" && reducer(values.pop());
    values = values.map(arrayify);
    const lengths = values.map(length$4);
    const j = values.length - 1;
    const index2 = new Array(j + 1).fill(0);
    const product = [];
    if (j < 0 || lengths.some(empty$2))
      return product;
    while (true) {
      product.push(index2.map((j2, i2) => values[i2][j2]));
      let i = j;
      while (++index2[i] === lengths[i]) {
        if (i === 0)
          return reduce2 ? product.map(reduce2) : product;
        index2[i--] = 0;
      }
    }
  }
  function cumsum(values, valueof) {
    var sum2 = 0, index2 = 0;
    return Float64Array.from(values, valueof === void 0 ? (v) => sum2 += +v || 0 : (v) => sum2 += +valueof(v, index2++, values) || 0);
  }
  function variance(values, valueof) {
    let count2 = 0;
    let delta;
    let mean2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value - mean2);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count2;
          sum2 += delta * (value - mean2);
        }
      }
    }
    if (count2 > 1)
      return sum2 / (count2 - 1);
  }
  function deviation(values, valueof) {
    const v = variance(values, valueof);
    return v ? Math.sqrt(v) : v;
  }
  function extent$1(values, valueof) {
    let min2;
    let max2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null) {
          if (min2 === void 0) {
            if (value >= value)
              min2 = max2 = value;
          } else {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null) {
          if (min2 === void 0) {
            if (value >= value)
              min2 = max2 = value;
          } else {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    }
    return [min2, max2];
  }
  class Adder {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x2) {
      const p = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y2 = p[j], hi = x2 + y2, lo = Math.abs(x2) < Math.abs(y2) ? x2 - (hi - y2) : y2 - (hi - x2);
        if (lo)
          p[i++] = lo;
        x2 = hi;
      }
      p[i] = x2;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p = this._partials;
      let n = this._n, x2, y2, lo, hi = 0;
      if (n > 0) {
        hi = p[--n];
        while (n > 0) {
          x2 = hi;
          y2 = p[--n];
          hi = x2 + y2;
          lo = y2 - (hi - x2);
          if (lo)
            break;
        }
        if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
          y2 = lo * 2;
          x2 = hi + y2;
          if (y2 == x2 - hi)
            hi = x2;
        }
      }
      return hi;
    }
  }
  function fsum(values, valueof) {
    const adder = new Adder();
    if (valueof === void 0) {
      for (let value of values) {
        if (value = +value) {
          adder.add(value);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index2, values)) {
          adder.add(value);
        }
      }
    }
    return +adder;
  }
  function fcumsum(values, valueof) {
    const adder = new Adder();
    let index2 = -1;
    return Float64Array.from(
      values,
      valueof === void 0 ? (v) => adder.add(+v || 0) : (v) => adder.add(+valueof(v, ++index2, values) || 0)
    );
  }
  class InternMap extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null)
        for (const [key2, value] of entries)
          this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  }
  class InternSet extends Set {
    constructor(values, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values != null)
        for (const value of values)
          this.add(value);
    }
    has(value) {
      return super.has(intern_get(this, value));
    }
    add(value) {
      return super.add(intern_set(this, value));
    }
    delete(value) {
      return super.delete(intern_delete(this, value));
    }
  }
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key))
      return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function identity$9(x2) {
    return x2;
  }
  function group(values, ...keys) {
    return nest(values, identity$9, identity$9, keys);
  }
  function groups(values, ...keys) {
    return nest(values, Array.from, identity$9, keys);
  }
  function flatten$1(groups2, keys) {
    for (let i = 1, n = keys.length; i < n; ++i) {
      groups2 = groups2.flatMap((g) => g.pop().map(([key, value]) => [...g, key, value]));
    }
    return groups2;
  }
  function flatGroup(values, ...keys) {
    return flatten$1(groups(values, ...keys), keys);
  }
  function flatRollup(values, reduce2, ...keys) {
    return flatten$1(rollups(values, reduce2, ...keys), keys);
  }
  function rollup(values, reduce2, ...keys) {
    return nest(values, identity$9, reduce2, keys);
  }
  function rollups(values, reduce2, ...keys) {
    return nest(values, Array.from, reduce2, keys);
  }
  function index$4(values, ...keys) {
    return nest(values, identity$9, unique, keys);
  }
  function indexes(values, ...keys) {
    return nest(values, Array.from, unique, keys);
  }
  function unique(values) {
    if (values.length !== 1)
      throw new Error("duplicate key");
    return values[0];
  }
  function nest(values, map2, reduce2, keys) {
    return function regroup(values2, i) {
      if (i >= keys.length)
        return reduce2(values2);
      const groups2 = new InternMap();
      const keyof2 = keys[i++];
      let index2 = -1;
      for (const value of values2) {
        const key = keyof2(value, ++index2, values2);
        const group2 = groups2.get(key);
        if (group2)
          group2.push(value);
        else
          groups2.set(key, [value]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map2(groups2);
    }(values, 0);
  }
  function permute(source, keys) {
    return Array.from(keys, (key) => source[key]);
  }
  function sort(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function")
      throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f] = F;
    if (f && f.length !== 2 || F.length > 1) {
      const index2 = Uint32Array.from(values, (d, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index2.sort((i, j) => {
          for (const f2 of F) {
            const c2 = ascendingDefined(f2[i], f2[j]);
            if (c2)
              return c2;
          }
        });
      } else {
        f = values.map(f);
        index2.sort((i, j) => ascendingDefined(f[i], f[j]));
      }
      return permute(values, index2);
    }
    return values.sort(compareDefined(f));
  }
  function compareDefined(compare = ascending$3) {
    if (compare === ascending$3)
      return ascendingDefined;
    if (typeof compare !== "function")
      throw new TypeError("compare is not a function");
    return (a2, b) => {
      const x2 = compare(a2, b);
      if (x2 || x2 === 0)
        return x2;
      return (compare(b, b) === 0) - (compare(a2, a2) === 0);
    };
  }
  function ascendingDefined(a2, b) {
    return (a2 == null || !(a2 >= a2)) - (b == null || !(b >= b)) || (a2 < b ? -1 : a2 > b ? 1 : 0);
  }
  function groupSort(values, reduce2, key) {
    return (reduce2.length !== 2 ? sort(rollup(values, reduce2, key), ([ak, av], [bk2, bv]) => ascending$3(av, bv) || ascending$3(ak, bk2)) : sort(group(values, key), ([ak, av], [bk2, bv]) => reduce2(av, bv) || ascending$3(ak, bk2))).map(([key2]) => key2);
  }
  var array$5 = Array.prototype;
  var slice$4 = array$5.slice;
  function constant$b(x2) {
    return () => x2;
  }
  var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
  function ticks(start2, stop, count2) {
    var reverse2, i = -1, n, ticks2, step;
    stop = +stop, start2 = +start2, count2 = +count2;
    if (start2 === stop && count2 > 0)
      return [start2];
    if (reverse2 = stop < start2)
      n = start2, start2 = stop, stop = n;
    if ((step = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step))
      return [];
    if (step > 0) {
      let r0 = Math.round(start2 / step), r1 = Math.round(stop / step);
      if (r0 * step < start2)
        ++r0;
      if (r1 * step > stop)
        --r1;
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n)
        ticks2[i] = (r0 + i) * step;
    } else {
      step = -step;
      let r0 = Math.round(start2 * step), r1 = Math.round(stop * step);
      if (r0 / step < start2)
        ++r0;
      if (r1 / step > stop)
        --r1;
      ticks2 = new Array(n = r1 - r0 + 1);
      while (++i < n)
        ticks2[i] = (r0 + i) / step;
    }
    if (reverse2)
      ticks2.reverse();
    return ticks2;
  }
  function tickIncrement(start2, stop, count2) {
    var step = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
    return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
  }
  function tickStep(start2, stop, count2) {
    var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
    if (error >= e10)
      step1 *= 10;
    else if (error >= e5)
      step1 *= 5;
    else if (error >= e2)
      step1 *= 2;
    return stop < start2 ? -step1 : step1;
  }
  function nice$1(start2, stop, count2) {
    let prestep;
    while (true) {
      const step = tickIncrement(start2, stop, count2);
      if (step === prestep || step === 0 || !isFinite(step)) {
        return [start2, stop];
      } else if (step > 0) {
        start2 = Math.floor(start2 / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start2 = Math.ceil(start2 * step) / step;
        stop = Math.floor(stop * step) / step;
      }
      prestep = step;
    }
  }
  function thresholdSturges(values) {
    return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
  }
  function bin() {
    var value = identity$9, domain = extent$1, threshold2 = thresholdSturges;
    function histogram(data) {
      if (!Array.isArray(data))
        data = Array.from(data);
      var i, n = data.length, x2, step, values = new Array(n);
      for (i = 0; i < n; ++i) {
        values[i] = value(data[i], i, data);
      }
      var xz = domain(values), x02 = xz[0], x12 = xz[1], tz = threshold2(values, x02, x12);
      if (!Array.isArray(tz)) {
        const max2 = x12, tn = +tz;
        if (domain === extent$1)
          [x02, x12] = nice$1(x02, x12, tn);
        tz = ticks(x02, x12, tn);
        if (tz[0] <= x02)
          step = tickIncrement(x02, x12, tn);
        if (tz[tz.length - 1] >= x12) {
          if (max2 >= x12 && domain === extent$1) {
            const step2 = tickIncrement(x02, x12, tn);
            if (isFinite(step2)) {
              if (step2 > 0) {
                x12 = (Math.floor(x12 / step2) + 1) * step2;
              } else if (step2 < 0) {
                x12 = (Math.ceil(x12 * -step2) + 1) / -step2;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      var m2 = tz.length;
      while (tz[0] <= x02)
        tz.shift(), --m2;
      while (tz[m2 - 1] > x12)
        tz.pop(), --m2;
      var bins = new Array(m2 + 1), bin2;
      for (i = 0; i <= m2; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x02;
        bin2.x1 = i < m2 ? tz[i] : x12;
      }
      if (isFinite(step)) {
        if (step > 0) {
          for (i = 0; i < n; ++i) {
            if ((x2 = values[i]) != null && x02 <= x2 && x2 <= x12) {
              bins[Math.min(m2, Math.floor((x2 - x02) / step))].push(data[i]);
            }
          }
        } else if (step < 0) {
          for (i = 0; i < n; ++i) {
            if ((x2 = values[i]) != null && x02 <= x2 && x2 <= x12) {
              const j = Math.floor((x02 - x2) * step);
              bins[Math.min(m2, j + (tz[j] <= x2))].push(data[i]);
            }
          }
        }
      } else {
        for (i = 0; i < n; ++i) {
          if ((x2 = values[i]) != null && x02 <= x2 && x2 <= x12) {
            bins[bisect(tz, x2, 0, m2)].push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(_2) {
      return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$b(_2), histogram) : value;
    };
    histogram.domain = function(_2) {
      return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant$b([_2[0], _2[1]]), histogram) : domain;
    };
    histogram.thresholds = function(_2) {
      return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$b(slice$4.call(_2)) : constant$b(_2), histogram) : threshold2;
    };
    return histogram;
  }
  function max$3(values, valueof) {
    let max2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value;
        }
      }
    }
    return max2;
  }
  function maxIndex(values, valueof) {
    let max2;
    let maxIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value of values) {
        ++index2;
        if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value, maxIndex2 = index2;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
          max2 = value, maxIndex2 = index2;
        }
      }
    }
    return maxIndex2;
  }
  function min$2(values, valueof) {
    let min2;
    if (valueof === void 0) {
      for (const value of values) {
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value;
        }
      }
    }
    return min2;
  }
  function minIndex(values, valueof) {
    let min2;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof === void 0) {
      for (const value of values) {
        ++index2;
        if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value, minIndex2 = index2;
        }
      }
    } else {
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
          min2 = value, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }
  function quickselect(array2, k2, left2 = 0, right2 = array2.length - 1, compare) {
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n = right2 - left2 + 1;
        const m2 = k2 - left2 + 1;
        const z = Math.log(n);
        const s2 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s2 * (n - s2) / n) * (m2 - n / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k2 - m2 * s2 / n + sd));
        const newRight = Math.min(right2, Math.floor(k2 + (n - m2) * s2 / n + sd));
        quickselect(array2, k2, newLeft, newRight, compare);
      }
      const t = array2[k2];
      let i = left2;
      let j = right2;
      swap$1(array2, left2, k2);
      if (compare(array2[right2], t) > 0)
        swap$1(array2, left2, right2);
      while (i < j) {
        swap$1(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0)
          ++i;
        while (compare(array2[j], t) > 0)
          --j;
      }
      if (compare(array2[left2], t) === 0)
        swap$1(array2, left2, j);
      else
        ++j, swap$1(array2, j, right2);
      if (j <= k2)
        left2 = j + 1;
      if (k2 <= j)
        right2 = j - 1;
    }
    return array2;
  }
  function swap$1(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }
  function greatest(values, compare = ascending$3) {
    let max2;
    let defined = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value = compare(element);
        if (defined ? ascending$3(value, maxValue) > 0 : ascending$3(value, value) === 0) {
          max2 = element;
          maxValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined ? compare(value, max2) > 0 : compare(value, value) === 0) {
          max2 = value;
          defined = true;
        }
      }
    }
    return max2;
  }
  function quantile$1(values, p, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n = values.length))
      return;
    if ((p = +p) <= 0 || n < 2)
      return min$2(values);
    if (p >= 1)
      return max$3(values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min$2(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileSorted(values, p, valueof = number$3) {
    if (!(n = values.length))
      return;
    if ((p = +p) <= 0 || n < 2)
      return +valueof(values[0], 0, values);
    if (p >= 1)
      return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileIndex(values, p, valueof) {
    values = Float64Array.from(numbers(values, valueof));
    if (!(n = values.length))
      return;
    if ((p = +p) <= 0 || n < 2)
      return minIndex(values);
    if (p >= 1)
      return maxIndex(values);
    var n, i = Math.floor((n - 1) * p), order = (i2, j) => ascendingDefined(values[i2], values[j]), index2 = quickselect(Uint32Array.from(values, (_2, i2) => i2), i, 0, n - 1, order);
    return greatest(index2.subarray(0, i + 1), (i2) => values[i2]);
  }
  function thresholdFreedmanDiaconis(values, min2, max2) {
    return Math.ceil((max2 - min2) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
  }
  function thresholdScott(values, min2, max2) {
    return Math.ceil((max2 - min2) * Math.cbrt(count$1(values)) / (3.49 * deviation(values)));
  }
  function mean(values, valueof) {
    let count2 = 0;
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && (value = +value) >= value) {
          ++count2, sum2 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && (value = +value) >= value) {
          ++count2, sum2 += value;
        }
      }
    }
    if (count2)
      return sum2 / count2;
  }
  function median(values, valueof) {
    return quantile$1(values, 0.5, valueof);
  }
  function medianIndex(values, valueof) {
    return quantileIndex(values, 0.5, valueof);
  }
  function* flatten(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge$1(arrays) {
    return Array.from(flatten(arrays));
  }
  function mode(values, valueof) {
    const counts = new InternMap();
    if (valueof === void 0) {
      for (let value of values) {
        if (value != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if ((value = valueof(value, ++index2, values)) != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    }
    let modeValue;
    let modeCount = 0;
    for (const [value, count2] of counts) {
      if (count2 > modeCount) {
        modeCount = count2;
        modeValue = value;
      }
    }
    return modeValue;
  }
  function pairs(values, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first = false;
    for (const value of values) {
      if (first)
        pairs2.push(pairof(previous, value));
      previous = value;
      first = true;
    }
    return pairs2;
  }
  function pair(a2, b) {
    return [a2, b];
  }
  function range$2(start2, stop, step) {
    start2 = +start2, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step)) | 0, range2 = new Array(n);
    while (++i < n) {
      range2[i] = start2 + i * step;
    }
    return range2;
  }
  function rank(values, valueof = ascending$3) {
    if (typeof values[Symbol.iterator] !== "function")
      throw new TypeError("values is not iterable");
    let V = Array.from(values);
    const R = new Float64Array(V.length);
    if (valueof.length !== 2)
      V = V.map(valueof), valueof = ascending$3;
    const compareIndex = (i, j) => valueof(V[i], V[j]);
    let k2, r;
    Uint32Array.from(V, (_2, i) => i).sort(valueof === ascending$3 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex)).forEach((j, i) => {
      const c2 = compareIndex(j, k2 === void 0 ? j : k2);
      if (c2 >= 0) {
        if (k2 === void 0 || c2 > 0)
          k2 = j, r = i;
        R[j] = r;
      } else {
        R[j] = NaN;
      }
    });
    return R;
  }
  function least(values, compare = ascending$3) {
    let min2;
    let defined = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values) {
        const value = compare(element);
        if (defined ? ascending$3(value, minValue) < 0 : ascending$3(value, value) === 0) {
          min2 = element;
          minValue = value;
          defined = true;
        }
      }
    } else {
      for (const value of values) {
        if (defined ? compare(value, min2) < 0 : compare(value, value) === 0) {
          min2 = value;
          defined = true;
        }
      }
    }
    return min2;
  }
  function leastIndex(values, compare = ascending$3) {
    if (compare.length === 1)
      return minIndex(values, compare);
    let minValue;
    let min2 = -1;
    let index2 = -1;
    for (const value of values) {
      ++index2;
      if (min2 < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {
        minValue = value;
        min2 = index2;
      }
    }
    return min2;
  }
  function greatestIndex(values, compare = ascending$3) {
    if (compare.length === 1)
      return maxIndex(values, compare);
    let maxValue;
    let max2 = -1;
    let index2 = -1;
    for (const value of values) {
      ++index2;
      if (max2 < 0 ? compare(value, value) === 0 : compare(value, maxValue) > 0) {
        maxValue = value;
        max2 = index2;
      }
    }
    return max2;
  }
  function scan(values, compare) {
    const index2 = leastIndex(values, compare);
    return index2 < 0 ? void 0 : index2;
  }
  const shuffle$1 = shuffler(Math.random);
  function shuffler(random2) {
    return function shuffle2(array2, i0 = 0, i1 = array2.length) {
      let m2 = i1 - (i0 = +i0);
      while (m2) {
        const i = random2() * m2-- | 0, t = array2[m2 + i0];
        array2[m2 + i0] = array2[i + i0];
        array2[i + i0] = t;
      }
      return array2;
    };
  }
  function sum$2(values, valueof) {
    let sum2 = 0;
    if (valueof === void 0) {
      for (let value of values) {
        if (value = +value) {
          sum2 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values) {
        if (value = +valueof(value, ++index2, values)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  }
  function transpose(matrix) {
    if (!(n = matrix.length))
      return [];
    for (var i = -1, m2 = min$2(matrix, length$3), transpose2 = new Array(m2); ++i < m2; ) {
      for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose2;
  }
  function length$3(d) {
    return d.length;
  }
  function zip() {
    return transpose(arguments);
  }
  function every(values, test) {
    if (typeof test !== "function")
      throw new TypeError("test is not a function");
    let index2 = -1;
    for (const value of values) {
      if (!test(value, ++index2, values)) {
        return false;
      }
    }
    return true;
  }
  function some(values, test) {
    if (typeof test !== "function")
      throw new TypeError("test is not a function");
    let index2 = -1;
    for (const value of values) {
      if (test(value, ++index2, values)) {
        return true;
      }
    }
    return false;
  }
  function filter$1(values, test) {
    if (typeof test !== "function")
      throw new TypeError("test is not a function");
    const array2 = [];
    let index2 = -1;
    for (const value of values) {
      if (test(value, ++index2, values)) {
        array2.push(value);
      }
    }
    return array2;
  }
  function map$1(values, mapper) {
    if (typeof values[Symbol.iterator] !== "function")
      throw new TypeError("values is not iterable");
    if (typeof mapper !== "function")
      throw new TypeError("mapper is not a function");
    return Array.from(values, (value, index2) => mapper(value, index2, values));
  }
  function reduce(values, reducer2, value) {
    if (typeof reducer2 !== "function")
      throw new TypeError("reducer is not a function");
    const iterator = values[Symbol.iterator]();
    let done, next2, index2 = -1;
    if (arguments.length < 3) {
      ({ done, value } = iterator.next());
      if (done)
        return;
      ++index2;
    }
    while ({ done, value: next2 } = iterator.next(), !done) {
      value = reducer2(value, next2, ++index2, values);
    }
    return value;
  }
  function reverse$1(values) {
    if (typeof values[Symbol.iterator] !== "function")
      throw new TypeError("values is not iterable");
    return Array.from(values).reverse();
  }
  function difference(values, ...others) {
    values = new InternSet(values);
    for (const other of others) {
      for (const value of other) {
        values.delete(value);
      }
    }
    return values;
  }
  function disjoint(values, other) {
    const iterator = other[Symbol.iterator](), set2 = new InternSet();
    for (const v of values) {
      if (set2.has(v))
        return false;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done)
          break;
        if (Object.is(v, value))
          return false;
        set2.add(value);
      }
    }
    return true;
  }
  function intersection$1(values, ...others) {
    values = new InternSet(values);
    others = others.map(set$2);
    out:
      for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
    return values;
  }
  function set$2(values) {
    return values instanceof InternSet ? values : new InternSet(values);
  }
  function superset(values, other) {
    const iterator = values[Symbol.iterator](), set2 = /* @__PURE__ */ new Set();
    for (const o of other) {
      const io = intern(o);
      if (set2.has(io))
        continue;
      let value, done;
      while ({ value, done } = iterator.next()) {
        if (done)
          return false;
        const ivalue = intern(value);
        set2.add(ivalue);
        if (Object.is(io, ivalue))
          break;
      }
    }
    return true;
  }
  function intern(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function subset(values, other) {
    return superset(other, values);
  }
  function union(...others) {
    const set2 = new InternSet();
    for (const other of others) {
      for (const o of other) {
        set2.add(o);
      }
    }
    return set2;
  }
  function identity$8(x2) {
    return x2;
  }
  var top = 1, right = 2, bottom = 3, left = 4, epsilon$6 = 1e-6;
  function translateX(x2) {
    return "translate(" + x2 + ",0)";
  }
  function translateY(y2) {
    return "translate(0," + y2 + ")";
  }
  function number$2(scale) {
    return (d) => +scale(d);
  }
  function center$1(scale, offset) {
    offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
    if (scale.round())
      offset = Math.round(offset);
    return (d) => +scale(d) + offset;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position2 = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
      path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick = tick.merge(tickEnter);
      line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
      text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection2) {
        path2 = path2.transition(context);
        tick = tick.transition(context);
        line2 = line2.transition(context);
        text2 = text2.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon$6).attr("transform", function(d) {
          return isFinite(d = position2(d)) ? transform2(d + offset) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon$6).attr("transform", function(d) {
          var p = this.parentNode.__axis;
          return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset);
        });
      }
      tickExit.remove();
      path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
      tick.attr("opacity", 1).attr("transform", function(d) {
        return transform2(position2(d) + offset);
      });
      line2.attr(x2 + "2", k2 * tickSizeInner);
      text2.attr(x2, k2 * spacing).text(format2);
      selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection2.each(function() {
        this.__axis = position2;
      });
    }
    axis2.scale = function(_2) {
      return arguments.length ? (scale = _2, axis2) : scale;
    };
    axis2.ticks = function() {
      return tickArguments = Array.from(arguments), axis2;
    };
    axis2.tickArguments = function(_2) {
      return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_2) {
      return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_2) {
      return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_2) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_2) {
      return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_2) {
      return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_2) {
      return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
    };
    axis2.offset = function(_2) {
      return arguments.length ? (offset = +_2, axis2) : offset;
    };
    return axis2;
  }
  function axisTop(scale) {
    return axis(top, scale);
  }
  function axisRight(scale) {
    return axis(right, scale);
  }
  function axisBottom(scale) {
    return axis(bottom, scale);
  }
  function axisLeft(scale) {
    return axis(left, scale);
  }
  var noop$3 = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
        throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames$1(typenames, types2) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0)
        name2 = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types2.hasOwnProperty(t))
        throw new Error("unknown type: " + t);
      return { type: t, name: name2 };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames$1(typename + "", _2), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t = (typename = T[i]).type) && (t = get$1(_2[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type)
          _2[t] = set$1(_2[t], typename.name, callback);
        else if (callback == null)
          for (t in _2)
            _2[t] = set$1(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy2 = {}, _2 = this._;
      for (var t in _2)
        copy2[t] = _2[t].slice();
      return new Dispatch(copy2);
    },
    call: function(type2, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    },
    apply: function(type2, that, args) {
      if (!this._.hasOwnProperty(type2))
        throw new Error("unknown type: " + type2);
      for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    }
  };
  function get$1(type2, name2) {
    for (var i = 0, n = type2.length, c2; i < n; ++i) {
      if ((c2 = type2[i]).name === name2) {
        return c2.value;
      }
    }
  }
  function set$1(type2, name2, callback) {
    for (var i = 0, n = type2.length; i < n; ++i) {
      if (type2[i].name === name2) {
        type2[i] = noop$3, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type2.push({ name: name2, value: callback });
    return type2;
  }
  var xhtml = "http://www.w3.org/1999/xhtml";
  const namespaces = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function namespace(name2) {
    var prefix = name2 += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name2.slice(0, i)) !== "xmlns")
      name2 = name2.slice(i + 1);
    return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name2 } : name2;
  }
  function creatorInherit(name2) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator(name2) {
    var fullname = namespace(name2);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }
  function none$2() {
  }
  function selector(selector2) {
    return selector2 == null ? none$2 : function() {
      return this.querySelector(selector2);
    };
  }
  function selection_select(select2) {
    if (typeof select2 !== "function")
      select2 = selector(select2);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
        if ((node2 = group2[i]) && (subnode = select2.call(node2, node2.__data__, i, group2))) {
          if ("__data__" in node2)
            subnode.__data__ = node2.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function array$4(x2) {
    return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
  }
  function empty$1() {
    return [];
  }
  function selectorAll(selector2) {
    return selector2 == null ? empty$1 : function() {
      return this.querySelectorAll(selector2);
    };
  }
  function arrayAll(select2) {
    return function() {
      return array$4(select2.apply(this, arguments));
    };
  }
  function selection_selectAll(select2) {
    if (typeof select2 === "function")
      select2 = arrayAll(select2);
    else
      select2 = selectorAll(select2);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = [], parents2 = [], j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, node2, i = 0; i < n; ++i) {
        if (node2 = group2[i]) {
          subgroups.push(select2.call(node2, node2.__data__, i, group2));
          parents2.push(node2);
        }
      }
    }
    return new Selection$1(subgroups, parents2);
  }
  function matcher(selector2) {
    return function() {
      return this.matches(selector2);
    };
  }
  function childMatcher(selector2) {
    return function(node2) {
      return node2.matches(selector2);
    };
  }
  var find$1 = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find$1.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selection_selectChild(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selection_selectChildren(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }
  function selection_filter(match) {
    if (typeof match !== "function")
      match = matcher(match);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
        if ((node2 = group2[i]) && match.call(node2, node2.__data__, i, group2)) {
          subgroup.push(node2);
        }
      }
    }
    return new Selection$1(subgroups, this._parents);
  }
  function sparse(update) {
    return new Array(update.length);
  }
  function selection_enter() {
    return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next2) {
      return this._parent.insertBefore(child, next2);
    },
    querySelector: function(selector2) {
      return this._parent.querySelector(selector2);
    },
    querySelectorAll: function(selector2) {
      return this._parent.querySelectorAll(selector2);
    }
  };
  function constant$a(x2) {
    return function() {
      return x2;
    };
  }
  function bindIndex(parent, group2, enter, update, exit, data) {
    var i = 0, node2, groupLength = group2.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node2 = group2[i]) {
        node2.__data__ = data[i];
        update[i] = node2;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node2 = group2[i]) {
        exit[i] = node2;
      }
    }
  }
  function bindKey(parent, group2, enter, update, exit, data, key) {
    var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group2.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node2 = group2[i]) {
        keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group2) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node2;
        } else {
          nodeByKeyValue.set(keyValue, node2);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node2 = nodeByKeyValue.get(keyValue)) {
        update[i] = node2;
        node2.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node2 = group2[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
        exit[i] = node2;
      }
    }
  }
  function datum(node2) {
    return node2.__data__;
  }
  function selection_data(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents2 = this._parents, groups2 = this._groups;
    if (typeof value !== "function")
      value = constant$a(value);
    for (var m2 = groups2.length, update = new Array(m2), enter = new Array(m2), exit = new Array(m2), j = 0; j < m2; ++j) {
      var parent = parents2[j], group2 = groups2[j], groupLength = group2.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents2)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group2, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next2 = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next2 || null;
        }
      }
    }
    update = new Selection$1(update, parents2);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }
  function selection_exit() {
    return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
  }
  function selection_join(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update)
        update = update.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }
  function selection_merge(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group0[i] || group1[i]) {
          merge2[i] = node2;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection$1(merges, this._parents);
  }
  function selection_order() {
    for (var groups2 = this._groups, j = -1, m2 = groups2.length; ++j < m2; ) {
      for (var group2 = groups2[j], i = group2.length - 1, next2 = group2[i], node2; --i >= 0; ) {
        if (node2 = group2[i]) {
          if (next2 && node2.compareDocumentPosition(next2) ^ 4)
            next2.parentNode.insertBefore(node2, next2);
          next2 = node2;
        }
      }
    }
    return this;
  }
  function selection_sort(compare) {
    if (!compare)
      compare = ascending$2;
    function compareNode(a2, b) {
      return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
    }
    for (var groups2 = this._groups, m2 = groups2.length, sortgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group2[i]) {
          sortgroup[i] = node2;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection$1(sortgroups, this._parents).order();
  }
  function ascending$2(a2, b) {
    return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
  }
  function selection_call() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }
  function selection_nodes() {
    return Array.from(this);
  }
  function selection_node() {
    for (var groups2 = this._groups, j = 0, m2 = groups2.length; j < m2; ++j) {
      for (var group2 = groups2[j], i = 0, n = group2.length; i < n; ++i) {
        var node2 = group2[i];
        if (node2)
          return node2;
      }
    }
    return null;
  }
  function selection_size() {
    let size = 0;
    for (const node2 of this)
      ++size;
    return size;
  }
  function selection_empty() {
    return !this.node();
  }
  function selection_each(callback) {
    for (var groups2 = this._groups, j = 0, m2 = groups2.length; j < m2; ++j) {
      for (var group2 = groups2[j], i = 0, n = group2.length, node2; i < n; ++i) {
        if (node2 = group2[i])
          callback.call(node2, node2.__data__, i, group2);
      }
    }
    return this;
  }
  function attrRemove$1(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS$1(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant$1(name2, value) {
    return function() {
      this.setAttribute(name2, value);
    };
  }
  function attrConstantNS$1(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction$1(name2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name2);
      else
        this.setAttribute(name2, v);
    };
  }
  function attrFunctionNS$1(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function selection_attr(name2, value) {
    var fullname = namespace(name2);
    if (arguments.length < 2) {
      var node2 = this.node();
      return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
  }
  function defaultView(node2) {
    return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
  }
  function styleRemove$1(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant$1(name2, value, priority) {
    return function() {
      this.style.setProperty(name2, value, priority);
    };
  }
  function styleFunction$1(name2, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name2);
      else
        this.style.setProperty(name2, v, priority);
    };
  }
  function selection_style(name2, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
  }
  function styleValue(node2, name2) {
    return node2.style.getPropertyValue(name2) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name2);
  }
  function propertyRemove(name2) {
    return function() {
      delete this[name2];
    };
  }
  function propertyConstant(name2, value) {
    return function() {
      this[name2] = value;
    };
  }
  function propertyFunction(name2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name2];
      else
        this[name2] = v;
    };
  }
  function selection_property(name2, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
  }
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node2) {
    return node2.classList || new ClassList(node2);
  }
  function ClassList(node2) {
    this._node = node2;
    this._names = classArray(node2.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name2) {
      var i = this._names.indexOf(name2);
      if (i < 0) {
        this._names.push(name2);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name2) {
      var i = this._names.indexOf(name2);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name2) {
      return this._names.indexOf(name2) >= 0;
    }
  };
  function classedAdd(node2, names) {
    var list2 = classList(node2), i = -1, n = names.length;
    while (++i < n)
      list2.add(names[i]);
  }
  function classedRemove(node2, names) {
    var list2 = classList(node2), i = -1, n = names.length;
    while (++i < n)
      list2.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function selection_classed(name2, value) {
    var names = classArray(name2 + "");
    if (arguments.length < 2) {
      var list2 = classList(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list2.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }
  function textRemove() {
    this.textContent = "";
  }
  function textConstant$1(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction$1(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function selection_text(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
  }
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function selection_html(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function selection_raise() {
    return this.each(raise);
  }
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function selection_lower() {
    return this.each(lower);
  }
  function selection_append(name2) {
    var create2 = typeof name2 === "function" ? name2 : creator(name2);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }
  function constantNull() {
    return null;
  }
  function selection_insert(name2, before) {
    var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function selection_remove() {
    return this.each(remove);
  }
  function selection_cloneShallow() {
    var clone2 = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_cloneDeep() {
    var clone2 = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
  }
  function selection_clone(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }
  function selection_datum(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0)
        name2 = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name: name2 };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m2 = on.length, o; j < m2; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options2) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m2 = on.length; j < m2; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options2);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options2);
      o = { type: typename.type, name: typename.name, value, listener, options: options2 };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function selection_on(typename, value, options2) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m2 = on.length, o; j < m2; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, options2));
    return this;
  }
  function dispatchEvent(node2, type2, params) {
    var window2 = defaultView(node2), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type2, false, false);
    }
    node2.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function selection_dispatch(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }
  function* selection_iterator() {
    for (var groups2 = this._groups, j = 0, m2 = groups2.length; j < m2; ++j) {
      for (var group2 = groups2[j], i = 0, n = group2.length, node2; i < n; ++i) {
        if (node2 = group2[i])
          yield node2;
      }
    }
  }
  var root$5 = [null];
  function Selection$1(groups2, parents2) {
    this._groups = groups2;
    this._parents = parents2;
  }
  function selection() {
    return new Selection$1([[document.documentElement]], root$5);
  }
  function selection_selection() {
    return this;
  }
  Selection$1.prototype = selection.prototype = {
    constructor: Selection$1,
    select: selection_select,
    selectAll: selection_selectAll,
    selectChild: selection_selectChild,
    selectChildren: selection_selectChildren,
    filter: selection_filter,
    data: selection_data,
    enter: selection_enter,
    exit: selection_exit,
    join: selection_join,
    merge: selection_merge,
    selection: selection_selection,
    order: selection_order,
    sort: selection_sort,
    call: selection_call,
    nodes: selection_nodes,
    node: selection_node,
    size: selection_size,
    empty: selection_empty,
    each: selection_each,
    attr: selection_attr,
    style: selection_style,
    property: selection_property,
    classed: selection_classed,
    text: selection_text,
    html: selection_html,
    raise: selection_raise,
    lower: selection_lower,
    append: selection_append,
    insert: selection_insert,
    remove: selection_remove,
    clone: selection_clone,
    datum: selection_datum,
    on: selection_on,
    dispatch: selection_dispatch,
    [Symbol.iterator]: selection_iterator
  };
  function select(selector2) {
    return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$5);
  }
  function create$2(name2) {
    return select(creator(name2).call(document.documentElement));
  }
  var nextId = 0;
  function local$1() {
    return new Local();
  }
  function Local() {
    this._ = "@" + (++nextId).toString(36);
  }
  Local.prototype = local$1.prototype = {
    constructor: Local,
    get: function(node2) {
      var id2 = this._;
      while (!(id2 in node2))
        if (!(node2 = node2.parentNode))
          return;
      return node2[id2];
    },
    set: function(node2, value) {
      return node2[this._] = value;
    },
    remove: function(node2) {
      return this._ in node2 && delete node2[this._];
    },
    toString: function() {
      return this._;
    }
  };
  function sourceEvent(event) {
    let sourceEvent2;
    while (sourceEvent2 = event.sourceEvent)
      event = sourceEvent2;
    return event;
  }
  function pointer(event, node2) {
    event = sourceEvent(event);
    if (node2 === void 0)
      node2 = event.currentTarget;
    if (node2) {
      var svg2 = node2.ownerSVGElement || node2;
      if (svg2.createSVGPoint) {
        var point2 = svg2.createSVGPoint();
        point2.x = event.clientX, point2.y = event.clientY;
        point2 = point2.matrixTransform(node2.getScreenCTM().inverse());
        return [point2.x, point2.y];
      }
      if (node2.getBoundingClientRect) {
        var rect2 = node2.getBoundingClientRect();
        return [event.clientX - rect2.left - node2.clientLeft, event.clientY - rect2.top - node2.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }
  function pointers(events, node2) {
    if (events.target) {
      events = sourceEvent(events);
      if (node2 === void 0)
        node2 = events.currentTarget;
      events = events.touches || [events];
    }
    return Array.from(events, (event) => pointer(event, node2));
  }
  function selectAll(selector2) {
    return typeof selector2 === "string" ? new Selection$1([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$1([array$4(selector2)], root$5);
  }
  const nonpassive = { passive: false };
  const nonpassivecapture = { capture: true, passive: false };
  function nopropagation$2(event) {
    event.stopImmediatePropagation();
  }
  function noevent$2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function dragDisable(view) {
    var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", noevent$2, nonpassivecapture);
    } else {
      root2.__noselect = root2.style.MozUserSelect;
      root2.style.MozUserSelect = "none";
    }
  }
  function yesdrag(view, noclick) {
    var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
    if (noclick) {
      selection2.on("click.drag", noevent$2, nonpassivecapture);
      setTimeout(function() {
        selection2.on("click.drag", null);
      }, 0);
    }
    if ("onselectstart" in root2) {
      selection2.on("selectstart.drag", null);
    } else {
      root2.style.MozUserSelect = root2.__noselect;
      delete root2.__noselect;
    }
  }
  const constant$9 = (x2) => () => x2;
  function DragEvent(type2, {
    sourceEvent: sourceEvent2,
    subject,
    target,
    identifier: identifier2,
    active: active2,
    x: x2,
    y: y2,
    dx,
    dy,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
      subject: { value: subject, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      identifier: { value: identifier2, enumerable: true, configurable: true },
      active: { value: active2, enumerable: true, configurable: true },
      x: { value: x2, enumerable: true, configurable: true },
      y: { value: y2, enumerable: true, configurable: true },
      dx: { value: dx, enumerable: true, configurable: true },
      dy: { value: dy, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  DragEvent.prototype.on = function() {
    var value = this._.on.apply(this._, arguments);
    return value === this._ ? this : value;
  };
  function defaultFilter$2(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultContainer() {
    return this.parentNode;
  }
  function defaultSubject(event, d) {
    return d == null ? { x: event.x, y: event.y } : d;
  }
  function defaultTouchable$2() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function drag() {
    var filter2 = defaultFilter$2, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$2, gestures = {}, listeners = dispatch("start", "drag", "end"), active2 = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
    function drag2(selection2) {
      selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function mousedowned(event, d) {
      if (touchending || !filter2.call(this, event, d))
        return;
      var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
      if (!gesture)
        return;
      select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
      dragDisable(event.view);
      nopropagation$2(event);
      mousemoving = false;
      mousedownx = event.clientX;
      mousedowny = event.clientY;
      gesture("start", event);
    }
    function mousemoved(event) {
      noevent$2(event);
      if (!mousemoving) {
        var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
        mousemoving = dx * dx + dy * dy > clickDistance2;
      }
      gestures.mouse("drag", event);
    }
    function mouseupped(event) {
      select(event.view).on("mousemove.drag mouseup.drag", null);
      yesdrag(event.view, mousemoving);
      noevent$2(event);
      gestures.mouse("end", event);
    }
    function touchstarted(event, d) {
      if (!filter2.call(this, event, d))
        return;
      var touches = event.changedTouches, c2 = container.call(this, event, d), n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = beforestart(this, c2, event, d, touches[i].identifier, touches[i])) {
          nopropagation$2(event);
          gesture("start", event, touches[i]);
        }
      }
    }
    function touchmoved(event) {
      var touches = event.changedTouches, n = touches.length, i, gesture;
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          noevent$2(event);
          gesture("drag", event, touches[i]);
        }
      }
    }
    function touchended(event) {
      var touches = event.changedTouches, n = touches.length, i, gesture;
      if (touchending)
        clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, 500);
      for (i = 0; i < n; ++i) {
        if (gesture = gestures[touches[i].identifier]) {
          nopropagation$2(event);
          gesture("end", event, touches[i]);
        }
      }
    }
    function beforestart(that, container2, event, d, identifier2, touch) {
      var dispatch2 = listeners.copy(), p = pointer(touch || event, container2), dx, dy, s2;
      if ((s2 = subject.call(that, new DragEvent("beforestart", {
        sourceEvent: event,
        target: drag2,
        identifier: identifier2,
        active: active2,
        x: p[0],
        y: p[1],
        dx: 0,
        dy: 0,
        dispatch: dispatch2
      }), d)) == null)
        return;
      dx = s2.x - p[0] || 0;
      dy = s2.y - p[1] || 0;
      return function gesture(type2, event2, touch2) {
        var p02 = p, n;
        switch (type2) {
          case "start":
            gestures[identifier2] = gesture, n = active2++;
            break;
          case "end":
            delete gestures[identifier2], --active2;
          case "drag":
            p = pointer(touch2 || event2, container2), n = active2;
            break;
        }
        dispatch2.call(
          type2,
          that,
          new DragEvent(type2, {
            sourceEvent: event2,
            subject: s2,
            target: drag2,
            identifier: identifier2,
            active: n,
            x: p[0] + dx,
            y: p[1] + dy,
            dx: p[0] - p02[0],
            dy: p[1] - p02[1],
            dispatch: dispatch2
          }),
          d
        );
      };
    }
    drag2.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$9(!!_2), drag2) : filter2;
    };
    drag2.container = function(_2) {
      return arguments.length ? (container = typeof _2 === "function" ? _2 : constant$9(_2), drag2) : container;
    };
    drag2.subject = function(_2) {
      return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant$9(_2), drag2) : subject;
    };
    drag2.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$9(!!_2), drag2) : touchable;
    };
    drag2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? drag2 : value;
    };
    drag2.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
    };
    return drag2;
  }
  function define2(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }
  function Color$2() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define2(Color$2, color, {
    copy(channels2) {
      return Object.assign(new this.constructor(), this, channels2);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m2, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m2 = reHex.exec(format2)) ? (l = m2[1].length, m2 = parseInt(m2[1], 16), l === 6 ? rgbn(m2) : l === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l === 8 ? rgba$2(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l === 4 ? rgba$2(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba$2(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba$2(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba$2(r, g, b, a2) {
    if (a2 <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a2);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color$2))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define2(Rgb, rgb, extend(Color$2, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s2, l, a2) {
    if (a2 <= 0)
      h = s2 = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s2 = NaN;
    else if (s2 <= 0)
      h = NaN;
    return new Hsl(h, s2, l, a2);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color$2))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
    if (s2) {
      if (r === max2)
        h = (g - b) / s2 + (g < b) * 6;
      else if (g === max2)
        h = (b - r) / s2 + 2;
      else
        h = (r - g) / s2 + 4;
      s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s2 = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s2, l, o.opacity);
  }
  function hsl$2(h, s2, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s2, l, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l;
    this.opacity = +opacity;
  }
  define2(Hsl, hsl$2, extend(Color$2, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Hsl(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a2 = clampa(this.opacity);
      return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  const radians$1 = Math.PI / 180;
  const degrees$2 = 180 / Math.PI;
  const K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
  function labConvert(o) {
    if (o instanceof Lab)
      return new Lab(o.l, o.a, o.b, o.opacity);
    if (o instanceof Hcl)
      return hcl2lab(o);
    if (!(o instanceof Rgb))
      o = rgbConvert(o);
    var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
    if (r === g && g === b)
      x2 = z = y2;
    else {
      x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
      z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
    }
    return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
  }
  function gray(l, opacity) {
    return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
  }
  function lab$1(l, a2, b, opacity) {
    return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
  }
  function Lab(l, a2, b, opacity) {
    this.l = +l;
    this.a = +a2;
    this.b = +b;
    this.opacity = +opacity;
  }
  define2(Lab, lab$1, extend(Color$2, {
    brighter(k2) {
      return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
    },
    darker(k2) {
      return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
    },
    rgb() {
      var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
      x2 = Xn * lab2xyz(x2);
      y2 = Yn * lab2xyz(y2);
      z = Zn * lab2xyz(z);
      return new Rgb(
        lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
        lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
        lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
        this.opacity
      );
    }
  }));
  function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
  }
  function lab2xyz(t) {
    return t > t1$1 ? t * t * t : t2 * (t - t0$1);
  }
  function lrgb2rgb(x2) {
    return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x2) {
    return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o) {
    if (o instanceof Hcl)
      return new Hcl(o.h, o.c, o.l, o.opacity);
    if (!(o instanceof Lab))
      o = labConvert(o);
    if (o.a === 0 && o.b === 0)
      return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
    var h = Math.atan2(o.b, o.a) * degrees$2;
    return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
  }
  function lch(l, c2, h, opacity) {
    return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
  }
  function hcl$1(h, c2, l, opacity) {
    return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
  }
  function Hcl(h, c2, l, opacity) {
    this.h = +h;
    this.c = +c2;
    this.l = +l;
    this.opacity = +opacity;
  }
  function hcl2lab(o) {
    if (isNaN(o.h))
      return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * radians$1;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  define2(Hcl, hcl$1, extend(Color$2, {
    brighter(k2) {
      return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
    },
    darker(k2) {
      return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));
  var A = -0.14861, B$1 = 1.78277, C = -0.29227, D$1 = -0.90649, E = 1.97294, ED = E * D$1, EB = E * B$1, BC_DA = B$1 * C - D$1 * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix)
      return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb))
      o = rgbConvert(o);
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D$1, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * degrees$2 - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
  }
  function cubehelix$3(h, s2, l, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s2, l, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l;
    this.opacity = +opacity;
  }
  define2(Cubehelix, cubehelix$3, extend(Color$2, {
    brighter(k2) {
      k2 = k2 == null ? brighter : Math.pow(brighter, k2);
      return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
    },
    darker(k2) {
      k2 = k2 == null ? darker : Math.pow(darker, k2);
      return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
    },
    rgb() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
      return new Rgb(
        255 * (l + a2 * (A * cosh2 + B$1 * sinh2)),
        255 * (l + a2 * (C * cosh2 + D$1 * sinh2)),
        255 * (l + a2 * (E * cosh2)),
        this.opacity
      );
    }
  }));
  function basis(t12, v0, v1, v2, v3) {
    var t22 = t12 * t12, t32 = t22 * t12;
    return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
  }
  function basis$1(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }
  function basisClosed(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }
  const constant$8 = (x2) => () => x2;
  function linear$2(a2, d) {
    return function(t) {
      return a2 + t * d;
    };
  }
  function exponential$1(a2, b, y2) {
    return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
      return Math.pow(a2 + t * b, y2);
    };
  }
  function hue$1(a2, b) {
    var d = b - a2;
    return d ? linear$2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a2) ? b : a2);
  }
  function gamma$1(y2) {
    return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
      return b - a2 ? exponential$1(a2, b, y2) : constant$8(isNaN(a2) ? b : a2);
    };
  }
  function nogamma(a2, b) {
    var d = b - a2;
    return d ? linear$2(a2, d) : constant$8(isNaN(a2) ? b : a2);
  }
  const interpolateRgb = function rgbGamma(y2) {
    var color2 = gamma$1(y2);
    function rgb$1(start2, end2) {
      var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb$1.gamma = rgbGamma;
    return rgb$1;
  }(1);
  function rgbSpline(spline) {
    return function(colors2) {
      var n = colors2.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors2[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis$1);
  var rgbBasisClosed = rgbSpline(basisClosed);
  function numberArray(a2, b) {
    if (!b)
      b = [];
    var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i)
        c2[i] = a2[i] * (1 - t) + b[i] * t;
      return c2;
    };
  }
  function isNumberArray(x2) {
    return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
  }
  function array$3(a2, b) {
    return (isNumberArray(b) ? numberArray : genericArray)(a2, b);
  }
  function genericArray(a2, b) {
    var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x2[i] = interpolate$2(a2[i], b[i]);
    for (; i < nb; ++i)
      c2[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i)
        c2[i] = x2[i](t);
      return c2;
    };
  }
  function date$1(a2, b) {
    var d = new Date();
    return a2 = +a2, b = +b, function(t) {
      return d.setTime(a2 * (1 - t) + b * t), d;
    };
  }
  function interpolateNumber(a2, b) {
    return a2 = +a2, b = +b, function(t) {
      return a2 * (1 - t) + b * t;
    };
  }
  function object$1(a2, b) {
    var i = {}, c2 = {}, k2;
    if (a2 === null || typeof a2 !== "object")
      a2 = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k2 in b) {
      if (k2 in a2) {
        i[k2] = interpolate$2(a2[k2], b[k2]);
      } else {
        c2[k2] = b[k2];
      }
    }
    return function(t) {
      for (k2 in i)
        c2[k2] = i[k2](t);
      return c2;
    };
  }
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function interpolateString(a2, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
    a2 = a2 + "", b = b + "";
    while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s2[i])
          s2[i] += bs;
        else
          s2[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s2[i])
          s2[i] += bm;
        else
          s2[++i] = bm;
      } else {
        s2[++i] = null;
        q.push({ i, x: interpolateNumber(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s2[(o = q[i2]).i] = o.x(t);
      return s2.join("");
    });
  }
  function interpolate$2(a2, b) {
    var t = typeof b, c2;
    return b == null || t === "boolean" ? constant$8(b) : (t === "number" ? interpolateNumber : t === "string" ? (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1 : interpolateNumber)(a2, b);
  }
  function discrete(range2) {
    var n = range2.length;
    return function(t) {
      return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }
  function hue(a2, b) {
    var i = hue$1(+a2, +b);
    return function(t) {
      var x2 = i(t);
      return x2 - 360 * Math.floor(x2 / 360);
    };
  }
  function interpolateRound(a2, b) {
    return a2 = +a2, b = +b, function(t) {
      return Math.round(a2 * (1 - t) + b * t);
    };
  }
  var degrees$1 = 180 / Math.PI;
  var identity$7 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose(a2, b, c2, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a2 * a2 + b * b))
      a2 /= scaleX, b /= scaleX;
    if (skewX = a2 * c2 + b * d)
      c2 -= a2 * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c2 * c2 + d * d))
      c2 /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a2 * d < b * c2)
      a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a2) * degrees$1,
      skewX: Math.atan(skewX) * degrees$1,
      scaleX,
      scaleY
    };
  }
  var svgNode;
  function parseCss(value) {
    const m2 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m2.isIdentity ? identity$7 : decompose(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity$7;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity$7;
    value = value.matrix;
    return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
  }
  function interpolateTransform(parse2, pxComma, pxParen, degParen) {
    function pop(s2) {
      return s2.length ? s2.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
      } else if (xb || yb) {
        s2.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a2, b, s2, q) {
      if (a2 !== b) {
        if (a2 - b > 180)
          b += 360;
        else if (b - a2 > 180)
          a2 += 360;
        q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "rotate(" + b + degParen);
      }
    }
    function skewX(a2, b, s2, q) {
      if (a2 !== b) {
        q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
      } else if (b) {
        s2.push(pop(s2) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s2, q) {
      if (xa !== xb || ya !== yb) {
        var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a2, b) {
      var s2 = [], q = [];
      a2 = parse2(a2), b = parse2(b);
      translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
      rotate(a2.rotate, b.rotate, s2, q);
      skewX(a2.skewX, b.skewX, s2, q);
      scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
      a2 = b = null;
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n)
          s2[(o = q[i]).i] = o.x(t);
        return s2.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
  var epsilon2$1 = 1e-12;
  function cosh(x2) {
    return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
  }
  function sinh(x2) {
    return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
  }
  function tanh(x2) {
    return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
  }
  const interpolateZoom = function zoomRho(rho, rho2, rho4) {
    function zoom2(p02, p1) {
      var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
      if (d2 < epsilon2$1) {
        S = Math.log(w1 / w0) / rho;
        i = function(t) {
          return [
            ux0 + t * dx,
            uy0 + t * dy,
            w0 * Math.exp(rho * t * S)
          ];
        };
      } else {
        var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
        S = (r1 - r0) / rho;
        i = function(t) {
          var s2 = t * S, coshr0 = cosh(r0), u2 = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
          return [
            ux0 + u2 * dx,
            uy0 + u2 * dy,
            w0 * coshr0 / cosh(rho * s2 + r0)
          ];
        };
      }
      i.duration = S * 1e3 * rho / Math.SQRT2;
      return i;
    }
    zoom2.rho = function(_2) {
      var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
      return zoomRho(_1, _22, _4);
    };
    return zoom2;
  }(Math.SQRT2, 2, 4);
  function hsl(hue2) {
    return function(start2, end2) {
      var h = hue2((start2 = hsl$2(start2)).h, (end2 = hsl$2(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s2(t);
        start2.l = l(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    };
  }
  const hsl$1 = hsl(hue$1);
  var hslLong = hsl(nogamma);
  function lab(start2, end2) {
    var l = nogamma((start2 = lab$1(start2)).l, (end2 = lab$1(end2)).l), a2 = nogamma(start2.a, end2.a), b = nogamma(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.l = l(t);
      start2.a = a2(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  function hcl(hue2) {
    return function(start2, end2) {
      var h = hue2((start2 = hcl$1(start2)).h, (end2 = hcl$1(end2)).h), c2 = nogamma(start2.c, end2.c), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.h = h(t);
        start2.c = c2(t);
        start2.l = l(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    };
  }
  const interpolateHcl = hcl(hue$1);
  var hclLong = hcl(nogamma);
  function cubehelix$1(hue2) {
    return function cubehelixGamma(y2) {
      y2 = +y2;
      function cubehelix2(start2, end2) {
        var h = hue2((start2 = cubehelix$3(start2)).h, (end2 = cubehelix$3(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
        return function(t) {
          start2.h = h(t);
          start2.s = s2(t);
          start2.l = l(Math.pow(t, y2));
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      cubehelix2.gamma = cubehelixGamma;
      return cubehelix2;
    }(1);
  }
  const cubehelix$2 = cubehelix$1(hue$1);
  var cubehelixLong = cubehelix$1(nogamma);
  function piecewise(interpolate2, values) {
    if (values === void 0)
      values = interpolate2, interpolate2 = interpolate$2;
    var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
    while (i < n)
      I[i] = interpolate2(v, v = values[++i]);
    return function(t) {
      var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
      return I[i2](t - i2);
    };
  }
  function quantize$1(interpolator, n) {
    var samples = new Array(n);
    for (var i = 0; i < n; ++i)
      samples[i] = interpolator(i / (n - 1));
    return samples;
  }
  var frame = 0, timeout$1 = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time2) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time2;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time2) {
    var t = new Timer();
    t.restart(callback, delay, time2);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout$1 = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t02, t12 = taskHead, t22, time2 = Infinity;
    while (t12) {
      if (t12._call) {
        if (time2 > t12._time)
          time2 = t12._time;
        t02 = t12, t12 = t12._next;
      } else {
        t22 = t12._next, t12._next = null;
        t12 = t02 ? t02._next = t22 : taskHead = t22;
      }
    }
    taskTail = t02;
    sleep(time2);
  }
  function sleep(time2) {
    if (frame)
      return;
    if (timeout$1)
      timeout$1 = clearTimeout(timeout$1);
    var delay = time2 - clockNow;
    if (delay > 24) {
      if (time2 < Infinity)
        timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
      if (interval$1)
        interval$1 = clearInterval(interval$1);
    } else {
      if (!interval$1)
        clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }
  function timeout(callback, delay, time2) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time2);
    return t;
  }
  function interval(callback, delay, time2) {
    var t = new Timer(), total = delay;
    if (delay == null)
      return t.restart(callback, delay, time2), t;
    t._restart = t.restart;
    t.restart = function(callback2, delay2, time3) {
      delay2 = +delay2, time3 = time3 == null ? now() : +time3;
      t._restart(function tick(elapsed) {
        elapsed += total;
        t._restart(tick, total += delay2, time3);
        callback2(elapsed);
      }, delay2, time3);
    };
    t.restart(callback, delay, time2);
    return t;
  }
  var emptyOn = dispatch("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule(node2, name2, id2, index2, group2, timing) {
    var schedules = node2.__transition;
    if (!schedules)
      node2.__transition = {};
    else if (id2 in schedules)
      return;
    create$1(node2, id2, {
      name: name2,
      index: index2,
      group: group2,
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init$1(node2, id2) {
    var schedule2 = get(node2, id2);
    if (schedule2.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule2;
  }
  function set(node2, id2) {
    var schedule2 = get(node2, id2);
    if (schedule2.state > STARTED)
      throw new Error("too late; already running");
    return schedule2;
  }
  function get(node2, id2) {
    var schedule2 = node2.__transition;
    if (!schedule2 || !(schedule2 = schedule2[id2]))
      throw new Error("transition not found");
    return schedule2;
  }
  function create$1(node2, id2, self2) {
    var schedules = node2.__transition, tween;
    schedules[id2] = self2;
    self2.timer = timer(schedule2, 0, self2.time);
    function schedule2(elapsed) {
      self2.state = SCHEDULED;
      self2.timer.restart(start2, self2.delay, self2.time);
      if (self2.delay <= elapsed)
        start2(elapsed - self2.delay);
    }
    function start2(elapsed) {
      var i, j, n, o;
      if (self2.state !== SCHEDULED)
        return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self2.name)
          continue;
        if (o.state === STARTED)
          return timeout(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node2, node2.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout(function() {
        if (self2.state === STARTED) {
          self2.state = RUNNING;
          self2.timer.restart(tick, self2.delay, self2.time);
          tick(elapsed);
        }
      });
      self2.state = STARTING;
      self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
      if (self2.state !== STARTING)
        return;
      self2.state = STARTED;
      tween = new Array(n = self2.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node2, t);
      }
      if (self2.state === ENDING) {
        self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
        stop();
      }
    }
    function stop() {
      self2.state = ENDED;
      self2.timer.stop();
      delete schedules[id2];
      for (var i in schedules)
        return;
      delete node2.__transition;
    }
  }
  function interrupt(node2, name2) {
    var schedules = node2.__transition, schedule2, active2, empty2 = true, i;
    if (!schedules)
      return;
    name2 = name2 == null ? null : name2 + "";
    for (i in schedules) {
      if ((schedule2 = schedules[i]).name !== name2) {
        empty2 = false;
        continue;
      }
      active2 = schedule2.state > STARTING && schedule2.state < ENDING;
      schedule2.state = ENDED;
      schedule2.timer.stop();
      schedule2.on.call(active2 ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
      delete schedules[i];
    }
    if (empty2)
      delete node2.__transition;
  }
  function selection_interrupt(name2) {
    return this.each(function() {
      interrupt(this, name2);
    });
  }
  function tweenRemove(id2, name2) {
    var tween0, tween1;
    return function() {
      var schedule2 = set(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name2) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule2.tween = tween1;
    };
  }
  function tweenFunction(id2, name2, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule2 = set(this, id2), tween = schedule2.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name2) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n)
          tween1.push(t);
      }
      schedule2.tween = tween1;
    };
  }
  function transition_tween(name2, value) {
    var id2 = this._id;
    name2 += "";
    if (arguments.length < 2) {
      var tween = get(this.node(), id2).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name2) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
  }
  function tweenValue(transition2, name2, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule2 = set(this, id2);
      (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
    });
    return function(node2) {
      return get(node2, id2).value[name2];
    };
  }
  function interpolate$1(a2, b) {
    var c2;
    return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
  }
  function attrRemove(name2) {
    return function() {
      this.removeAttribute(name2);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name2, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrConstantNS(fullname, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function attrFunction(name2, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name2);
      string0 = this.getAttribute(name2);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function attrFunctionNS(fullname, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function transition_attr(name2, value) {
    var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
    return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
  }
  function attrInterpolate(name2, i) {
    return function(t) {
      this.setAttribute(name2, i.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t02, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t02 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t02;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name2, value) {
    var t02, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t02 = (i0 = i) && attrInterpolate(name2, i);
      return t02;
    }
    tween._value = value;
    return tween;
  }
  function transition_attrTween(name2, value) {
    var key = "attr." + name2;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace(name2);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }
  function delayFunction(id2, value) {
    return function() {
      init$1(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init$1(this, id2).delay = value;
    };
  }
  function transition_delay(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
  }
  function durationFunction(id2, value) {
    return function() {
      set(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set(this, id2).duration = value;
    };
  }
  function transition_duration(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
  }
  function easeConstant(id2, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set(this, id2).ease = value;
    };
  }
  function transition_ease(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
  }
  function easeVarying(id2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set(this, id2).ease = v;
    };
  }
  function transition_easeVarying(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }
  function transition_filter(match) {
    if (typeof match !== "function")
      match = matcher(match);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
        if ((node2 = group2[i]) && match.call(node2, node2.__data__, i, group2)) {
          subgroup.push(node2);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }
  function transition_merge(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m2 = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m2; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
        if (node2 = group0[i] || group1[i]) {
          merge2[i] = node2;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }
  function start$1(name2) {
    return (name2 + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0)
        t = t.slice(0, i);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name2, listener) {
    var on0, on1, sit = start$1(name2) ? init$1 : set;
    return function() {
      var schedule2 = sit(this, id2), on = schedule2.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name2, listener);
      schedule2.on = on1;
    };
  }
  function transition_on(name2, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
  }
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition)
        if (+i !== id2)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function transition_remove() {
    return this.on("end.remove", removeFunction(this._id));
  }
  function transition_select(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function")
      select2 = selector(select2);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = new Array(m2), j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
        if ((node2 = group2[i]) && (subnode = select2.call(node2, node2.__data__, i, group2))) {
          if ("__data__" in node2)
            subnode.__data__ = node2.__data__;
          subgroup[i] = subnode;
          schedule(subgroup[i], name2, id2, i, subgroup, get(node2, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name2, id2);
  }
  function transition_selectAll(select2) {
    var name2 = this._name, id2 = this._id;
    if (typeof select2 !== "function")
      select2 = selectorAll(select2);
    for (var groups2 = this._groups, m2 = groups2.length, subgroups = [], parents2 = [], j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, node2, i = 0; i < n; ++i) {
        if (node2 = group2[i]) {
          for (var children2 = select2.call(node2, node2.__data__, i, group2), child, inherit2 = get(node2, id2), k2 = 0, l = children2.length; k2 < l; ++k2) {
            if (child = children2[k2]) {
              schedule(child, name2, id2, k2, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents2.push(node2);
        }
      }
    }
    return new Transition(subgroups, parents2, name2, id2);
  }
  var Selection = selection.prototype.constructor;
  function transition_selection() {
    return new Selection(this._groups, this._parents);
  }
  function styleNull(name2, interpolate2) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
    };
  }
  function styleRemove(name2) {
    return function() {
      this.style.removeProperty(name2);
    };
  }
  function styleConstant(name2, interpolate2, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name2);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
    };
  }
  function styleFunction(name2, interpolate2, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name2) {
    var on0, on1, listener0, key = "style." + name2, event = "end." + key, remove2;
    return function() {
      var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule2.on = on1;
    };
  }
  function transition_style(name2, value, priority) {
    var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate$1;
    return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value), priority).on("end.style." + name2, null);
  }
  function styleInterpolate(name2, i, priority) {
    return function(t) {
      this.style.setProperty(name2, i.call(this, t), priority);
    };
  }
  function styleTween(name2, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t = (i0 = i) && styleInterpolate(name2, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function transition_styleTween(name2, value, priority) {
    var key = "style." + (name2 += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function transition_text(value) {
    return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
  }
  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }
  function textTween(value) {
    var t02, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t02 = (i0 = i) && textInterpolate(i);
      return t02;
    }
    tween._value = value;
    return tween;
  }
  function transition_textTween(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }
  function transition_transition() {
    var name2 = this._name, id0 = this._id, id1 = newId();
    for (var groups2 = this._groups, m2 = groups2.length, j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, node2, i = 0; i < n; ++i) {
        if (node2 = group2[i]) {
          var inherit2 = get(node2, id0);
          schedule(node2, name2, id1, i, group2, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups2, this._parents, name2, id1);
  }
  function transition_end() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end2 = { value: function() {
        if (--size === 0)
          resolve();
      } };
      that.each(function() {
        var schedule2 = set(this, id2), on = schedule2.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end2);
        }
        schedule2.on = on1;
      });
      if (size === 0)
        resolve();
    });
  }
  var id = 0;
  function Transition(groups2, parents2, name2, id2) {
    this._groups = groups2;
    this._parents = parents2;
    this._name = name2;
    this._id = id2;
  }
  function transition(name2) {
    return selection().transition(name2);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: transition_select,
    selectAll: transition_selectAll,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: transition_filter,
    merge: transition_merge,
    selection: transition_selection,
    transition: transition_transition,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: transition_on,
    attr: transition_attr,
    attrTween: transition_attrTween,
    style: transition_style,
    styleTween: transition_styleTween,
    text: transition_text,
    textTween: transition_textTween,
    remove: transition_remove,
    tween: transition_tween,
    delay: transition_delay,
    duration: transition_duration,
    ease: transition_ease,
    easeVarying: transition_easeVarying,
    end: transition_end,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };
  const linear$1 = (t) => +t;
  function quadIn(t) {
    return t * t;
  }
  function quadOut(t) {
    return t * (2 - t);
  }
  function quadInOut(t) {
    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
  }
  function cubicIn(t) {
    return t * t * t;
  }
  function cubicOut(t) {
    return --t * t * t + 1;
  }
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }
  var exponent$1 = 3;
  var polyIn = function custom(e) {
    e = +e;
    function polyIn2(t) {
      return Math.pow(t, e);
    }
    polyIn2.exponent = custom;
    return polyIn2;
  }(exponent$1);
  var polyOut = function custom(e) {
    e = +e;
    function polyOut2(t) {
      return 1 - Math.pow(1 - t, e);
    }
    polyOut2.exponent = custom;
    return polyOut2;
  }(exponent$1);
  var polyInOut = function custom(e) {
    e = +e;
    function polyInOut2(t) {
      return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
    }
    polyInOut2.exponent = custom;
    return polyInOut2;
  }(exponent$1);
  var pi$4 = Math.PI, halfPi$3 = pi$4 / 2;
  function sinIn(t) {
    return +t === 1 ? 1 : 1 - Math.cos(t * halfPi$3);
  }
  function sinOut(t) {
    return Math.sin(t * halfPi$3);
  }
  function sinInOut(t) {
    return (1 - Math.cos(pi$4 * t)) / 2;
  }
  function tpmt(x2) {
    return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
  }
  function expIn(t) {
    return tpmt(1 - +t);
  }
  function expOut(t) {
    return 1 - tpmt(t);
  }
  function expInOut(t) {
    return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
  }
  function circleIn(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function circleOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  function circleInOut(t) {
    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
  }
  var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
  function bounceIn(t) {
    return 1 - bounceOut(1 - t);
  }
  function bounceOut(t) {
    return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
  }
  function bounceInOut(t) {
    return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
  }
  var overshoot = 1.70158;
  var backIn = function custom(s2) {
    s2 = +s2;
    function backIn2(t) {
      return (t = +t) * t * (s2 * (t - 1) + t);
    }
    backIn2.overshoot = custom;
    return backIn2;
  }(overshoot);
  var backOut = function custom(s2) {
    s2 = +s2;
    function backOut2(t) {
      return --t * t * ((t + 1) * s2 + t) + 1;
    }
    backOut2.overshoot = custom;
    return backOut2;
  }(overshoot);
  var backInOut = function custom(s2) {
    s2 = +s2;
    function backInOut2(t) {
      return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;
    }
    backInOut2.overshoot = custom;
    return backInOut2;
  }(overshoot);
  var tau$5 = 2 * Math.PI, amplitude = 1, period = 0.3;
  var elasticIn = function custom(a2, p) {
    var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$5);
    function elasticIn2(t) {
      return a2 * tpmt(- --t) * Math.sin((s2 - t) / p);
    }
    elasticIn2.amplitude = function(a3) {
      return custom(a3, p * tau$5);
    };
    elasticIn2.period = function(p2) {
      return custom(a2, p2);
    };
    return elasticIn2;
  }(amplitude, period);
  var elasticOut = function custom(a2, p) {
    var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$5);
    function elasticOut2(t) {
      return 1 - a2 * tpmt(t = +t) * Math.sin((t + s2) / p);
    }
    elasticOut2.amplitude = function(a3) {
      return custom(a3, p * tau$5);
    };
    elasticOut2.period = function(p2) {
      return custom(a2, p2);
    };
    return elasticOut2;
  }(amplitude, period);
  var elasticInOut = function custom(a2, p) {
    var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$5);
    function elasticInOut2(t) {
      return ((t = t * 2 - 1) < 0 ? a2 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a2 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;
    }
    elasticInOut2.amplitude = function(a3) {
      return custom(a3, p * tau$5);
    };
    elasticInOut2.period = function(p2) {
      return custom(a2, p2);
    };
    return elasticInOut2;
  }(amplitude, period);
  var defaultTiming = {
    time: null,
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node2, id2) {
    var timing;
    while (!(timing = node2.__transition) || !(timing = timing[id2])) {
      if (!(node2 = node2.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function selection_transition(name2) {
    var id2, timing;
    if (name2 instanceof Transition) {
      id2 = name2._id, name2 = name2._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
    }
    for (var groups2 = this._groups, m2 = groups2.length, j = 0; j < m2; ++j) {
      for (var group2 = groups2[j], n = group2.length, node2, i = 0; i < n; ++i) {
        if (node2 = group2[i]) {
          schedule(node2, name2, id2, i, group2, timing || inherit(node2, id2));
        }
      }
    }
    return new Transition(groups2, this._parents, name2, id2);
  }
  selection.prototype.interrupt = selection_interrupt;
  selection.prototype.transition = selection_transition;
  var root$4 = [null];
  function active(node2, name2) {
    var schedules = node2.__transition, schedule2, i;
    if (schedules) {
      name2 = name2 == null ? null : name2 + "";
      for (i in schedules) {
        if ((schedule2 = schedules[i]).state > SCHEDULED && schedule2.name === name2) {
          return new Transition([[node2]], root$4, name2, +i);
        }
      }
    }
    return null;
  }
  const constant$7 = (x2) => () => x2;
  function BrushEvent(type2, {
    sourceEvent: sourceEvent2,
    target,
    selection: selection2,
    mode: mode2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      selection: { value: selection2, enumerable: true, configurable: true },
      mode: { value: mode2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  function nopropagation$1(event) {
    event.stopImmediatePropagation();
  }
  function noevent$1(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
  const { abs: abs$4, max: max$2, min: min$1 } = Math;
  function number1(e) {
    return [+e[0], +e[1]];
  }
  function number2(e) {
    return [number1(e[0]), number1(e[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type$1),
    input: function(x2, e) {
      return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type$1),
    input: function(y2, e) {
      return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type$1),
    input: function(xy) {
      return xy == null ? null : number2(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  var cursors = {
    overlay: "crosshair",
    selection: "move",
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var flipX = {
    e: "w",
    w: "e",
    nw: "ne",
    ne: "nw",
    se: "sw",
    sw: "se"
  };
  var flipY = {
    n: "s",
    s: "n",
    nw: "sw",
    ne: "se",
    se: "ne",
    sw: "nw"
  };
  var signsX = {
    overlay: 1,
    selection: 1,
    n: null,
    e: 1,
    s: null,
    w: -1,
    nw: -1,
    ne: 1,
    se: 1,
    sw: -1
  };
  var signsY = {
    overlay: 1,
    selection: 1,
    n: -1,
    e: null,
    s: 1,
    w: null,
    nw: -1,
    ne: -1,
    se: 1,
    sw: 1
  };
  function type$1(t) {
    return { type: t };
  }
  function defaultFilter$1(event) {
    return !event.ctrlKey && !event.button;
  }
  function defaultExtent$1() {
    var svg2 = this.ownerSVGElement || this;
    if (svg2.hasAttribute("viewBox")) {
      svg2 = svg2.viewBox.baseVal;
      return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
    }
    return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
  }
  function defaultTouchable$1() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function local(node2) {
    while (!node2.__brush)
      if (!(node2 = node2.parentNode))
        return;
    return node2.__brush;
  }
  function empty(extent2) {
    return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
  }
  function brushSelection(node2) {
    var state = node2.__brush;
    return state ? state.dim.output(state.selection) : null;
  }
  function brushX() {
    return brush$1(X);
  }
  function brushY() {
    return brush$1(Y);
  }
  function brush() {
    return brush$1(XY);
  }
  function brush$1(dim) {
    var extent2 = defaultExtent$1, filter2 = defaultFilter$1, touchable = defaultTouchable$1, keys = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
    function brush2(group2) {
      var overlay = group2.property("__brush", initialize2).selectAll(".overlay").data([type$1("overlay")]);
      overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
        var extent3 = local(this).extent;
        select(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
      });
      group2.selectAll(".selection").data([type$1("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
      var handle = group2.selectAll(".handle").data(dim.handles, function(d) {
        return d.type;
      });
      handle.exit().remove();
      handle.enter().append("rect").attr("class", function(d) {
        return "handle handle--" + d.type;
      }).attr("cursor", function(d) {
        return cursors[d.type];
      });
      group2.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    brush2.move = function(group2, selection2, event) {
      if (group2.tween) {
        group2.on("start.brush", function(event2) {
          emitter(this, arguments).beforestart().start(event2);
        }).on("interrupt.brush end.brush", function(event2) {
          emitter(this, arguments).end(event2);
        }).tween("brush", function() {
          var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = interpolate$2(selection0, selection1);
          function tween(t) {
            state.selection = t === 1 && selection1 === null ? null : i(t);
            redraw.call(that);
            emit.brush();
          }
          return selection0 !== null && selection1 !== null ? tween : tween(1);
        });
      } else {
        group2.each(function() {
          var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
          interrupt(that);
          state.selection = selection1 === null ? null : selection1;
          redraw.call(that);
          emit.start(event).brush(event).end(event);
        });
      }
    };
    brush2.clear = function(group2, event) {
      brush2.move(group2, null, event);
    };
    function redraw() {
      var group2 = select(this), selection2 = local(this).selection;
      if (selection2) {
        group2.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
        group2.selectAll(".handle").style("display", null).attr("x", function(d) {
          return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
        }).attr("y", function(d) {
          return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
        }).attr("width", function(d) {
          return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
        }).attr("height", function(d) {
          return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
        });
      } else {
        group2.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
      }
    }
    function emitter(that, args, clean) {
      var emit = that.__brush.emitter;
      return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
    }
    function Emitter(that, args, clean) {
      this.that = that;
      this.args = args;
      this.state = that.__brush;
      this.active = 0;
      this.clean = clean;
    }
    Emitter.prototype = {
      beforestart: function() {
        if (++this.active === 1)
          this.state.emitter = this, this.starting = true;
        return this;
      },
      start: function(event, mode2) {
        if (this.starting)
          this.starting = false, this.emit("start", event, mode2);
        else
          this.emit("brush", event);
        return this;
      },
      brush: function(event, mode2) {
        this.emit("brush", event, mode2);
        return this;
      },
      end: function(event, mode2) {
        if (--this.active === 0)
          delete this.state.emitter, this.emit("end", event, mode2);
        return this;
      },
      emit: function(type2, event, mode2) {
        var d = select(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new BrushEvent(type2, {
            sourceEvent: event,
            target: brush2,
            selection: dim.output(this.state.selection),
            mode: mode2,
            dispatch: listeners
          }),
          d
        );
      }
    };
    function started(event) {
      if (touchending && !event.touches)
        return;
      if (!filter2.apply(this, arguments))
        return;
      var that = this, type2 = event.target.__data__.type, mode2 = (keys && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E2 = extent3[1][0], e0, e1, S = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys && event.shiftKey, lockX, lockY, points = Array.from(event.touches || [event], (t) => {
        const i = t.identifier;
        t = pointer(t, that);
        t.point0 = t.slice();
        t.identifier = i;
        return t;
      });
      interrupt(that);
      var emit = emitter(that, arguments, true).beforestart();
      if (type2 === "overlay") {
        if (selection2)
          moving = true;
        const pts = [points[0], points[1] || points[0]];
        state.selection = selection2 = [[
          w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
          n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
        ], [
          e0 = dim === Y ? E2 : max$2(pts[0][0], pts[1][0]),
          s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
        ]];
        if (points.length > 1)
          move(event);
      } else {
        w0 = selection2[0][0];
        n0 = selection2[0][1];
        e0 = selection2[1][0];
        s0 = selection2[1][1];
      }
      w1 = w0;
      n1 = n0;
      e1 = e0;
      s1 = s0;
      var group2 = select(that).attr("pointer-events", "none");
      var overlay = group2.selectAll(".overlay").attr("cursor", cursors[type2]);
      if (event.touches) {
        emit.moved = moved;
        emit.ended = ended;
      } else {
        var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
        if (keys)
          view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
        dragDisable(event.view);
      }
      redraw.call(that);
      emit.start(event, mode2.name);
      function moved(event2) {
        for (const p of event2.changedTouches || [event2]) {
          for (const d of points)
            if (d.identifier === p.identifier)
              d.cur = pointer(p, that);
        }
        if (shifting && !lockX && !lockY && points.length === 1) {
          const point2 = points[0];
          if (abs$4(point2.cur[0] - point2[0]) > abs$4(point2.cur[1] - point2[1]))
            lockY = true;
          else
            lockX = true;
        }
        for (const point2 of points)
          if (point2.cur)
            point2[0] = point2.cur[0], point2[1] = point2.cur[1];
        moving = true;
        noevent$1(event2);
        move(event2);
      }
      function move(event2) {
        const point2 = points[0], point0 = point2.point0;
        var t;
        dx = point2[0] - point0[0];
        dy = point2[1] - point0[1];
        switch (mode2) {
          case MODE_SPACE:
          case MODE_DRAG: {
            if (signX)
              dx = max$2(W - w0, min$1(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY)
              dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }
          case MODE_HANDLE: {
            if (points[1]) {
              if (signX)
                w1 = max$2(W, min$1(E2, points[0][0])), e1 = max$2(W, min$1(E2, points[1][0])), signX = 1;
              if (signY)
                n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
            } else {
              if (signX < 0)
                dx = max$2(W - w0, min$1(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
              else if (signX > 0)
                dx = max$2(W - e0, min$1(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
              if (signY < 0)
                dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
              else if (signY > 0)
                dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            }
            break;
          }
          case MODE_CENTER: {
            if (signX)
              w1 = max$2(W, min$1(E2, w0 - dx * signX)), e1 = max$2(W, min$1(E2, e0 + dx * signX));
            if (signY)
              n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
            break;
          }
        }
        if (e1 < w1) {
          signX *= -1;
          t = w0, w0 = e0, e0 = t;
          t = w1, w1 = e1, e1 = t;
          if (type2 in flipX)
            overlay.attr("cursor", cursors[type2 = flipX[type2]]);
        }
        if (s1 < n1) {
          signY *= -1;
          t = n0, n0 = s0, s0 = t;
          t = n1, n1 = s1, s1 = t;
          if (type2 in flipY)
            overlay.attr("cursor", cursors[type2 = flipY[type2]]);
        }
        if (state.selection)
          selection2 = state.selection;
        if (lockX)
          w1 = selection2[0][0], e1 = selection2[1][0];
        if (lockY)
          n1 = selection2[0][1], s1 = selection2[1][1];
        if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
          state.selection = [[w1, n1], [e1, s1]];
          redraw.call(that);
          emit.brush(event2, mode2.name);
        }
      }
      function ended(event2) {
        nopropagation$1(event2);
        if (event2.touches) {
          if (event2.touches.length)
            return;
          if (touchending)
            clearTimeout(touchending);
          touchending = setTimeout(function() {
            touchending = null;
          }, 500);
        } else {
          yesdrag(event2.view, moving);
          view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
        }
        group2.attr("pointer-events", "all");
        overlay.attr("cursor", cursors.overlay);
        if (state.selection)
          selection2 = state.selection;
        if (empty(selection2))
          state.selection = null, redraw.call(that);
        emit.end(event2, mode2.name);
      }
      function keydowned(event2) {
        switch (event2.keyCode) {
          case 16: {
            shifting = signX && signY;
            break;
          }
          case 18: {
            if (mode2 === MODE_HANDLE) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode2 = MODE_CENTER;
              move(event2);
            }
            break;
          }
          case 32: {
            if (mode2 === MODE_HANDLE || mode2 === MODE_CENTER) {
              if (signX < 0)
                e0 = e1 - dx;
              else if (signX > 0)
                w0 = w1 - dx;
              if (signY < 0)
                s0 = s1 - dy;
              else if (signY > 0)
                n0 = n1 - dy;
              mode2 = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move(event2);
            }
            break;
          }
          default:
            return;
        }
        noevent$1(event2);
      }
      function keyupped(event2) {
        switch (event2.keyCode) {
          case 16: {
            if (shifting) {
              lockX = lockY = shifting = false;
              move(event2);
            }
            break;
          }
          case 18: {
            if (mode2 === MODE_CENTER) {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode2 = MODE_HANDLE;
              move(event2);
            }
            break;
          }
          case 32: {
            if (mode2 === MODE_SPACE) {
              if (event2.altKey) {
                if (signX)
                  e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY)
                  s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode2 = MODE_CENTER;
              } else {
                if (signX < 0)
                  e0 = e1;
                else if (signX > 0)
                  w0 = w1;
                if (signY < 0)
                  s0 = s1;
                else if (signY > 0)
                  n0 = n1;
                mode2 = MODE_HANDLE;
              }
              overlay.attr("cursor", cursors[type2]);
              move(event2);
            }
            break;
          }
          default:
            return;
        }
        noevent$1(event2);
      }
    }
    function touchmoved(event) {
      emitter(this, arguments).moved(event);
    }
    function touchended(event) {
      emitter(this, arguments).ended(event);
    }
    function initialize2() {
      var state = this.__brush || { selection: null };
      state.extent = number2(extent2.apply(this, arguments));
      state.dim = dim;
      return state;
    }
    brush2.extent = function(_2) {
      return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant$7(number2(_2)), brush2) : extent2;
    };
    brush2.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant$7(!!_2), brush2) : filter2;
    };
    brush2.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$7(!!_2), brush2) : touchable;
    };
    brush2.handleSize = function(_2) {
      return arguments.length ? (handleSize = +_2, brush2) : handleSize;
    };
    brush2.keyModifiers = function(_2) {
      return arguments.length ? (keys = !!_2, brush2) : keys;
    };
    brush2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? brush2 : value;
    };
    return brush2;
  }
  var abs$3 = Math.abs;
  var cos$2 = Math.cos;
  var sin$2 = Math.sin;
  var pi$3 = Math.PI;
  var halfPi$2 = pi$3 / 2;
  var tau$4 = pi$3 * 2;
  var max$1 = Math.max;
  var epsilon$5 = 1e-12;
  function range$1(i, j) {
    return Array.from({ length: j - i }, (_2, k2) => i + k2);
  }
  function compareValue(compare) {
    return function(a2, b) {
      return compare(
        a2.source.value + a2.target.value,
        b.source.value + b.target.value
      );
    };
  }
  function chord() {
    return chord$1(false, false);
  }
  function chordTranspose() {
    return chord$1(false, true);
  }
  function chordDirected() {
    return chord$1(true, false);
  }
  function chord$1(directed, transpose2) {
    var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
    function chord2(matrix) {
      var n = matrix.length, groupSums = new Array(n), groupIndex = range$1(0, n), chords = new Array(n * n), groups2 = new Array(n), k2 = 0, dx;
      matrix = Float64Array.from({ length: n * n }, transpose2 ? (_2, i) => matrix[i % n][i / n | 0] : (_2, i) => matrix[i / n | 0][i % n]);
      for (let i = 0; i < n; ++i) {
        let x2 = 0;
        for (let j = 0; j < n; ++j)
          x2 += matrix[i * n + j] + directed * matrix[j * n + i];
        k2 += groupSums[i] = x2;
      }
      k2 = max$1(0, tau$4 - padAngle * n) / k2;
      dx = k2 ? padAngle : tau$4 / n;
      {
        let x2 = 0;
        if (sortGroups)
          groupIndex.sort((a2, b) => sortGroups(groupSums[a2], groupSums[b]));
        for (const i of groupIndex) {
          const x02 = x2;
          if (directed) {
            const subgroupIndex = range$1(~n + 1, n).filter((j) => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
            if (sortSubgroups)
              subgroupIndex.sort((a2, b) => sortSubgroups(a2 < 0 ? -matrix[~a2 * n + i] : matrix[i * n + a2], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
            for (const j of subgroupIndex) {
              if (j < 0) {
                const chord3 = chords[~j * n + i] || (chords[~j * n + i] = { source: null, target: null });
                chord3.target = { index: i, startAngle: x2, endAngle: x2 += matrix[~j * n + i] * k2, value: matrix[~j * n + i] };
              } else {
                const chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });
                chord3.source = { index: i, startAngle: x2, endAngle: x2 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
              }
            }
            groups2[i] = { index: i, startAngle: x02, endAngle: x2, value: groupSums[i] };
          } else {
            const subgroupIndex = range$1(0, n).filter((j) => matrix[i * n + j] || matrix[j * n + i]);
            if (sortSubgroups)
              subgroupIndex.sort((a2, b) => sortSubgroups(matrix[i * n + a2], matrix[i * n + b]));
            for (const j of subgroupIndex) {
              let chord3;
              if (i < j) {
                chord3 = chords[i * n + j] || (chords[i * n + j] = { source: null, target: null });
                chord3.source = { index: i, startAngle: x2, endAngle: x2 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
              } else {
                chord3 = chords[j * n + i] || (chords[j * n + i] = { source: null, target: null });
                chord3.target = { index: i, startAngle: x2, endAngle: x2 += matrix[i * n + j] * k2, value: matrix[i * n + j] };
                if (i === j)
                  chord3.source = chord3.target;
              }
              if (chord3.source && chord3.target && chord3.source.value < chord3.target.value) {
                const source = chord3.source;
                chord3.source = chord3.target;
                chord3.target = source;
              }
            }
            groups2[i] = { index: i, startAngle: x02, endAngle: x2, value: groupSums[i] };
          }
          x2 += dx;
        }
      }
      chords = Object.values(chords);
      chords.groups = groups2;
      return sortChords ? chords.sort(sortChords) : chords;
    }
    chord2.padAngle = function(_2) {
      return arguments.length ? (padAngle = max$1(0, _2), chord2) : padAngle;
    };
    chord2.sortGroups = function(_2) {
      return arguments.length ? (sortGroups = _2, chord2) : sortGroups;
    };
    chord2.sortSubgroups = function(_2) {
      return arguments.length ? (sortSubgroups = _2, chord2) : sortSubgroups;
    };
    chord2.sortChords = function(_2) {
      return arguments.length ? (_2 == null ? sortChords = null : (sortChords = compareValue(_2))._ = _2, chord2) : sortChords && sortChords._;
    };
    return chord2;
  }
  const pi$2 = Math.PI, tau$3 = 2 * pi$2, epsilon$4 = 1e-6, tauEpsilon = tau$3 - epsilon$4;
  function Path$1() {
    this._x0 = this._y0 = this._x1 = this._y1 = null;
    this._ = "";
  }
  function path() {
    return new Path$1();
  }
  Path$1.prototype = path.prototype = {
    constructor: Path$1,
    moveTo: function(x2, y2) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
    },
    closePath: function() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    },
    lineTo: function(x2, y2) {
      this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    quadraticCurveTo: function(x12, y12, x2, y2) {
      this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
    },
    bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
      this._ += "C" + +x12 + "," + +y12 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
    },
    arcTo: function(x12, y12, x2, y2, r) {
      x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
      var x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
      } else if (!(l01_2 > epsilon$4))
        ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
        this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
      } else {
        var x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
        if (Math.abs(t01 - 1) > epsilon$4) {
          this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
        }
        this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
      }
    },
    arc: function(x2, y2, r, a0, a1, ccw) {
      x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
      var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (r < 0)
        throw new Error("negative radius: " + r);
      if (this._x1 === null) {
        this._ += "M" + x02 + "," + y02;
      } else if (Math.abs(this._x1 - x02) > epsilon$4 || Math.abs(this._y1 - y02) > epsilon$4) {
        this._ += "L" + x02 + "," + y02;
      }
      if (!r)
        return;
      if (da < 0)
        da = da % tau$3 + tau$3;
      if (da > tauEpsilon) {
        this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x02) + "," + (this._y1 = y02);
      } else if (da > epsilon$4) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
      }
    },
    rect: function(x2, y2, w2, h) {
      this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w2 + "v" + +h + "h" + -w2 + "Z";
    },
    toString: function() {
      return this._;
    }
  };
  var slice$3 = Array.prototype.slice;
  function constant$6(x2) {
    return function() {
      return x2;
    };
  }
  function defaultSource$1(d) {
    return d.source;
  }
  function defaultTarget(d) {
    return d.target;
  }
  function defaultRadius$1(d) {
    return d.radius;
  }
  function defaultStartAngle(d) {
    return d.startAngle;
  }
  function defaultEndAngle(d) {
    return d.endAngle;
  }
  function defaultPadAngle() {
    return 0;
  }
  function defaultArrowheadRadius() {
    return 10;
  }
  function ribbon(headRadius) {
    var source = defaultSource$1, target = defaultTarget, sourceRadius = defaultRadius$1, targetRadius = defaultRadius$1, startAngle = defaultStartAngle, endAngle = defaultEndAngle, padAngle = defaultPadAngle, context = null;
    function ribbon2() {
      var buffer2, s2 = source.apply(this, arguments), t = target.apply(this, arguments), ap = padAngle.apply(this, arguments) / 2, argv = slice$3.call(arguments), sr = +sourceRadius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi$2, sa1 = endAngle.apply(this, argv) - halfPi$2, tr = +targetRadius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi$2, ta1 = endAngle.apply(this, argv) - halfPi$2;
      if (!context)
        context = buffer2 = path();
      if (ap > epsilon$5) {
        if (abs$3(sa1 - sa0) > ap * 2 + epsilon$5)
          sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
        else
          sa0 = sa1 = (sa0 + sa1) / 2;
        if (abs$3(ta1 - ta0) > ap * 2 + epsilon$5)
          ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
        else
          ta0 = ta1 = (ta0 + ta1) / 2;
      }
      context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
      context.arc(0, 0, sr, sa0, sa1);
      if (sa0 !== ta0 || sa1 !== ta1) {
        if (headRadius) {
          var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
          context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
          context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
          context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
        } else {
          context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
          context.arc(0, 0, tr, ta0, ta1);
        }
      }
      context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
      context.closePath();
      if (buffer2)
        return context = null, buffer2 + "" || null;
    }
    if (headRadius)
      ribbon2.headRadius = function(_2) {
        return arguments.length ? (headRadius = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : headRadius;
      };
    ribbon2.radius = function(_2) {
      return arguments.length ? (sourceRadius = targetRadius = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : sourceRadius;
    };
    ribbon2.sourceRadius = function(_2) {
      return arguments.length ? (sourceRadius = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : sourceRadius;
    };
    ribbon2.targetRadius = function(_2) {
      return arguments.length ? (targetRadius = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : targetRadius;
    };
    ribbon2.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : startAngle;
    };
    ribbon2.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : endAngle;
    };
    ribbon2.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$6(+_2), ribbon2) : padAngle;
    };
    ribbon2.source = function(_2) {
      return arguments.length ? (source = _2, ribbon2) : source;
    };
    ribbon2.target = function(_2) {
      return arguments.length ? (target = _2, ribbon2) : target;
    };
    ribbon2.context = function(_2) {
      return arguments.length ? (context = _2 == null ? null : _2, ribbon2) : context;
    };
    return ribbon2;
  }
  function ribbon$1() {
    return ribbon();
  }
  function ribbonArrow() {
    return ribbon(defaultArrowheadRadius);
  }
  var array$2 = Array.prototype;
  var slice$2 = array$2.slice;
  function ascending$1(a2, b) {
    return a2 - b;
  }
  function area$3(ring) {
    var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
    while (++i < n)
      area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
    return area2;
  }
  const constant$5 = (x2) => () => x2;
  function contains$2(ring, hole) {
    var i = -1, n = hole.length, c2;
    while (++i < n)
      if (c2 = ringContains(ring, hole[i]))
        return c2;
    return 0;
  }
  function ringContains(ring, point2) {
    var x2 = point2[0], y2 = point2[1], contains2 = -1;
    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
      var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
      if (segmentContains(pi2, pj, point2))
        return 0;
      if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
        contains2 = -contains2;
    }
    return contains2;
  }
  function segmentContains(a2, b, c2) {
    var i;
    return collinear$1(a2, b, c2) && within(a2[i = +(a2[0] === b[0])], c2[i], b[i]);
  }
  function collinear$1(a2, b, c2) {
    return (b[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b[1] - a2[1]);
  }
  function within(p, q, r) {
    return p <= q && q <= r || r <= q && q <= p;
  }
  function noop$2() {
  }
  var cases = [
    [],
    [[[1, 1.5], [0.5, 1]]],
    [[[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [0.5, 1]]],
    [[[1, 0.5], [1.5, 1]]],
    [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
    [[[1, 0.5], [1, 1.5]]],
    [[[1, 0.5], [0.5, 1]]],
    [[[0.5, 1], [1, 0.5]]],
    [[[1, 1.5], [1, 0.5]]],
    [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [1, 0.5]]],
    [[[0.5, 1], [1.5, 1]]],
    [[[1, 1.5], [1.5, 1]]],
    [[[0.5, 1], [1, 1.5]]],
    []
  ];
  function Contours() {
    var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
    function contours(values) {
      var tz = threshold2(values);
      if (!Array.isArray(tz)) {
        const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
        tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
      } else {
        tz = tz.slice().sort(ascending$1);
      }
      return tz.map((value) => contour(values, value));
    }
    function contour(values, value) {
      var polygons = [], holes = [];
      isorings(values, value, function(ring) {
        smooth(ring, values, value);
        if (area$3(ring) > 0)
          polygons.push([ring]);
        else
          holes.push(ring);
      });
      holes.forEach(function(hole) {
        for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
          if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
            polygon.push(hole);
            return;
          }
        }
      });
      return {
        type: "MultiPolygon",
        value,
        coordinates: polygons
      };
    }
    function isorings(values, value, callback) {
      var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t12, t22, t32;
      x2 = y2 = -1;
      t12 = values[0] >= value;
      cases[t12 << 1].forEach(stitch);
      while (++x2 < dx - 1) {
        t02 = t12, t12 = values[x2 + 1] >= value;
        cases[t02 | t12 << 1].forEach(stitch);
      }
      cases[t12 << 0].forEach(stitch);
      while (++y2 < dy - 1) {
        x2 = -1;
        t12 = values[y2 * dx + dx] >= value;
        t22 = values[y2 * dx] >= value;
        cases[t12 << 1 | t22 << 2].forEach(stitch);
        while (++x2 < dx - 1) {
          t02 = t12, t12 = values[y2 * dx + dx + x2 + 1] >= value;
          t32 = t22, t22 = values[y2 * dx + x2 + 1] >= value;
          cases[t02 | t12 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
        }
        cases[t12 | t22 << 3].forEach(stitch);
      }
      x2 = -1;
      t22 = values[y2 * dx] >= value;
      cases[t22 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t32 = t22, t22 = values[y2 * dx + x2 + 1] >= value;
        cases[t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t22 << 3].forEach(stitch);
      function stitch(line2) {
        var start2 = [line2[0][0] + x2, line2[0][1] + y2], end2 = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index2(start2), endIndex = index2(end2), f, g;
        if (f = fragmentByEnd[startIndex]) {
          if (g = fragmentByStart[endIndex]) {
            delete fragmentByEnd[f.end];
            delete fragmentByStart[g.start];
            if (f === g) {
              f.ring.push(end2);
              callback(f.ring);
            } else {
              fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
            }
          } else {
            delete fragmentByEnd[f.end];
            f.ring.push(end2);
            fragmentByEnd[f.end = endIndex] = f;
          }
        } else if (f = fragmentByStart[endIndex]) {
          if (g = fragmentByEnd[startIndex]) {
            delete fragmentByStart[f.start];
            delete fragmentByEnd[g.end];
            if (f === g) {
              f.ring.push(end2);
              callback(f.ring);
            } else {
              fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
            }
          } else {
            delete fragmentByStart[f.start];
            f.ring.unshift(start2);
            fragmentByStart[f.start = startIndex] = f;
          }
        } else {
          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end2] };
        }
      }
    }
    function index2(point2) {
      return point2[0] * 2 + point2[1] * (dx + 1) * 4;
    }
    function smoothLinear(ring, values, value) {
      ring.forEach(function(point2) {
        var x2 = point2[0], y2 = point2[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values[yt * dx + xt];
        if (x2 > 0 && x2 < dx && xt === x2) {
          v0 = values[yt * dx + xt - 1];
          point2[0] = x2 + (value - v0) / (v1 - v0) - 0.5;
        }
        if (y2 > 0 && y2 < dy && yt === y2) {
          v0 = values[(yt - 1) * dx + xt];
          point2[1] = y2 + (value - v0) / (v1 - v0) - 0.5;
        }
      });
    }
    contours.contour = contour;
    contours.size = function(_2) {
      if (!arguments.length)
        return [dx, dy];
      var _0 = Math.floor(_2[0]), _1 = Math.floor(_2[1]);
      if (!(_0 >= 0 && _1 >= 0))
        throw new Error("invalid size");
      return dx = _0, dy = _1, contours;
    };
    contours.thresholds = function(_2) {
      return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$5(slice$2.call(_2)) : constant$5(_2), contours) : threshold2;
    };
    contours.smooth = function(_2) {
      return arguments.length ? (smooth = _2 ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
    };
    return contours;
  }
  function defaultX$1(d) {
    return d[0];
  }
  function defaultY$1(d) {
    return d[1];
  }
  function defaultWeight() {
    return 1;
  }
  function density() {
    var x2 = defaultX$1, y2 = defaultY$1, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m2 = dy + o * 2 >> k2, threshold2 = constant$5(20);
    function grid(data) {
      var values = new Float32Array(n * m2), pow2k = Math.pow(2, -k2), i = -1;
      for (const d of data) {
        var xi = (x2(d, ++i, data) + o) * pow2k, yi = (y2(d, i, data) + o) * pow2k, wi = +weight(d, i, data);
        if (xi >= 0 && xi < n && yi >= 0 && yi < m2) {
          var x02 = Math.floor(xi), y02 = Math.floor(yi), xt = xi - x02 - 0.5, yt = yi - y02 - 0.5;
          values[x02 + y02 * n] += (1 - xt) * (1 - yt) * wi;
          values[x02 + 1 + y02 * n] += xt * (1 - yt) * wi;
          values[x02 + 1 + (y02 + 1) * n] += xt * yt * wi;
          values[x02 + (y02 + 1) * n] += (1 - xt) * yt * wi;
        }
      }
      blur2({ data: values, width: n, height: m2 }, r * pow2k);
      return values;
    }
    function density2(data) {
      var values = grid(data), tz = threshold2(values), pow4k = Math.pow(2, 2 * k2);
      if (!Array.isArray(tz)) {
        tz = ticks(Number.MIN_VALUE, max$3(values) / pow4k, tz);
      }
      return Contours().size([n, m2]).thresholds(tz.map((d) => d * pow4k))(values).map((c2, i) => (c2.value = +tz[i], transform2(c2)));
    }
    density2.contours = function(data) {
      var values = grid(data), contours = Contours().size([n, m2]), pow4k = Math.pow(2, 2 * k2), contour = (value) => {
        value = +value;
        var c2 = transform2(contours.contour(values, value * pow4k));
        c2.value = value;
        return c2;
      };
      Object.defineProperty(contour, "max", { get: () => max$3(values) / pow4k });
      return contour;
    };
    function transform2(geometry) {
      geometry.coordinates.forEach(transformPolygon);
      return geometry;
    }
    function transformPolygon(coordinates2) {
      coordinates2.forEach(transformRing);
    }
    function transformRing(coordinates2) {
      coordinates2.forEach(transformPoint);
    }
    function transformPoint(coordinates2) {
      coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
      coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
    }
    function resize() {
      o = r * 3;
      n = dx + o * 2 >> k2;
      m2 = dy + o * 2 >> k2;
      return density2;
    }
    density2.x = function(_2) {
      return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$5(+_2), density2) : x2;
    };
    density2.y = function(_2) {
      return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$5(+_2), density2) : y2;
    };
    density2.weight = function(_2) {
      return arguments.length ? (weight = typeof _2 === "function" ? _2 : constant$5(+_2), density2) : weight;
    };
    density2.size = function(_2) {
      if (!arguments.length)
        return [dx, dy];
      var _0 = +_2[0], _1 = +_2[1];
      if (!(_0 >= 0 && _1 >= 0))
        throw new Error("invalid size");
      return dx = _0, dy = _1, resize();
    };
    density2.cellSize = function(_2) {
      if (!arguments.length)
        return 1 << k2;
      if (!((_2 = +_2) >= 1))
        throw new Error("invalid cell size");
      return k2 = Math.floor(Math.log(_2) / Math.LN2), resize();
    };
    density2.thresholds = function(_2) {
      return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$5(slice$2.call(_2)) : constant$5(_2), density2) : threshold2;
    };
    density2.bandwidth = function(_2) {
      if (!arguments.length)
        return Math.sqrt(r * (r + 1));
      if (!((_2 = +_2) >= 0))
        throw new Error("invalid bandwidth");
      return r = (Math.sqrt(4 * _2 * _2 + 1) - 1) / 2, resize();
    };
    return density2;
  }
  const epsilon$3 = 11102230246251565e-32;
  const splitter = 134217729;
  const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;
  function sum$1(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
      Q = enow;
      enow = e[++eindex];
    } else {
      Q = fnow;
      fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q;
        hh = Q - (Qnew - enow);
        enow = e[++eindex];
      } else {
        Qnew = fnow + Q;
        hh = Q - (Qnew - fnow);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q + enow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (enow - bvirt);
          enow = e[++eindex];
        } else {
          Qnew = Q + fnow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
    }
    while (eindex < elen) {
      Qnew = Q + enow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (enow - bvirt);
      enow = e[++eindex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    while (findex < flen) {
      Qnew = Q + fnow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f[++findex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    if (Q !== 0 || hindex === 0) {
      h[hindex++] = Q;
    }
    return hindex;
  }
  function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++)
      Q += e[i];
    return Q;
  }
  function vec(n) {
    return new Float64Array(n);
  }
  const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
  const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
  const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;
  const B = vec(4);
  const C1 = vec(8);
  const C2 = vec(12);
  const D = vec(16);
  const u = vec(4);
  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c2, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t12, t02, u3;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c2 = splitter * acx;
    ahi = c2 - (c2 - acx);
    alo = acx - ahi;
    c2 = splitter * bcy;
    bhi = c2 - (c2 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t12 = acy * bcx;
    c2 = splitter * acy;
    ahi = c2 - (c2 - acy);
    alo = acy - ahi;
    c2 = splitter * bcx;
    bhi = c2 - (c2 - bcx);
    blo = bcx - bhi;
    t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t02;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t02);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t12;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t12);
    u3 = _j + _i;
    bvirt = u3 - _j;
    B[2] = _j - (u3 - bvirt) + (_i - bvirt);
    B[3] = u3;
    let det = estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
      return det;
    }
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det;
    }
    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound)
      return det;
    s1 = acxtail * bcy;
    c2 = splitter * acxtail;
    ahi = c2 - (c2 - acxtail);
    alo = acxtail - ahi;
    c2 = splitter * bcy;
    bhi = c2 - (c2 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t12 = acytail * bcx;
    c2 = splitter * acytail;
    ahi = c2 - (c2 - acytail);
    alo = acytail - ahi;
    c2 = splitter * bcx;
    bhi = c2 - (c2 - bcx);
    blo = bcx - bhi;
    t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t02;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t02);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t12;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t12);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C1len = sum$1(4, B, 4, u, C1);
    s1 = acx * bcytail;
    c2 = splitter * acx;
    ahi = c2 - (c2 - acx);
    alo = acx - ahi;
    c2 = splitter * bcytail;
    bhi = c2 - (c2 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t12 = acy * bcxtail;
    c2 = splitter * acy;
    ahi = c2 - (c2 - acy);
    alo = acy - ahi;
    c2 = splitter * bcxtail;
    bhi = c2 - (c2 - bcxtail);
    blo = bcxtail - bhi;
    t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t02;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t02);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t12;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t12);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const C2len = sum$1(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c2 = splitter * acxtail;
    ahi = c2 - (c2 - acxtail);
    alo = acxtail - ahi;
    c2 = splitter * bcytail;
    bhi = c2 - (c2 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t12 = acytail * bcxtail;
    c2 = splitter * acytail;
    ahi = c2 - (c2 - acytail);
    alo = acytail - ahi;
    c2 = splitter * bcxtail;
    bhi = c2 - (c2 - bcxtail);
    blo = bcxtail - bhi;
    t02 = alo * blo - (t12 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t02;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t02);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t12;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t12);
    u3 = _j + _i;
    bvirt = u3 - _j;
    u[2] = _j - (u3 - bvirt) + (_i - bvirt);
    u[3] = u3;
    const Dlen = sum$1(C2len, C2, 4, u, D);
    return D[Dlen - 1];
  }
  function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    if (detleft === 0 || detright === 0 || detleft > 0 !== detright > 0)
      return det;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum)
      return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }
  const EPSILON = Math.pow(2, -52);
  const EDGE_STACK = new Uint32Array(512);
  class Delaunator {
    static from(points, getX = defaultGetX, getY = defaultGetY) {
      const n = points.length;
      const coords = new Float64Array(n * 2);
      for (let i = 0; i < n; i++) {
        const p = points[i];
        coords[2 * i] = getX(p);
        coords[2 * i + 1] = getY(p);
      }
      return new Delaunator(coords);
    }
    constructor(coords) {
      const n = coords.length >> 1;
      if (n > 0 && typeof coords[0] !== "number")
        throw new Error("Expected coords to contain numbers.");
      this.coords = coords;
      const maxTriangles = Math.max(2 * n - 5, 0);
      this._triangles = new Uint32Array(maxTriangles * 3);
      this._halfedges = new Int32Array(maxTriangles * 3);
      this._hashSize = Math.ceil(Math.sqrt(n));
      this._hullPrev = new Uint32Array(n);
      this._hullNext = new Uint32Array(n);
      this._hullTri = new Uint32Array(n);
      this._hullHash = new Int32Array(this._hashSize).fill(-1);
      this._ids = new Uint32Array(n);
      this._dists = new Float64Array(n);
      this.update();
    }
    update() {
      const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
      const n = coords.length >> 1;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY2 = -Infinity;
      for (let i = 0; i < n; i++) {
        const x2 = coords[2 * i];
        const y2 = coords[2 * i + 1];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY2)
          maxY2 = y2;
        this._ids[i] = i;
      }
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY2) / 2;
      let minDist = Infinity;
      let i0, i1, i2;
      for (let i = 0; i < n; i++) {
        const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist) {
          i0 = i;
          minDist = d;
        }
      }
      const i0x = coords[2 * i0];
      const i0y = coords[2 * i0 + 1];
      minDist = Infinity;
      for (let i = 0; i < n; i++) {
        if (i === i0)
          continue;
        const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
        if (d < minDist && d > 0) {
          i1 = i;
          minDist = d;
        }
      }
      let i1x = coords[2 * i1];
      let i1y = coords[2 * i1 + 1];
      let minRadius = Infinity;
      for (let i = 0; i < n; i++) {
        if (i === i0 || i === i1)
          continue;
        const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
        if (r < minRadius) {
          i2 = i;
          minRadius = r;
        }
      }
      let i2x = coords[2 * i2];
      let i2y = coords[2 * i2 + 1];
      if (minRadius === Infinity) {
        for (let i = 0; i < n; i++) {
          this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
        }
        quicksort(this._ids, this._dists, 0, n - 1);
        const hull2 = new Uint32Array(n);
        let j = 0;
        for (let i = 0, d0 = -Infinity; i < n; i++) {
          const id2 = this._ids[i];
          if (this._dists[id2] > d0) {
            hull2[j++] = id2;
            d0 = this._dists[id2];
          }
        }
        this.hull = hull2.subarray(0, j);
        this.triangles = new Uint32Array(0);
        this.halfedges = new Uint32Array(0);
        return;
      }
      if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
        const i = i1;
        const x2 = i1x;
        const y2 = i1y;
        i1 = i2;
        i1x = i2x;
        i1y = i2y;
        i2 = i;
        i2x = x2;
        i2y = y2;
      }
      const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
      this._cx = center2.x;
      this._cy = center2.y;
      for (let i = 0; i < n; i++) {
        this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center2.x, center2.y);
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      this._hullStart = i0;
      let hullSize = 3;
      hullNext[i0] = hullPrev[i2] = i1;
      hullNext[i1] = hullPrev[i0] = i2;
      hullNext[i2] = hullPrev[i1] = i0;
      hullTri[i0] = 0;
      hullTri[i1] = 1;
      hullTri[i2] = 2;
      hullHash.fill(-1);
      hullHash[this._hashKey(i0x, i0y)] = i0;
      hullHash[this._hashKey(i1x, i1y)] = i1;
      hullHash[this._hashKey(i2x, i2y)] = i2;
      this.trianglesLen = 0;
      this._addTriangle(i0, i1, i2, -1, -1, -1);
      for (let k2 = 0, xp, yp; k2 < this._ids.length; k2++) {
        const i = this._ids[k2];
        const x2 = coords[2 * i];
        const y2 = coords[2 * i + 1];
        if (k2 > 0 && Math.abs(x2 - xp) <= EPSILON && Math.abs(y2 - yp) <= EPSILON)
          continue;
        xp = x2;
        yp = y2;
        if (i === i0 || i === i1 || i === i2)
          continue;
        let start2 = 0;
        for (let j = 0, key = this._hashKey(x2, y2); j < this._hashSize; j++) {
          start2 = hullHash[(key + j) % this._hashSize];
          if (start2 !== -1 && start2 !== hullNext[start2])
            break;
        }
        start2 = hullPrev[start2];
        let e = start2, q;
        while (q = hullNext[e], orient2d(x2, y2, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
          e = q;
          if (e === start2) {
            e = -1;
            break;
          }
        }
        if (e === -1)
          continue;
        let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
        hullTri[i] = this._legalize(t + 2);
        hullTri[e] = t;
        hullSize++;
        let n2 = hullNext[e];
        while (q = hullNext[n2], orient2d(x2, y2, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
          t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
          hullTri[i] = this._legalize(t + 2);
          hullNext[n2] = n2;
          hullSize--;
          n2 = q;
        }
        if (e === start2) {
          while (q = hullPrev[e], orient2d(x2, y2, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
            t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
            this._legalize(t + 2);
            hullTri[q] = t;
            hullNext[e] = e;
            hullSize--;
            e = q;
          }
        }
        this._hullStart = hullPrev[i] = e;
        hullNext[e] = hullPrev[n2] = i;
        hullNext[i] = n2;
        hullHash[this._hashKey(x2, y2)] = i;
        hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
      }
      this.hull = new Uint32Array(hullSize);
      for (let i = 0, e = this._hullStart; i < hullSize; i++) {
        this.hull[i] = e;
        e = hullNext[e];
      }
      this.triangles = this._triangles.subarray(0, this.trianglesLen);
      this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(x2, y2) {
      return Math.floor(pseudoAngle(x2 - this._cx, y2 - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(a2) {
      const { _triangles: triangles, _halfedges: halfedges, coords } = this;
      let i = 0;
      let ar = 0;
      while (true) {
        const b = halfedges[a2];
        const a0 = a2 - a2 % 3;
        ar = a0 + (a2 + 2) % 3;
        if (b === -1) {
          if (i === 0)
            break;
          a2 = EDGE_STACK[--i];
          continue;
        }
        const b02 = b - b % 3;
        const al = a0 + (a2 + 1) % 3;
        const bl = b02 + (b + 2) % 3;
        const p02 = triangles[ar];
        const pr = triangles[a2];
        const pl = triangles[al];
        const p1 = triangles[bl];
        const illegal = inCircle(
          coords[2 * p02],
          coords[2 * p02 + 1],
          coords[2 * pr],
          coords[2 * pr + 1],
          coords[2 * pl],
          coords[2 * pl + 1],
          coords[2 * p1],
          coords[2 * p1 + 1]
        );
        if (illegal) {
          triangles[a2] = p1;
          triangles[b] = p02;
          const hbl = halfedges[bl];
          if (hbl === -1) {
            let e = this._hullStart;
            do {
              if (this._hullTri[e] === bl) {
                this._hullTri[e] = a2;
                break;
              }
              e = this._hullPrev[e];
            } while (e !== this._hullStart);
          }
          this._link(a2, hbl);
          this._link(b, halfedges[ar]);
          this._link(ar, bl);
          const br = b02 + (b + 1) % 3;
          if (i < EDGE_STACK.length) {
            EDGE_STACK[i++] = br;
          }
        } else {
          if (i === 0)
            break;
          a2 = EDGE_STACK[--i];
        }
      }
      return ar;
    }
    _link(a2, b) {
      this._halfedges[a2] = b;
      if (b !== -1)
        this._halfedges[b] = a2;
    }
    _addTriangle(i0, i1, i2, a2, b, c2) {
      const t = this.trianglesLen;
      this._triangles[t] = i0;
      this._triangles[t + 1] = i1;
      this._triangles[t + 2] = i2;
      this._link(t, a2);
      this._link(t + 1, b);
      this._link(t + 2, c2);
      this.trianglesLen += 3;
      return t;
    }
  }
  function pseudoAngle(dx, dy) {
    const p = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p : 1 + p) / 4;
  }
  function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }
  function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x2 = (ey * bl - dy * cl) * d;
    const y2 = (dx * cl - ex * bl) * d;
    return x2 * x2 + y2 * y2;
  }
  function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d = 0.5 / (dx * ey - dy * ex);
    const x2 = ax + (ey * bl - dy * cl) * d;
    const y2 = ay + (dx * cl - ex * bl) * d;
    return { x: x2, y: y2 };
  }
  function quicksort(ids, dists, left2, right2) {
    if (right2 - left2 <= 20) {
      for (let i = left2 + 1; i <= right2; i++) {
        const temp = ids[i];
        const tempDist = dists[temp];
        let j = i - 1;
        while (j >= left2 && dists[ids[j]] > tempDist)
          ids[j + 1] = ids[j--];
        ids[j + 1] = temp;
      }
    } else {
      const median2 = left2 + right2 >> 1;
      let i = left2 + 1;
      let j = right2;
      swap(ids, median2, i);
      if (dists[ids[left2]] > dists[ids[right2]])
        swap(ids, left2, right2);
      if (dists[ids[i]] > dists[ids[right2]])
        swap(ids, i, right2);
      if (dists[ids[left2]] > dists[ids[i]])
        swap(ids, left2, i);
      const temp = ids[i];
      const tempDist = dists[temp];
      while (true) {
        do
          i++;
        while (dists[ids[i]] < tempDist);
        do
          j--;
        while (dists[ids[j]] > tempDist);
        if (j < i)
          break;
        swap(ids, i, j);
      }
      ids[left2 + 1] = ids[j];
      ids[j] = temp;
      if (right2 - i + 1 >= j - left2) {
        quicksort(ids, dists, i, right2);
        quicksort(ids, dists, left2, j - 1);
      } else {
        quicksort(ids, dists, left2, j - 1);
        quicksort(ids, dists, i, right2);
      }
    }
  }
  function swap(arr, i, j) {
    const tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
  function defaultGetX(p) {
    return p[0];
  }
  function defaultGetY(p) {
    return p[1];
  }
  const epsilon$2 = 1e-6;
  class Path {
    constructor() {
      this._x0 = this._y0 = this._x1 = this._y1 = null;
      this._ = "";
    }
    moveTo(x2, y2) {
      this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    }
    lineTo(x2, y2) {
      this._ += `L${this._x1 = +x2},${this._y1 = +y2}`;
    }
    arc(x2, y2, r) {
      x2 = +x2, y2 = +y2, r = +r;
      const x02 = x2 + r;
      const y02 = y2;
      if (r < 0)
        throw new Error("negative radius");
      if (this._x1 === null)
        this._ += `M${x02},${y02}`;
      else if (Math.abs(this._x1 - x02) > epsilon$2 || Math.abs(this._y1 - y02) > epsilon$2)
        this._ += "L" + x02 + "," + y02;
      if (!r)
        return;
      this._ += `A${r},${r},0,1,1,${x2 - r},${y2}A${r},${r},0,1,1,${this._x1 = x02},${this._y1 = y02}`;
    }
    rect(x2, y2, w2, h) {
      this._ += `M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${+w2}v${+h}h${-w2}Z`;
    }
    value() {
      return this._ || null;
    }
  }
  class Polygon {
    constructor() {
      this._ = [];
    }
    moveTo(x2, y2) {
      this._.push([x2, y2]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(x2, y2) {
      this._.push([x2, y2]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  }
  class Voronoi {
    constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
      if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin)))
        throw new Error("invalid bounds");
      this.delaunay = delaunay;
      this._circumcenters = new Float64Array(delaunay.points.length * 2);
      this.vectors = new Float64Array(delaunay.points.length * 2);
      this.xmax = xmax, this.xmin = xmin;
      this.ymax = ymax, this.ymin = ymin;
      this._init();
    }
    update() {
      this.delaunay.update();
      this._init();
      return this;
    }
    _init() {
      const { delaunay: { points, hull: hull2, triangles }, vectors } = this;
      const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
      for (let i = 0, j = 0, n = triangles.length, x2, y2; i < n; i += 3, j += 2) {
        const t12 = triangles[i] * 2;
        const t22 = triangles[i + 1] * 2;
        const t32 = triangles[i + 2] * 2;
        const x13 = points[t12];
        const y13 = points[t12 + 1];
        const x22 = points[t22];
        const y22 = points[t22 + 1];
        const x3 = points[t32];
        const y3 = points[t32 + 1];
        const dx = x22 - x13;
        const dy = y22 - y13;
        const ex = x3 - x13;
        const ey = y3 - y13;
        const ab = (dx * ey - dy * ex) * 2;
        if (Math.abs(ab) < 1e-9) {
          let a2 = 1e9;
          const r = triangles[0] * 2;
          a2 *= Math.sign((points[r] - x13) * ey - (points[r + 1] - y13) * ex);
          x2 = (x13 + x3) / 2 - a2 * ey;
          y2 = (y13 + y3) / 2 + a2 * ex;
        } else {
          const d = 1 / ab;
          const bl = dx * dx + dy * dy;
          const cl = ex * ex + ey * ey;
          x2 = x13 + (ey * bl - dy * cl) * d;
          y2 = y13 + (dx * cl - ex * bl) * d;
        }
        circumcenters[j] = x2;
        circumcenters[j + 1] = y2;
      }
      let h = hull2[hull2.length - 1];
      let p02, p1 = h * 4;
      let x02, x12 = points[2 * h];
      let y02, y12 = points[2 * h + 1];
      vectors.fill(0);
      for (let i = 0; i < hull2.length; ++i) {
        h = hull2[i];
        p02 = p1, x02 = x12, y02 = y12;
        p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];
        vectors[p02 + 2] = vectors[p1] = y02 - y12;
        vectors[p02 + 3] = vectors[p1 + 1] = x12 - x02;
      }
    }
    render(context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      const { delaunay: { halfedges, inedges, hull: hull2 }, circumcenters, vectors } = this;
      if (hull2.length <= 1)
        return null;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j = halfedges[i];
        if (j < i)
          continue;
        const ti = Math.floor(i / 3) * 2;
        const tj = Math.floor(j / 3) * 2;
        const xi = circumcenters[ti];
        const yi = circumcenters[ti + 1];
        const xj = circumcenters[tj];
        const yj = circumcenters[tj + 1];
        this._renderSegment(xi, yi, xj, yj, context);
      }
      let h0, h1 = hull2[hull2.length - 1];
      for (let i = 0; i < hull2.length; ++i) {
        h0 = h1, h1 = hull2[i];
        const t = Math.floor(inedges[h1] / 3) * 2;
        const x2 = circumcenters[t];
        const y2 = circumcenters[t + 1];
        const v = h0 * 4;
        const p = this._project(x2, y2, vectors[v + 2], vectors[v + 3]);
        if (p)
          this._renderSegment(x2, y2, p[0], p[1], context);
      }
      return buffer2 && buffer2.value();
    }
    renderBounds(context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
      return buffer2 && buffer2.value();
    }
    renderCell(i, context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      const points = this._clip(i);
      if (points === null || !points.length)
        return;
      context.moveTo(points[0], points[1]);
      let n = points.length;
      while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1)
        n -= 2;
      for (let i2 = 2; i2 < n; i2 += 2) {
        if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
          context.lineTo(points[i2], points[i2 + 1]);
      }
      context.closePath();
      return buffer2 && buffer2.value();
    }
    *cellPolygons() {
      const { delaunay: { points } } = this;
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const cell = this.cellPolygon(i);
        if (cell)
          cell.index = i, yield cell;
      }
    }
    cellPolygon(i) {
      const polygon = new Polygon();
      this.renderCell(i, polygon);
      return polygon.value();
    }
    _renderSegment(x02, y02, x12, y12, context) {
      let S;
      const c0 = this._regioncode(x02, y02);
      const c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        context.moveTo(x02, y02);
        context.lineTo(x12, y12);
      } else if (S = this._clipSegment(x02, y02, x12, y12, c0, c1)) {
        context.moveTo(S[0], S[1]);
        context.lineTo(S[2], S[3]);
      }
    }
    contains(i, x2, y2) {
      if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2))
        return false;
      return this.delaunay._step(i, x2, y2) === i;
    }
    *neighbors(i) {
      const ci = this._clip(i);
      if (ci)
        for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          if (cj)
            loop:
              for (let ai = 0, li = ci.length; ai < li; ai += 2) {
                for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
                  if (ci[ai] == cj[aj] && ci[ai + 1] == cj[aj + 1] && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]) {
                    yield j;
                    break loop;
                  }
                }
              }
        }
    }
    _cell(i) {
      const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
      const e0 = inedges[i];
      if (e0 === -1)
        return null;
      const points = [];
      let e = e0;
      do {
        const t = Math.floor(e / 3);
        points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i)
          break;
        e = halfedges[e];
      } while (e !== e0 && e !== -1);
      return points;
    }
    _clip(i) {
      if (i === 0 && this.delaunay.hull.length === 1) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      const points = this._cell(i);
      if (points === null)
        return null;
      const { vectors: V } = this;
      const v = i * 4;
      return V[v] || V[v + 1] ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3]) : this._clipFinite(i, points);
    }
    _clipFinite(i, points) {
      const n = points.length;
      let P = null;
      let x02, y02, x12 = points[n - 2], y12 = points[n - 1];
      let c0, c1 = this._regioncode(x12, y12);
      let e0, e1 = 0;
      for (let j = 0; j < n; j += 2) {
        x02 = x12, y02 = y12, x12 = points[j], y12 = points[j + 1];
        c0 = c1, c1 = this._regioncode(x12, y12);
        if (c0 === 0 && c1 === 0) {
          e0 = e1, e1 = 0;
          if (P)
            P.push(x12, y12);
          else
            P = [x12, y12];
        } else {
          let S, sx0, sy0, sx1, sy1;
          if (c0 === 0) {
            if ((S = this._clipSegment(x02, y02, x12, y12, c0, c1)) === null)
              continue;
            [sx0, sy0, sx1, sy1] = S;
          } else {
            if ((S = this._clipSegment(x12, y12, x02, y02, c1, c0)) === null)
              continue;
            [sx1, sy1, sx0, sy0] = S;
            e0 = e1, e1 = this._edgecode(sx0, sy0);
            if (e0 && e1)
              this._edge(i, e0, e1, P, P.length);
            if (P)
              P.push(sx0, sy0);
            else
              P = [sx0, sy0];
          }
          e0 = e1, e1 = this._edgecode(sx1, sy1);
          if (e0 && e1)
            this._edge(i, e0, e1, P, P.length);
          if (P)
            P.push(sx1, sy1);
          else
            P = [sx1, sy1];
        }
      }
      if (P) {
        e0 = e1, e1 = this._edgecode(P[0], P[1]);
        if (e0 && e1)
          this._edge(i, e0, e1, P, P.length);
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      return P;
    }
    _clipSegment(x02, y02, x12, y12, c0, c1) {
      while (true) {
        if (c0 === 0 && c1 === 0)
          return [x02, y02, x12, y12];
        if (c0 & c1)
          return null;
        let x2, y2, c2 = c0 || c1;
        if (c2 & 8)
          x2 = x02 + (x12 - x02) * (this.ymax - y02) / (y12 - y02), y2 = this.ymax;
        else if (c2 & 4)
          x2 = x02 + (x12 - x02) * (this.ymin - y02) / (y12 - y02), y2 = this.ymin;
        else if (c2 & 2)
          y2 = y02 + (y12 - y02) * (this.xmax - x02) / (x12 - x02), x2 = this.xmax;
        else
          y2 = y02 + (y12 - y02) * (this.xmin - x02) / (x12 - x02), x2 = this.xmin;
        if (c0)
          x02 = x2, y02 = y2, c0 = this._regioncode(x02, y02);
        else
          x12 = x2, y12 = y2, c1 = this._regioncode(x12, y12);
      }
    }
    _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
      let P = Array.from(points), p;
      if (p = this._project(P[0], P[1], vx0, vy0))
        P.unshift(p[0], p[1]);
      if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn))
        P.push(p[0], p[1]);
      if (P = this._clipFinite(i, P)) {
        for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
          c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
          if (c0 && c1)
            j = this._edge(i, c0, c1, P, j), n = P.length;
        }
      } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
      }
      return P;
    }
    _edge(i, e0, e1, P, j) {
      while (e0 !== e1) {
        let x2, y2;
        switch (e0) {
          case 5:
            e0 = 4;
            continue;
          case 4:
            e0 = 6, x2 = this.xmax, y2 = this.ymin;
            break;
          case 6:
            e0 = 2;
            continue;
          case 2:
            e0 = 10, x2 = this.xmax, y2 = this.ymax;
            break;
          case 10:
            e0 = 8;
            continue;
          case 8:
            e0 = 9, x2 = this.xmin, y2 = this.ymax;
            break;
          case 9:
            e0 = 1;
            continue;
          case 1:
            e0 = 5, x2 = this.xmin, y2 = this.ymin;
            break;
        }
        if ((P[j] !== x2 || P[j + 1] !== y2) && this.contains(i, x2, y2)) {
          P.splice(j, 0, x2, y2), j += 2;
        }
      }
      if (P.length > 4) {
        for (let i2 = 0; i2 < P.length; i2 += 2) {
          const j2 = (i2 + 2) % P.length, k2 = (i2 + 4) % P.length;
          if (P[i2] === P[j2] && P[j2] === P[k2] || P[i2 + 1] === P[j2 + 1] && P[j2 + 1] === P[k2 + 1])
            P.splice(j2, 2), i2 -= 2;
        }
      }
      return j;
    }
    _project(x02, y02, vx, vy) {
      let t = Infinity, c2, x2, y2;
      if (vy < 0) {
        if (y02 <= this.ymin)
          return null;
        if ((c2 = (this.ymin - y02) / vy) < t)
          y2 = this.ymin, x2 = x02 + (t = c2) * vx;
      } else if (vy > 0) {
        if (y02 >= this.ymax)
          return null;
        if ((c2 = (this.ymax - y02) / vy) < t)
          y2 = this.ymax, x2 = x02 + (t = c2) * vx;
      }
      if (vx > 0) {
        if (x02 >= this.xmax)
          return null;
        if ((c2 = (this.xmax - x02) / vx) < t)
          x2 = this.xmax, y2 = y02 + (t = c2) * vy;
      } else if (vx < 0) {
        if (x02 <= this.xmin)
          return null;
        if ((c2 = (this.xmin - x02) / vx) < t)
          x2 = this.xmin, y2 = y02 + (t = c2) * vy;
      }
      return [x2, y2];
    }
    _edgecode(x2, y2) {
      return (x2 === this.xmin ? 1 : x2 === this.xmax ? 2 : 0) | (y2 === this.ymin ? 4 : y2 === this.ymax ? 8 : 0);
    }
    _regioncode(x2, y2) {
      return (x2 < this.xmin ? 1 : x2 > this.xmax ? 2 : 0) | (y2 < this.ymin ? 4 : y2 > this.ymax ? 8 : 0);
    }
  }
  const tau$2 = 2 * Math.PI, pow$2 = Math.pow;
  function pointX(p) {
    return p[0];
  }
  function pointY(p) {
    return p[1];
  }
  function collinear(d) {
    const { triangles, coords } = d;
    for (let i = 0; i < triangles.length; i += 3) {
      const a2 = 2 * triangles[i], b = 2 * triangles[i + 1], c2 = 2 * triangles[i + 2], cross2 = (coords[c2] - coords[a2]) * (coords[b + 1] - coords[a2 + 1]) - (coords[b] - coords[a2]) * (coords[c2 + 1] - coords[a2 + 1]);
      if (cross2 > 1e-10)
        return false;
    }
    return true;
  }
  function jitter(x2, y2, r) {
    return [x2 + Math.sin(x2 + y2) * r, y2 + Math.cos(x2 - y2) * r];
  }
  class Delaunay {
    static from(points, fx = pointX, fy = pointY, that) {
      return new Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
    }
    constructor(points) {
      this._delaunator = new Delaunator(points);
      this.inedges = new Int32Array(points.length / 2);
      this._hullIndex = new Int32Array(points.length / 2);
      this.points = this._delaunator.coords;
      this._init();
    }
    update() {
      this._delaunator.update();
      this._init();
      return this;
    }
    _init() {
      const d = this._delaunator, points = this.points;
      if (d.hull && d.hull.length > 2 && collinear(d)) {
        this.collinear = Int32Array.from({ length: points.length / 2 }, (_2, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
        const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds2 = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds2[3] - bounds2[1], bounds2[2] - bounds2[0]);
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const p = jitter(points[2 * i], points[2 * i + 1], r);
          points[2 * i] = p[0];
          points[2 * i + 1] = p[1];
        }
        this._delaunator = new Delaunator(points);
      } else {
        delete this.collinear;
      }
      const halfedges = this.halfedges = this._delaunator.halfedges;
      const hull2 = this.hull = this._delaunator.hull;
      const triangles = this.triangles = this._delaunator.triangles;
      const inedges = this.inedges.fill(-1);
      const hullIndex = this._hullIndex.fill(-1);
      for (let e = 0, n = halfedges.length; e < n; ++e) {
        const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
        if (halfedges[e] === -1 || inedges[p] === -1)
          inedges[p] = e;
      }
      for (let i = 0, n = hull2.length; i < n; ++i) {
        hullIndex[hull2[i]] = i;
      }
      if (hull2.length <= 2 && hull2.length > 0) {
        this.triangles = new Int32Array(3).fill(-1);
        this.halfedges = new Int32Array(3).fill(-1);
        this.triangles[0] = hull2[0];
        inedges[hull2[0]] = 1;
        if (hull2.length === 2) {
          inedges[hull2[1]] = 0;
          this.triangles[1] = hull2[1];
          this.triangles[2] = hull2[1];
        }
      }
    }
    voronoi(bounds2) {
      return new Voronoi(this, bounds2);
    }
    *neighbors(i) {
      const { inedges, hull: hull2, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
      if (collinear2) {
        const l = collinear2.indexOf(i);
        if (l > 0)
          yield collinear2[l - 1];
        if (l < collinear2.length - 1)
          yield collinear2[l + 1];
        return;
      }
      const e0 = inedges[i];
      if (e0 === -1)
        return;
      let e = e0, p02 = -1;
      do {
        yield p02 = triangles[e];
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i)
          return;
        e = halfedges[e];
        if (e === -1) {
          const p = hull2[(_hullIndex[i] + 1) % hull2.length];
          if (p !== p02)
            yield p;
          return;
        }
      } while (e !== e0);
    }
    find(x2, y2, i = 0) {
      if ((x2 = +x2, x2 !== x2) || (y2 = +y2, y2 !== y2))
        return -1;
      const i0 = i;
      let c2;
      while ((c2 = this._step(i, x2, y2)) >= 0 && c2 !== i && c2 !== i0)
        i = c2;
      return c2;
    }
    _step(i, x2, y2) {
      const { inedges, hull: hull2, _hullIndex, halfedges, triangles, points } = this;
      if (inedges[i] === -1 || !points.length)
        return (i + 1) % (points.length >> 1);
      let c2 = i;
      let dc = pow$2(x2 - points[i * 2], 2) + pow$2(y2 - points[i * 2 + 1], 2);
      const e0 = inedges[i];
      let e = e0;
      do {
        let t = triangles[e];
        const dt = pow$2(x2 - points[t * 2], 2) + pow$2(y2 - points[t * 2 + 1], 2);
        if (dt < dc)
          dc = dt, c2 = t;
        e = e % 3 === 2 ? e - 2 : e + 1;
        if (triangles[e] !== i)
          break;
        e = halfedges[e];
        if (e === -1) {
          e = hull2[(_hullIndex[i] + 1) % hull2.length];
          if (e !== t) {
            if (pow$2(x2 - points[e * 2], 2) + pow$2(y2 - points[e * 2 + 1], 2) < dc)
              return e;
          }
          break;
        }
      } while (e !== e0);
      return c2;
    }
    render(context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      const { points, halfedges, triangles } = this;
      for (let i = 0, n = halfedges.length; i < n; ++i) {
        const j = halfedges[i];
        if (j < i)
          continue;
        const ti = triangles[i] * 2;
        const tj = triangles[j] * 2;
        context.moveTo(points[ti], points[ti + 1]);
        context.lineTo(points[tj], points[tj + 1]);
      }
      this.renderHull(context);
      return buffer2 && buffer2.value();
    }
    renderPoints(context, r) {
      if (r === void 0 && (!context || typeof context.moveTo !== "function"))
        r = context, context = null;
      r = r == void 0 ? 2 : +r;
      const buffer2 = context == null ? context = new Path() : void 0;
      const { points } = this;
      for (let i = 0, n = points.length; i < n; i += 2) {
        const x2 = points[i], y2 = points[i + 1];
        context.moveTo(x2 + r, y2);
        context.arc(x2, y2, r, 0, tau$2);
      }
      return buffer2 && buffer2.value();
    }
    renderHull(context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      const { hull: hull2, points } = this;
      const h = hull2[0] * 2, n = hull2.length;
      context.moveTo(points[h], points[h + 1]);
      for (let i = 1; i < n; ++i) {
        const h2 = 2 * hull2[i];
        context.lineTo(points[h2], points[h2 + 1]);
      }
      context.closePath();
      return buffer2 && buffer2.value();
    }
    hullPolygon() {
      const polygon = new Polygon();
      this.renderHull(polygon);
      return polygon.value();
    }
    renderTriangle(i, context) {
      const buffer2 = context == null ? context = new Path() : void 0;
      const { points, triangles } = this;
      const t02 = triangles[i *= 3] * 2;
      const t12 = triangles[i + 1] * 2;
      const t22 = triangles[i + 2] * 2;
      context.moveTo(points[t02], points[t02 + 1]);
      context.lineTo(points[t12], points[t12 + 1]);
      context.lineTo(points[t22], points[t22 + 1]);
      context.closePath();
      return buffer2 && buffer2.value();
    }
    *trianglePolygons() {
      const { triangles } = this;
      for (let i = 0, n = triangles.length / 3; i < n; ++i) {
        yield this.trianglePolygon(i);
      }
    }
    trianglePolygon(i) {
      const polygon = new Polygon();
      this.renderTriangle(i, polygon);
      return polygon.value();
    }
  }
  function flatArray(points, fx, fy, that) {
    const n = points.length;
    const array2 = new Float64Array(n * 2);
    for (let i = 0; i < n; ++i) {
      const p = points[i];
      array2[i * 2] = fx.call(that, p, i, points);
      array2[i * 2 + 1] = fy.call(that, p, i, points);
    }
    return array2;
  }
  function* flatIterable(points, fx, fy, that) {
    let i = 0;
    for (const p of points) {
      yield fx.call(that, p, i, points);
      yield fy.call(that, p, i, points);
      ++i;
    }
  }
  var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name2, i) {
      return JSON.stringify(name2) + ": d[" + i + '] || ""';
    }).join(",") + "}");
  }
  function customConverter(columns, f) {
    var object2 = objectConverter(columns);
    return function(row, i) {
      return f(object2(row), i, columns);
    };
  }
  function inferColumns(rows) {
    var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
    rows.forEach(function(row) {
      for (var column2 in row) {
        if (!(column2 in columnSet)) {
          columns.push(columnSet[column2] = column2);
        }
      }
    });
    return columns;
  }
  function pad$1(value, width2) {
    var s2 = value + "", length2 = s2.length;
    return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s2 : s2;
  }
  function formatYear$1(year2) {
    return year2 < 0 ? "-" + pad$1(-year2, 6) : year2 > 9999 ? "+" + pad$1(year2, 6) : pad$1(year2, 4);
  }
  function formatDate(date2) {
    var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
    return isNaN(date2) ? "Invalid Date" : formatYear$1(date2.getUTCFullYear()) + "-" + pad$1(date2.getUTCMonth() + 1, 2) + "-" + pad$1(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "." + pad$1(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + "Z" : "");
  }
  function dsvFormat(delimiter2) {
    var reFormat = new RegExp('["' + delimiter2 + "\n\r]"), DELIMITER = delimiter2.charCodeAt(0);
    function parse2(text2, f) {
      var convert, columns, rows = parseRows(text2, function(row, i) {
        if (convert)
          return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }
    function parseRows(text2, f) {
      var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
      if (text2.charCodeAt(N - 1) === NEWLINE)
        --N;
      if (text2.charCodeAt(N - 1) === RETURN)
        --N;
      function token2() {
        if (eof)
          return EOF;
        if (eol)
          return eol = false, EOL;
        var i, j = I, c2;
        if (text2.charCodeAt(j) === QUOTE) {
          while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
            ;
          if ((i = I) >= N)
            eof = true;
          else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
            eol = true;
          else if (c2 === RETURN) {
            eol = true;
            if (text2.charCodeAt(I) === NEWLINE)
              ++I;
          }
          return text2.slice(j + 1, i - 1).replace(/""/g, '"');
        }
        while (I < N) {
          if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
            eol = true;
          else if (c2 === RETURN) {
            eol = true;
            if (text2.charCodeAt(I) === NEWLINE)
              ++I;
          } else if (c2 !== DELIMITER)
            continue;
          return text2.slice(j, i);
        }
        return eof = true, text2.slice(j, N);
      }
      while ((t = token2()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF)
          row.push(t), t = token2();
        if (f && (row = f(row, n++)) == null)
          continue;
        rows.push(row);
      }
      return rows;
    }
    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column2) {
          return formatValue(row[column2]);
        }).join(delimiter2);
      });
    }
    function format2(rows, columns) {
      if (columns == null)
        columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter2)].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
      if (columns == null)
        columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }
    function formatRow(row) {
      return row.map(formatValue).join(delimiter2);
    }
    function formatValue(value) {
      return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
    }
    return {
      parse: parse2,
      parseRows,
      format: format2,
      formatBody,
      formatRows,
      formatRow,
      formatValue
    };
  }
  var csv$1 = dsvFormat(",");
  var csvParse = csv$1.parse;
  var csvParseRows = csv$1.parseRows;
  var csvFormat = csv$1.format;
  var csvFormatBody = csv$1.formatBody;
  var csvFormatRows = csv$1.formatRows;
  var csvFormatRow = csv$1.formatRow;
  var csvFormatValue = csv$1.formatValue;
  var tsv$1 = dsvFormat("	");
  var tsvParse = tsv$1.parse;
  var tsvParseRows = tsv$1.parseRows;
  var tsvFormat = tsv$1.format;
  var tsvFormatBody = tsv$1.formatBody;
  var tsvFormatRows = tsv$1.formatRows;
  var tsvFormatRow = tsv$1.formatRow;
  var tsvFormatValue = tsv$1.formatValue;
  function autoType(object2) {
    for (var key in object2) {
      var value = object2[key].trim(), number3, m2;
      if (!value)
        value = null;
      else if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      else if (value === "NaN")
        value = NaN;
      else if (!isNaN(number3 = +value))
        value = number3;
      else if (m2 = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m2[4] && !m2[7])
          value = value.replace(/-/g, "/").replace(/T/, " ");
        value = new Date(value);
      } else
        continue;
      object2[key] = value;
    }
    return object2;
  }
  const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
  function responseBlob(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    return response.blob();
  }
  function blob(input, init2) {
    return fetch(input, init2).then(responseBlob);
  }
  function responseArrayBuffer(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    return response.arrayBuffer();
  }
  function buffer(input, init2) {
    return fetch(input, init2).then(responseArrayBuffer);
  }
  function responseText(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    return response.text();
  }
  function text$1(input, init2) {
    return fetch(input, init2).then(responseText);
  }
  function dsvParse(parse2) {
    return function(input, init2, row) {
      if (arguments.length === 2 && typeof init2 === "function")
        row = init2, init2 = void 0;
      return text$1(input, init2).then(function(response) {
        return parse2(response, row);
      });
    };
  }
  function dsv(delimiter2, input, init2, row) {
    if (arguments.length === 3 && typeof init2 === "function")
      row = init2, init2 = void 0;
    var format2 = dsvFormat(delimiter2);
    return text$1(input, init2).then(function(response) {
      return format2.parse(response, row);
    });
  }
  var csv = dsvParse(csvParse);
  var tsv = dsvParse(tsvParse);
  function image(input, init2) {
    return new Promise(function(resolve, reject) {
      var image2 = new Image();
      for (var key in init2)
        image2[key] = init2[key];
      image2.onerror = reject;
      image2.onload = function() {
        resolve(image2);
      };
      image2.src = input;
    });
  }
  function responseJson(response) {
    if (!response.ok)
      throw new Error(response.status + " " + response.statusText);
    if (response.status === 204 || response.status === 205)
      return;
    return response.json();
  }
  function json$1(input, init2) {
    return fetch(input, init2).then(responseJson);
  }
  function parser$c(type2) {
    return (input, init2) => text$1(input, init2).then((text2) => new DOMParser().parseFromString(text2, type2));
  }
  const xml$1 = parser$c("application/xml");
  var html$2 = parser$c("text/html");
  var svg$2 = parser$c("image/svg+xml");
  function center(x2, y2) {
    var nodes, strength = 1;
    if (x2 == null)
      x2 = 0;
    if (y2 == null)
      y2 = 0;
    function force() {
      var i, n = nodes.length, node2, sx = 0, sy = 0;
      for (i = 0; i < n; ++i) {
        node2 = nodes[i], sx += node2.x, sy += node2.y;
      }
      for (sx = (sx / n - x2) * strength, sy = (sy / n - y2) * strength, i = 0; i < n; ++i) {
        node2 = nodes[i], node2.x -= sx, node2.y -= sy;
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
    };
    force.x = function(_2) {
      return arguments.length ? (x2 = +_2, force) : x2;
    };
    force.y = function(_2) {
      return arguments.length ? (y2 = +_2, force) : y2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    return force;
  }
  function tree_add(d) {
    const x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
    return add(this.cover(x2, y2), x2, y2, d);
  }
  function add(tree2, x2, y2, d) {
    if (isNaN(x2) || isNaN(y2))
      return tree2;
    var parent, node2 = tree2._root, leaf = { data: d }, x02 = tree2._x0, y02 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;
    if (!node2)
      return tree2._root = leaf, tree2;
    while (node2.length) {
      if (right2 = x2 >= (xm = (x02 + x12) / 2))
        x02 = xm;
      else
        x12 = xm;
      if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
        y02 = ym;
      else
        y12 = ym;
      if (parent = node2, !(node2 = node2[i = bottom2 << 1 | right2]))
        return parent[i] = leaf, tree2;
    }
    xp = +tree2._x.call(null, node2.data);
    yp = +tree2._y.call(null, node2.data);
    if (x2 === xp && y2 === yp)
      return leaf.next = node2, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
    do {
      parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
      if (right2 = x2 >= (xm = (x02 + x12) / 2))
        x02 = xm;
      else
        x12 = xm;
      if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
        y02 = ym;
      else
        y12 = ym;
    } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node2, parent[i] = leaf, tree2;
  }
  function addAll(data) {
    var d, i, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
    for (i = 0; i < n; ++i) {
      if (isNaN(x2 = +this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d)))
        continue;
      xz[i] = x2;
      yz[i] = y2;
      if (x2 < x02)
        x02 = x2;
      if (x2 > x12)
        x12 = x2;
      if (y2 < y02)
        y02 = y2;
      if (y2 > y12)
        y12 = y2;
    }
    if (x02 > x12 || y02 > y12)
      return this;
    this.cover(x02, y02).cover(x12, y12);
    for (i = 0; i < n; ++i) {
      add(this, xz[i], yz[i], data[i]);
    }
    return this;
  }
  function tree_cover(x2, y2) {
    if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
      return this;
    var x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1;
    if (isNaN(x02)) {
      x12 = (x02 = Math.floor(x2)) + 1;
      y12 = (y02 = Math.floor(y2)) + 1;
    } else {
      var z = x12 - x02 || 1, node2 = this._root, parent, i;
      while (x02 > x2 || x2 >= x12 || y02 > y2 || y2 >= y12) {
        i = (y2 < y02) << 1 | x2 < x02;
        parent = new Array(4), parent[i] = node2, node2 = parent, z *= 2;
        switch (i) {
          case 0:
            x12 = x02 + z, y12 = y02 + z;
            break;
          case 1:
            x02 = x12 - z, y12 = y02 + z;
            break;
          case 2:
            x12 = x02 + z, y02 = y12 - z;
            break;
          case 3:
            x02 = x12 - z, y02 = y12 - z;
            break;
        }
      }
      if (this._root && this._root.length)
        this._root = node2;
    }
    this._x0 = x02;
    this._y0 = y02;
    this._x1 = x12;
    this._y1 = y12;
    return this;
  }
  function tree_data() {
    var data = [];
    this.visit(function(node2) {
      if (!node2.length)
        do
          data.push(node2.data);
        while (node2 = node2.next);
    });
    return data;
  }
  function tree_extent(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }
  function Quad(node2, x02, y02, x12, y12) {
    this.node = node2;
    this.x0 = x02;
    this.y0 = y02;
    this.x1 = x12;
    this.y1 = y12;
  }
  function tree_find(x2, y2, radius) {
    var data, x02 = this._x0, y02 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node2 = this._root, q, i;
    if (node2)
      quads.push(new Quad(node2, x02, y02, x3, y3));
    if (radius == null)
      radius = Infinity;
    else {
      x02 = x2 - radius, y02 = y2 - radius;
      x3 = x2 + radius, y3 = y2 + radius;
      radius *= radius;
    }
    while (q = quads.pop()) {
      if (!(node2 = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x02 || (y22 = q.y1) < y02)
        continue;
      if (node2.length) {
        var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
        quads.push(
          new Quad(node2[3], xm, ym, x22, y22),
          new Quad(node2[2], x12, ym, xm, y22),
          new Quad(node2[1], xm, y12, x22, ym),
          new Quad(node2[0], x12, y12, xm, ym)
        );
        if (i = (y2 >= ym) << 1 | x2 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x2 - +this._x.call(null, node2.data), dy = y2 - +this._y.call(null, node2.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x02 = x2 - d, y02 = y2 - d;
          x3 = x2 + d, y3 = y2 + d;
          data = node2.data;
        }
      }
    }
    return data;
  }
  function tree_remove(d) {
    if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
      return this;
    var parent, node2 = this._root, retainer, previous, next2, x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right2, bottom2, i, j;
    if (!node2)
      return this;
    if (node2.length)
      while (true) {
        if (right2 = x2 >= (xm = (x02 + x12) / 2))
          x02 = xm;
        else
          x12 = xm;
        if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
          y02 = ym;
        else
          y12 = ym;
        if (!(parent = node2, node2 = node2[i = bottom2 << 1 | right2]))
          return this;
        if (!node2.length)
          break;
        if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
          retainer = parent, j = i;
      }
    while (node2.data !== d)
      if (!(previous = node2, node2 = node2.next))
        return this;
    if (next2 = node2.next)
      delete node2.next;
    if (previous)
      return next2 ? previous.next = next2 : delete previous.next, this;
    if (!parent)
      return this._root = next2, this;
    next2 ? parent[i] = next2 : delete parent[i];
    if ((node2 = parent[0] || parent[1] || parent[2] || parent[3]) && node2 === (parent[3] || parent[2] || parent[1] || parent[0]) && !node2.length) {
      if (retainer)
        retainer[j] = node2;
      else
        this._root = node2;
    }
    return this;
  }
  function removeAll(data) {
    for (var i = 0, n = data.length; i < n; ++i)
      this.remove(data[i]);
    return this;
  }
  function tree_root() {
    return this._root;
  }
  function tree_size() {
    var size = 0;
    this.visit(function(node2) {
      if (!node2.length)
        do
          ++size;
        while (node2 = node2.next);
    });
    return size;
  }
  function tree_visit(callback) {
    var quads = [], q, node2 = this._root, child, x02, y02, x12, y12;
    if (node2)
      quads.push(new Quad(node2, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node2 = q.node, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1) && node2.length) {
        var xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
        if (child = node2[3])
          quads.push(new Quad(child, xm, ym, x12, y12));
        if (child = node2[2])
          quads.push(new Quad(child, x02, ym, xm, y12));
        if (child = node2[1])
          quads.push(new Quad(child, xm, y02, x12, ym));
        if (child = node2[0])
          quads.push(new Quad(child, x02, y02, xm, ym));
      }
    }
    return this;
  }
  function tree_visitAfter(callback) {
    var quads = [], next2 = [], q;
    if (this._root)
      quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node2 = q.node;
      if (node2.length) {
        var child, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
        if (child = node2[0])
          quads.push(new Quad(child, x02, y02, xm, ym));
        if (child = node2[1])
          quads.push(new Quad(child, xm, y02, x12, ym));
        if (child = node2[2])
          quads.push(new Quad(child, x02, ym, xm, y12));
        if (child = node2[3])
          quads.push(new Quad(child, xm, ym, x12, y12));
      }
      next2.push(q);
    }
    while (q = next2.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }
  function defaultX(d) {
    return d[0];
  }
  function tree_x(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }
  function defaultY(d) {
    return d[1];
  }
  function tree_y(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }
  function quadtree(nodes, x2, y2) {
    var tree2 = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
    return nodes == null ? tree2 : tree2.addAll(nodes);
  }
  function Quadtree(x2, y2, x02, y02, x12, y12) {
    this._x = x2;
    this._y = y2;
    this._x0 = x02;
    this._y0 = y02;
    this._x1 = x12;
    this._y1 = y12;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy2 = { data: leaf.data }, next2 = copy2;
    while (leaf = leaf.next)
      next2 = next2.next = { data: leaf.data };
    return copy2;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node2 = this._root, nodes, child;
    if (!node2)
      return copy2;
    if (!node2.length)
      return copy2._root = leaf_copy(node2), copy2;
    nodes = [{ source: node2, target: copy2._root = new Array(4) }];
    while (node2 = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node2.source[i]) {
          if (child.length)
            nodes.push({ source: child, target: node2.target[i] = new Array(4) });
          else
            node2.target[i] = leaf_copy(child);
        }
      }
    }
    return copy2;
  };
  treeProto.add = tree_add;
  treeProto.addAll = addAll;
  treeProto.cover = tree_cover;
  treeProto.data = tree_data;
  treeProto.extent = tree_extent;
  treeProto.find = tree_find;
  treeProto.remove = tree_remove;
  treeProto.removeAll = removeAll;
  treeProto.root = tree_root;
  treeProto.size = tree_size;
  treeProto.visit = tree_visit;
  treeProto.visitAfter = tree_visitAfter;
  treeProto.x = tree_x;
  treeProto.y = tree_y;
  function constant$4(x2) {
    return function() {
      return x2;
    };
  }
  function jiggle(random2) {
    return (random2() - 0.5) * 1e-6;
  }
  function x$4(d) {
    return d.x + d.vx;
  }
  function y$3(d) {
    return d.y + d.vy;
  }
  function collide(radius) {
    var nodes, radii, random2, strength = 1, iterations2 = 1;
    if (typeof radius !== "function")
      radius = constant$4(radius == null ? 1 : +radius);
    function force() {
      var i, n = nodes.length, tree2, node2, xi, yi, ri, ri2;
      for (var k2 = 0; k2 < iterations2; ++k2) {
        tree2 = quadtree(nodes, x$4, y$3).visitAfter(prepare);
        for (i = 0; i < n; ++i) {
          node2 = nodes[i];
          ri = radii[node2.index], ri2 = ri * ri;
          xi = node2.x + node2.vx;
          yi = node2.y + node2.vy;
          tree2.visit(apply2);
        }
      }
      function apply2(quad, x02, y02, x12, y12) {
        var data = quad.data, rj = quad.r, r = ri + rj;
        if (data) {
          if (data.index > node2.index) {
            var x2 = xi - data.x - data.vx, y2 = yi - data.y - data.vy, l = x2 * x2 + y2 * y2;
            if (l < r * r) {
              if (x2 === 0)
                x2 = jiggle(random2), l += x2 * x2;
              if (y2 === 0)
                y2 = jiggle(random2), l += y2 * y2;
              l = (r - (l = Math.sqrt(l))) / l * strength;
              node2.vx += (x2 *= l) * (r = (rj *= rj) / (ri2 + rj));
              node2.vy += (y2 *= l) * r;
              data.vx -= x2 * (r = 1 - r);
              data.vy -= y2 * r;
            }
          }
          return;
        }
        return x02 > xi + r || x12 < xi - r || y02 > yi + r || y12 < yi - r;
      }
    }
    function prepare(quad) {
      if (quad.data)
        return quad.r = radii[quad.data.index];
      for (var i = quad.r = 0; i < 4; ++i) {
        if (quad[i] && quad[i].r > quad.r) {
          quad.r = quad[i].r;
        }
      }
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length, node2;
      radii = new Array(n);
      for (i = 0; i < n; ++i)
        node2 = nodes[i], radii[node2.index] = +radius(node2, i, nodes);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random2 = _random;
      initialize2();
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, force) : iterations2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : radius;
    };
    return force;
  }
  function index$3(d) {
    return d.index;
  }
  function find(nodeById, nodeId) {
    var node2 = nodeById.get(nodeId);
    if (!node2)
      throw new Error("node not found: " + nodeId);
    return node2;
  }
  function link$2(links2) {
    var id2 = index$3, strength = defaultStrength, strengths, distance2 = constant$4(30), distances, nodes, count2, bias, random2, iterations2 = 1;
    if (links2 == null)
      links2 = [];
    function defaultStrength(link2) {
      return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
    }
    function force(alpha) {
      for (var k2 = 0, n = links2.length; k2 < iterations2; ++k2) {
        for (var i = 0, link2, source, target, x2, y2, l, b; i < n; ++i) {
          link2 = links2[i], source = link2.source, target = link2.target;
          x2 = target.x + target.vx - source.x - source.vx || jiggle(random2);
          y2 = target.y + target.vy - source.y - source.vy || jiggle(random2);
          l = Math.sqrt(x2 * x2 + y2 * y2);
          l = (l - distances[i]) / l * alpha * strengths[i];
          x2 *= l, y2 *= l;
          target.vx -= x2 * (b = bias[i]);
          target.vy -= y2 * b;
          source.vx += x2 * (b = 1 - b);
          source.vy += y2 * b;
        }
      }
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length, m2 = links2.length, nodeById = new Map(nodes.map((d, i2) => [id2(d, i2, nodes), d])), link2;
      for (i = 0, count2 = new Array(n); i < m2; ++i) {
        link2 = links2[i], link2.index = i;
        if (typeof link2.source !== "object")
          link2.source = find(nodeById, link2.source);
        if (typeof link2.target !== "object")
          link2.target = find(nodeById, link2.target);
        count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
        count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m2); i < m2; ++i) {
        link2 = links2[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
      }
      strengths = new Array(m2), initializeStrength();
      distances = new Array(m2), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes)
        return;
      for (var i = 0, n = links2.length; i < n; ++i) {
        strengths[i] = +strength(links2[i], i, links2);
      }
    }
    function initializeDistance() {
      if (!nodes)
        return;
      for (var i = 0, n = links2.length; i < n; ++i) {
        distances[i] = +distance2(links2[i], i, links2);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random2 = _random;
      initialize2();
    };
    force.links = function(_2) {
      return arguments.length ? (links2 = _2, initialize2(), force) : links2;
    };
    force.id = function(_2) {
      return arguments.length ? (id2 = _2, force) : id2;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, force) : iterations2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$4(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant$4(+_2), initializeDistance(), force) : distance2;
    };
    return force;
  }
  const a$2 = 1664525;
  const c$5 = 1013904223;
  const m$1 = 4294967296;
  function lcg$2() {
    let s2 = 1;
    return () => (s2 = (a$2 * s2 + c$5) % m$1) / m$1;
  }
  function x$3(d) {
    return d.x;
  }
  function y$2(d) {
    return d.y;
  }
  var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation(nodes) {
    var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step), event = dispatch("tick", "end"), random2 = lcg$2();
    if (nodes == null)
      nodes = [];
    function step() {
      tick();
      event.call("tick", simulation2);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation2);
      }
    }
    function tick(iterations2) {
      var i, n = nodes.length, node2;
      if (iterations2 === void 0)
        iterations2 = 1;
      for (var k2 = 0; k2 < iterations2; ++k2) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n; ++i) {
          node2 = nodes[i];
          if (node2.fx == null)
            node2.x += node2.vx *= velocityDecay;
          else
            node2.x = node2.fx, node2.vx = 0;
          if (node2.fy == null)
            node2.y += node2.vy *= velocityDecay;
          else
            node2.y = node2.fy, node2.vy = 0;
        }
      }
      return simulation2;
    }
    function initializeNodes() {
      for (var i = 0, n = nodes.length, node2; i < n; ++i) {
        node2 = nodes[i], node2.index = i;
        if (node2.fx != null)
          node2.x = node2.fx;
        if (node2.fy != null)
          node2.y = node2.fy;
        if (isNaN(node2.x) || isNaN(node2.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle2 = i * initialAngle;
          node2.x = radius * Math.cos(angle2);
          node2.y = radius * Math.sin(angle2);
        }
        if (isNaN(node2.vx) || isNaN(node2.vy)) {
          node2.vx = node2.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize)
        force.initialize(nodes, random2);
      return force;
    }
    initializeNodes();
    return simulation2 = {
      tick,
      restart: function() {
        return stepper.restart(step), simulation2;
      },
      stop: function() {
        return stepper.stop(), simulation2;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation2) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation2) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation2) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation2) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation2) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation2) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random2 = _2, forces.forEach(initializeForce), simulation2) : random2;
      },
      force: function(name2, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation2) : forces.get(name2);
      },
      find: function(x2, y2, radius) {
        var i = 0, n = nodes.length, dx, dy, d2, node2, closest;
        if (radius == null)
          radius = Infinity;
        else
          radius *= radius;
        for (i = 0; i < n; ++i) {
          node2 = nodes[i];
          dx = x2 - node2.x;
          dy = y2 - node2.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius)
            closest = node2, radius = d2;
        }
        return closest;
      },
      on: function(name2, _2) {
        return arguments.length > 1 ? (event.on(name2, _2), simulation2) : event.on(name2);
      }
    };
  }
  function manyBody() {
    var nodes, node2, random2, alpha, strength = constant$4(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_2) {
      var i, n = nodes.length, tree2 = quadtree(nodes, x$3, y$2).visitAfter(accumulate);
      for (alpha = _2, i = 0; i < n; ++i)
        node2 = nodes[i], tree2.visit(apply2);
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length, node3;
      strengths = new Array(n);
      for (i = 0; i < n; ++i)
        node3 = nodes[i], strengths[node3.index] = +strength(node3, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q, c2, weight = 0, x2, y2, i;
      if (quad.length) {
        for (x2 = y2 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
            strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
          }
        }
        quad.x = x2 / weight;
        quad.y = y2 / weight;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply2(quad, x12, _2, x2) {
      if (!quad.value)
        return true;
      var x3 = quad.x - node2.x, y2 = quad.y - node2.y, w2 = x2 - x12, l = x3 * x3 + y2 * y2;
      if (w2 * w2 / theta2 < l) {
        if (l < distanceMax2) {
          if (x3 === 0)
            x3 = jiggle(random2), l += x3 * x3;
          if (y2 === 0)
            y2 = jiggle(random2), l += y2 * y2;
          if (l < distanceMin2)
            l = Math.sqrt(distanceMin2 * l);
          node2.vx += x3 * quad.value * alpha / l;
          node2.vy += y2 * quad.value * alpha / l;
        }
        return true;
      } else if (quad.length || l >= distanceMax2)
        return;
      if (quad.data !== node2 || quad.next) {
        if (x3 === 0)
          x3 = jiggle(random2), l += x3 * x3;
        if (y2 === 0)
          y2 = jiggle(random2), l += y2 * y2;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
      }
      do
        if (quad.data !== node2) {
          w2 = strengths[quad.data.index] * alpha / l;
          node2.vx += x3 * w2;
          node2.vy += y2 * w2;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random2 = _random;
      initialize2();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
    };
    return force;
  }
  function radial$1(radius, x2, y2) {
    var nodes, strength = constant$4(0.1), strengths, radiuses;
    if (typeof radius !== "function")
      radius = constant$4(+radius);
    if (x2 == null)
      x2 = 0;
    if (y2 == null)
      y2 = 0;
    function force(alpha) {
      for (var i = 0, n = nodes.length; i < n; ++i) {
        var node2 = nodes[i], dx = node2.x - x2 || 1e-6, dy = node2.y - y2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;
        node2.vx += dx * k2;
        node2.vy += dy * k2;
      }
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      radiuses = new Array(n);
      for (i = 0; i < n; ++i) {
        radiuses[i] = +radius(nodes[i], i, nodes);
        strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2, initialize2();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : strength;
    };
    force.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : radius;
    };
    force.x = function(_2) {
      return arguments.length ? (x2 = +_2, force) : x2;
    };
    force.y = function(_2) {
      return arguments.length ? (y2 = +_2, force) : y2;
    };
    return force;
  }
  function x$2(x2) {
    var strength = constant$4(0.1), nodes, strengths, xz;
    if (typeof x2 !== "function")
      x2 = constant$4(x2 == null ? 0 : +x2);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node2; i < n; ++i) {
        node2 = nodes[i], node2.vx += (xz[i] - node2.x) * strengths[i] * alpha;
      }
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      xz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize2();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : strength;
    };
    force.x = function(_2) {
      return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : x2;
    };
    return force;
  }
  function y$1(y2) {
    var strength = constant$4(0.1), nodes, strengths, yz;
    if (typeof y2 !== "function")
      y2 = constant$4(y2 == null ? 0 : +y2);
    function force(alpha) {
      for (var i = 0, n = nodes.length, node2; i < n; ++i) {
        node2 = nodes[i], node2.vy += (yz[i] - node2.y) * strengths[i] * alpha;
      }
    }
    function initialize2() {
      if (!nodes)
        return;
      var i, n = nodes.length;
      strengths = new Array(n);
      yz = new Array(n);
      for (i = 0; i < n; ++i) {
        strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize2();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : strength;
    };
    force.y = function(_2) {
      return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$4(+_2), initialize2(), force) : y2;
    };
    return force;
  }
  function formatDecimal(x2) {
    return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
  }
  function formatDecimalParts(x2, p) {
    if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x2.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x2.slice(i + 1)
    ];
  }
  function exponent(x2) {
    return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
  }
  function formatGroup(grouping, thousands) {
    return function(value, width2) {
      var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
      while (i > 0 && g > 0) {
        if (length2 + g + 1 > width2)
          g = Math.max(1, width2 - length2);
        t.push(value.substring(i -= g, i + g));
        if ((length2 += g + 1) > width2)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }
  function formatNumerals(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function formatTrim(s2) {
    out:
      for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s2[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s2[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }
  var prefixExponent;
  function formatPrefixAuto(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
  }
  function formatRounded(x2, p) {
    var d = formatDecimalParts(x2, p);
    if (!d)
      return x2 + "";
    var coefficient = d[0], exponent2 = d[1];
    return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
  }
  const formatTypes = {
    "%": (x2, p) => (x2 * 100).toFixed(p),
    "b": (x2) => Math.round(x2).toString(2),
    "c": (x2) => x2 + "",
    "d": formatDecimal,
    "e": (x2, p) => x2.toExponential(p),
    "f": (x2, p) => x2.toFixed(p),
    "g": (x2, p) => x2.toPrecision(p),
    "o": (x2) => Math.round(x2).toString(8),
    "p": (x2, p) => formatRounded(x2 * 100, p),
    "r": formatRounded,
    "s": formatPrefixAuto,
    "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
    "x": (x2) => Math.round(x2).toString(16)
  };
  function identity$6(x2) {
    return x2;
  }
  var map = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function formatLocale$1(locale2) {
    var group2 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$6 : formatGroup(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$6 : formatNumerals(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
      if (type2 === "n")
        comma = true, type2 = "g";
      else if (!formatTypes[type2])
        precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
      if (zero2 || fill === "0" && align === "=")
        zero2 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c2;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim2)
            value = formatTrim(value);
          if (valueNegative && +value === 0 && sign2 !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
                valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero2)
          value = group2(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
        if (comma && zero2)
          value = group2(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding2;
            break;
          case "=":
            value = valuePrefix + padding2 + value + valueSuffix;
            break;
          case "^":
            value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
            break;
          default:
            value = padding2 + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k2 * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }
  var locale$1;
  var format;
  var formatPrefix;
  defaultLocale$1({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale$1(definition) {
    locale$1 = formatLocale$1(definition);
    format = locale$1.format;
    formatPrefix = locale$1.formatPrefix;
    return locale$1;
  }
  function precisionFixed(step) {
    return Math.max(0, -exponent(Math.abs(step)));
  }
  function precisionPrefix(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
  }
  function precisionRound(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent(max2) - exponent(step)) + 1;
  }
  var epsilon$1 = 1e-6;
  var epsilon2 = 1e-12;
  var pi$1 = Math.PI;
  var halfPi$1 = pi$1 / 2;
  var quarterPi = pi$1 / 4;
  var tau$1 = pi$1 * 2;
  var degrees = 180 / pi$1;
  var radians = pi$1 / 180;
  var abs$2 = Math.abs;
  var atan = Math.atan;
  var atan2$1 = Math.atan2;
  var cos$1 = Math.cos;
  var ceil = Math.ceil;
  var exp = Math.exp;
  var hypot = Math.hypot;
  var log$2 = Math.log;
  var pow$1 = Math.pow;
  var sin$1 = Math.sin;
  var sign$1 = Math.sign || function(x2) {
    return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
  };
  var sqrt$2 = Math.sqrt;
  var tan = Math.tan;
  function acos$1(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
  }
  function asin$1(x2) {
    return x2 > 1 ? halfPi$1 : x2 < -1 ? -halfPi$1 : Math.asin(x2);
  }
  function haversin(x2) {
    return (x2 = sin$1(x2 / 2)) * x2;
  }
  function noop$1() {
  }
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object2, stream) {
      streamGeometry(object2.geometry, stream);
    },
    FeatureCollection: function(object2, stream) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n)
        streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object2, stream) {
      stream.sphere();
    },
    Point: function(object2, stream) {
      object2 = object2.coordinates;
      stream.point(object2[0], object2[1], object2[2]);
    },
    MultiPoint: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
    },
    LineString: function(object2, stream) {
      streamLine(object2.coordinates, stream, 0);
    },
    MultiLineString: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        streamLine(coordinates2[i], stream, 0);
    },
    Polygon: function(object2, stream) {
      streamPolygon(object2.coordinates, stream);
    },
    MultiPolygon: function(object2, stream) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        streamPolygon(coordinates2[i], stream);
    },
    GeometryCollection: function(object2, stream) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n)
        streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates2, stream, closed) {
    var i = -1, n = coordinates2.length - closed, coordinate;
    stream.lineStart();
    while (++i < n)
      coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates2, stream) {
    var i = -1, n = coordinates2.length;
    stream.polygonStart();
    while (++i < n)
      streamLine(coordinates2[i], stream, 1);
    stream.polygonEnd();
  }
  function geoStream(object2, stream) {
    if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
      streamObjectType[object2.type](object2, stream);
    } else {
      streamGeometry(object2, stream);
    }
  }
  var areaRingSum$1 = new Adder();
  var areaSum$1 = new Adder(), lambda00$2, phi00$2, lambda0$2, cosPhi0$1, sinPhi0$1;
  var areaStream$1 = {
    point: noop$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: function() {
      areaRingSum$1 = new Adder();
      areaStream$1.lineStart = areaRingStart$1;
      areaStream$1.lineEnd = areaRingEnd$1;
    },
    polygonEnd: function() {
      var areaRing = +areaRingSum$1;
      areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
      this.lineStart = this.lineEnd = this.point = noop$1;
    },
    sphere: function() {
      areaSum$1.add(tau$1);
    }
  };
  function areaRingStart$1() {
    areaStream$1.point = areaPointFirst$1;
  }
  function areaRingEnd$1() {
    areaPoint$1(lambda00$2, phi00$2);
  }
  function areaPointFirst$1(lambda, phi2) {
    areaStream$1.point = areaPoint$1;
    lambda00$2 = lambda, phi00$2 = phi2;
    lambda *= radians, phi2 *= radians;
    lambda0$2 = lambda, cosPhi0$1 = cos$1(phi2 = phi2 / 2 + quarterPi), sinPhi0$1 = sin$1(phi2);
  }
  function areaPoint$1(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    phi2 = phi2 / 2 + quarterPi;
    var dLambda = lambda - lambda0$2, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$1(phi2), sinPhi = sin$1(phi2), k2 = sinPhi0$1 * sinPhi, u2 = cosPhi0$1 * cosPhi + k2 * cos$1(adLambda), v = k2 * sdLambda * sin$1(adLambda);
    areaRingSum$1.add(atan2$1(v, u2));
    lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
  }
  function area$2(object2) {
    areaSum$1 = new Adder();
    geoStream(object2, areaStream$1);
    return areaSum$1 * 2;
  }
  function spherical(cartesian2) {
    return [atan2$1(cartesian2[1], cartesian2[0]), asin$1(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos$1(phi2);
    return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2)];
  }
  function cartesianDot(a2, b) {
    return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
  }
  function cartesianCross(a2, b) {
    return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
  }
  function cartesianAddInPlace(a2, b) {
    a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
  }
  function cartesianScale(vector, k2) {
    return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }
  var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum, ranges, range;
  var boundsStream$2 = {
    point: boundsPoint$1,
    lineStart: boundsLineStart,
    lineEnd: boundsLineEnd,
    polygonStart: function() {
      boundsStream$2.point = boundsRingPoint;
      boundsStream$2.lineStart = boundsRingStart;
      boundsStream$2.lineEnd = boundsRingEnd;
      deltaSum = new Adder();
      areaStream$1.polygonStart();
    },
    polygonEnd: function() {
      areaStream$1.polygonEnd();
      boundsStream$2.point = boundsPoint$1;
      boundsStream$2.lineStart = boundsLineStart;
      boundsStream$2.lineEnd = boundsLineEnd;
      if (areaRingSum$1 < 0)
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      else if (deltaSum > epsilon$1)
        phi1 = 90;
      else if (deltaSum < -epsilon$1)
        phi0 = -90;
      range[0] = lambda0$1, range[1] = lambda1;
    },
    sphere: function() {
      lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    }
  };
  function boundsPoint$1(lambda, phi2) {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
    if (phi2 < phi0)
      phi0 = phi2;
    if (phi2 > phi1)
      phi1 = phi2;
  }
  function linePoint(lambda, phi2) {
    var p = cartesian([lambda * radians, phi2 * radians]);
    if (p0) {
      var normal2 = cartesianCross(p0, p), equatorial = [normal2[1], -normal2[0], 0], inflection = cartesianCross(equatorial, normal2);
      cartesianNormalizeInPlace(inflection);
      inflection = spherical(inflection);
      var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs$2(delta) > 180;
      if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = inflection[1] * degrees;
        if (phii > phi1)
          phi1 = phii;
      } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
        phii = -inflection[1] * degrees;
        if (phii < phi0)
          phi0 = phii;
      } else {
        if (phi2 < phi0)
          phi0 = phi2;
        if (phi2 > phi1)
          phi1 = phi2;
      }
      if (antimeridian) {
        if (lambda < lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
            lambda0$1 = lambda;
        }
      } else {
        if (lambda1 >= lambda0$1) {
          if (lambda < lambda0$1)
            lambda0$1 = lambda;
          if (lambda > lambda1)
            lambda1 = lambda;
        } else {
          if (lambda > lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
              lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
              lambda0$1 = lambda;
          }
        }
      }
    } else {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
    }
    if (phi2 < phi0)
      phi0 = phi2;
    if (phi2 > phi1)
      phi1 = phi2;
    p0 = p, lambda2 = lambda;
  }
  function boundsLineStart() {
    boundsStream$2.point = linePoint;
  }
  function boundsLineEnd() {
    range[0] = lambda0$1, range[1] = lambda1;
    boundsStream$2.point = boundsPoint$1;
    p0 = null;
  }
  function boundsRingPoint(lambda, phi2) {
    if (p0) {
      var delta = lambda - lambda2;
      deltaSum.add(abs$2(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
    } else {
      lambda00$1 = lambda, phi00$1 = phi2;
    }
    areaStream$1.point(lambda, phi2);
    linePoint(lambda, phi2);
  }
  function boundsRingStart() {
    areaStream$1.lineStart();
  }
  function boundsRingEnd() {
    boundsRingPoint(lambda00$1, phi00$1);
    areaStream$1.lineEnd();
    if (abs$2(deltaSum) > epsilon$1)
      lambda0$1 = -(lambda1 = 180);
    range[0] = lambda0$1, range[1] = lambda1;
    p0 = null;
  }
  function angle(lambda02, lambda12) {
    return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
  }
  function rangeCompare(a2, b) {
    return a2[0] - b[0];
  }
  function rangeContains(range2, x2) {
    return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
  }
  function bounds$2(feature) {
    var i, n, a2, b, merged, deltaMax, delta;
    phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
    ranges = [];
    geoStream(feature, boundsStream$2);
    if (n = ranges.length) {
      ranges.sort(rangeCompare);
      for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
        b = ranges[i];
        if (rangeContains(a2, b[0]) || rangeContains(a2, b[1])) {
          if (angle(a2[0], b[1]) > angle(a2[0], a2[1]))
            a2[1] = b[1];
          if (angle(b[0], a2[1]) > angle(a2[0], a2[1]))
            a2[0] = b[0];
        } else {
          merged.push(a2 = b);
        }
      }
      for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b, ++i) {
        b = merged[i];
        if ((delta = angle(a2[1], b[0])) > deltaMax)
          deltaMax = delta, lambda0$1 = b[0], lambda1 = a2[1];
      }
    }
    ranges = range = null;
    return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
  }
  var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$1, Y2$1, Z2$1, lambda00, phi00, x0$4, y0$4, z0;
  var centroidStream$1 = {
    sphere: noop$1,
    point: centroidPoint$1,
    lineStart: centroidLineStart$1,
    lineEnd: centroidLineEnd$1,
    polygonStart: function() {
      centroidStream$1.lineStart = centroidRingStart$1;
      centroidStream$1.lineEnd = centroidRingEnd$1;
    },
    polygonEnd: function() {
      centroidStream$1.lineStart = centroidLineStart$1;
      centroidStream$1.lineEnd = centroidLineEnd$1;
    }
  };
  function centroidPoint$1(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    var cosPhi = cos$1(phi2);
    centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2));
  }
  function centroidPointCartesian(x2, y2, z) {
    ++W0;
    X0$1 += (x2 - X0$1) / W0;
    Y0$1 += (y2 - Y0$1) / W0;
    Z0$1 += (z - Z0$1) / W0;
  }
  function centroidLineStart$1() {
    centroidStream$1.point = centroidLinePointFirst;
  }
  function centroidLinePointFirst(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    var cosPhi = cos$1(phi2);
    x0$4 = cosPhi * cos$1(lambda);
    y0$4 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi2);
    centroidStream$1.point = centroidLinePoint;
    centroidPointCartesian(x0$4, y0$4, z0);
  }
  function centroidLinePoint(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), w2 = atan2$1(sqrt$2((w2 = y0$4 * z - z0 * y2) * w2 + (w2 = z0 * x2 - x0$4 * z) * w2 + (w2 = x0$4 * y2 - y0$4 * x2) * w2), x0$4 * x2 + y0$4 * y2 + z0 * z);
    W1 += w2;
    X1$1 += w2 * (x0$4 + (x0$4 = x2));
    Y1$1 += w2 * (y0$4 + (y0$4 = y2));
    Z1$1 += w2 * (z0 + (z0 = z));
    centroidPointCartesian(x0$4, y0$4, z0);
  }
  function centroidLineEnd$1() {
    centroidStream$1.point = centroidPoint$1;
  }
  function centroidRingStart$1() {
    centroidStream$1.point = centroidRingPointFirst;
  }
  function centroidRingEnd$1() {
    centroidRingPoint(lambda00, phi00);
    centroidStream$1.point = centroidPoint$1;
  }
  function centroidRingPointFirst(lambda, phi2) {
    lambda00 = lambda, phi00 = phi2;
    lambda *= radians, phi2 *= radians;
    centroidStream$1.point = centroidRingPoint;
    var cosPhi = cos$1(phi2);
    x0$4 = cosPhi * cos$1(lambda);
    y0$4 = cosPhi * sin$1(lambda);
    z0 = sin$1(phi2);
    centroidPointCartesian(x0$4, y0$4, z0);
  }
  function centroidRingPoint(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), cx = y0$4 * z - z0 * y2, cy = z0 * x2 - x0$4 * z, cz = x0$4 * y2 - y0$4 * x2, m2 = hypot(cx, cy, cz), w2 = asin$1(m2), v = m2 && -w2 / m2;
    X2$1.add(v * cx);
    Y2$1.add(v * cy);
    Z2$1.add(v * cz);
    W1 += w2;
    X1$1 += w2 * (x0$4 + (x0$4 = x2));
    Y1$1 += w2 * (y0$4 + (y0$4 = y2));
    Z1$1 += w2 * (z0 + (z0 = z));
    centroidPointCartesian(x0$4, y0$4, z0);
  }
  function centroid$1(object2) {
    W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = 0;
    X2$1 = new Adder();
    Y2$1 = new Adder();
    Z2$1 = new Adder();
    geoStream(object2, centroidStream$1);
    var x2 = +X2$1, y2 = +Y2$1, z = +Z2$1, m2 = hypot(x2, y2, z);
    if (m2 < epsilon2) {
      x2 = X1$1, y2 = Y1$1, z = Z1$1;
      if (W1 < epsilon$1)
        x2 = X0$1, y2 = Y0$1, z = Z0$1;
      m2 = hypot(x2, y2, z);
      if (m2 < epsilon2)
        return [NaN, NaN];
    }
    return [atan2$1(y2, x2) * degrees, asin$1(z / m2) * degrees];
  }
  function constant$3(x2) {
    return function() {
      return x2;
    };
  }
  function compose(a2, b) {
    function compose2(x2, y2) {
      return x2 = a2(x2, y2), b(x2[0], x2[1]);
    }
    if (a2.invert && b.invert)
      compose2.invert = function(x2, y2) {
        return x2 = b.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
      };
    return compose2;
  }
  function rotationIdentity(lambda, phi2) {
    return [abs$2(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi2];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau$1) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi2) {
      return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi2];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation2 = forwardRotationLambda(deltaLambda);
    rotation2.invert = forwardRotationLambda(-deltaLambda);
    return rotation2;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
    function rotation2(lambda, phi2) {
      var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
      return [
        atan2$1(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
        asin$1(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
      ];
    }
    rotation2.invert = function(lambda, phi2) {
      var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaGamma - y2 * sinDeltaGamma;
      return [
        atan2$1(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
        asin$1(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
      ];
    };
    return rotation2;
  }
  function rotation(rotate) {
    rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
    function forward(coordinates2) {
      coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
      return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
    }
    forward.invert = function(coordinates2) {
      coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
      return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
    };
    return forward;
  }
  function circleStream(stream, radius, delta, direction2, t02, t12) {
    if (!delta)
      return;
    var cosRadius = cos$1(radius), sinRadius = sin$1(radius), step = direction2 * delta;
    if (t02 == null) {
      t02 = radius + direction2 * tau$1;
      t12 = radius - step / 2;
    } else {
      t02 = circleRadius(cosRadius, t02);
      t12 = circleRadius(cosRadius, t12);
      if (direction2 > 0 ? t02 < t12 : t02 > t12)
        t02 += direction2 * tau$1;
    }
    for (var point2, t = t02; direction2 > 0 ? t > t12 : t < t12; t -= step) {
      point2 = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
      stream.point(point2[0], point2[1]);
    }
  }
  function circleRadius(cosRadius, point2) {
    point2 = cartesian(point2), point2[0] -= cosRadius;
    cartesianNormalizeInPlace(point2);
    var radius = acos$1(-point2[1]);
    return ((-point2[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
  }
  function circle$4() {
    var center2 = constant$3([0, 0]), radius = constant$3(90), precision = constant$3(6), ring, rotate, stream = { point: point2 };
    function point2(x2, y2) {
      ring.push(x2 = rotate(x2, y2));
      x2[0] *= degrees, x2[1] *= degrees;
    }
    function circle2() {
      var c2 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
      ring = [];
      rotate = rotateRadians(-c2[0] * radians, -c2[1] * radians, 0).invert;
      circleStream(stream, r, p, 1);
      c2 = { type: "Polygon", coordinates: [ring] };
      ring = rotate = null;
      return c2;
    }
    circle2.center = function(_2) {
      return arguments.length ? (center2 = typeof _2 === "function" ? _2 : constant$3([+_2[0], +_2[1]]), circle2) : center2;
    };
    circle2.radius = function(_2) {
      return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$3(+_2), circle2) : radius;
    };
    circle2.precision = function(_2) {
      return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant$3(+_2), circle2) : precision;
    };
    return circle2;
  }
  function clipBuffer() {
    var lines = [], line2;
    return {
      point: function(x2, y2, m2) {
        line2.push([x2, y2, m2]);
      },
      lineStart: function() {
        lines.push(line2 = []);
      },
      lineEnd: noop$1,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line2 = null;
        return result;
      }
    };
  }
  function pointEqual(a2, b) {
    return abs$2(a2[0] - b[0]) < epsilon$1 && abs$2(a2[1] - b[1]) < epsilon$1;
  }
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
    var subject = [], clip2 = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p02 = segment[0], p1 = segment[n2], x2;
      if (pointEqual(p02, p1)) {
        if (!p02[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n2; ++i)
            stream.point((p02 = segment[i])[0], p02[1]);
          stream.lineEnd();
          return;
        }
        p1[0] += 2 * epsilon$1;
      }
      subject.push(x2 = new Intersection(p02, segment, null, true));
      clip2.push(x2.o = new Intersection(p02, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip2.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip2.sort(compareIntersection2);
    link$1(subject);
    link$1(clip2);
    for (i = 0, n = clip2.length; i < n; ++i) {
      clip2[i].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point2;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v)
        if ((current = current.n) === start2)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate2(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate2(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link$1(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a2 = array2[0], b;
    while (++i < n) {
      a2.n = b = array2[i];
      b.p = a2;
      a2 = b;
    }
    a2.n = b = array2[0];
    b.p = a2;
  }
  function longitude(point2) {
    return abs$2(point2[0]) <= pi$1 ? point2[0] : sign$1(point2[0]) * ((abs$2(point2[0]) + pi$1) % tau$1 - pi$1);
  }
  function polygonContains(polygon, point2) {
    var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin$1(phi2), normal2 = [sin$1(lambda), -cos$1(lambda), 0], angle2 = 0, winding = 0;
    var sum2 = new Adder();
    if (sinPhi === 1)
      phi2 = halfPi$1 + epsilon$1;
    else if (sinPhi === -1)
      phi2 = -halfPi$1 - epsilon$1;
    for (var i = 0, n = polygon.length; i < n; ++i) {
      if (!(m2 = (ring = polygon[i]).length))
        continue;
      var ring, m2, point0 = ring[m2 - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin$1(phi02), cosPhi02 = cos$1(phi02);
      for (var j = 0; j < m2; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi12), cosPhi1 = cos$1(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$1, k2 = sinPhi02 * sinPhi1;
        sum2.add(atan2$1(k2 * sign2 * sin$1(absDelta), cosPhi02 * cosPhi1 + k2 * cos$1(absDelta)));
        angle2 += antimeridian ? delta + sign2 * tau$1 : delta;
        if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection2 = cartesianCross(normal2, arc);
          cartesianNormalizeInPlace(intersection2);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection2[2]);
          if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle2 < -epsilon$1 || angle2 < epsilon$1 && sum2 < -epsilon2) ^ winding & 1;
  }
  function clip(pointVisible, clipLine2, interpolate2, start2) {
    return function(sink) {
      var line2 = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
      var clip2 = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip2.point = pointRing;
          clip2.lineStart = ringStart;
          clip2.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip2.point = point2;
          clip2.lineStart = lineStart;
          clip2.lineEnd = lineEnd;
          segments = merge$1(segments);
          var startInside = polygonContains(polygon, start2);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate2(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi2) {
        if (pointVisible(lambda, phi2))
          sink.point(lambda, phi2);
      }
      function pointLine(lambda, phi2) {
        line2.point(lambda, phi2);
      }
      function lineStart() {
        clip2.point = pointLine;
        line2.lineStart();
      }
      function lineEnd() {
        clip2.point = point2;
        line2.lineEnd();
      }
      function pointRing(lambda, phi2) {
        ring.push([lambda, phi2]);
        ringSink.point(lambda, phi2);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m2, segment, point3;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m2 = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m2; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip2;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a2, b) {
    return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi$1 - epsilon$1 : halfPi$1 - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
  }
  const clipAntimeridian = clip(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi$1, -halfPi$1]
  );
  function clipAntimeridianLine(stream) {
    var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda12, phi12) {
        var sign1 = lambda12 > 0 ? pi$1 : -pi$1, delta = abs$2(lambda12 - lambda02);
        if (abs$2(delta - pi$1) < epsilon$1) {
          stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi$1 : -halfPi$1);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          stream.point(lambda12, phi02);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi$1) {
          if (abs$2(lambda02 - sign0) < epsilon$1)
            lambda02 -= sign0 * epsilon$1;
          if (abs$2(lambda12 - sign1) < epsilon$1)
            lambda12 -= sign1 * epsilon$1;
          phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
          stream.point(sign0, phi02);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi02);
          clean = 0;
        }
        stream.point(lambda02 = lambda12, phi02 = phi12);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda02 = phi02 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
    var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin$1(lambda02 - lambda12);
    return abs$2(sinLambda0Lambda1) > epsilon$1 ? atan((sin$1(phi02) * (cosPhi1 = cos$1(phi12)) * sin$1(lambda12) - sin$1(phi12) * (cosPhi02 = cos$1(phi02)) * sin$1(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
  }
  function clipAntimeridianInterpolate(from2, to, direction2, stream) {
    var phi2;
    if (from2 == null) {
      phi2 = direction2 * halfPi$1;
      stream.point(-pi$1, phi2);
      stream.point(0, phi2);
      stream.point(pi$1, phi2);
      stream.point(pi$1, 0);
      stream.point(pi$1, -phi2);
      stream.point(0, -phi2);
      stream.point(-pi$1, -phi2);
      stream.point(-pi$1, 0);
      stream.point(-pi$1, phi2);
    } else if (abs$2(from2[0] - to[0]) > epsilon$1) {
      var lambda = from2[0] < to[0] ? pi$1 : -pi$1;
      phi2 = direction2 * lambda / 2;
      stream.point(-lambda, phi2);
      stream.point(0, phi2);
      stream.point(lambda, phi2);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function clipCircle(radius) {
    var cr = cos$1(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs$2(cr) > epsilon$1;
    function interpolate2(from2, to, direction2, stream) {
      circleStream(stream, radius, delta, direction2, from2, to);
    }
    function visible(lambda, phi2) {
      return cos$1(lambda) * cos$1(phi2) > cr;
    }
    function clipLine2(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi2) {
          var point1 = [lambda, phi2], point2, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi2) : 0;
          if (!point0 && (v00 = v0 = v))
            stream.lineStart();
          if (v !== v0) {
            point2 = intersect2(point0, point1);
            if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
              point1[2] = 1;
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              stream.lineStart();
              point2 = intersect2(point1, point0);
              stream.point(point2[0], point2[1]);
            } else {
              point2 = intersect2(point0, point1);
              stream.point(point2[0], point2[1], 2);
              stream.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c2 & c0) && (t = intersect2(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v && (!point0 || !pointEqual(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c2;
        },
        lineEnd: function() {
          if (v0)
            stream.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect2(a2, b, two) {
      var pa = cartesian(a2), pb = cartesian(b);
      var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant)
        return !two && a2;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
      cartesianAddInPlace(A5, B2);
      var u2 = n1xn2, w2 = cartesianDot(A5, u2), uu = cartesianDot(u2, u2), t22 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
      if (t22 < 0)
        return;
      var t = sqrt$2(t22), q = cartesianScale(u2, (-w2 - t) / uu);
      cartesianAddInPlace(q, A5);
      q = spherical(q);
      if (!two)
        return q;
      var lambda02 = a2[0], lambda12 = b[0], phi02 = a2[1], phi12 = b[1], z;
      if (lambda12 < lambda02)
        z = lambda02, lambda02 = lambda12, lambda12 = z;
      var delta2 = lambda12 - lambda02, polar = abs$2(delta2 - pi$1) < epsilon$1, meridian = polar || delta2 < epsilon$1;
      if (!polar && phi12 < phi02)
        z = phi02, phi02 = phi12, phi12 = z;
      if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs$2(q[0] - lambda02) < epsilon$1 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi$1 ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
        var q1 = cartesianScale(u2, (-w2 + t) / uu);
        cartesianAddInPlace(q1, A5);
        return [q, spherical(q1)];
      }
    }
    function code(lambda, phi2) {
      var r = smallRadius ? radius : pi$1 - radius, code2 = 0;
      if (lambda < -r)
        code2 |= 1;
      else if (lambda > r)
        code2 |= 2;
      if (phi2 < -r)
        code2 |= 4;
      else if (phi2 > r)
        code2 |= 8;
      return code2;
    }
    return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
  }
  function clipLine(a2, b, x02, y02, x12, y12) {
    var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t02)
        return;
      if (r < t12)
        t12 = r;
    } else if (dx > 0) {
      if (r > t12)
        return;
      if (r > t02)
        t02 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t12)
        return;
      if (r > t02)
        t02 = r;
    } else if (dx > 0) {
      if (r < t02)
        return;
      if (r < t12)
        t12 = r;
    }
    r = y02 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t02)
        return;
      if (r < t12)
        t12 = r;
    } else if (dy > 0) {
      if (r > t12)
        return;
      if (r > t02)
        t02 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t12)
        return;
      if (r > t02)
        t02 = r;
    } else if (dy > 0) {
      if (r < t02)
        return;
      if (r < t12)
        t12 = r;
    }
    if (t02 > 0)
      a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
    if (t12 < 1)
      b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
    return true;
  }
  var clipMax = 1e9, clipMin = -clipMax;
  function clipRectangle(x02, y02, x12, y12) {
    function visible(x2, y2) {
      return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
    }
    function interpolate2(from2, to, direction2, stream) {
      var a2 = 0, a1 = 0;
      if (from2 == null || (a2 = corner(from2, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from2, to) < 0 ^ direction2 > 0) {
        do
          stream.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
        while ((a2 = (a2 + direction2 + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p, direction2) {
      return abs$2(p[0] - x02) < epsilon$1 ? direction2 > 0 ? 0 : 3 : abs$2(p[0] - x12) < epsilon$1 ? direction2 > 0 ? 2 : 1 : abs$2(p[1] - y02) < epsilon$1 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
    }
    function compareIntersection2(a2, b) {
      return comparePoint(a2.x, b.x);
    }
    function comparePoint(a2, b) {
      var ca = corner(a2, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
      var clipStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point2(x2, y2) {
        if (visible(x2, y2))
          activeStream.point(x2, y2);
      }
      function polygonInside() {
        var winding = 0;
        for (var i = 0, n = polygon.length; i < n; ++i) {
          for (var ring2 = polygon[i], j = 1, m2 = ring2.length, point3 = ring2[0], a0, a1, b02 = point3[0], b12 = point3[1]; j < m2; ++j) {
            a0 = b02, a1 = b12, point3 = ring2[j], b02 = point3[0], b12 = point3[1];
            if (a1 <= y12) {
              if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x02 - a0))
                ++winding;
            } else {
              if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x02 - a0))
                --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge$1(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate2(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint2;
        if (polygon)
          polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint2(x__, y__);
          if (v__ && v_)
            bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point2;
        if (v_)
          activeStream.lineEnd();
      }
      function linePoint2(x2, y2) {
        var v = visible(x2, y2);
        if (polygon)
          ring.push([x2, y2]);
        if (first) {
          x__ = x2, y__ = y2, v__ = v;
          first = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
          }
        } else {
          if (v && v_)
            activeStream.point(x2, y2);
          else {
            var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
            if (clipLine(a2, b, x02, y02, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a2[0], a2[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v)
                activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x2, y2);
              clean = false;
            }
          }
        }
        x_ = x2, y_ = y2, v_ = v;
      }
      return clipStream;
    };
  }
  function extent() {
    var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
    return clip2 = {
      stream: function(stream) {
        return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
      },
      extent: function(_2) {
        return arguments.length ? (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
      }
    };
  }
  var lengthSum$1, lambda0, sinPhi0, cosPhi0;
  var lengthStream$1 = {
    sphere: noop$1,
    point: noop$1,
    lineStart: lengthLineStart,
    lineEnd: noop$1,
    polygonStart: noop$1,
    polygonEnd: noop$1
  };
  function lengthLineStart() {
    lengthStream$1.point = lengthPointFirst$1;
    lengthStream$1.lineEnd = lengthLineEnd;
  }
  function lengthLineEnd() {
    lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
  }
  function lengthPointFirst$1(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    lambda0 = lambda, sinPhi0 = sin$1(phi2), cosPhi0 = cos$1(phi2);
    lengthStream$1.point = lengthPoint$1;
  }
  function lengthPoint$1(lambda, phi2) {
    lambda *= radians, phi2 *= radians;
    var sinPhi = sin$1(phi2), cosPhi = cos$1(phi2), delta = abs$2(lambda - lambda0), cosDelta = cos$1(delta), sinDelta = sin$1(delta), x2 = cosPhi * sinDelta, y2 = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta, z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
    lengthSum$1.add(atan2$1(sqrt$2(x2 * x2 + y2 * y2), z));
    lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
  }
  function length$2(object2) {
    lengthSum$1 = new Adder();
    geoStream(object2, lengthStream$1);
    return +lengthSum$1;
  }
  var coordinates = [null, null], object = { type: "LineString", coordinates };
  function distance$1(a2, b) {
    coordinates[0] = a2;
    coordinates[1] = b;
    return length$2(object);
  }
  var containsObjectType = {
    Feature: function(object2, point2) {
      return containsGeometry(object2.geometry, point2);
    },
    FeatureCollection: function(object2, point2) {
      var features = object2.features, i = -1, n = features.length;
      while (++i < n)
        if (containsGeometry(features[i].geometry, point2))
          return true;
      return false;
    }
  };
  var containsGeometryType = {
    Sphere: function() {
      return true;
    },
    Point: function(object2, point2) {
      return containsPoint(object2.coordinates, point2);
    },
    MultiPoint: function(object2, point2) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        if (containsPoint(coordinates2[i], point2))
          return true;
      return false;
    },
    LineString: function(object2, point2) {
      return containsLine(object2.coordinates, point2);
    },
    MultiLineString: function(object2, point2) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        if (containsLine(coordinates2[i], point2))
          return true;
      return false;
    },
    Polygon: function(object2, point2) {
      return containsPolygon(object2.coordinates, point2);
    },
    MultiPolygon: function(object2, point2) {
      var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
      while (++i < n)
        if (containsPolygon(coordinates2[i], point2))
          return true;
      return false;
    },
    GeometryCollection: function(object2, point2) {
      var geometries = object2.geometries, i = -1, n = geometries.length;
      while (++i < n)
        if (containsGeometry(geometries[i], point2))
          return true;
      return false;
    }
  };
  function containsGeometry(geometry, point2) {
    return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point2) : false;
  }
  function containsPoint(coordinates2, point2) {
    return distance$1(coordinates2, point2) === 0;
  }
  function containsLine(coordinates2, point2) {
    var ao, bo, ab;
    for (var i = 0, n = coordinates2.length; i < n; i++) {
      bo = distance$1(coordinates2[i], point2);
      if (bo === 0)
        return true;
      if (i > 0) {
        ab = distance$1(coordinates2[i], coordinates2[i - 1]);
        if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab)
          return true;
      }
      ao = bo;
    }
    return false;
  }
  function containsPolygon(coordinates2, point2) {
    return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point2));
  }
  function ringRadians(ring) {
    return ring = ring.map(pointRadians), ring.pop(), ring;
  }
  function pointRadians(point2) {
    return [point2[0] * radians, point2[1] * radians];
  }
  function contains$1(object2, point2) {
    return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point2);
  }
  function graticuleX(y02, y12, dy) {
    var y2 = range$2(y02, y12 - epsilon$1, dy).concat(y12);
    return function(x2) {
      return y2.map(function(y3) {
        return [x2, y3];
      });
    };
  }
  function graticuleY(x02, x12, dx) {
    var x2 = range$2(x02, x12 - epsilon$1, dx).concat(x12);
    return function(y2) {
      return x2.map(function(x3) {
        return [x3, y2];
      });
    };
  }
  function graticule() {
    var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
    function graticule2() {
      return { type: "MultiLineString", coordinates: lines() };
    }
    function lines() {
      return range$2(ceil(X02 / DX) * DX, X12, DX).map(X3).concat(range$2(ceil(Y02 / DY) * DY, Y12, DY).map(Y3)).concat(range$2(ceil(x02 / dx) * dx, x12, dx).filter(function(x3) {
        return abs$2(x3 % DX) > epsilon$1;
      }).map(x2)).concat(range$2(ceil(y02 / dy) * dy, y12, dy).filter(function(y3) {
        return abs$2(y3 % DY) > epsilon$1;
      }).map(y2));
    }
    graticule2.lines = function() {
      return lines().map(function(coordinates2) {
        return { type: "LineString", coordinates: coordinates2 };
      });
    };
    graticule2.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X3(X02).concat(
            Y3(Y12).slice(1),
            X3(X12).reverse().slice(1),
            Y3(Y02).reverse().slice(1)
          )
        ]
      };
    };
    graticule2.extent = function(_2) {
      if (!arguments.length)
        return graticule2.extentMinor();
      return graticule2.extentMajor(_2).extentMinor(_2);
    };
    graticule2.extentMajor = function(_2) {
      if (!arguments.length)
        return [[X02, Y02], [X12, Y12]];
      X02 = +_2[0][0], X12 = +_2[1][0];
      Y02 = +_2[0][1], Y12 = +_2[1][1];
      if (X02 > X12)
        _2 = X02, X02 = X12, X12 = _2;
      if (Y02 > Y12)
        _2 = Y02, Y02 = Y12, Y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.extentMinor = function(_2) {
      if (!arguments.length)
        return [[x02, y02], [x12, y12]];
      x02 = +_2[0][0], x12 = +_2[1][0];
      y02 = +_2[0][1], y12 = +_2[1][1];
      if (x02 > x12)
        _2 = x02, x02 = x12, x12 = _2;
      if (y02 > y12)
        _2 = y02, y02 = y12, y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.step = function(_2) {
      if (!arguments.length)
        return graticule2.stepMinor();
      return graticule2.stepMajor(_2).stepMinor(_2);
    };
    graticule2.stepMajor = function(_2) {
      if (!arguments.length)
        return [DX, DY];
      DX = +_2[0], DY = +_2[1];
      return graticule2;
    };
    graticule2.stepMinor = function(_2) {
      if (!arguments.length)
        return [dx, dy];
      dx = +_2[0], dy = +_2[1];
      return graticule2;
    };
    graticule2.precision = function(_2) {
      if (!arguments.length)
        return precision;
      precision = +_2;
      x2 = graticuleX(y02, y12, 90);
      y2 = graticuleY(x02, x12, precision);
      X3 = graticuleX(Y02, Y12, 90);
      Y3 = graticuleY(X02, X12, precision);
      return graticule2;
    };
    return graticule2.extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]]).extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
  }
  function graticule10() {
    return graticule()();
  }
  function interpolate(a2, b) {
    var x02 = a2[0] * radians, y02 = a2[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos$1(y02), sy0 = sin$1(y02), cy1 = cos$1(y12), sy1 = sin$1(y12), kx0 = cy0 * cos$1(x02), ky0 = cy0 * sin$1(x02), kx1 = cy1 * cos$1(x12), ky1 = cy1 * sin$1(x12), d = 2 * asin$1(sqrt$2(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k2 = sin$1(d);
    var interpolate2 = d ? function(t) {
      var B2 = sin$1(t *= d) / k2, A5 = sin$1(d - t) / k2, x2 = A5 * kx0 + B2 * kx1, y2 = A5 * ky0 + B2 * ky1, z = A5 * sy0 + B2 * sy1;
      return [
        atan2$1(y2, x2) * degrees,
        atan2$1(z, sqrt$2(x2 * x2 + y2 * y2)) * degrees
      ];
    } : function() {
      return [x02 * degrees, y02 * degrees];
    };
    interpolate2.distance = d;
    return interpolate2;
  }
  const identity$5 = (x2) => x2;
  var areaSum = new Adder(), areaRingSum = new Adder(), x00$2, y00$2, x0$3, y0$3;
  var areaStream = {
    point: noop$1,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
      areaSum.add(abs$2(areaRingSum));
      areaRingSum = new Adder();
    },
    result: function() {
      var area2 = areaSum / 2;
      areaSum = new Adder();
      return area2;
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaPointFirst(x2, y2) {
    areaStream.point = areaPoint;
    x00$2 = x0$3 = x2, y00$2 = y0$3 = y2;
  }
  function areaPoint(x2, y2) {
    areaRingSum.add(y0$3 * x2 - x0$3 * y2);
    x0$3 = x2, y0$3 = y2;
  }
  function areaRingEnd() {
    areaPoint(x00$2, y00$2);
  }
  const pathArea = areaStream;
  var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
  var boundsStream = {
    point: boundsPoint,
    lineStart: noop$1,
    lineEnd: noop$1,
    polygonStart: noop$1,
    polygonEnd: noop$1,
    result: function() {
      var bounds2 = [[x0$2, y0$2], [x1, y1]];
      x1 = y1 = -(y0$2 = x0$2 = Infinity);
      return bounds2;
    }
  };
  function boundsPoint(x2, y2) {
    if (x2 < x0$2)
      x0$2 = x2;
    if (x2 > x1)
      x1 = x2;
    if (y2 < y0$2)
      y0$2 = y2;
    if (y2 > y1)
      y1 = y2;
  }
  const boundsStream$1 = boundsStream;
  var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2 = 0, Y2 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid2 = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
      X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
      return centroid2;
    }
  };
  function centroidPoint(x2, y2) {
    X0 += x2;
    Y0 += y2;
    ++Z0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x2, y2) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x0$1 = x2, y0$1 = y2);
  }
  function centroidPointLine(x2, y2) {
    var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
    X1 += z * (x0$1 + x2) / 2;
    Y1 += z * (y0$1 + y2) / 2;
    Z1 += z;
    centroidPoint(x0$1 = x2, y0$1 = y2);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }
  function centroidRingEnd() {
    centroidPointRing(x00$1, y00$1);
  }
  function centroidPointFirstRing(x2, y2) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x00$1 = x0$1 = x2, y00$1 = y0$1 = y2);
  }
  function centroidPointRing(x2, y2) {
    var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
    X1 += z * (x0$1 + x2) / 2;
    Y1 += z * (y0$1 + y2) / 2;
    Z1 += z;
    z = y0$1 * x2 - x0$1 * y2;
    X2 += z * (x0$1 + x2);
    Y2 += z * (y0$1 + y2);
    Z2 += z * 3;
    centroidPoint(x0$1 = x2, y0$1 = y2);
  }
  const pathCentroid = centroidStream;
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_2) {
      return this._radius = _2, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau$1);
          break;
        }
      }
    },
    result: noop$1
  };
  var lengthSum = new Adder(), lengthRing, x00, y00, x0, y0;
  var lengthStream = {
    point: noop$1,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing)
        lengthPoint(x00, y00);
      lengthStream.point = noop$1;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length2 = +lengthSum;
      lengthSum = new Adder();
      return length2;
    }
  };
  function lengthPointFirst(x2, y2) {
    lengthStream.point = lengthPoint;
    x00 = x0 = x2, y00 = y0 = y2;
  }
  function lengthPoint(x2, y2) {
    x0 -= x2, y0 -= y2;
    lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
    x0 = x2, y0 = y2;
  }
  const pathMeasure = lengthStream;
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle$3(4.5),
    pointRadius: function(_2) {
      if ((_2 = +_2) !== this._radius)
        this._radius = _2, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle$3(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle$3(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  function index$2(projection2, context) {
    var pointRadius = 4.5, projectionStream, contextStream;
    function path2(object2) {
      if (object2) {
        if (typeof pointRadius === "function")
          contextStream.pointRadius(+pointRadius.apply(this, arguments));
        geoStream(object2, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path2.area = function(object2) {
      geoStream(object2, projectionStream(pathArea));
      return pathArea.result();
    };
    path2.measure = function(object2) {
      geoStream(object2, projectionStream(pathMeasure));
      return pathMeasure.result();
    };
    path2.bounds = function(object2) {
      geoStream(object2, projectionStream(boundsStream$1));
      return boundsStream$1.result();
    };
    path2.centroid = function(object2) {
      geoStream(object2, projectionStream(pathCentroid));
      return pathCentroid.result();
    };
    path2.projection = function(_2) {
      return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity$5) : (projection2 = _2).stream, path2) : projection2;
    };
    path2.context = function(_2) {
      if (!arguments.length)
        return context;
      contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
      if (typeof pointRadius !== "function")
        contextStream.pointRadius(pointRadius);
      return path2;
    };
    path2.pointRadius = function(_2) {
      if (!arguments.length)
        return pointRadius;
      pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
      return path2;
    };
    return path2.projection(projection2).context(context);
  }
  function transform$1(methods) {
    return {
      stream: transformer$3(methods)
    };
  }
  function transformer$3(methods) {
    return function(stream) {
      var s2 = new TransformStream();
      for (var key in methods)
        s2[key] = methods[key];
      s2.stream = stream;
      return s2;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function fit(projection2, fitBounds, object2) {
    var clip2 = projection2.clipExtent && projection2.clipExtent();
    projection2.scale(150).translate([0, 0]);
    if (clip2 != null)
      projection2.clipExtent(null);
    geoStream(object2, projection2.stream(boundsStream$1));
    fitBounds(boundsStream$1.result());
    if (clip2 != null)
      projection2.clipExtent(clip2);
    return projection2;
  }
  function fitExtent(projection2, extent2, object2) {
    return fit(projection2, function(b) {
      var w2 = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object2);
  }
  function fitSize(projection2, size, object2) {
    return fitExtent(projection2, [[0, 0], size], object2);
  }
  function fitWidth(projection2, width2, object2) {
    return fit(projection2, function(b) {
      var w2 = +width2, k2 = w2 / (b[1][0] - b[0][0]), x2 = (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = -k2 * b[0][1];
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object2);
  }
  function fitHeight(projection2, height2, object2) {
    return fit(projection2, function(b) {
      var h = +height2, k2 = h / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y2 = (h - k2 * (b[1][1] + b[0][1])) / 2;
      projection2.scale(150 * k2).translate([x2, y2]);
    }, object2);
  }
  var maxDepth = 16, cosMinDistance = cos$1(30 * radians);
  function resample(project, delta2) {
    return +delta2 ? resample$1(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer$3({
      point: function(x2, y2) {
        x2 = project(x2, y2);
        this.stream.point(x2[0], x2[1]);
      }
    });
  }
  function resample$1(project, delta2) {
    function resampleLineTo(x02, y02, lambda02, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
      var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a2 = a0 + a1, b = b02 + b12, c2 = c0 + c1, m2 = sqrt$2(a2 * a2 + b * b + c2 * c2), phi2 = asin$1(c2 /= m2), lambda22 = abs$2(abs$2(c2) - 1) < epsilon$1 || abs$2(lambda02 - lambda12) < epsilon$1 ? (lambda02 + lambda12) / 2 : atan2$1(b, a2), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 || abs$2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x02, y02, lambda02, a0, b02, c0, x2, y2, lambda22, a2 /= m2, b /= m2, c2, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, lambda22, a2, b, c2, x12, y12, lambda12, a1, b12, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b02, c0;
      var resampleStream = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point2(x2, y2) {
        x2 = project(x2, y2);
        stream.point(x2[0], x2[1]);
      }
      function lineStart() {
        x02 = NaN;
        resampleStream.point = linePoint2;
        stream.lineStart();
      }
      function linePoint2(lambda, phi2) {
        var c2 = cartesian([lambda, phi2]), p = project(lambda, phi2);
        resampleLineTo(x02, y02, lambda02, a0, b02, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c2[0], b02 = c2[1], c0 = c2[2], maxDepth, stream);
        stream.point(x02, y02);
      }
      function lineEnd() {
        resampleStream.point = point2;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi2) {
        linePoint2(lambda002 = lambda, phi2), x002 = x02, y002 = y02, a00 = a0, b00 = b02, c00 = c0;
        resampleStream.point = linePoint2;
      }
      function ringEnd() {
        resampleLineTo(x02, y02, lambda02, a0, b02, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }
  var transformRadians = transformer$3({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });
  function transformRotate(rotate) {
    return transformer$3({
      point: function(x2, y2) {
        var r = rotate(x2, y2);
        return this.stream.point(r[0], r[1]);
      }
    });
  }
  function scaleTranslate(k2, dx, dy, sx, sy) {
    function transform2(x2, y2) {
      x2 *= sx;
      y2 *= sy;
      return [dx + k2 * x2, dy - k2 * y2];
    }
    transform2.invert = function(x2, y2) {
      return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
    };
    return transform2;
  }
  function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
    if (!alpha)
      return scaleTranslate(k2, dx, dy, sx, sy);
    var cosAlpha = cos$1(alpha), sinAlpha = sin$1(alpha), a2 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
    function transform2(x2, y2) {
      x2 *= sx;
      y2 *= sy;
      return [a2 * x2 - b * y2 + dx, dy - b * x2 - a2 * y2];
    }
    transform2.invert = function(x2, y2) {
      return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
    };
    return transform2;
  }
  function projection(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$5, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
    function projection2(point2) {
      return projectRotateTransform(point2[0] * radians, point2[1] * radians);
    }
    function invert2(point2) {
      point2 = projectRotateTransform.invert(point2[0], point2[1]);
      return point2 && [point2[0] * degrees, point2[1] * degrees];
    }
    projection2.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection2.preclip = function(_2) {
      return arguments.length ? (preclip = _2, theta = void 0, reset2()) : preclip;
    };
    projection2.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
    };
    projection2.clipAngle = function(_2) {
      return arguments.length ? (preclip = +_2 ? clipCircle(theta = _2 * radians) : (theta = null, clipAntimeridian), reset2()) : theta * degrees;
    };
    projection2.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
    };
    projection2.scale = function(_2) {
      return arguments.length ? (k2 = +_2, recenter()) : k2;
    };
    projection2.translate = function(_2) {
      return arguments.length ? (x2 = +_2[0], y2 = +_2[1], recenter()) : [x2, y2];
    };
    projection2.center = function(_2) {
      return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
    };
    projection2.rotate = function(_2) {
      return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
    };
    projection2.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
    };
    projection2.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
    };
    projection2.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
    };
    projection2.precision = function(_2) {
      return arguments.length ? (projectResample = resample(projectTransform, delta2 = _2 * _2), reset2()) : sqrt$2(delta2);
    };
    projection2.fitExtent = function(extent2, object2) {
      return fitExtent(projection2, extent2, object2);
    };
    projection2.fitSize = function(size, object2) {
      return fitSize(projection2, size, object2);
    };
    projection2.fitWidth = function(width2, object2) {
      return fitWidth(projection2, width2, object2);
    };
    projection2.fitHeight = function(height2, object2) {
      return fitHeight(projection2, height2, object2);
    };
    function recenter() {
      var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = scaleTranslateRotate(k2, x2 - center2[0], y2 - center2[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose(project, transform2);
      projectRotateTransform = compose(rotate, projectTransform);
      projectResample = resample(projectTransform, delta2);
      return reset2();
    }
    function reset2() {
      cache = cacheStream = null;
      return projection2;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection2.invert = project.invert && invert2;
      return recenter();
    };
  }
  function conicProjection(projectAt) {
    var phi02 = 0, phi12 = pi$1 / 3, m2 = projectionMutator(projectAt), p = m2(phi02, phi12);
    p.parallels = function(_2) {
      return arguments.length ? m2(phi02 = _2[0] * radians, phi12 = _2[1] * radians) : [phi02 * degrees, phi12 * degrees];
    };
    return p;
  }
  function cylindricalEqualAreaRaw(phi02) {
    var cosPhi02 = cos$1(phi02);
    function forward(lambda, phi2) {
      return [lambda * cosPhi02, sin$1(phi2) / cosPhi02];
    }
    forward.invert = function(x2, y2) {
      return [x2 / cosPhi02, asin$1(y2 * cosPhi02)];
    };
    return forward;
  }
  function conicEqualAreaRaw(y02, y12) {
    var sy0 = sin$1(y02), n = (sy0 + sin$1(y12)) / 2;
    if (abs$2(n) < epsilon$1)
      return cylindricalEqualAreaRaw(y02);
    var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c2) / n;
    function project(x2, y2) {
      var r = sqrt$2(c2 - 2 * n * sin$1(y2)) / n;
      return [r * sin$1(x2 *= n), r0 - r * cos$1(x2)];
    }
    project.invert = function(x2, y2) {
      var r0y = r0 - y2, l = atan2$1(x2, abs$2(r0y)) * sign$1(r0y);
      if (r0y * n < 0)
        l -= pi$1 * sign$1(x2) * sign$1(r0y);
      return [l / n, asin$1((c2 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
    };
    return project;
  }
  function conicEqualArea() {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  }
  function albers() {
    return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }
  function multiplex(streams) {
    var n = streams.length;
    return {
      point: function(x2, y2) {
        var i = -1;
        while (++i < n)
          streams[i].point(x2, y2);
      },
      sphere: function() {
        var i = -1;
        while (++i < n)
          streams[i].sphere();
      },
      lineStart: function() {
        var i = -1;
        while (++i < n)
          streams[i].lineStart();
      },
      lineEnd: function() {
        var i = -1;
        while (++i < n)
          streams[i].lineEnd();
      },
      polygonStart: function() {
        var i = -1;
        while (++i < n)
          streams[i].polygonStart();
      },
      polygonEnd: function() {
        var i = -1;
        while (++i < n)
          streams[i].polygonEnd();
      }
    };
  }
  function albersUsa() {
    var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x2, y2) {
      point2 = [x2, y2];
    } };
    function albersUsa2(coordinates2) {
      var x2 = coordinates2[0], y2 = coordinates2[1];
      return point2 = null, (lower48Point.point(x2, y2), point2) || (alaskaPoint.point(x2, y2), point2) || (hawaiiPoint.point(x2, y2), point2);
    }
    albersUsa2.invert = function(coordinates2) {
      var k2 = lower48.scale(), t = lower48.translate(), x2 = (coordinates2[0] - t[0]) / k2, y2 = (coordinates2[1] - t[1]) / k2;
      return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates2);
    };
    albersUsa2.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };
    albersUsa2.precision = function(_2) {
      if (!arguments.length)
        return lower48.precision();
      lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
      return reset2();
    };
    albersUsa2.scale = function(_2) {
      if (!arguments.length)
        return lower48.scale();
      lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
      return albersUsa2.translate(lower48.translate());
    };
    albersUsa2.translate = function(_2) {
      if (!arguments.length)
        return lower48.translate();
      var k2 = lower48.scale(), x2 = +_2[0], y2 = +_2[1];
      lower48Point = lower48.translate(_2).clipExtent([[x2 - 0.455 * k2, y2 - 0.238 * k2], [x2 + 0.455 * k2, y2 + 0.238 * k2]]).stream(pointStream);
      alaskaPoint = alaska.translate([x2 - 0.307 * k2, y2 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon$1, y2 + 0.12 * k2 + epsilon$1], [x2 - 0.214 * k2 - epsilon$1, y2 + 0.234 * k2 - epsilon$1]]).stream(pointStream);
      hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y2 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon$1, y2 + 0.166 * k2 + epsilon$1], [x2 - 0.115 * k2 - epsilon$1, y2 + 0.234 * k2 - epsilon$1]]).stream(pointStream);
      return reset2();
    };
    albersUsa2.fitExtent = function(extent2, object2) {
      return fitExtent(albersUsa2, extent2, object2);
    };
    albersUsa2.fitSize = function(size, object2) {
      return fitSize(albersUsa2, size, object2);
    };
    albersUsa2.fitWidth = function(width2, object2) {
      return fitWidth(albersUsa2, width2, object2);
    };
    albersUsa2.fitHeight = function(height2, object2) {
      return fitHeight(albersUsa2, height2, object2);
    };
    function reset2() {
      cache = cacheStream = null;
      return albersUsa2;
    }
    return albersUsa2.scale(1070);
  }
  function azimuthalRaw(scale) {
    return function(x2, y2) {
      var cx = cos$1(x2), cy = cos$1(y2), k2 = scale(cx * cy);
      if (k2 === Infinity)
        return [2, 0];
      return [
        k2 * cy * sin$1(x2),
        k2 * sin$1(y2)
      ];
    };
  }
  function azimuthalInvert(angle2) {
    return function(x2, y2) {
      var z = sqrt$2(x2 * x2 + y2 * y2), c2 = angle2(z), sc = sin$1(c2), cc = cos$1(c2);
      return [
        atan2$1(x2 * sc, z * cc),
        asin$1(z && y2 * sc / z)
      ];
    };
  }
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt$2(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin$1(z / 2);
  });
  function azimuthalEqualArea() {
    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  }
  var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
    return (c2 = acos$1(c2)) && c2 / sin$1(c2);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });
  function azimuthalEquidistant() {
    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }
  function mercatorRaw(lambda, phi2) {
    return [lambda, log$2(tan((halfPi$1 + phi2) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi$1];
  };
  function mercator() {
    return mercatorProjection(mercatorRaw).scale(961 / tau$1);
  }
  function mercatorProjection(project) {
    var m2 = projection(project), center2 = m2.center, scale = m2.scale, translate = m2.translate, clipExtent = m2.clipExtent, x02 = null, y02, x12, y12;
    m2.scale = function(_2) {
      return arguments.length ? (scale(_2), reclip()) : scale();
    };
    m2.translate = function(_2) {
      return arguments.length ? (translate(_2), reclip()) : translate();
    };
    m2.center = function(_2) {
      return arguments.length ? (center2(_2), reclip()) : center2();
    };
    m2.clipExtent = function(_2) {
      return arguments.length ? (_2 == null ? x02 = y02 = x12 = y12 = null : (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
    };
    function reclip() {
      var k2 = pi$1 * scale(), t = m2(rotation(m2.rotate()).invert([0, 0]));
      return clipExtent(x02 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x02), y02], [Math.min(t[0] + k2, x12), y12]] : [[x02, Math.max(t[1] - k2, y02)], [x12, Math.min(t[1] + k2, y12)]]);
    }
    return reclip();
  }
  function tany(y2) {
    return tan((halfPi$1 + y2) / 2);
  }
  function conicConformalRaw(y02, y12) {
    var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : log$2(cy0 / cos$1(y12)) / log$2(tany(y12) / tany(y02)), f = cy0 * pow$1(tany(y02), n) / n;
    if (!n)
      return mercatorRaw;
    function project(x2, y2) {
      if (f > 0) {
        if (y2 < -halfPi$1 + epsilon$1)
          y2 = -halfPi$1 + epsilon$1;
      } else {
        if (y2 > halfPi$1 - epsilon$1)
          y2 = halfPi$1 - epsilon$1;
      }
      var r = f / pow$1(tany(y2), n);
      return [r * sin$1(n * x2), f - r * cos$1(n * x2)];
    }
    project.invert = function(x2, y2) {
      var fy = f - y2, r = sign$1(n) * sqrt$2(x2 * x2 + fy * fy), l = atan2$1(x2, abs$2(fy)) * sign$1(fy);
      if (fy * n < 0)
        l -= pi$1 * sign$1(x2) * sign$1(fy);
      return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
    };
    return project;
  }
  function conicConformal() {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  }
  function equirectangularRaw(lambda, phi2) {
    return [lambda, phi2];
  }
  equirectangularRaw.invert = equirectangularRaw;
  function equirectangular() {
    return projection(equirectangularRaw).scale(152.63);
  }
  function conicEquidistantRaw(y02, y12) {
    var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : (cy0 - cos$1(y12)) / (y12 - y02), g = cy0 / n + y02;
    if (abs$2(n) < epsilon$1)
      return equirectangularRaw;
    function project(x2, y2) {
      var gy = g - y2, nx = n * x2;
      return [gy * sin$1(nx), g - gy * cos$1(nx)];
    }
    project.invert = function(x2, y2) {
      var gy = g - y2, l = atan2$1(x2, abs$2(gy)) * sign$1(gy);
      if (gy * n < 0)
        l -= pi$1 * sign$1(x2) * sign$1(gy);
      return [l / n, g - sign$1(n) * sqrt$2(x2 * x2 + gy * gy)];
    };
    return project;
  }
  function conicEquidistant() {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  }
  var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$2(3) / 2, iterations = 12;
  function equalEarthRaw(lambda, phi2) {
    var l = asin$1(M * sin$1(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
    return [
      lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
      l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
    ];
  }
  equalEarthRaw.invert = function(x2, y2) {
    var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
      fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
      fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
      l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
      if (abs$2(delta) < epsilon2)
        break;
    }
    return [
      M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
      asin$1(sin$1(l) / M)
    ];
  };
  function equalEarth() {
    return projection(equalEarthRaw).scale(177.158);
  }
  function gnomonicRaw(x2, y2) {
    var cy = cos$1(y2), k2 = cos$1(x2) * cy;
    return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);
  function gnomonic() {
    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
  }
  function identity$4() {
    var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer$3({
      point: function(x2, y2) {
        var p = projection2([x2, y2]);
        this.stream.point(p[0], p[1]);
      }
    }), postclip = identity$5, cache, cacheStream;
    function reset2() {
      kx2 = k2 * sx;
      ky2 = k2 * sy;
      cache = cacheStream = null;
      return projection2;
    }
    function projection2(p) {
      var x2 = p[0] * kx2, y2 = p[1] * ky2;
      if (alpha) {
        var t = y2 * ca - x2 * sa;
        x2 = x2 * ca + y2 * sa;
        y2 = t;
      }
      return [x2 + tx, y2 + ty];
    }
    projection2.invert = function(p) {
      var x2 = p[0] - tx, y2 = p[1] - ty;
      if (alpha) {
        var t = y2 * ca + x2 * sa;
        x2 = x2 * ca - y2 * sa;
        y2 = t;
      }
      return [x2 / kx2, y2 / ky2];
    };
    projection2.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
    };
    projection2.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
    };
    projection2.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
    };
    projection2.scale = function(_2) {
      return arguments.length ? (k2 = +_2, reset2()) : k2;
    };
    projection2.translate = function(_2) {
      return arguments.length ? (tx = +_2[0], ty = +_2[1], reset2()) : [tx, ty];
    };
    projection2.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset2()) : alpha * degrees;
    };
    projection2.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, reset2()) : sx < 0;
    };
    projection2.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, reset2()) : sy < 0;
    };
    projection2.fitExtent = function(extent2, object2) {
      return fitExtent(projection2, extent2, object2);
    };
    projection2.fitSize = function(size, object2) {
      return fitSize(projection2, size, object2);
    };
    projection2.fitWidth = function(width2, object2) {
      return fitWidth(projection2, width2, object2);
    };
    projection2.fitHeight = function(height2, object2) {
      return fitHeight(projection2, height2, object2);
    };
    return projection2;
  }
  function naturalEarth1Raw(lambda, phi2) {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    return [
      lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
      phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x2, y2) {
    var phi2 = y2, i = 25, delta;
    do {
      var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
      phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
    } while (abs$2(delta) > epsilon$1 && --i > 0);
    return [
      x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
      phi2
    ];
  };
  function naturalEarth1() {
    return projection(naturalEarth1Raw).scale(175.295);
  }
  function orthographicRaw(x2, y2) {
    return [cos$1(y2) * sin$1(x2), sin$1(y2)];
  }
  orthographicRaw.invert = azimuthalInvert(asin$1);
  function orthographic() {
    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$1);
  }
  function stereographicRaw(x2, y2) {
    var cy = cos$1(y2), k2 = 1 + cos$1(x2) * cy;
    return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });
  function stereographic() {
    return projection(stereographicRaw).scale(250).clipAngle(142);
  }
  function transverseMercatorRaw(lambda, phi2) {
    return [log$2(tan((halfPi$1 + phi2) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x2, y2) {
    return [-y2, 2 * atan(exp(x2)) - halfPi$1];
  };
  function transverseMercator() {
    var m2 = mercatorProjection(transverseMercatorRaw), center2 = m2.center, rotate = m2.rotate;
    m2.center = function(_2) {
      return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
    };
    m2.rotate = function(_2) {
      return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
    };
    return rotate([0, 0, 90]).scale(159.155);
  }
  function defaultSeparation$1(a2, b) {
    return a2.parent === b.parent ? 1 : 2;
  }
  function meanX(children2) {
    return children2.reduce(meanXReduce, 0) / children2.length;
  }
  function meanXReduce(x2, c2) {
    return x2 + c2.x;
  }
  function maxY(children2) {
    return 1 + children2.reduce(maxYReduce, 0);
  }
  function maxYReduce(y2, c2) {
    return Math.max(y2, c2.y);
  }
  function leafLeft(node2) {
    var children2;
    while (children2 = node2.children)
      node2 = children2[0];
    return node2;
  }
  function leafRight(node2) {
    var children2;
    while (children2 = node2.children)
      node2 = children2[children2.length - 1];
    return node2;
  }
  function cluster() {
    var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
    function cluster2(root2) {
      var previousNode, x2 = 0;
      root2.eachAfter(function(node2) {
        var children2 = node2.children;
        if (children2) {
          node2.x = meanX(children2);
          node2.y = maxY(children2);
        } else {
          node2.x = previousNode ? x2 += separation(node2, previousNode) : 0;
          node2.y = 0;
          previousNode = node2;
        }
      });
      var left2 = leafLeft(root2), right2 = leafRight(root2), x02 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
      return root2.eachAfter(nodeSize ? function(node2) {
        node2.x = (node2.x - root2.x) * dx;
        node2.y = (root2.y - node2.y) * dy;
      } : function(node2) {
        node2.x = (node2.x - x02) / (x12 - x02) * dx;
        node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * dy;
      });
    }
    cluster2.separation = function(x2) {
      return arguments.length ? (separation = x2, cluster2) : separation;
    };
    cluster2.size = function(x2) {
      return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
    };
    cluster2.nodeSize = function(x2) {
      return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
    };
    return cluster2;
  }
  function count(node2) {
    var sum2 = 0, children2 = node2.children, i = children2 && children2.length;
    if (!i)
      sum2 = 1;
    else
      while (--i >= 0)
        sum2 += children2[i].value;
    node2.value = sum2;
  }
  function node_count() {
    return this.eachAfter(count);
  }
  function node_each(callback, that) {
    let index2 = -1;
    for (const node2 of this) {
      callback.call(that, node2, ++index2, this);
    }
    return this;
  }
  function node_eachBefore(callback, that) {
    var node2 = this, nodes = [node2], children2, i, index2 = -1;
    while (node2 = nodes.pop()) {
      callback.call(that, node2, ++index2, this);
      if (children2 = node2.children) {
        for (i = children2.length - 1; i >= 0; --i) {
          nodes.push(children2[i]);
        }
      }
    }
    return this;
  }
  function node_eachAfter(callback, that) {
    var node2 = this, nodes = [node2], next2 = [], children2, i, n, index2 = -1;
    while (node2 = nodes.pop()) {
      next2.push(node2);
      if (children2 = node2.children) {
        for (i = 0, n = children2.length; i < n; ++i) {
          nodes.push(children2[i]);
        }
      }
    }
    while (node2 = next2.pop()) {
      callback.call(that, node2, ++index2, this);
    }
    return this;
  }
  function node_find(callback, that) {
    let index2 = -1;
    for (const node2 of this) {
      if (callback.call(that, node2, ++index2, this)) {
        return node2;
      }
    }
  }
  function node_sum(value) {
    return this.eachAfter(function(node2) {
      var sum2 = +value(node2.data) || 0, children2 = node2.children, i = children2 && children2.length;
      while (--i >= 0)
        sum2 += children2[i].value;
      node2.value = sum2;
    });
  }
  function node_sort(compare) {
    return this.eachBefore(function(node2) {
      if (node2.children) {
        node2.children.sort(compare);
      }
    });
  }
  function node_path(end2) {
    var start2 = this, ancestor = leastCommonAncestor(start2, end2), nodes = [start2];
    while (start2 !== ancestor) {
      start2 = start2.parent;
      nodes.push(start2);
    }
    var k2 = nodes.length;
    while (end2 !== ancestor) {
      nodes.splice(k2, 0, end2);
      end2 = end2.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a2, b) {
    if (a2 === b)
      return a2;
    var aNodes = a2.ancestors(), bNodes = b.ancestors(), c2 = null;
    a2 = aNodes.pop();
    b = bNodes.pop();
    while (a2 === b) {
      c2 = a2;
      a2 = aNodes.pop();
      b = bNodes.pop();
    }
    return c2;
  }
  function node_ancestors() {
    var node2 = this, nodes = [node2];
    while (node2 = node2.parent) {
      nodes.push(node2);
    }
    return nodes;
  }
  function node_descendants() {
    return Array.from(this);
  }
  function node_leaves() {
    var leaves = [];
    this.eachBefore(function(node2) {
      if (!node2.children) {
        leaves.push(node2);
      }
    });
    return leaves;
  }
  function node_links() {
    var root2 = this, links2 = [];
    root2.each(function(node2) {
      if (node2 !== root2) {
        links2.push({ source: node2.parent, target: node2 });
      }
    });
    return links2;
  }
  function* node_iterator() {
    var node2 = this, current, next2 = [node2], children2, i, n;
    do {
      current = next2.reverse(), next2 = [];
      while (node2 = current.pop()) {
        yield node2;
        if (children2 = node2.children) {
          for (i = 0, n = children2.length; i < n; ++i) {
            next2.push(children2[i]);
          }
        }
      }
    } while (next2.length);
  }
  function hierarchy(data, children2) {
    if (data instanceof Map) {
      data = [void 0, data];
      if (children2 === void 0)
        children2 = mapChildren;
    } else if (children2 === void 0) {
      children2 = objectChildren;
    }
    var root2 = new Node$1(data), node2, nodes = [root2], child, childs, i, n;
    while (node2 = nodes.pop()) {
      if ((childs = children2(node2.data)) && (n = (childs = Array.from(childs)).length)) {
        node2.children = childs;
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node$1(childs[i]));
          child.parent = node2;
          child.depth = node2.depth + 1;
        }
      }
    }
    return root2.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d) {
    return d.children;
  }
  function mapChildren(d) {
    return Array.isArray(d) ? d[1] : null;
  }
  function copyData(node2) {
    if (node2.data.value !== void 0)
      node2.value = node2.data.value;
    node2.data = node2.data.data;
  }
  function computeHeight(node2) {
    var height2 = 0;
    do
      node2.height = height2;
    while ((node2 = node2.parent) && node2.height < ++height2);
  }
  function Node$1(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node$1.prototype = hierarchy.prototype = {
    constructor: Node$1,
    count: node_count,
    each: node_each,
    eachAfter: node_eachAfter,
    eachBefore: node_eachBefore,
    find: node_find,
    sum: node_sum,
    sort: node_sort,
    path: node_path,
    ancestors: node_ancestors,
    descendants: node_descendants,
    leaves: node_leaves,
    links: node_links,
    copy: node_copy,
    [Symbol.iterator]: node_iterator
  };
  function optional(f) {
    return f == null ? null : required(f);
  }
  function required(f) {
    if (typeof f !== "function")
      throw new Error();
    return f;
  }
  function constantZero() {
    return 0;
  }
  function constant$2(x2) {
    return function() {
      return x2;
    };
  }
  const a$1 = 1664525;
  const c$4 = 1013904223;
  const m = 4294967296;
  function lcg$1() {
    let s2 = 1;
    return () => (s2 = (a$1 * s2 + c$4) % m) / m;
  }
  function array$1(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }
  function shuffle(array2, random2) {
    let m2 = array2.length, t, i;
    while (m2) {
      i = random2() * m2-- | 0;
      t = array2[m2];
      array2[m2] = array2[i];
      array2[i] = t;
    }
    return array2;
  }
  function enclose(circles) {
    return packEncloseRandom(circles, lcg$1());
  }
  function packEncloseRandom(circles, random2) {
    var i = 0, n = (circles = shuffle(Array.from(circles), random2)).length, B2 = [], p, e;
    while (i < n) {
      p = circles[i];
      if (e && enclosesWeak(e, p))
        ++i;
      else
        e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
    }
    return e;
  }
  function extendBasis(B2, p) {
    var i, j;
    if (enclosesWeakAll(p, B2))
      return [p];
    for (i = 0; i < B2.length; ++i) {
      if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
        return [B2[i], p];
      }
    }
    for (i = 0; i < B2.length - 1; ++i) {
      for (j = i + 1; j < B2.length; ++j) {
        if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
          return [B2[i], B2[j], p];
        }
      }
    }
    throw new Error();
  }
  function enclosesNot(a2, b) {
    var dr = a2.r - b.r, dx = b.x - a2.x, dy = b.y - a2.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }
  function enclosesWeak(a2, b) {
    var dr = a2.r - b.r + Math.max(a2.r, b.r, 1) * 1e-9, dx = b.x - a2.x, dy = b.y - a2.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function enclosesWeakAll(a2, B2) {
    for (var i = 0; i < B2.length; ++i) {
      if (!enclosesWeak(a2, B2[i])) {
        return false;
      }
    }
    return true;
  }
  function encloseBasis(B2) {
    switch (B2.length) {
      case 1:
        return encloseBasis1(B2[0]);
      case 2:
        return encloseBasis2(B2[0], B2[1]);
      case 3:
        return encloseBasis3(B2[0], B2[1], B2[2]);
    }
  }
  function encloseBasis1(a2) {
    return {
      x: a2.x,
      y: a2.y,
      r: a2.r
    };
  }
  function encloseBasis2(a2, b) {
    var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x12 + x2 + x21 / l * r21) / 2,
      y: (y12 + y2 + y21 / l * r21) / 2,
      r: (l + r1 + r2) / 2
    };
  }
  function encloseBasis3(a2, b, c2) {
    var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x12 - x2, a3 = x12 - x3, b22 = y12 - y2, b32 = y12 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d32 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a22 * b32, xa = (b22 * d32 - b32 * d2) / (ab * 2) - x12, xb = (b32 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d32) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C3)) / (2 * A5) : C3 / B2);
    return {
      x: x12 + xa + xb * r,
      y: y12 + ya + yb * r,
      r
    };
  }
  function place(b, a2, c2) {
    var dx = b.x - a2.x, x2, a22, dy = b.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
    if (d2) {
      a22 = a2.r + c2.r, a22 *= a22;
      b22 = b.r + c2.r, b22 *= b22;
      if (a22 > b22) {
        x2 = (d2 + b22 - a22) / (2 * d2);
        y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
        c2.x = b.x - x2 * dx - y2 * dy;
        c2.y = b.y - x2 * dy + y2 * dx;
      } else {
        x2 = (d2 + a22 - b22) / (2 * d2);
        y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
        c2.x = a2.x + x2 * dx - y2 * dy;
        c2.y = a2.y + x2 * dy + y2 * dx;
      }
    } else {
      c2.x = a2.x + c2.r;
      c2.y = a2.y;
    }
  }
  function intersects(a2, b) {
    var dr = a2.r + b.r - 1e-6, dx = b.x - a2.x, dy = b.y - a2.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function score(node2) {
    var a2 = node2._, b = node2.next._, ab = a2.r + b.r, dx = (a2.x * b.r + b.x * a2.r) / ab, dy = (a2.y * b.r + b.y * a2.r) / ab;
    return dx * dx + dy * dy;
  }
  function Node(circle2) {
    this._ = circle2;
    this.next = null;
    this.previous = null;
  }
  function packSiblingsRandom(circles, random2) {
    if (!(n = (circles = array$1(circles)).length))
      return 0;
    var a2, b, c2, n, aa, ca, i, j, k2, sj, sk;
    a2 = circles[0], a2.x = 0, a2.y = 0;
    if (!(n > 1))
      return a2.r;
    b = circles[1], a2.x = -b.r, b.x = a2.r, b.y = 0;
    if (!(n > 2))
      return a2.r + b.r;
    place(b, a2, c2 = circles[2]);
    a2 = new Node(a2), b = new Node(b), c2 = new Node(c2);
    a2.next = c2.previous = b;
    b.next = a2.previous = c2;
    c2.next = b.previous = a2;
    pack:
      for (i = 3; i < n; ++i) {
        place(a2._, b._, c2 = circles[i]), c2 = new Node(c2);
        j = b.next, k2 = a2.previous, sj = b._.r, sk = a2._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c2._)) {
              b = j, a2.next = b, b.previous = a2, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k2._, c2._)) {
              a2 = k2, a2.next = b, b.previous = a2, --i;
              continue pack;
            }
            sk += k2._.r, k2 = k2.previous;
          }
        } while (j !== k2.next);
        c2.previous = a2, c2.next = b, a2.next = b.previous = b = c2;
        aa = score(a2);
        while ((c2 = c2.next) !== b) {
          if ((ca = score(c2)) < aa) {
            a2 = c2, aa = ca;
          }
        }
        b = a2.next;
      }
    a2 = [b._], c2 = b;
    while ((c2 = c2.next) !== b)
      a2.push(c2._);
    c2 = packEncloseRandom(a2, random2);
    for (i = 0; i < n; ++i)
      a2 = circles[i], a2.x -= c2.x, a2.y -= c2.y;
    return c2.r;
  }
  function siblings(circles) {
    packSiblingsRandom(circles, lcg$1());
    return circles;
  }
  function defaultRadius(d) {
    return Math.sqrt(d.value);
  }
  function index$1() {
    var radius = null, dx = 1, dy = 1, padding2 = constantZero;
    function pack(root2) {
      const random2 = lcg$1();
      root2.x = dx / 2, root2.y = dy / 2;
      if (radius) {
        root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding2, 0.5, random2)).eachBefore(translateChild(1));
      } else {
        root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random2)).eachAfter(packChildrenRandom(padding2, root2.r / Math.min(dx, dy), random2)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
      }
      return root2;
    }
    pack.radius = function(x2) {
      return arguments.length ? (radius = optional(x2), pack) : radius;
    };
    pack.size = function(x2) {
      return arguments.length ? (dx = +x2[0], dy = +x2[1], pack) : [dx, dy];
    };
    pack.padding = function(x2) {
      return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$2(+x2), pack) : padding2;
    };
    return pack;
  }
  function radiusLeaf(radius) {
    return function(node2) {
      if (!node2.children) {
        node2.r = Math.max(0, +radius(node2) || 0);
      }
    };
  }
  function packChildrenRandom(padding2, k2, random2) {
    return function(node2) {
      if (children2 = node2.children) {
        var children2, i, n = children2.length, r = padding2(node2) * k2 || 0, e;
        if (r)
          for (i = 0; i < n; ++i)
            children2[i].r += r;
        e = packSiblingsRandom(children2, random2);
        if (r)
          for (i = 0; i < n; ++i)
            children2[i].r -= r;
        node2.r = e + r;
      }
    };
  }
  function translateChild(k2) {
    return function(node2) {
      var parent = node2.parent;
      node2.r *= k2;
      if (parent) {
        node2.x = parent.x + k2 * node2.x;
        node2.y = parent.y + k2 * node2.y;
      }
    };
  }
  function roundNode(node2) {
    node2.x0 = Math.round(node2.x0);
    node2.y0 = Math.round(node2.y0);
    node2.x1 = Math.round(node2.x1);
    node2.y1 = Math.round(node2.y1);
  }
  function treemapDice(parent, x02, y02, x12, y12) {
    var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (x12 - x02) / parent.value;
    while (++i < n) {
      node2 = nodes[i], node2.y0 = y02, node2.y1 = y12;
      node2.x0 = x02, node2.x1 = x02 += node2.value * k2;
    }
  }
  function partition() {
    var dx = 1, dy = 1, padding2 = 0, round = false;
    function partition2(root2) {
      var n = root2.height + 1;
      root2.x0 = root2.y0 = padding2;
      root2.x1 = dx;
      root2.y1 = dy / n;
      root2.eachBefore(positionNode2(dy, n));
      if (round)
        root2.eachBefore(roundNode);
      return root2;
    }
    function positionNode2(dy2, n) {
      return function(node2) {
        if (node2.children) {
          treemapDice(node2, node2.x0, dy2 * (node2.depth + 1) / n, node2.x1, dy2 * (node2.depth + 2) / n);
        }
        var x02 = node2.x0, y02 = node2.y0, x12 = node2.x1 - padding2, y12 = node2.y1 - padding2;
        if (x12 < x02)
          x02 = x12 = (x02 + x12) / 2;
        if (y12 < y02)
          y02 = y12 = (y02 + y12) / 2;
        node2.x0 = x02;
        node2.y0 = y02;
        node2.x1 = x12;
        node2.y1 = y12;
      };
    }
    partition2.round = function(x2) {
      return arguments.length ? (round = !!x2, partition2) : round;
    };
    partition2.size = function(x2) {
      return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
    };
    partition2.padding = function(x2) {
      return arguments.length ? (padding2 = +x2, partition2) : padding2;
    };
    return partition2;
  }
  var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
  function defaultId(d) {
    return d.id;
  }
  function defaultParentId(d) {
    return d.parentId;
  }
  function stratify() {
    var id2 = defaultId, parentId = defaultParentId, path2;
    function stratify2(data) {
      var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n, d, i, root2, parent, node2, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
      if (path2 != null) {
        const I = nodes.map((d2, i2) => normalize$2(path2(d2, i2, data)));
        const P = I.map(parentof);
        const S = new Set(I).add("");
        for (const i2 of P) {
          if (!S.has(i2)) {
            S.add(i2);
            I.push(i2);
            P.push(parentof(i2));
            nodes.push(imputed);
          }
        }
        currentId = (_2, i2) => I[i2];
        currentParentId = (_2, i2) => P[i2];
      }
      for (i = 0, n = nodes.length; i < n; ++i) {
        d = nodes[i], node2 = nodes[i] = new Node$1(d);
        if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
          nodeKey = node2.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node2);
        }
        if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
          node2.parent = nodeId;
        }
      }
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        if (nodeId = node2.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent)
            throw new Error("missing: " + nodeId);
          if (parent === ambiguous)
            throw new Error("ambiguous: " + nodeId);
          if (parent.children)
            parent.children.push(node2);
          else
            parent.children = [node2];
          node2.parent = parent;
        } else {
          if (root2)
            throw new Error("multiple roots");
          root2 = node2;
        }
      }
      if (!root2)
        throw new Error("no root");
      if (path2 != null) {
        while (root2.data === imputed && root2.children.length === 1) {
          root2 = root2.children[0], --n;
        }
        for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
          node2 = nodes[i2];
          if (node2.data !== imputed)
            break;
          node2.data = null;
        }
      }
      root2.parent = preroot;
      root2.eachBefore(function(node3) {
        node3.depth = node3.parent.depth + 1;
        --n;
      }).eachBefore(computeHeight);
      root2.parent = null;
      if (n > 0)
        throw new Error("cycle");
      return root2;
    }
    stratify2.id = function(x2) {
      return arguments.length ? (id2 = optional(x2), stratify2) : id2;
    };
    stratify2.parentId = function(x2) {
      return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
    };
    stratify2.path = function(x2) {
      return arguments.length ? (path2 = optional(x2), stratify2) : path2;
    };
    return stratify2;
  }
  function normalize$2(path2) {
    path2 = `${path2}`;
    let i = path2.length;
    if (slash(path2, i - 1) && !slash(path2, i - 2))
      path2 = path2.slice(0, -1);
    return path2[0] === "/" ? path2 : `/${path2}`;
  }
  function parentof(path2) {
    let i = path2.length;
    if (i < 2)
      return "";
    while (--i > 1)
      if (slash(path2, i))
        break;
    return path2.slice(0, i);
  }
  function slash(path2, i) {
    if (path2[i] === "/") {
      let k2 = 0;
      while (i > 0 && path2[--i] === "\\")
        ++k2;
      if ((k2 & 1) === 0)
        return true;
    }
    return false;
  }
  function defaultSeparation(a2, b) {
    return a2.parent === b.parent ? 1 : 2;
  }
  function nextLeft(v) {
    var children2 = v.children;
    return children2 ? children2[0] : v.t;
  }
  function nextRight(v) {
    var children2 = v.children;
    return children2 ? children2[children2.length - 1] : v.t;
  }
  function moveSubtree(wm, wp, shift) {
    var change2 = shift / (wp.i - wm.i);
    wp.c -= change2;
    wp.s += shift;
    wm.c += change2;
    wp.z += shift;
    wp.m += shift;
  }
  function executeShifts(v) {
    var shift = 0, change2 = 0, children2 = v.children, i = children2.length, w2;
    while (--i >= 0) {
      w2 = children2[i];
      w2.z += shift;
      w2.m += shift;
      shift += w2.s + (change2 += w2.c);
    }
  }
  function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  function TreeNode(node2, i) {
    this._ = node2;
    this.parent = null;
    this.children = null;
    this.A = null;
    this.a = this;
    this.z = 0;
    this.m = 0;
    this.c = 0;
    this.s = 0;
    this.t = null;
    this.i = i;
  }
  TreeNode.prototype = Object.create(Node$1.prototype);
  function treeRoot(root2) {
    var tree2 = new TreeNode(root2, 0), node2, nodes = [tree2], child, children2, i, n;
    while (node2 = nodes.pop()) {
      if (children2 = node2._.children) {
        node2.children = new Array(n = children2.length);
        for (i = n - 1; i >= 0; --i) {
          nodes.push(child = node2.children[i] = new TreeNode(children2[i], i));
          child.parent = node2;
        }
      }
    }
    (tree2.parent = new TreeNode(null, 0)).children = [tree2];
    return tree2;
  }
  function tree() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
    function tree2(root2) {
      var t = treeRoot(root2);
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);
      if (nodeSize)
        root2.eachBefore(sizeNode);
      else {
        var left2 = root2, right2 = root2, bottom2 = root2;
        root2.eachBefore(function(node2) {
          if (node2.x < left2.x)
            left2 = node2;
          if (node2.x > right2.x)
            right2 = node2;
          if (node2.depth > bottom2.depth)
            bottom2 = node2;
        });
        var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);
        root2.eachBefore(function(node2) {
          node2.x = (node2.x + tx) * kx2;
          node2.y = node2.depth * ky2;
        });
      }
      return root2;
    }
    function firstWalk(v) {
      var children2 = v.children, siblings2 = v.parent.children, w2 = v.i ? siblings2[v.i - 1] : null;
      if (children2) {
        executeShifts(v);
        var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
        if (w2) {
          v.z = w2.z + separation(v._, w2._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w2) {
        v.z = w2.z + separation(v._, w2._);
      }
      v.parent.A = apportion(v, w2, v.parent.A || siblings2[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w2, ancestor) {
      if (w2) {
        var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node2) {
      node2.x *= dx;
      node2.y = node2.depth * dy;
    }
    tree2.separation = function(x2) {
      return arguments.length ? (separation = x2, tree2) : separation;
    };
    tree2.size = function(x2) {
      return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
    };
    tree2.nodeSize = function(x2) {
      return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
    };
    return tree2;
  }
  function treemapSlice(parent, x02, y02, x12, y12) {
    var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (y12 - y02) / parent.value;
    while (++i < n) {
      node2 = nodes[i], node2.x0 = x02, node2.x1 = x12;
      node2.y0 = y02, node2.y1 = y02 += node2.value * k2;
    }
  }
  var phi = (1 + Math.sqrt(5)) / 2;
  function squarifyRatio(ratio, parent, x02, y02, x12, y12) {
    var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta2;
    while (i0 < n) {
      dx = x12 - x02, dy = y12 - y02;
      do
        sumValue = nodes[i1++].value;
      while (!sumValue && i1 < n);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
      beta2 = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta2, beta2 / minValue);
      for (; i1 < n; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue)
          minValue = nodeValue;
        if (nodeValue > maxValue)
          maxValue = nodeValue;
        beta2 = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta2, beta2 / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;
          break;
        }
        minRatio = newRatio;
      }
      rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
      if (row.dice)
        treemapDice(row, x02, y02, x12, value ? y02 += dy * sumValue / value : y12);
      else
        treemapSlice(row, x02, y02, value ? x02 += dx * sumValue / value : x12, y12);
      value -= sumValue, i0 = i1;
    }
    return rows;
  }
  const squarify = function custom(ratio) {
    function squarify2(parent, x02, y02, x12, y12) {
      squarifyRatio(ratio, parent, x02, y02, x12, y12);
    }
    squarify2.ratio = function(x2) {
      return custom((x2 = +x2) > 1 ? x2 : 1);
    };
    return squarify2;
  }(phi);
  function index() {
    var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
    function treemap(root2) {
      root2.x0 = root2.y0 = 0;
      root2.x1 = dx;
      root2.y1 = dy;
      root2.eachBefore(positionNode2);
      paddingStack = [0];
      if (round)
        root2.eachBefore(roundNode);
      return root2;
    }
    function positionNode2(node2) {
      var p = paddingStack[node2.depth], x02 = node2.x0 + p, y02 = node2.y0 + p, x12 = node2.x1 - p, y12 = node2.y1 - p;
      if (x12 < x02)
        x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02)
        y02 = y12 = (y02 + y12) / 2;
      node2.x0 = x02;
      node2.y0 = y02;
      node2.x1 = x12;
      node2.y1 = y12;
      if (node2.children) {
        p = paddingStack[node2.depth + 1] = paddingInner(node2) / 2;
        x02 += paddingLeft(node2) - p;
        y02 += paddingTop(node2) - p;
        x12 -= paddingRight(node2) - p;
        y12 -= paddingBottom(node2) - p;
        if (x12 < x02)
          x02 = x12 = (x02 + x12) / 2;
        if (y12 < y02)
          y02 = y12 = (y02 + y12) / 2;
        tile(node2, x02, y02, x12, y12);
      }
    }
    treemap.round = function(x2) {
      return arguments.length ? (round = !!x2, treemap) : round;
    };
    treemap.size = function(x2) {
      return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
    };
    treemap.tile = function(x2) {
      return arguments.length ? (tile = required(x2), treemap) : tile;
    };
    treemap.padding = function(x2) {
      return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
    };
    treemap.paddingInner = function(x2) {
      return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant$2(+x2), treemap) : paddingInner;
    };
    treemap.paddingOuter = function(x2) {
      return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
    };
    treemap.paddingTop = function(x2) {
      return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$2(+x2), treemap) : paddingTop;
    };
    treemap.paddingRight = function(x2) {
      return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$2(+x2), treemap) : paddingRight;
    };
    treemap.paddingBottom = function(x2) {
      return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$2(+x2), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function(x2) {
      return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$2(+x2), treemap) : paddingLeft;
    };
    return treemap;
  }
  function binary(parent, x02, y02, x12, y12) {
    var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
    for (sums[0] = sum2 = i = 0; i < n; ++i) {
      sums[i + 1] = sum2 += nodes[i].value;
    }
    partition2(0, n, parent.value, x02, y02, x12, y12);
    function partition2(i2, j, value, x03, y03, x13, y13) {
      if (i2 >= j - 1) {
        var node2 = nodes[i2];
        node2.x0 = x03, node2.y0 = y03;
        node2.x1 = x13, node2.y1 = y13;
        return;
      }
      var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
      while (k2 < hi) {
        var mid = k2 + hi >>> 1;
        if (sums[mid] < valueTarget)
          k2 = mid + 1;
        else
          hi = mid;
      }
      if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
        --k2;
      var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
      if (x13 - x03 > y13 - y03) {
        var xk = value ? (x03 * valueRight + x13 * valueLeft) / value : x13;
        partition2(i2, k2, valueLeft, x03, y03, xk, y13);
        partition2(k2, j, valueRight, xk, y03, x13, y13);
      } else {
        var yk = value ? (y03 * valueRight + y13 * valueLeft) / value : y13;
        partition2(i2, k2, valueLeft, x03, y03, x13, yk);
        partition2(k2, j, valueRight, x03, yk, x13, y13);
      }
    }
  }
  function sliceDice(parent, x02, y02, x12, y12) {
    (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x02, y02, x12, y12);
  }
  const resquarify = function custom(ratio) {
    function resquarify2(parent, x02, y02, x12, y12) {
      if ((rows = parent._squarify) && rows.ratio === ratio) {
        var rows, row, nodes, i, j = -1, n, m2 = rows.length, value = parent.value;
        while (++j < m2) {
          row = rows[j], nodes = row.children;
          for (i = row.value = 0, n = nodes.length; i < n; ++i)
            row.value += nodes[i].value;
          if (row.dice)
            treemapDice(row, x02, y02, x12, value ? y02 += (y12 - y02) * row.value / value : y12);
          else
            treemapSlice(row, x02, y02, value ? x02 += (x12 - x02) * row.value / value : x12, y12);
          value -= row.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x02, y02, x12, y12);
        rows.ratio = ratio;
      }
    }
    resquarify2.ratio = function(x2) {
      return custom((x2 = +x2) > 1 ? x2 : 1);
    };
    return resquarify2;
  }(phi);
  function area$1(polygon) {
    var i = -1, n = polygon.length, a2, b = polygon[n - 1], area2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      area2 += a2[1] * b[0] - a2[0] * b[1];
    }
    return area2 / 2;
  }
  function centroid(polygon) {
    var i = -1, n = polygon.length, x2 = 0, y2 = 0, a2, b = polygon[n - 1], c2, k2 = 0;
    while (++i < n) {
      a2 = b;
      b = polygon[i];
      k2 += c2 = a2[0] * b[1] - b[0] * a2[1];
      x2 += (a2[0] + b[0]) * c2;
      y2 += (a2[1] + b[1]) * c2;
    }
    return k2 *= 3, [x2 / k2, y2 / k2];
  }
  function cross$2(a2, b, c2) {
    return (b[0] - a2[0]) * (c2[1] - a2[1]) - (b[1] - a2[1]) * (c2[0] - a2[0]);
  }
  function lexicographicOrder(a2, b) {
    return a2[0] - b[0] || a2[1] - b[1];
  }
  function computeUpperHullIndexes(points) {
    const n = points.length, indexes2 = [0, 1];
    let size = 2, i;
    for (i = 2; i < n; ++i) {
      while (size > 1 && cross$2(points[indexes2[size - 2]], points[indexes2[size - 1]], points[i]) <= 0)
        --size;
      indexes2[size++] = i;
    }
    return indexes2.slice(0, size);
  }
  function hull(points) {
    if ((n = points.length) < 3)
      return null;
    var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
    for (i = 0; i < n; ++i)
      sortedPoints[i] = [+points[i][0], +points[i][1], i];
    sortedPoints.sort(lexicographicOrder);
    for (i = 0; i < n; ++i)
      flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
    var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
    var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];
    for (i = upperIndexes.length - 1; i >= 0; --i)
      hull2.push(points[sortedPoints[upperIndexes[i]][2]]);
    for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
      hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);
    return hull2;
  }
  function contains(polygon, point2) {
    var n = polygon.length, p = polygon[n - 1], x2 = point2[0], y2 = point2[1], x02 = p[0], y02 = p[1], x12, y12, inside = false;
    for (var i = 0; i < n; ++i) {
      p = polygon[i], x12 = p[0], y12 = p[1];
      if (y12 > y2 !== y02 > y2 && x2 < (x02 - x12) * (y2 - y12) / (y02 - y12) + x12)
        inside = !inside;
      x02 = x12, y02 = y12;
    }
    return inside;
  }
  function length$1(polygon) {
    var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
    while (++i < n) {
      xa = xb;
      ya = yb;
      b = polygon[i];
      xb = b[0];
      yb = b[1];
      xa -= xb;
      ya -= yb;
      perimeter += Math.hypot(xa, ya);
    }
    return perimeter;
  }
  const defaultSource = Math.random;
  const uniform = function sourceRandomUniform(source) {
    function randomUniform(min2, max2) {
      min2 = min2 == null ? 0 : +min2;
      max2 = max2 == null ? 1 : +max2;
      if (arguments.length === 1)
        max2 = min2, min2 = 0;
      else
        max2 -= min2;
      return function() {
        return source() * max2 + min2;
      };
    }
    randomUniform.source = sourceRandomUniform;
    return randomUniform;
  }(defaultSource);
  const int = function sourceRandomInt(source) {
    function randomInt(min2, max2) {
      if (arguments.length < 2)
        max2 = min2, min2 = 0;
      min2 = Math.floor(min2);
      max2 = Math.floor(max2) - min2;
      return function() {
        return Math.floor(source() * max2 + min2);
      };
    }
    randomInt.source = sourceRandomInt;
    return randomInt;
  }(defaultSource);
  const normal = function sourceRandomNormal(source) {
    function randomNormal(mu, sigma) {
      var x2, r;
      mu = mu == null ? 0 : +mu;
      sigma = sigma == null ? 1 : +sigma;
      return function() {
        var y2;
        if (x2 != null)
          y2 = x2, x2 = null;
        else
          do {
            x2 = source() * 2 - 1;
            y2 = source() * 2 - 1;
            r = x2 * x2 + y2 * y2;
          } while (!r || r > 1);
        return mu + sigma * y2 * Math.sqrt(-2 * Math.log(r) / r);
      };
    }
    randomNormal.source = sourceRandomNormal;
    return randomNormal;
  }(defaultSource);
  const logNormal = function sourceRandomLogNormal(source) {
    var N = normal.source(source);
    function randomLogNormal() {
      var randomNormal = N.apply(this, arguments);
      return function() {
        return Math.exp(randomNormal());
      };
    }
    randomLogNormal.source = sourceRandomLogNormal;
    return randomLogNormal;
  }(defaultSource);
  const irwinHall = function sourceRandomIrwinHall(source) {
    function randomIrwinHall(n) {
      if ((n = +n) <= 0)
        return () => 0;
      return function() {
        for (var sum2 = 0, i = n; i > 1; --i)
          sum2 += source();
        return sum2 + i * source();
      };
    }
    randomIrwinHall.source = sourceRandomIrwinHall;
    return randomIrwinHall;
  }(defaultSource);
  const bates = function sourceRandomBates(source) {
    var I = irwinHall.source(source);
    function randomBates(n) {
      if ((n = +n) === 0)
        return source;
      var randomIrwinHall = I(n);
      return function() {
        return randomIrwinHall() / n;
      };
    }
    randomBates.source = sourceRandomBates;
    return randomBates;
  }(defaultSource);
  const exponential = function sourceRandomExponential(source) {
    function randomExponential(lambda) {
      return function() {
        return -Math.log1p(-source()) / lambda;
      };
    }
    randomExponential.source = sourceRandomExponential;
    return randomExponential;
  }(defaultSource);
  const pareto = function sourceRandomPareto(source) {
    function randomPareto(alpha) {
      if ((alpha = +alpha) < 0)
        throw new RangeError("invalid alpha");
      alpha = 1 / -alpha;
      return function() {
        return Math.pow(1 - source(), alpha);
      };
    }
    randomPareto.source = sourceRandomPareto;
    return randomPareto;
  }(defaultSource);
  const bernoulli = function sourceRandomBernoulli(source) {
    function randomBernoulli(p) {
      if ((p = +p) < 0 || p > 1)
        throw new RangeError("invalid p");
      return function() {
        return Math.floor(source() + p);
      };
    }
    randomBernoulli.source = sourceRandomBernoulli;
    return randomBernoulli;
  }(defaultSource);
  const geometric = function sourceRandomGeometric(source) {
    function randomGeometric(p) {
      if ((p = +p) < 0 || p > 1)
        throw new RangeError("invalid p");
      if (p === 0)
        return () => Infinity;
      if (p === 1)
        return () => 1;
      p = Math.log1p(-p);
      return function() {
        return 1 + Math.floor(Math.log1p(-source()) / p);
      };
    }
    randomGeometric.source = sourceRandomGeometric;
    return randomGeometric;
  }(defaultSource);
  const gamma = function sourceRandomGamma(source) {
    var randomNormal = normal.source(source)();
    function randomGamma(k2, theta) {
      if ((k2 = +k2) < 0)
        throw new RangeError("invalid k");
      if (k2 === 0)
        return () => 0;
      theta = theta == null ? 1 : +theta;
      if (k2 === 1)
        return () => -Math.log1p(-source()) * theta;
      var d = (k2 < 1 ? k2 + 1 : k2) - 1 / 3, c2 = 1 / (3 * Math.sqrt(d)), multiplier = k2 < 1 ? () => Math.pow(source(), 1 / k2) : () => 1;
      return function() {
        do {
          do {
            var x2 = randomNormal(), v = 1 + c2 * x2;
          } while (v <= 0);
          v *= v * v;
          var u2 = 1 - source();
        } while (u2 >= 1 - 0.0331 * x2 * x2 * x2 * x2 && Math.log(u2) >= 0.5 * x2 * x2 + d * (1 - v + Math.log(v)));
        return d * v * multiplier() * theta;
      };
    }
    randomGamma.source = sourceRandomGamma;
    return randomGamma;
  }(defaultSource);
  const beta = function sourceRandomBeta(source) {
    var G = gamma.source(source);
    function randomBeta(alpha, beta2) {
      var X3 = G(alpha), Y3 = G(beta2);
      return function() {
        var x2 = X3();
        return x2 === 0 ? 0 : x2 / (x2 + Y3());
      };
    }
    randomBeta.source = sourceRandomBeta;
    return randomBeta;
  }(defaultSource);
  const binomial = function sourceRandomBinomial(source) {
    var G = geometric.source(source), B2 = beta.source(source);
    function randomBinomial(n, p) {
      n = +n;
      if ((p = +p) >= 1)
        return () => n;
      if (p <= 0)
        return () => 0;
      return function() {
        var acc = 0, nn = n, pp = p;
        while (nn * pp > 16 && nn * (1 - pp) > 16) {
          var i = Math.floor((nn + 1) * pp), y2 = B2(i, nn - i + 1)();
          if (y2 <= pp) {
            acc += i;
            nn -= i;
            pp = (pp - y2) / (1 - y2);
          } else {
            nn = i - 1;
            pp /= y2;
          }
        }
        var sign2 = pp < 0.5, pFinal = sign2 ? pp : 1 - pp, g = G(pFinal);
        for (var s2 = g(), k2 = 0; s2 <= nn; ++k2)
          s2 += g();
        return acc + (sign2 ? k2 : nn - k2);
      };
    }
    randomBinomial.source = sourceRandomBinomial;
    return randomBinomial;
  }(defaultSource);
  const weibull = function sourceRandomWeibull(source) {
    function randomWeibull(k2, a2, b) {
      var outerFunc;
      if ((k2 = +k2) === 0) {
        outerFunc = (x2) => -Math.log(x2);
      } else {
        k2 = 1 / k2;
        outerFunc = (x2) => Math.pow(x2, k2);
      }
      a2 = a2 == null ? 0 : +a2;
      b = b == null ? 1 : +b;
      return function() {
        return a2 + b * outerFunc(-Math.log1p(-source()));
      };
    }
    randomWeibull.source = sourceRandomWeibull;
    return randomWeibull;
  }(defaultSource);
  const cauchy = function sourceRandomCauchy(source) {
    function randomCauchy(a2, b) {
      a2 = a2 == null ? 0 : +a2;
      b = b == null ? 1 : +b;
      return function() {
        return a2 + b * Math.tan(Math.PI * source());
      };
    }
    randomCauchy.source = sourceRandomCauchy;
    return randomCauchy;
  }(defaultSource);
  const logistic = function sourceRandomLogistic(source) {
    function randomLogistic(a2, b) {
      a2 = a2 == null ? 0 : +a2;
      b = b == null ? 1 : +b;
      return function() {
        var u2 = source();
        return a2 + b * Math.log(u2 / (1 - u2));
      };
    }
    randomLogistic.source = sourceRandomLogistic;
    return randomLogistic;
  }(defaultSource);
  const poisson = function sourceRandomPoisson(source) {
    var G = gamma.source(source), B2 = binomial.source(source);
    function randomPoisson(lambda) {
      return function() {
        var acc = 0, l = lambda;
        while (l > 16) {
          var n = Math.floor(0.875 * l), t = G(n)();
          if (t > l)
            return acc + B2(n - 1, l / t)();
          acc += n;
          l -= t;
        }
        for (var s2 = -Math.log1p(-source()), k2 = 0; s2 <= l; ++k2)
          s2 -= Math.log1p(-source());
        return acc + k2;
      };
    }
    randomPoisson.source = sourceRandomPoisson;
    return randomPoisson;
  }(defaultSource);
  const mul = 1664525;
  const inc = 1013904223;
  const eps = 1 / 4294967296;
  function lcg(seed = Math.random()) {
    let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
    return () => (state = mul * state + inc | 0, eps * (state >>> 0));
  }
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function")
          this.interpolator(domain);
        else
          this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function")
          this.interpolator(interpolator);
        else
          this.range(interpolator);
        break;
      }
    }
    return this;
  }
  const implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale(d) {
      let i = index2.get(d);
      if (i === void 0) {
        if (unknown !== implicit)
          return unknown;
        index2.set(d, i = domain.push(d) - 1);
      }
      return range2[i % range2.length];
    }
    scale.domain = function(_2) {
      if (!arguments.length)
        return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _2) {
        if (index2.has(value))
          continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), scale) : range2.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse2 = r1 < r0, start2 = reverse2 ? r1 : r0, stop = reverse2 ? r0 : r1;
      step = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round)
        step = Math.floor(step);
      start2 += (stop - start2 - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round)
        start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values = range$2(n).map(function(i) {
        return start2 + step * i;
      });
      return ordinalRange(reverse2 ? values.reverse() : values);
    }
    scale.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale.range = function(_2) {
      return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_2) {
      return [r0, r1] = _2, r0 = +r0, r1 = +r1, round = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_2) {
      return arguments.length ? (round = !!_2, rescale()) : round;
    };
    scale.padding = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_2) {
      return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
    };
    scale.align = function(_2) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale) {
    var copy2 = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
      return pointish(copy2());
    };
    return scale;
  }
  function point$5() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }
  function constants(x2) {
    return function() {
      return x2;
    };
  }
  function number$1(x2) {
    return +x2;
  }
  var unit$1 = [0, 1];
  function identity$3(x2) {
    return x2;
  }
  function normalize$1(a2, b) {
    return (b -= a2 = +a2) ? function(x2) {
      return (x2 - a2) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a2, b) {
    var t;
    if (a2 > b)
      t = a2, a2 = b, b = t;
    return function(x2) {
      return Math.max(a2, Math.min(b, x2));
    };
  }
  function bimap(domain, range2, interpolate2) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0)
      d0 = normalize$1(d1, d0), r0 = interpolate2(r1, r0);
    else
      d0 = normalize$1(d0, d1), r0 = interpolate2(r0, r1);
    return function(x2) {
      return r0(d0(x2));
    };
  }
  function polymap(domain, range2, interpolate2) {
    var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize$1(domain[i], domain[i + 1]);
      r[i] = interpolate2(range2[i], range2[i + 1]);
    }
    return function(x2) {
      var i2 = bisect(domain, x2, 1, j) - 1;
      return r[i2](d[i2](x2));
    };
  }
  function copy$2(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer$2() {
    var domain = unit$1, range2 = unit$1, interpolate2 = interpolate$2, transform2, untransform, unknown, clamp = identity$3, piecewise2, output, input;
    function rescale() {
      var n = Math.min(domain.length, range2.length);
      if (clamp !== identity$3)
        clamp = clamper(domain[0], domain[n - 1]);
      piecewise2 = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate2)))(transform2(clamp(x2)));
    }
    scale.invert = function(y2) {
      return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform2), interpolateNumber)))(y2)));
    };
    scale.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number$1), rescale()) : domain.slice();
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
    };
    scale.rangeRound = function(_2) {
      return range2 = Array.from(_2), interpolate2 = interpolateRound, rescale();
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp = _2 ? true : identity$3, rescale()) : clamp !== identity$3;
    };
    scale.interpolate = function(_2) {
      return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t, u2) {
      transform2 = t, untransform = u2;
      return rescale();
    };
  }
  function continuous() {
    return transformer$2()(identity$3, identity$3);
  }
  function tickFormat(start2, stop, count2, specifier) {
    var step = tickStep(start2, stop, count2), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
          specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start2), Math.abs(stop)))))
          specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
          specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count2) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
    };
    scale.tickFormat = function(count2, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
    };
    scale.nice = function(count2) {
      if (count2 == null)
        count2 = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start2 = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start2) {
        step = start2, start2 = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start2, stop, count2);
        if (step === prestep) {
          d[i0] = start2;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start2 = Math.floor(start2 / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start2 = Math.ceil(start2 * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear() {
    var scale = continuous();
    scale.copy = function() {
      return copy$2(scale, linear());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }
  function identity$2(domain) {
    var unknown;
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
    }
    scale.invert = scale;
    scale.domain = scale.range = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number$1), scale) : domain.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return identity$2(domain).unknown(unknown);
    };
    domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
    return linearish(scale);
  }
  function nice(domain, interval2) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t;
    if (x12 < x02) {
      t = i0, i0 = i1, i1 = t;
      t = x02, x02 = x12, x12 = t;
    }
    domain[i0] = interval2.floor(x02);
    domain[i1] = interval2.ceil(x12);
    return domain;
  }
  function transformLog(x2) {
    return Math.log(x2);
  }
  function transformExp(x2) {
    return Math.exp(x2);
  }
  function transformLogn(x2) {
    return -Math.log(-x2);
  }
  function transformExpn(x2) {
    return -Math.exp(-x2);
  }
  function pow10(x2) {
    return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
  }
  function reflect(f) {
    return (x2, k2) => -f(-x2, k2);
  }
  function loggish(transform2) {
    const scale = transform2(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform2(transformLogn, transformExpn);
      } else {
        transform2(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function(_2) {
      return arguments.length ? (base = +_2, rescale()) : base;
    };
    scale.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale.ticks = (count2) => {
      const d = domain();
      let u2 = d[0];
      let v = d[d.length - 1];
      const r = v < u2;
      if (r)
        [u2, v] = [v, u2];
      let i = logs(u2);
      let j = logs(v);
      let k2;
      let t;
      const n = count2 == null ? 10 : +count2;
      let z = [];
      if (!(base % 1) && j - i < n) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u2 > 0)
          for (; i <= j; ++i) {
            for (k2 = 1; k2 < base; ++k2) {
              t = i < 0 ? k2 / pows(-i) : k2 * pows(i);
              if (t < u2)
                continue;
              if (t > v)
                break;
              z.push(t);
            }
          }
        else
          for (; i <= j; ++i) {
            for (k2 = base - 1; k2 >= 1; --k2) {
              t = i > 0 ? k2 / pows(-i) : k2 * pows(i);
              if (t < u2)
                continue;
              if (t > v)
                break;
              z.push(t);
            }
          }
        if (z.length * 2 < n)
          z = ticks(u2, v, n);
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }
      return r ? z.reverse() : z;
    };
    scale.tickFormat = (count2, specifier) => {
      if (count2 == null)
        count2 = 10;
      if (specifier == null)
        specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
          specifier.trim = true;
        specifier = format(specifier);
      }
      if (count2 === Infinity)
        return specifier;
      const k2 = Math.max(1, base * count2 / scale.ticks().length);
      return (d) => {
        let i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5)
          i *= base;
        return i <= k2 ? specifier(d) : "";
      };
    };
    scale.nice = () => {
      return domain(nice(domain(), {
        floor: (x2) => pows(Math.floor(logs(x2))),
        ceil: (x2) => pows(Math.ceil(logs(x2)))
      }));
    };
    return scale;
  }
  function log$1() {
    const scale = loggish(transformer$2()).domain([1, 10]);
    scale.copy = () => copy$2(scale, log$1()).base(scale.base());
    initRange.apply(scale, arguments);
    return scale;
  }
  function transformSymlog(c2) {
    return function(x2) {
      return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
    };
  }
  function transformSymexp(c2) {
    return function(x2) {
      return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
    };
  }
  function symlogish(transform2) {
    var c2 = 1, scale = transform2(transformSymlog(c2), transformSymexp(c2));
    scale.constant = function(_2) {
      return arguments.length ? transform2(transformSymlog(c2 = +_2), transformSymexp(c2)) : c2;
    };
    return linearish(scale);
  }
  function symlog() {
    var scale = symlogish(transformer$2());
    scale.copy = function() {
      return copy$2(scale, symlog()).constant(scale.constant());
    };
    return initRange.apply(scale, arguments);
  }
  function transformPow(exponent2) {
    return function(x2) {
      return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
    };
  }
  function transformSqrt(x2) {
    return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
  }
  function transformSquare(x2) {
    return x2 < 0 ? -x2 * x2 : x2 * x2;
  }
  function powish(transform2) {
    var scale = transform2(identity$3, identity$3), exponent2 = 1;
    function rescale() {
      return exponent2 === 1 ? transform2(identity$3, identity$3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
    }
    scale.exponent = function(_2) {
      return arguments.length ? (exponent2 = +_2, rescale()) : exponent2;
    };
    return linearish(scale);
  }
  function pow() {
    var scale = powish(transformer$2());
    scale.copy = function() {
      return copy$2(scale, pow()).exponent(scale.exponent());
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function sqrt$1() {
    return pow.apply(null, arguments).exponent(0.5);
  }
  function square$1(x2) {
    return Math.sign(x2) * x2 * x2;
  }
  function unsquare(x2) {
    return Math.sign(x2) * Math.sqrt(Math.abs(x2));
  }
  function radial() {
    var squared = continuous(), range2 = [0, 1], round = false, unknown;
    function scale(x2) {
      var y2 = unsquare(squared(x2));
      return isNaN(y2) ? unknown : round ? Math.round(y2) : y2;
    }
    scale.invert = function(y2) {
      return squared.invert(square$1(y2));
    };
    scale.domain = function(_2) {
      return arguments.length ? (squared.domain(_2), scale) : squared.domain();
    };
    scale.range = function(_2) {
      return arguments.length ? (squared.range((range2 = Array.from(_2, number$1)).map(square$1)), scale) : range2.slice();
    };
    scale.rangeRound = function(_2) {
      return scale.range(_2).round(true);
    };
    scale.round = function(_2) {
      return arguments.length ? (round = !!_2, scale) : round;
    };
    scale.clamp = function(_2) {
      return arguments.length ? (squared.clamp(_2), scale) : squared.clamp();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return radial(squared.domain(), range2).round(round).clamp(squared.clamp()).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }
  function quantile() {
    var domain = [], range2 = [], thresholds = [], unknown;
    function rescale() {
      var i = 0, n = Math.max(1, range2.length);
      thresholds = new Array(n - 1);
      while (++i < n)
        thresholds[i - 1] = quantileSorted(domain, i / n);
      return scale;
    }
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : range2[bisect(thresholds, x2)];
    }
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };
    scale.domain = function(_2) {
      if (!arguments.length)
        return domain.slice();
      domain = [];
      for (let d of _2)
        if (d != null && !isNaN(d = +d))
          domain.push(d);
      domain.sort(ascending$3);
      return rescale();
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.quantiles = function() {
      return thresholds.slice();
    };
    scale.copy = function() {
      return quantile().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }
  function quantize() {
    var x02 = 0, x12 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range2[bisect(domain, x2, 0, n)] : unknown;
    }
    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n)
        domain[i] = ((i + 1) * x12 - (i - n) * x02) / (n + 1);
      return scale;
    }
    scale.domain = function(_2) {
      return arguments.length ? ([x02, x12] = _2, x02 = +x02, x12 = +x12, rescale()) : [x02, x12];
    };
    scale.range = function(_2) {
      return arguments.length ? (n = (range2 = Array.from(_2)).length - 1, rescale()) : range2.slice();
    };
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return i < 0 ? [NaN, NaN] : i < 1 ? [x02, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : scale;
    };
    scale.thresholds = function() {
      return domain.slice();
    };
    scale.copy = function() {
      return quantize().domain([x02, x12]).range(range2).unknown(unknown);
    };
    return initRange.apply(linearish(scale), arguments);
  }
  function threshold() {
    var domain = [0.5], range2 = [0, 1], unknown, n = 1;
    function scale(x2) {
      return x2 != null && x2 <= x2 ? range2[bisect(domain, x2, 0, n)] : unknown;
    }
    scale.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
    };
    scale.invertExtent = function(y2) {
      var i = range2.indexOf(y2);
      return [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return threshold().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }
  var t0 = new Date(), t1 = new Date();
  function newInterval(floori, offseti, count2, field) {
    function interval2(date2) {
      return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
    }
    interval2.floor = function(date2) {
      return floori(date2 = new Date(+date2)), date2;
    };
    interval2.ceil = function(date2) {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval2.round = function(date2) {
      var d0 = interval2(date2), d1 = interval2.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval2.offset = function(date2, step) {
      return offseti(date2 = new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval2.range = function(start2, stop, step) {
      var range2 = [], previous;
      start2 = interval2.ceil(start2);
      step = step == null ? 1 : Math.floor(step);
      if (!(start2 < stop) || !(step > 0))
        return range2;
      do
        range2.push(previous = new Date(+start2)), offseti(start2, step), floori(start2);
      while (previous < start2 && start2 < stop);
      return range2;
    };
    interval2.filter = function(test) {
      return newInterval(function(date2) {
        if (date2 >= date2)
          while (floori(date2), !test(date2))
            date2.setTime(date2 - 1);
      }, function(date2, step) {
        if (date2 >= date2) {
          if (step < 0)
            while (++step <= 0) {
              while (offseti(date2, -1), !test(date2)) {
              }
            }
          else
            while (--step >= 0) {
              while (offseti(date2, 1), !test(date2)) {
              }
            }
        }
      });
    };
    if (count2) {
      interval2.count = function(start2, end2) {
        t0.setTime(+start2), t1.setTime(+end2);
        floori(t0), floori(t1);
        return Math.floor(count2(t0, t1));
      };
      interval2.every = function(step) {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval2 : interval2.filter(field ? function(d) {
          return field(d) % step === 0;
        } : function(d) {
          return interval2.count(0, d) % step === 0;
        });
      };
    }
    return interval2;
  }
  var millisecond = newInterval(function() {
  }, function(date2, step) {
    date2.setTime(+date2 + step);
  }, function(start2, end2) {
    return end2 - start2;
  });
  millisecond.every = function(k2) {
    k2 = Math.floor(k2);
    if (!isFinite(k2) || !(k2 > 0))
      return null;
    if (!(k2 > 1))
      return millisecond;
    return newInterval(function(date2) {
      date2.setTime(Math.floor(date2 / k2) * k2);
    }, function(date2, step) {
      date2.setTime(+date2 + step * k2);
    }, function(start2, end2) {
      return (end2 - start2) / k2;
    });
  };
  const millisecond$1 = millisecond;
  var milliseconds = millisecond.range;
  const durationSecond = 1e3;
  const durationMinute = durationSecond * 60;
  const durationHour = durationMinute * 60;
  const durationDay = durationHour * 24;
  const durationWeek = durationDay * 7;
  const durationMonth = durationDay * 30;
  const durationYear = durationDay * 365;
  var second = newInterval(function(date2) {
    date2.setTime(date2 - date2.getMilliseconds());
  }, function(date2, step) {
    date2.setTime(+date2 + step * durationSecond);
  }, function(start2, end2) {
    return (end2 - start2) / durationSecond;
  }, function(date2) {
    return date2.getUTCSeconds();
  });
  const utcSecond = second;
  var seconds = second.range;
  var minute = newInterval(function(date2) {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, function(date2, step) {
    date2.setTime(+date2 + step * durationMinute);
  }, function(start2, end2) {
    return (end2 - start2) / durationMinute;
  }, function(date2) {
    return date2.getMinutes();
  });
  const timeMinute = minute;
  var minutes = minute.range;
  var hour = newInterval(function(date2) {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, function(date2, step) {
    date2.setTime(+date2 + step * durationHour);
  }, function(start2, end2) {
    return (end2 - start2) / durationHour;
  }, function(date2) {
    return date2.getHours();
  });
  const timeHour = hour;
  var hours = hour.range;
  var day = newInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  const timeDay = day;
  var days = day.range;
  function weekday(i) {
    return newInterval(function(date2) {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setDate(date2.getDate() + step * 7);
    }, function(start2, end2) {
      return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  var sunday = weekday(0);
  var monday = weekday(1);
  var tuesday = weekday(2);
  var wednesday = weekday(3);
  var thursday = weekday(4);
  var friday = weekday(5);
  var saturday = weekday(6);
  var sundays = sunday.range;
  var mondays = monday.range;
  var tuesdays = tuesday.range;
  var wednesdays = wednesday.range;
  var thursdays = thursday.range;
  var fridays = friday.range;
  var saturdays = saturday.range;
  var month = newInterval(function(date2) {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setMonth(date2.getMonth() + step);
  }, function(start2, end2) {
    return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
  }, function(date2) {
    return date2.getMonth();
  });
  const timeMonth = month;
  var months = month.range;
  var year = newInterval(function(date2) {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setFullYear(date2.getFullYear() + step);
  }, function(start2, end2) {
    return end2.getFullYear() - start2.getFullYear();
  }, function(date2) {
    return date2.getFullYear();
  });
  year.every = function(k2) {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
      date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setFullYear(date2.getFullYear() + step * k2);
    });
  };
  const timeYear = year;
  var years = year.range;
  var utcMinute = newInterval(function(date2) {
    date2.setUTCSeconds(0, 0);
  }, function(date2, step) {
    date2.setTime(+date2 + step * durationMinute);
  }, function(start2, end2) {
    return (end2 - start2) / durationMinute;
  }, function(date2) {
    return date2.getUTCMinutes();
  });
  const utcMinute$1 = utcMinute;
  var utcMinutes = utcMinute.range;
  var utcHour = newInterval(function(date2) {
    date2.setUTCMinutes(0, 0, 0);
  }, function(date2, step) {
    date2.setTime(+date2 + step * durationHour);
  }, function(start2, end2) {
    return (end2 - start2) / durationHour;
  }, function(date2) {
    return date2.getUTCHours();
  });
  const utcHour$1 = utcHour;
  var utcHours = utcHour.range;
  var utcDay = newInterval(function(date2) {
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, function(start2, end2) {
    return (end2 - start2) / durationDay;
  }, function(date2) {
    return date2.getUTCDate() - 1;
  });
  const utcDay$1 = utcDay;
  var utcDays = utcDay.range;
  function utcWeekday(i) {
    return newInterval(function(date2) {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, function(start2, end2) {
      return (end2 - start2) / durationWeek;
    });
  }
  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;
  var utcMonth = newInterval(function(date2) {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, function(start2, end2) {
    return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
  }, function(date2) {
    return date2.getUTCMonth();
  });
  const utcMonth$1 = utcMonth;
  var utcMonths = utcMonth.range;
  var utcYear = newInterval(function(date2) {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, function(start2, end2) {
    return end2.getUTCFullYear() - start2.getUTCFullYear();
  }, function(date2) {
    return date2.getUTCFullYear();
  });
  utcYear.every = function(k2) {
    return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, function(date2, step) {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
    });
  };
  const utcYear$1 = utcYear;
  var utcYears = utcYear.range;
  function ticker(year2, month2, week, day2, hour2, minute2) {
    const tickIntervals = [
      [utcSecond, 1, durationSecond],
      [utcSecond, 5, 5 * durationSecond],
      [utcSecond, 15, 15 * durationSecond],
      [utcSecond, 30, 30 * durationSecond],
      [minute2, 1, durationMinute],
      [minute2, 5, 5 * durationMinute],
      [minute2, 15, 15 * durationMinute],
      [minute2, 30, 30 * durationMinute],
      [hour2, 1, durationHour],
      [hour2, 3, 3 * durationHour],
      [hour2, 6, 6 * durationHour],
      [hour2, 12, 12 * durationHour],
      [day2, 1, durationDay],
      [day2, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month2, 1, durationMonth],
      [month2, 3, 3 * durationMonth],
      [year2, 1, durationYear]
    ];
    function ticks2(start2, stop, count2) {
      const reverse2 = stop < start2;
      if (reverse2)
        [start2, stop] = [stop, start2];
      const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
      const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
      return reverse2 ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start2, stop, count2) {
      const target = Math.abs(stop - start2) / count2;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length)
        return year2.every(tickStep(start2 / durationYear, stop / durationYear, count2));
      if (i === 0)
        return millisecond$1.every(Math.max(tickStep(start2, stop, count2), 1));
      const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t.every(step);
    }
    return [ticks2, tickInterval];
  }
  const [utcTicks, utcTickInterval] = ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
  const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);
  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date2.setFullYear(d.y);
      return date2;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date2.setUTCFullYear(d.y);
      return date2;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newDate(y2, m2, d) {
    return { y: y2, m: m2, d, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale2) {
    var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
        if (!(date2 instanceof Date))
          date2 = new Date(+date2);
        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
              c2 = specifier.charAt(++i);
            else
              pad2 = c2 === "e" ? " " : "0";
            if (format2 = formats2[c2])
              c2 = format2(date2, pad2);
            string.push(c2);
            j = i + 1;
          }
        }
        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }
    function newParse(specifier, Z) {
      return function(string) {
        var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
        if (i != string.length)
          return null;
        if ("Q" in d)
          return new Date(d.Q);
        if ("s" in d)
          return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
        if (Z && !("Z" in d))
          d.Z = 0;
        if ("p" in d)
          d.H = d.H % 12 + d.p * 12;
        if (d.m === void 0)
          d.m = "q" in d ? d.q : 0;
        if ("V" in d) {
          if (d.V < 1 || d.V > 53)
            return null;
          if (!("w" in d))
            d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
            week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay$1.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
            week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
            week = timeDay.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d))
            d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
        }
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }
        return localDate(d);
      };
    }
    function parseSpecifier(d, specifier, string, j) {
      var i = 0, n = specifier.length, m2 = string.length, c2, parse2;
      while (i < n) {
        if (j >= m2)
          return -1;
        c2 = specifier.charCodeAt(i++);
        if (c2 === 37) {
          c2 = specifier.charAt(i++);
          parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
          if (!parse2 || (j = parse2(d, string, j)) < 0)
            return -1;
        } else if (c2 != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() {
          return specifier;
        };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad(value, fill, width2) {
    var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length2 = string.length;
    return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
  }
  function requote(s2) {
    return s2.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }
  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }
  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
  }
  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }
  function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }
  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }
  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }
  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }
  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }
  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }
  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }
  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }
  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
  }
  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }
  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }
  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }
  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear(d, p) {
    return pad(1 + timeDay.count(timeYear(d), d), p, 3);
  }
  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }
  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }
  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }
  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday(d) {
    var day2 = d.getDay();
    return day2 === 0 ? 7 : day2;
  }
  function formatWeekNumberSunday(d, p) {
    return pad(sunday.count(timeYear(d) - 1, d), p, 2);
  }
  function dISO(d) {
    var day2 = d.getDay();
    return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  }
  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday(d, p) {
    return pad(monday.count(timeYear(d) - 1, d), p, 2);
  }
  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatYearISO(d, p) {
    d = dISO(d);
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatFullYearISO(d, p) {
    var day2 = d.getDay();
    d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
  }
  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }
  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
  }
  function UTCdISO(d) {
    var day2 = d.getUTCDay();
    return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  }
  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
  }
  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCFullYearISO(d, p) {
    var day2 = d.getUTCDay();
    d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d) {
    return +d;
  }
  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1e3);
  }
  var locale;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale(definition) {
    locale = formatLocale(definition);
    timeFormat = locale.format;
    timeParse = locale.parse;
    utcFormat = locale.utcFormat;
    utcParse = locale.utcParse;
    return locale;
  }
  var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
  function formatIsoNative(date2) {
    return date2.toISOString();
  }
  var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
  const formatIso$1 = formatIso;
  function parseIsoNative(string) {
    var date2 = new Date(string);
    return isNaN(date2) ? null : date2;
  }
  var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
  const parseIso$1 = parseIso;
  function date(t) {
    return new Date(t);
  }
  function number(t) {
    return t instanceof Date ? +t : +new Date(+t);
  }
  function calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
    var scale = continuous(), invert2 = scale.invert, domain = scale.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
    }
    scale.invert = function(y2) {
      return new Date(invert2(y2));
    };
    scale.domain = function(_2) {
      return arguments.length ? domain(Array.from(_2, number)) : domain().map(date);
    };
    scale.ticks = function(interval2) {
      var d = domain();
      return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    };
    scale.tickFormat = function(count2, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale.nice = function(interval2) {
      var d = domain();
      if (!interval2 || typeof interval2.range !== "function")
        interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
      return interval2 ? domain(nice(d, interval2)) : scale;
    };
    scale.copy = function() {
      return copy$2(scale, calendar(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
    };
    return scale;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }
  function transformer$1() {
    var x02 = 0, x12 = 1, t02, t12, k10, transform2, interpolator = identity$3, clamp = false, unknown;
    function scale(x2) {
      return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
    }
    scale.domain = function(_2) {
      return arguments.length ? ([x02, x12] = _2, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x02, x12];
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp = !!_2, scale) : clamp;
    };
    scale.interpolator = function(_2) {
      return arguments.length ? (interpolator = _2, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_2) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _2, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
      };
    }
    scale.range = range2(interpolate$2);
    scale.rangeRound = range2(interpolateRound);
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t) {
      transform2 = t, t02 = t(x02), t12 = t(x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
      return scale;
    };
  }
  function copy$1(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
  }
  function sequential() {
    var scale = linearish(transformer$1()(identity$3));
    scale.copy = function() {
      return copy$1(scale, sequential());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialLog() {
    var scale = loggish(transformer$1()).domain([1, 10]);
    scale.copy = function() {
      return copy$1(scale, sequentialLog()).base(scale.base());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialSymlog() {
    var scale = symlogish(transformer$1());
    scale.copy = function() {
      return copy$1(scale, sequentialSymlog()).constant(scale.constant());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialPow() {
    var scale = powish(transformer$1());
    scale.copy = function() {
      return copy$1(scale, sequentialPow()).exponent(scale.exponent());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function sequentialSqrt() {
    return sequentialPow.apply(null, arguments).exponent(0.5);
  }
  function sequentialQuantile() {
    var domain = [], interpolator = identity$3;
    function scale(x2) {
      if (x2 != null && !isNaN(x2 = +x2))
        return interpolator((bisect(domain, x2, 1) - 1) / (domain.length - 1));
    }
    scale.domain = function(_2) {
      if (!arguments.length)
        return domain.slice();
      domain = [];
      for (let d of _2)
        if (d != null && !isNaN(d = +d))
          domain.push(d);
      domain.sort(ascending$3);
      return scale;
    };
    scale.interpolator = function(_2) {
      return arguments.length ? (interpolator = _2, scale) : interpolator;
    };
    scale.range = function() {
      return domain.map((d, i) => interpolator(i / (domain.length - 1)));
    };
    scale.quantiles = function(n) {
      return Array.from({ length: n + 1 }, (_2, i) => quantile$1(domain, i / n));
    };
    scale.copy = function() {
      return sequentialQuantile(interpolator).domain(domain);
    };
    return initInterpolator.apply(scale, arguments);
  }
  function transformer() {
    var x02 = 0, x12 = 0.5, x2 = 1, s2 = 1, t02, t12, t22, k10, k21, interpolator = identity$3, transform2, clamp = false, unknown;
    function scale(x3) {
      return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
    }
    scale.domain = function(_2) {
      return arguments.length ? ([x02, x12, x2] = _2, t02 = transform2(x02 = +x02), t12 = transform2(x12 = +x12), t22 = transform2(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1, scale) : [x02, x12, x2];
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp = !!_2, scale) : clamp;
    };
    scale.interpolator = function(_2) {
      return arguments.length ? (interpolator = _2, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_2) {
        var r0, r1, r2;
        return arguments.length ? ([r0, r1, r2] = _2, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
      };
    }
    scale.range = range2(interpolate$2);
    scale.rangeRound = range2(interpolateRound);
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t) {
      transform2 = t, t02 = t(x02), t12 = t(x12), t22 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), s2 = t12 < t02 ? -1 : 1;
      return scale;
    };
  }
  function diverging$1() {
    var scale = linearish(transformer()(identity$3));
    scale.copy = function() {
      return copy$1(scale, diverging$1());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingLog() {
    var scale = loggish(transformer()).domain([0.1, 1, 10]);
    scale.copy = function() {
      return copy$1(scale, divergingLog()).base(scale.base());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingSymlog() {
    var scale = symlogish(transformer());
    scale.copy = function() {
      return copy$1(scale, divergingSymlog()).constant(scale.constant());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingPow() {
    var scale = powish(transformer());
    scale.copy = function() {
      return copy$1(scale, divergingPow()).exponent(scale.exponent());
    };
    return initInterpolator.apply(scale, arguments);
  }
  function divergingSqrt() {
    return divergingPow.apply(null, arguments).exponent(0.5);
  }
  function colors(specifier) {
    var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
    while (i < n)
      colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors2;
  }
  const category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
  const Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
  const Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
  const Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
  const Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
  const Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
  const Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
  const Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
  const Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
  const Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
  const ramp$1 = (scheme2) => rgbBasis(scheme2[scheme2.length - 1]);
  var scheme$q = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors);
  const BrBG = ramp$1(scheme$q);
  var scheme$p = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors);
  const PRGn = ramp$1(scheme$p);
  var scheme$o = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors);
  const PiYG = ramp$1(scheme$o);
  var scheme$n = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors);
  const PuOr = ramp$1(scheme$n);
  var scheme$m = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors);
  const RdBu = ramp$1(scheme$m);
  var scheme$l = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors);
  const RdGy = ramp$1(scheme$l);
  var scheme$k = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors);
  const RdYlBu = ramp$1(scheme$k);
  var scheme$j = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors);
  const RdYlGn = ramp$1(scheme$j);
  var scheme$i = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors);
  const Spectral = ramp$1(scheme$i);
  var scheme$h = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors);
  const BuGn = ramp$1(scheme$h);
  var scheme$g = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors);
  const BuPu = ramp$1(scheme$g);
  var scheme$f = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors);
  const GnBu = ramp$1(scheme$f);
  var scheme$e = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors);
  const OrRd = ramp$1(scheme$e);
  var scheme$d = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors);
  const PuBuGn = ramp$1(scheme$d);
  var scheme$c = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors);
  const PuBu = ramp$1(scheme$c);
  var scheme$b = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors);
  const PuRd = ramp$1(scheme$b);
  var scheme$a = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors);
  const RdPu = ramp$1(scheme$a);
  var scheme$9 = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors);
  const YlGnBu = ramp$1(scheme$9);
  var scheme$8 = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors);
  const YlGn = ramp$1(scheme$8);
  var scheme$7 = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors);
  const YlOrBr = ramp$1(scheme$7);
  var scheme$6 = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors);
  const YlOrRd = ramp$1(scheme$6);
  var scheme$5 = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors);
  const Blues = ramp$1(scheme$5);
  var scheme$4 = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors);
  const Greens = ramp$1(scheme$4);
  var scheme$3 = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors);
  const Greys = ramp$1(scheme$3);
  var scheme$2 = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors);
  const Purples = ramp$1(scheme$2);
  var scheme$1 = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors);
  const Reds = ramp$1(scheme$1);
  var scheme = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors);
  const Oranges = ramp$1(scheme);
  function cividis(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
  }
  const cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0), cubehelix$3(-240, 0.5, 1));
  var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
  var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
  var c$3 = cubehelix$3();
  function rainbow(t) {
    if (t < 0 || t > 1)
      t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c$3.h = 360 * t - 100;
    c$3.s = 1.5 - 1.5 * ts;
    c$3.l = 0.8 - 0.9 * ts;
    return c$3 + "";
  }
  var c$2 = rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
  function sinebow(t) {
    var x2;
    t = (0.5 - t) * Math.PI;
    c$2.r = 255 * (x2 = Math.sin(t)) * x2;
    c$2.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
    c$2.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
    return c$2 + "";
  }
  function turbo(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
  }
  function ramp(range2) {
    var n = range2.length;
    return function(t) {
      return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
    };
  }
  const viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
  var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
  var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
  var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
  function constant$1(x2) {
    return function constant2() {
      return x2;
    };
  }
  const abs$1 = Math.abs;
  const atan2 = Math.atan2;
  const cos = Math.cos;
  const max = Math.max;
  const min = Math.min;
  const sin = Math.sin;
  const sqrt = Math.sqrt;
  const epsilon = 1e-12;
  const pi = Math.PI;
  const halfPi = pi / 2;
  const tau = 2 * pi;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
  }
  function arcInnerRadius(d) {
    return d.innerRadius;
  }
  function arcOuterRadius(d) {
    return d.outerRadius;
  }
  function arcStartAngle(d) {
    return d.startAngle;
  }
  function arcEndAngle(d) {
    return d.endAngle;
  }
  function arcPadAngle(d) {
    return d && d.padAngle;
  }
  function intersect$2(x02, y02, x12, y12, x2, y2, x3, y3) {
    var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
    if (t * t < epsilon)
      return;
    t = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t;
    return [x02 + t * x10, y02 + t * y10];
  }
  function cornerTangents(x02, y02, x12, y12, r1, rc, cw) {
    var x01 = x02 - x12, y01 = y02 - y12, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
      cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }
  function d3arc() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$1(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
    function arc() {
      var buffer2, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs$1(a1 - a0), cw = a1 > a0;
      if (!context)
        context = buffer2 = path();
      if (r1 < r0)
        r = r1, r1 = r0, r0 = r;
      if (!(r1 > epsilon))
        context.moveTo(0, 0);
      else if (da > tau - epsilon) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw);
        if (r0 > epsilon) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
        if (rp > epsilon) {
          var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p02 * 2) > epsilon)
            p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
          else
            da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon)
            p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
          else
            da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
        if (rc > epsilon) {
          var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x002 = r0 * cos(a00), y002 = r0 * sin(a00), oc;
          if (da < pi && (oc = intersect$2(x01, y01, x002, y002, x11, y11, x10, y10))) {
            var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
            rc0 = min(rc, (r0 - lc) / (kc - 1));
            rc1 = min(rc, (r1 - lc) / (kc + 1));
          }
        }
        if (!(da1 > epsilon))
          context.moveTo(x01, y01);
        else if (rc1 > epsilon) {
          t02 = cornerTangents(x002, y002, x01, y01, r1, rc1, cw);
          t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
          context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc1 < rc)
            context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
            context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else
          context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
        if (!(r0 > epsilon) || !(da0 > epsilon))
          context.lineTo(x10, y10);
        else if (rc0 > epsilon) {
          t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
          t12 = cornerTangents(x01, y01, x002, y002, r0, -rc0, cw);
          context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
          if (rc0 < rc)
            context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
          else {
            context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
            context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
            context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
          }
        } else
          context.arc(0, 0, r0, a10, a00, cw);
      }
      context.closePath();
      if (buffer2)
        return context = null, buffer2 + "" || null;
    }
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
      return [cos(a2) * r, sin(a2) * r];
    };
    arc.innerRadius = function(_2) {
      return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : innerRadius;
    };
    arc.outerRadius = function(_2) {
      return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : outerRadius;
    };
    arc.cornerRadius = function(_2) {
      return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : cornerRadius;
    };
    arc.padRadius = function(_2) {
      return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant$1(+_2), arc) : padRadius;
    };
    arc.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : startAngle;
    };
    arc.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : endAngle;
    };
    arc.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$1(+_2), arc) : padAngle;
    };
    arc.context = function(_2) {
      return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
    };
    return arc;
  }
  var slice$1 = Array.prototype.slice;
  function array(x2) {
    return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
  }
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x2, y2);
          break;
      }
    }
  };
  function curveLinear(context) {
    return new Linear(context);
  }
  function x$1(p) {
    return p[0];
  }
  function y(p) {
    return p[1];
  }
  function line$1(x2, y$12) {
    var defined = constant$1(true), context = null, curve = curveLinear, output = null;
    x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$1 : constant$1(x2);
    y$12 = typeof y$12 === "function" ? y$12 : y$12 === void 0 ? y : constant$1(y$12);
    function line2(data) {
      var i, n = (data = array(data)).length, d, defined0 = false, buffer2;
      if (context == null)
        output = curve(buffer2 = path());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0)
            output.lineStart();
          else
            output.lineEnd();
        }
        if (defined0)
          output.point(+x2(d, i, data), +y$12(d, i, data));
      }
      if (buffer2)
        return output = null, buffer2 + "" || null;
    }
    line2.x = function(_2) {
      return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$1(+_2), line2) : x2;
    };
    line2.y = function(_2) {
      return arguments.length ? (y$12 = typeof _2 === "function" ? _2 : constant$1(+_2), line2) : y$12;
    };
    line2.defined = function(_2) {
      return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$1(!!_2), line2) : defined;
    };
    line2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
    };
    line2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
    };
    return line2;
  }
  function area(x02, y02, y12) {
    var x12 = null, defined = constant$1(true), context = null, curve = curveLinear, output = null;
    x02 = typeof x02 === "function" ? x02 : x02 === void 0 ? x$1 : constant$1(+x02);
    y02 = typeof y02 === "function" ? y02 : y02 === void 0 ? constant$1(0) : constant$1(+y02);
    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant$1(+y12);
    function area2(data) {
      var i, j, k2, n = (data = array(data)).length, d, defined0 = false, buffer2, x0z = new Array(n), y0z = new Array(n);
      if (context == null)
        output = curve(buffer2 = path());
      for (i = 0; i <= n; ++i) {
        if (!(i < n && defined(d = data[i], i, data)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k2 = i - 1; k2 >= j; --k2) {
              output.point(x0z[k2], y0z[k2]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x02(d, i, data), y0z[i] = +y02(d, i, data);
          output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
        }
      }
      if (buffer2)
        return output = null, buffer2 + "" || null;
    }
    function arealine() {
      return line$1().defined(defined).curve(curve).context(context);
    }
    area2.x = function(_2) {
      return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$1(+_2), x12 = null, area2) : x02;
    };
    area2.x0 = function(_2) {
      return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$1(+_2), area2) : x02;
    };
    area2.x1 = function(_2) {
      return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$1(+_2), area2) : x12;
    };
    area2.y = function(_2) {
      return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$1(+_2), y12 = null, area2) : y02;
    };
    area2.y0 = function(_2) {
      return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$1(+_2), area2) : y02;
    };
    area2.y1 = function(_2) {
      return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$1(+_2), area2) : y12;
    };
    area2.lineX0 = area2.lineY0 = function() {
      return arealine().x(x02).y(y02);
    };
    area2.lineY1 = function() {
      return arealine().x(x02).y(y12);
    };
    area2.lineX1 = function() {
      return arealine().x(x12).y(y02);
    };
    area2.defined = function(_2) {
      return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$1(!!_2), area2) : defined;
    };
    area2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
    };
    area2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
    };
    return area2;
  }
  function descending$1(a2, b) {
    return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
  }
  function identity$1(d) {
    return d;
  }
  function d3pie() {
    var value = identity$1, sortValues = descending$1, sort2 = null, startAngle = constant$1(0), endAngle = constant$1(tau), padAngle = constant$1(0);
    function pie(data) {
      var i, n = (data = array(data)).length, j, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
      for (i = 0; i < n; ++i) {
        if ((v = arcs[index2[i] = i] = +value(data[i], i, data)) > 0) {
          sum2 += v;
        }
      }
      if (sortValues != null)
        index2.sort(function(i2, j2) {
          return sortValues(arcs[i2], arcs[j2]);
        });
      else if (sort2 != null)
        index2.sort(function(i2, j2) {
          return sort2(data[i2], data[j2]);
        });
      for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
        j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }
      return arcs;
    }
    pie.value = function(_2) {
      return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$1(+_2), pie) : value;
    };
    pie.sortValues = function(_2) {
      return arguments.length ? (sortValues = _2, sort2 = null, pie) : sortValues;
    };
    pie.sort = function(_2) {
      return arguments.length ? (sort2 = _2, sortValues = null, pie) : sort2;
    };
    pie.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$1(+_2), pie) : startAngle;
    };
    pie.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$1(+_2), pie) : endAngle;
    };
    pie.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$1(+_2), pie) : padAngle;
    };
    return pie;
  }
  var curveRadialLinear = curveRadial(curveLinear);
  function Radial(curve) {
    this._curve = curve;
  }
  Radial.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a2, r) {
      this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
    }
  };
  function curveRadial(curve) {
    function radial2(context) {
      return new Radial(curve(context));
    }
    radial2._curve = curve;
    return radial2;
  }
  function lineRadial(l) {
    var c2 = l.curve;
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    l.curve = function(_2) {
      return arguments.length ? c2(curveRadial(_2)) : c2()._curve;
    };
    return l;
  }
  function lineRadial$1() {
    return lineRadial(line$1().curve(curveRadialLinear));
  }
  function areaRadial() {
    var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x02 = a2.lineX0, x12 = a2.lineX1, y02 = a2.lineY0, y12 = a2.lineY1;
    a2.angle = a2.x, delete a2.x;
    a2.startAngle = a2.x0, delete a2.x0;
    a2.endAngle = a2.x1, delete a2.x1;
    a2.radius = a2.y, delete a2.y;
    a2.innerRadius = a2.y0, delete a2.y0;
    a2.outerRadius = a2.y1, delete a2.y1;
    a2.lineStartAngle = function() {
      return lineRadial(x02());
    }, delete a2.lineX0;
    a2.lineEndAngle = function() {
      return lineRadial(x12());
    }, delete a2.lineX1;
    a2.lineInnerRadius = function() {
      return lineRadial(y02());
    }, delete a2.lineY0;
    a2.lineOuterRadius = function() {
      return lineRadial(y12());
    }, delete a2.lineY1;
    a2.curve = function(_2) {
      return arguments.length ? c2(curveRadial(_2)) : c2()._curve;
    };
    return a2;
  }
  function pointRadial(x2, y2) {
    return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
  }
  class Bump {
    constructor(context, x2) {
      this._context = context;
      this._x = x2;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    }
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0: {
          this._point = 1;
          if (this._line)
            this._context.lineTo(x2, y2);
          else
            this._context.moveTo(x2, y2);
          break;
        }
        case 1:
          this._point = 2;
        default: {
          if (this._x)
            this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
          else
            this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
          break;
        }
      }
      this._x0 = x2, this._y0 = y2;
    }
  }
  class BumpRadial {
    constructor(context) {
      this._context = context;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
    }
    point(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point++ === 0) {
        this._x0 = x2, this._y0 = y2;
      } else {
        const p02 = pointRadial(this._x0, this._y0);
        const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y2) / 2);
        const p2 = pointRadial(x2, this._y0);
        const p3 = pointRadial(x2, y2);
        this._context.moveTo(...p02);
        this._context.bezierCurveTo(...p1, ...p2, ...p3);
      }
    }
  }
  function bumpX(context) {
    return new Bump(context, true);
  }
  function bumpY(context) {
    return new Bump(context, false);
  }
  function bumpRadial(context) {
    return new BumpRadial(context);
  }
  function linkSource(d) {
    return d.source;
  }
  function linkTarget(d) {
    return d.target;
  }
  function link(curve) {
    let source = linkSource;
    let target = linkTarget;
    let x2 = x$1;
    let y$12 = y;
    let context = null;
    let output = null;
    function link2() {
      let buffer2;
      const argv = slice$1.call(arguments);
      const s2 = source.apply(this, argv);
      const t = target.apply(this, argv);
      if (context == null)
        output = curve(buffer2 = path());
      output.lineStart();
      argv[0] = s2, output.point(+x2.apply(this, argv), +y$12.apply(this, argv));
      argv[0] = t, output.point(+x2.apply(this, argv), +y$12.apply(this, argv));
      output.lineEnd();
      if (buffer2)
        return output = null, buffer2 + "" || null;
    }
    link2.source = function(_2) {
      return arguments.length ? (source = _2, link2) : source;
    };
    link2.target = function(_2) {
      return arguments.length ? (target = _2, link2) : target;
    };
    link2.x = function(_2) {
      return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$1(+_2), link2) : x2;
    };
    link2.y = function(_2) {
      return arguments.length ? (y$12 = typeof _2 === "function" ? _2 : constant$1(+_2), link2) : y$12;
    };
    link2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), link2) : context;
    };
    return link2;
  }
  function linkHorizontal() {
    return link(bumpX);
  }
  function linkVertical() {
    return link(bumpY);
  }
  function linkRadial() {
    const l = link(bumpRadial);
    l.angle = l.x, delete l.x;
    l.radius = l.y, delete l.y;
    return l;
  }
  const sqrt3$2 = sqrt(3);
  const asterisk = {
    draw(context, size) {
      const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;
      const t = r / 2;
      const u2 = t * sqrt3$2;
      context.moveTo(0, r);
      context.lineTo(0, -r);
      context.moveTo(-u2, -t);
      context.lineTo(u2, t);
      context.moveTo(-u2, t);
      context.lineTo(u2, -t);
    }
  };
  const circle$2 = {
    draw(context, size) {
      const r = sqrt(size / pi);
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, tau);
    }
  };
  const cross$1 = {
    draw(context, size) {
      const r = sqrt(size / 5) / 2;
      context.moveTo(-3 * r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, -3 * r);
      context.lineTo(r, -3 * r);
      context.lineTo(r, -r);
      context.lineTo(3 * r, -r);
      context.lineTo(3 * r, r);
      context.lineTo(r, r);
      context.lineTo(r, 3 * r);
      context.lineTo(-r, 3 * r);
      context.lineTo(-r, r);
      context.lineTo(-3 * r, r);
      context.closePath();
    }
  };
  const tan30 = sqrt(1 / 3);
  const tan30_2 = tan30 * 2;
  const diamond = {
    draw(context, size) {
      const y2 = sqrt(size / tan30_2);
      const x2 = y2 * tan30;
      context.moveTo(0, -y2);
      context.lineTo(x2, 0);
      context.lineTo(0, y2);
      context.lineTo(-x2, 0);
      context.closePath();
    }
  };
  const diamond2 = {
    draw(context, size) {
      const r = sqrt(size) * 0.62625;
      context.moveTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.lineTo(-r, 0);
      context.closePath();
    }
  };
  const plus = {
    draw(context, size) {
      const r = sqrt(size - min(size / 7, 2)) * 0.87559;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
      context.moveTo(0, r);
      context.lineTo(0, -r);
    }
  };
  const square = {
    draw(context, size) {
      const w2 = sqrt(size);
      const x2 = -w2 / 2;
      context.rect(x2, x2, w2, w2);
    }
  };
  const square2 = {
    draw(context, size) {
      const r = sqrt(size) * 0.4431;
      context.moveTo(r, r);
      context.lineTo(r, -r);
      context.lineTo(-r, -r);
      context.lineTo(-r, r);
      context.closePath();
    }
  };
  const ka = 0.8908130915292852;
  const kr = sin(pi / 10) / sin(7 * pi / 10);
  const kx = sin(tau / 10) * kr;
  const ky = -cos(tau / 10) * kr;
  const star = {
    draw(context, size) {
      const r = sqrt(size * ka);
      const x2 = kx * r;
      const y2 = ky * r;
      context.moveTo(0, -r);
      context.lineTo(x2, y2);
      for (let i = 1; i < 5; ++i) {
        const a2 = tau * i / 5;
        const c2 = cos(a2);
        const s2 = sin(a2);
        context.lineTo(s2 * r, -c2 * r);
        context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
      }
      context.closePath();
    }
  };
  const sqrt3$1 = sqrt(3);
  const triangle = {
    draw(context, size) {
      const y2 = -sqrt(size / (sqrt3$1 * 3));
      context.moveTo(0, y2 * 2);
      context.lineTo(-sqrt3$1 * y2, -y2);
      context.lineTo(sqrt3$1 * y2, -y2);
      context.closePath();
    }
  };
  const sqrt3 = sqrt(3);
  const triangle2 = {
    draw(context, size) {
      const s2 = sqrt(size) * 0.6824;
      const t = s2 / 2;
      const u2 = s2 * sqrt3 / 2;
      context.moveTo(0, -s2);
      context.lineTo(u2, t);
      context.lineTo(-u2, t);
      context.closePath();
    }
  };
  const c$1 = -0.5;
  const s = sqrt(3) / 2;
  const k = 1 / sqrt(12);
  const a = (k / 2 + 1) * 3;
  const wye = {
    draw(context, size) {
      const r = sqrt(size / a);
      const x02 = r / 2, y02 = r * k;
      const x12 = x02, y12 = r * k + r;
      const x2 = -x12, y2 = y12;
      context.moveTo(x02, y02);
      context.lineTo(x12, y12);
      context.lineTo(x2, y2);
      context.lineTo(c$1 * x02 - s * y02, s * x02 + c$1 * y02);
      context.lineTo(c$1 * x12 - s * y12, s * x12 + c$1 * y12);
      context.lineTo(c$1 * x2 - s * y2, s * x2 + c$1 * y2);
      context.lineTo(c$1 * x02 + s * y02, c$1 * y02 - s * x02);
      context.lineTo(c$1 * x12 + s * y12, c$1 * y12 - s * x12);
      context.lineTo(c$1 * x2 + s * y2, c$1 * y2 - s * x2);
      context.closePath();
    }
  };
  const x = {
    draw(context, size) {
      const r = sqrt(size - min(size / 6, 1.7)) * 0.6189;
      context.moveTo(-r, -r);
      context.lineTo(r, r);
      context.moveTo(-r, r);
      context.lineTo(r, -r);
    }
  };
  const symbolsFill = [
    circle$2,
    cross$1,
    diamond,
    square,
    star,
    triangle,
    wye
  ];
  const symbolsStroke = [
    circle$2,
    plus,
    x,
    triangle2,
    asterisk,
    square2,
    diamond2
  ];
  function Symbol$4(type2, size) {
    let context = null;
    type2 = typeof type2 === "function" ? type2 : constant$1(type2 || circle$2);
    size = typeof size === "function" ? size : constant$1(size === void 0 ? 64 : +size);
    function symbol() {
      let buffer2;
      if (!context)
        context = buffer2 = path();
      type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
      if (buffer2)
        return context = null, buffer2 + "" || null;
    }
    symbol.type = function(_2) {
      return arguments.length ? (type2 = typeof _2 === "function" ? _2 : constant$1(_2), symbol) : type2;
    };
    symbol.size = function(_2) {
      return arguments.length ? (size = typeof _2 === "function" ? _2 : constant$1(+_2), symbol) : size;
    };
    symbol.context = function(_2) {
      return arguments.length ? (context = _2 == null ? null : _2, symbol) : context;
    };
    return symbol;
  }
  function noop() {
  }
  function point$4(that, x2, y2) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x2) / 6,
      (that._y0 + 4 * that._y1 + y2) / 6
    );
  }
  function Basis(context) {
    this._context = context;
  }
  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          point$4(this, this._x1, this._y1);
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasis(context) {
    return new Basis(context);
  }
  function BasisClosed(context) {
    this._context = context;
  }
  BasisClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x2 = x2, this._y2 = y2;
          break;
        case 1:
          this._point = 2;
          this._x3 = x2, this._y3 = y2;
          break;
        case 2:
          this._point = 3;
          this._x4 = x2, this._y4 = y2;
          this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
          break;
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasisClosed(context) {
    return new BasisClosed(context);
  }
  function BasisOpen(context) {
    this._context = context;
  }
  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
          this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
          break;
        case 3:
          this._point = 4;
        default:
          point$4(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
    }
  };
  function curveBasisOpen(context) {
    return new BasisOpen(context);
  }
  function Bundle(context, beta2) {
    this._basis = new Basis(context);
    this._beta = beta2;
  }
  Bundle.prototype = {
    lineStart: function() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function() {
      var x2 = this._x, y2 = this._y, j = x2.length - 1;
      if (j > 0) {
        var x02 = x2[0], y02 = y2[0], dx = x2[j] - x02, dy = y2[j] - y02, i = -1, t;
        while (++i <= j) {
          t = i / j;
          this._basis.point(
            this._beta * x2[i] + (1 - this._beta) * (x02 + t * dx),
            this._beta * y2[i] + (1 - this._beta) * (y02 + t * dy)
          );
        }
      }
      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  const bundle = function custom(beta2) {
    function bundle2(context) {
      return beta2 === 1 ? new Basis(context) : new Bundle(context, beta2);
    }
    bundle2.beta = function(beta3) {
      return custom(+beta3);
    };
    return bundle2;
  }(0.85);
  function point$3(that, x2, y2) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x2),
      that._y2 + that._k * (that._y1 - y2),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point$3(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          this._x1 = x2, this._y1 = y2;
          break;
        case 2:
          this._point = 3;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinal = function custom(tension) {
    function cardinal2(context) {
      return new Cardinal(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalClosed = function custom(tension) {
    function cardinal2(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$3(this, x2, y2);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const cardinalOpen = function custom(tension) {
    function cardinal2(context) {
      return new CardinalOpen(context, tension);
    }
    cardinal2.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal2;
  }(0);
  function point$2(that, x2, y2) {
    var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon) {
      var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
      y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
    }
    if (that._l23_a > epsilon) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m2 = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m2;
      y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m2;
    }
    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRom = function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5);
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x2, this._y3 = y2;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x2, this._y4 = y2);
          break;
        case 2:
          this._point = 3;
          this._x5 = x2, this._y5 = y2;
          break;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomClosed = function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5);
  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point) {
        var x23 = this._x2 - x2, y23 = this._y2 - y2;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        default:
          point$2(this, x2, y2);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
    }
  };
  const catmullRomOpen = function custom(alpha) {
    function catmullRom2(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }
    catmullRom2.alpha = function(alpha2) {
      return custom(+alpha2);
    };
    return catmullRom2;
  }(0.5);
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop,
    areaEnd: noop,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point)
        this._context.closePath();
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      if (this._point)
        this._context.lineTo(x2, y2);
      else
        this._point = 1, this._context.moveTo(x2, y2);
    }
  };
  function curveLinearClosed(context) {
    return new LinearClosed(context);
  }
  function sign(x2) {
    return x2 < 0 ? -1 : 1;
  }
  function slope3(that, x2, y2) {
    var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
  }
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }
  function point$1(that, t02, t12) {
    var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
    that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point$1(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      var t12 = NaN;
      x2 = +x2, y2 = +y2;
      if (x2 === this._x1 && y2 === this._y1)
        return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
          break;
        default:
          point$1(this, this._t0, t12 = slope3(this, x2, y2));
          break;
      }
      this._x0 = this._x1, this._x1 = x2;
      this._y0 = this._y1, this._y1 = y2;
      this._t0 = t12;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
    MonotoneX.prototype.point.call(this, y2, x2);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x2, y2) {
      this._context.moveTo(y2, x2);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x2, y2) {
      this._context.lineTo(y2, x2);
    },
    bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
      this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }
  function Natural(context) {
    this._context = context;
  }
  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x2 = this._x, y2 = this._y, n = x2.length;
      if (n) {
        this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
        if (n === 2) {
          this._context.lineTo(x2[1], y2[1]);
        } else {
          var px = controlPoints(x2), py = controlPoints(y2);
          for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
          }
        }
      }
      if (this._line || this._line !== 0 && n === 1)
        this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x2, y2) {
      this._x.push(+x2);
      this._y.push(+y2);
    }
  };
  function controlPoints(x2) {
    var i, n = x2.length - 1, m2, a2 = new Array(n), b = new Array(n), r = new Array(n);
    a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
    for (i = 1; i < n - 1; ++i)
      a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
    a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
    for (i = 1; i < n; ++i)
      m2 = a2[i] / b[i - 1], b[i] -= m2, r[i] -= m2 * r[i - 1];
    a2[n - 1] = r[n - 1] / b[n - 1];
    for (i = n - 2; i >= 0; --i)
      a2[i] = (r[i] - a2[i + 1]) / b[i];
    b[n - 1] = (x2[n] + a2[n - 1]) / 2;
    for (i = 0; i < n - 1; ++i)
      b[i] = 2 * x2[i + 1] - a2[i + 1];
    return [a2, b];
  }
  function curveNatural(context) {
    return new Natural(context);
  }
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2)
        this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1)
        this._context.closePath();
      if (this._line >= 0)
        this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x2, y2) {
      x2 = +x2, y2 = +y2;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y2);
            this._context.lineTo(x2, y2);
          } else {
            var x12 = this._x * (1 - this._t) + x2 * this._t;
            this._context.lineTo(x12, this._y);
            this._context.lineTo(x12, y2);
          }
          break;
        }
      }
      this._x = x2, this._y = y2;
    }
  };
  function curveStep(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }
  function none$1(series, order) {
    if (!((n = series.length) > 1))
      return;
    for (var i = 1, j, s0, s1 = series[order[0]], n, m2 = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order[i]];
      for (j = 0; j < m2; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }
  function none(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0)
      o[n] = n;
    return o;
  }
  function stackValue(d, key) {
    return d[key];
  }
  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }
  function stack() {
    var keys = constant$1([]), order = none, offset = none$1, value = stackValue;
    function stack2(data) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
      for (const d of data) {
        for (i = 0, ++j; i < n; ++i) {
          (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
        }
      }
      for (i = 0, oz = array(order(sz)); i < n; ++i) {
        sz[oz[i]].index = i;
      }
      offset(sz, oz);
      return sz;
    }
    stack2.keys = function(_2) {
      return arguments.length ? (keys = typeof _2 === "function" ? _2 : constant$1(Array.from(_2)), stack2) : keys;
    };
    stack2.value = function(_2) {
      return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$1(+_2), stack2) : value;
    };
    stack2.order = function(_2) {
      return arguments.length ? (order = _2 == null ? none : typeof _2 === "function" ? _2 : constant$1(Array.from(_2)), stack2) : order;
    };
    stack2.offset = function(_2) {
      return arguments.length ? (offset = _2 == null ? none$1 : _2, stack2) : offset;
    };
    return stack2;
  }
  function expand(series, order) {
    if (!((n = series.length) > 0))
      return;
    for (var i, n, j = 0, m2 = series[0].length, y2; j < m2; ++j) {
      for (y2 = i = 0; i < n; ++i)
        y2 += series[i][j][1] || 0;
      if (y2)
        for (i = 0; i < n; ++i)
          series[i][j][1] /= y2;
    }
    none$1(series, order);
  }
  function diverging(series, order) {
    if (!((n = series.length) > 0))
      return;
    for (var i, j = 0, d, dy, yp, yn, n, m2 = series[order[0]].length; j < m2; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }
  function silhouette(series, order) {
    if (!((n = series.length) > 0))
      return;
    for (var j = 0, s0 = series[order[0]], n, m2 = s0.length; j < m2; ++j) {
      for (var i = 0, y2 = 0; i < n; ++i)
        y2 += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y2 / 2;
    }
    none$1(series, order);
  }
  function wiggle(series, order) {
    if (!((n = series.length) > 0) || !((m2 = (s0 = series[order[0]]).length) > 0))
      return;
    for (var y2 = 0, j = 1, s0, m2, n; j < m2; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
        for (var k2 = 0; k2 < i; ++k2) {
          var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y2;
      if (s1)
        y2 -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    none$1(series, order);
  }
  function appearance(series) {
    var peaks = series.map(peak);
    return none(series).sort(function(a2, b) {
      return peaks[a2] - peaks[b];
    });
  }
  function peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while (++i < n)
      if ((vi = +series[i][1]) > vj)
        vj = vi, j = i;
    return j;
  }
  function ascending(series) {
    var sums = series.map(sum);
    return none(series).sort(function(a2, b) {
      return sums[a2] - sums[b];
    });
  }
  function sum(series) {
    var s2 = 0, i = -1, n = series.length, v;
    while (++i < n)
      if (v = +series[i][1])
        s2 += v;
    return s2;
  }
  function descending(series) {
    return ascending(series).reverse();
  }
  function insideOut(series) {
    var n = series.length, i, j, sums = series.map(sum), order = appearance(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
    for (i = 0; i < n; ++i) {
      j = order[i];
      if (top2 < bottom2) {
        top2 += sums[j];
        tops.push(j);
      } else {
        bottom2 += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  }
  function reverse(series) {
    return none(series).reverse();
  }
  const constant = (x2) => () => x2;
  function ZoomEvent(type2, {
    sourceEvent: sourceEvent2,
    target,
    transform: transform2,
    dispatch: dispatch2
  }) {
    Object.defineProperties(this, {
      type: { value: type2, enumerable: true, configurable: true },
      sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
      target: { value: target, enumerable: true, configurable: true },
      transform: { value: transform2, enumerable: true, configurable: true },
      _: { value: dispatch2 }
    });
  }
  function Transform(k2, x2, y2) {
    this.k = k2;
    this.x = x2;
    this.y = y2;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k2) {
      return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
    },
    translate: function(x2, y2) {
      return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
    },
    apply: function(point2) {
      return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
    },
    applyX: function(x2) {
      return x2 * this.k + this.x;
    },
    applyY: function(y2) {
      return y2 * this.k + this.y;
    },
    invert: function(location2) {
      return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
    },
    invertX: function(x2) {
      return (x2 - this.x) / this.k;
    },
    invertY: function(y2) {
      return (y2 - this.y) / this.k;
    },
    rescaleX: function(x2) {
      return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
    },
    rescaleY: function(y2) {
      return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity = new Transform(1, 0, 0);
  transform.prototype = Transform.prototype;
  function transform(node2) {
    while (!node2.__zoom)
      if (!(node2 = node2.parentNode))
        return identity;
    return node2.__zoom;
  }
  function nopropagation(event) {
    event.stopImmediatePropagation();
  }
  function noevent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function defaultFilter(event) {
    return (!event.ctrlKey || event.type === "wheel") && !event.button;
  }
  function defaultExtent() {
    var e = this;
    if (e instanceof SVGElement) {
      e = e.ownerSVGElement || e;
      if (e.hasAttribute("viewBox")) {
        e = e.viewBox.baseVal;
        return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
      }
      return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
    }
    return [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function defaultTransform() {
    return this.__zoom || identity;
  }
  function defaultWheelDelta(event) {
    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
  }
  function defaultTouchable() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function defaultConstrain(transform2, extent2, translateExtent) {
    var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
    return transform2.translate(
      dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
      dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
    );
  }
  function zoom() {
    var filter2 = defaultFilter, extent2 = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
    function zoom2(selection2) {
      selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    zoom2.transform = function(collection, transform2, point2, event) {
      var selection2 = collection.selection ? collection.selection() : collection;
      selection2.property("__zoom", defaultTransform);
      if (collection !== selection2) {
        schedule2(collection, transform2, point2, event);
      } else {
        selection2.interrupt().each(function() {
          gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
        });
      }
    };
    zoom2.scaleBy = function(selection2, k2, p, event) {
      zoom2.scaleTo(selection2, function() {
        var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return k0 * k1;
      }, p, event);
    };
    zoom2.scaleTo = function(selection2, k2, p, event) {
      zoom2.transform(selection2, function() {
        var e = extent2.apply(this, arguments), t02 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
        return constrain(translate(scale(t02, k1), p02, p1), e, translateExtent);
      }, p, event);
    };
    zoom2.translateBy = function(selection2, x2, y2, event) {
      zoom2.transform(selection2, function() {
        return constrain(this.__zoom.translate(
          typeof x2 === "function" ? x2.apply(this, arguments) : x2,
          typeof y2 === "function" ? y2.apply(this, arguments) : y2
        ), extent2.apply(this, arguments), translateExtent);
      }, null, event);
    };
    zoom2.translateTo = function(selection2, x2, y2, p, event) {
      zoom2.transform(selection2, function() {
        var e = extent2.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p;
        return constrain(identity.translate(p02[0], p02[1]).scale(t.k).translate(
          typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
          typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
        ), e, translateExtent);
      }, p, event);
    };
    function scale(transform2, k2) {
      k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
      return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
    }
    function translate(transform2, p02, p1) {
      var x2 = p02[0] - p1[0] * transform2.k, y2 = p02[1] - p1[1] * transform2.k;
      return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
    }
    function centroid2(extent3) {
      return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
    }
    function schedule2(transition2, transform2, point2, event) {
      transition2.on("start.zoom", function() {
        gesture(this, arguments).event(event).start();
      }).on("interrupt.zoom end.zoom", function() {
        gesture(this, arguments).event(event).end();
      }).tween("zoom", function() {
        var that = this, args = arguments, g = gesture(that, args).event(event), e = extent2.apply(that, args), p = point2 == null ? centroid2(e) : typeof point2 === "function" ? point2.apply(that, args) : point2, w2 = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate2(a2.invert(p).concat(w2 / a2.k), b.invert(p).concat(w2 / b.k));
        return function(t) {
          if (t === 1)
            t = b;
          else {
            var l = i(t), k2 = w2 / l[2];
            t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
          }
          g.zoom(null, t);
        };
      });
    }
    function gesture(that, args, clean) {
      return !clean && that.__zooming || new Gesture(that, args);
    }
    function Gesture(that, args) {
      this.that = that;
      this.args = args;
      this.active = 0;
      this.sourceEvent = null;
      this.extent = extent2.apply(that, args);
      this.taps = 0;
    }
    Gesture.prototype = {
      event: function(event) {
        if (event)
          this.sourceEvent = event;
        return this;
      },
      start: function() {
        if (++this.active === 1) {
          this.that.__zooming = this;
          this.emit("start");
        }
        return this;
      },
      zoom: function(key, transform2) {
        if (this.mouse && key !== "mouse")
          this.mouse[1] = transform2.invert(this.mouse[0]);
        if (this.touch0 && key !== "touch")
          this.touch0[1] = transform2.invert(this.touch0[0]);
        if (this.touch1 && key !== "touch")
          this.touch1[1] = transform2.invert(this.touch1[0]);
        this.that.__zoom = transform2;
        this.emit("zoom");
        return this;
      },
      end: function() {
        if (--this.active === 0) {
          delete this.that.__zooming;
          this.emit("end");
        }
        return this;
      },
      emit: function(type2) {
        var d = select(this.that).datum();
        listeners.call(
          type2,
          this.that,
          new ZoomEvent(type2, {
            sourceEvent: this.sourceEvent,
            target: zoom2,
            type: type2,
            transform: this.that.__zoom,
            dispatch: listeners
          }),
          d
        );
      }
    };
    function wheeled(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var g = gesture(this, args).event(event), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer(event);
      if (g.wheel) {
        if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
          g.mouse[1] = t.invert(g.mouse[0] = p);
        }
        clearTimeout(g.wheel);
      } else if (t.k === k2)
        return;
      else {
        g.mouse = [p, t.invert(p)];
        interrupt(this);
        g.start();
      }
      noevent(event);
      g.wheel = setTimeout(wheelidled, wheelDelay);
      g.zoom("mouse", constrain(translate(scale(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
      function wheelidled() {
        g.wheel = null;
        g.end();
      }
    }
    function mousedowned(event, ...args) {
      if (touchending || !filter2.apply(this, arguments))
        return;
      var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer(event, currentTarget), x02 = event.clientX, y02 = event.clientY;
      dragDisable(event.view);
      nopropagation(event);
      g.mouse = [p, this.__zoom.invert(p)];
      interrupt(this);
      g.start();
      function mousemoved(event2) {
        noevent(event2);
        if (!g.moved) {
          var dx = event2.clientX - x02, dy = event2.clientY - y02;
          g.moved = dx * dx + dy * dy > clickDistance2;
        }
        g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
      }
      function mouseupped(event2) {
        v.on("mousemove.zoom mouseup.zoom", null);
        yesdrag(event2.view, g.moved);
        noevent(event2);
        g.event(event2).end();
      }
    }
    function dblclicked(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var t02 = this.__zoom, p02 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t02.invert(p02), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p02, p1), extent2.apply(this, args), translateExtent);
      noevent(event);
      if (duration > 0)
        select(this).transition().duration(duration).call(schedule2, t12, p02, event);
      else
        select(this).call(zoom2.transform, t12, p02, event);
    }
    function touchstarted(event, ...args) {
      if (!filter2.apply(this, arguments))
        return;
      var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
      nopropagation(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer(t, this);
        p = [p, this.__zoom.invert(p), t.identifier];
        if (!g.touch0)
          g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
        else if (!g.touch1 && g.touch0[2] !== p[2])
          g.touch1 = p, g.taps = 0;
      }
      if (touchstarting)
        touchstarting = clearTimeout(touchstarting);
      if (started) {
        if (g.taps < 2)
          touchfirst = p[0], touchstarting = setTimeout(function() {
            touchstarting = null;
          }, touchDelay);
        interrupt(this);
        g.start();
      }
    }
    function touchmoved(event, ...args) {
      if (!this.__zooming)
        return;
      var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
      noevent(event);
      for (i = 0; i < n; ++i) {
        t = touches[i], p = pointer(t, this);
        if (g.touch0 && g.touch0[2] === t.identifier)
          g.touch0[0] = p;
        else if (g.touch1 && g.touch1[2] === t.identifier)
          g.touch1[0] = p;
      }
      t = g.that.__zoom;
      if (g.touch1) {
        var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
        t = scale(t, Math.sqrt(dp / dl));
        p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
        l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
      } else if (g.touch0)
        p = g.touch0[0], l = g.touch0[1];
      else
        return;
      g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
    }
    function touchended(event, ...args) {
      if (!this.__zooming)
        return;
      var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
      nopropagation(event);
      if (touchending)
        clearTimeout(touchending);
      touchending = setTimeout(function() {
        touchending = null;
      }, touchDelay);
      for (i = 0; i < n; ++i) {
        t = touches[i];
        if (g.touch0 && g.touch0[2] === t.identifier)
          delete g.touch0;
        else if (g.touch1 && g.touch1[2] === t.identifier)
          delete g.touch1;
      }
      if (g.touch1 && !g.touch0)
        g.touch0 = g.touch1, delete g.touch1;
      if (g.touch0)
        g.touch0[1] = this.__zoom.invert(g.touch0[0]);
      else {
        g.end();
        if (g.taps === 2) {
          t = pointer(t, this);
          if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
            var p = select(this).on("dblclick.zoom");
            if (p)
              p.apply(this, arguments);
          }
        }
      }
    }
    zoom2.wheelDelta = function(_2) {
      return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant(+_2), zoom2) : wheelDelta;
    };
    zoom2.filter = function(_2) {
      return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : filter2;
    };
    zoom2.touchable = function(_2) {
      return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : touchable;
    };
    zoom2.extent = function(_2) {
      return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent2;
    };
    zoom2.scaleExtent = function(_2) {
      return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
    };
    zoom2.translateExtent = function(_2) {
      return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
    };
    zoom2.constrain = function(_2) {
      return arguments.length ? (constrain = _2, zoom2) : constrain;
    };
    zoom2.duration = function(_2) {
      return arguments.length ? (duration = +_2, zoom2) : duration;
    };
    zoom2.interpolate = function(_2) {
      return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
    };
    zoom2.on = function() {
      var value = listeners.on.apply(listeners, arguments);
      return value === listeners ? zoom2 : value;
    };
    zoom2.clickDistance = function(_2) {
      return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
    };
    zoom2.tapDistance = function(_2) {
      return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
    };
    return zoom2;
  }
  const src = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bisect,
    bisectRight,
    bisectLeft,
    bisectCenter,
    ascending: ascending$3,
    bisector,
    blur,
    blur2,
    blurImage,
    count: count$1,
    cross: cross$3,
    cumsum,
    descending: descending$2,
    deviation,
    extent: extent$1,
    Adder,
    fsum,
    fcumsum,
    group,
    flatGroup,
    flatRollup,
    groups,
    index: index$4,
    indexes,
    rollup,
    rollups,
    groupSort,
    bin,
    histogram: bin,
    thresholdFreedmanDiaconis,
    thresholdScott,
    thresholdSturges,
    max: max$3,
    maxIndex,
    mean,
    median,
    medianIndex,
    merge: merge$1,
    min: min$2,
    minIndex,
    mode,
    nice: nice$1,
    pairs,
    permute,
    quantile: quantile$1,
    quantileIndex,
    quantileSorted,
    quickselect,
    range: range$2,
    rank,
    least,
    leastIndex,
    greatest,
    greatestIndex,
    scan,
    shuffle: shuffle$1,
    shuffler,
    sum: sum$2,
    ticks,
    tickIncrement,
    tickStep,
    transpose,
    variance,
    zip,
    every,
    some,
    filter: filter$1,
    map: map$1,
    reduce,
    reverse: reverse$1,
    sort,
    difference,
    disjoint,
    intersection: intersection$1,
    subset,
    superset,
    union,
    InternMap,
    InternSet,
    axisTop,
    axisRight,
    axisBottom,
    axisLeft,
    brush,
    brushX,
    brushY,
    brushSelection,
    chord,
    chordTranspose,
    chordDirected,
    ribbon: ribbon$1,
    ribbonArrow,
    color,
    rgb,
    hsl: hsl$2,
    lab: lab$1,
    hcl: hcl$1,
    lch,
    gray,
    cubehelix: cubehelix$3,
    contours: Contours,
    contourDensity: density,
    Delaunay,
    Voronoi,
    dispatch,
    drag,
    dragDisable,
    dragEnable: yesdrag,
    dsvFormat,
    csvParse,
    csvParseRows,
    csvFormat,
    csvFormatBody,
    csvFormatRows,
    csvFormatRow,
    csvFormatValue,
    tsvParse,
    tsvParseRows,
    tsvFormat,
    tsvFormatBody,
    tsvFormatRows,
    tsvFormatRow,
    tsvFormatValue,
    autoType,
    easeLinear: linear$1,
    easeQuad: quadInOut,
    easeQuadIn: quadIn,
    easeQuadOut: quadOut,
    easeQuadInOut: quadInOut,
    easeCubic: cubicInOut,
    easeCubicIn: cubicIn,
    easeCubicOut: cubicOut,
    easeCubicInOut: cubicInOut,
    easePoly: polyInOut,
    easePolyIn: polyIn,
    easePolyOut: polyOut,
    easePolyInOut: polyInOut,
    easeSin: sinInOut,
    easeSinIn: sinIn,
    easeSinOut: sinOut,
    easeSinInOut: sinInOut,
    easeExp: expInOut,
    easeExpIn: expIn,
    easeExpOut: expOut,
    easeExpInOut: expInOut,
    easeCircle: circleInOut,
    easeCircleIn: circleIn,
    easeCircleOut: circleOut,
    easeCircleInOut: circleInOut,
    easeBounce: bounceOut,
    easeBounceIn: bounceIn,
    easeBounceOut: bounceOut,
    easeBounceInOut: bounceInOut,
    easeBack: backInOut,
    easeBackIn: backIn,
    easeBackOut: backOut,
    easeBackInOut: backInOut,
    easeElastic: elasticOut,
    easeElasticIn: elasticIn,
    easeElasticOut: elasticOut,
    easeElasticInOut: elasticInOut,
    blob,
    buffer,
    dsv,
    csv,
    tsv,
    image,
    json: json$1,
    text: text$1,
    xml: xml$1,
    html: html$2,
    svg: svg$2,
    forceCenter: center,
    forceCollide: collide,
    forceLink: link$2,
    forceManyBody: manyBody,
    forceRadial: radial$1,
    forceSimulation: simulation,
    forceX: x$2,
    forceY: y$1,
    formatDefaultLocale: defaultLocale$1,
    get format() {
      return format;
    },
    get formatPrefix() {
      return formatPrefix;
    },
    formatLocale: formatLocale$1,
    formatSpecifier,
    FormatSpecifier,
    precisionFixed,
    precisionPrefix,
    precisionRound,
    geoArea: area$2,
    geoBounds: bounds$2,
    geoCentroid: centroid$1,
    geoCircle: circle$4,
    geoClipAntimeridian: clipAntimeridian,
    geoClipCircle: clipCircle,
    geoClipExtent: extent,
    geoClipRectangle: clipRectangle,
    geoContains: contains$1,
    geoDistance: distance$1,
    geoGraticule: graticule,
    geoGraticule10: graticule10,
    geoInterpolate: interpolate,
    geoLength: length$2,
    geoPath: index$2,
    geoAlbers: albers,
    geoAlbersUsa: albersUsa,
    geoAzimuthalEqualArea: azimuthalEqualArea,
    geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: azimuthalEquidistant,
    geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
    geoConicConformal: conicConformal,
    geoConicConformalRaw: conicConformalRaw,
    geoConicEqualArea: conicEqualArea,
    geoConicEqualAreaRaw: conicEqualAreaRaw,
    geoConicEquidistant: conicEquidistant,
    geoConicEquidistantRaw: conicEquidistantRaw,
    geoEqualEarth: equalEarth,
    geoEqualEarthRaw: equalEarthRaw,
    geoEquirectangular: equirectangular,
    geoEquirectangularRaw: equirectangularRaw,
    geoGnomonic: gnomonic,
    geoGnomonicRaw: gnomonicRaw,
    geoIdentity: identity$4,
    geoProjection: projection,
    geoProjectionMutator: projectionMutator,
    geoMercator: mercator,
    geoMercatorRaw: mercatorRaw,
    geoNaturalEarth1: naturalEarth1,
    geoNaturalEarth1Raw: naturalEarth1Raw,
    geoOrthographic: orthographic,
    geoOrthographicRaw: orthographicRaw,
    geoStereographic: stereographic,
    geoStereographicRaw: stereographicRaw,
    geoTransverseMercator: transverseMercator,
    geoTransverseMercatorRaw: transverseMercatorRaw,
    geoRotation: rotation,
    geoStream,
    geoTransform: transform$1,
    cluster,
    hierarchy,
    Node: Node$1,
    pack: index$1,
    packSiblings: siblings,
    packEnclose: enclose,
    partition,
    stratify,
    tree,
    treemap: index,
    treemapBinary: binary,
    treemapDice,
    treemapSlice,
    treemapSliceDice: sliceDice,
    treemapSquarify: squarify,
    treemapResquarify: resquarify,
    interpolate: interpolate$2,
    interpolateArray: array$3,
    interpolateBasis: basis$1,
    interpolateBasisClosed: basisClosed,
    interpolateDate: date$1,
    interpolateDiscrete: discrete,
    interpolateHue: hue,
    interpolateNumber,
    interpolateNumberArray: numberArray,
    interpolateObject: object$1,
    interpolateRound,
    interpolateString,
    interpolateTransformCss,
    interpolateTransformSvg,
    interpolateZoom,
    interpolateRgb,
    interpolateRgbBasis: rgbBasis,
    interpolateRgbBasisClosed: rgbBasisClosed,
    interpolateHsl: hsl$1,
    interpolateHslLong: hslLong,
    interpolateLab: lab,
    interpolateHcl,
    interpolateHclLong: hclLong,
    interpolateCubehelix: cubehelix$2,
    interpolateCubehelixLong: cubehelixLong,
    piecewise,
    quantize: quantize$1,
    path,
    polygonArea: area$1,
    polygonCentroid: centroid,
    polygonHull: hull,
    polygonContains: contains,
    polygonLength: length$1,
    quadtree,
    randomUniform: uniform,
    randomInt: int,
    randomNormal: normal,
    randomLogNormal: logNormal,
    randomBates: bates,
    randomIrwinHall: irwinHall,
    randomExponential: exponential,
    randomPareto: pareto,
    randomBernoulli: bernoulli,
    randomGeometric: geometric,
    randomBinomial: binomial,
    randomGamma: gamma,
    randomBeta: beta,
    randomWeibull: weibull,
    randomCauchy: cauchy,
    randomLogistic: logistic,
    randomPoisson: poisson,
    randomLcg: lcg,
    scaleBand: band,
    scalePoint: point$5,
    scaleIdentity: identity$2,
    scaleLinear: linear,
    scaleLog: log$1,
    scaleSymlog: symlog,
    scaleOrdinal: ordinal,
    scaleImplicit: implicit,
    scalePow: pow,
    scaleSqrt: sqrt$1,
    scaleRadial: radial,
    scaleQuantile: quantile,
    scaleQuantize: quantize,
    scaleThreshold: threshold,
    scaleTime: time,
    scaleUtc: utcTime,
    scaleSequential: sequential,
    scaleSequentialLog: sequentialLog,
    scaleSequentialPow: sequentialPow,
    scaleSequentialSqrt: sequentialSqrt,
    scaleSequentialSymlog: sequentialSymlog,
    scaleSequentialQuantile: sequentialQuantile,
    scaleDiverging: diverging$1,
    scaleDivergingLog: divergingLog,
    scaleDivergingPow: divergingPow,
    scaleDivergingSqrt: divergingSqrt,
    scaleDivergingSymlog: divergingSymlog,
    tickFormat,
    schemeCategory10: category10,
    schemeAccent: Accent,
    schemeDark2: Dark2,
    schemePaired: Paired,
    schemePastel1: Pastel1,
    schemePastel2: Pastel2,
    schemeSet1: Set1,
    schemeSet2: Set2,
    schemeSet3: Set3,
    schemeTableau10: Tableau10,
    interpolateBrBG: BrBG,
    schemeBrBG: scheme$q,
    interpolatePRGn: PRGn,
    schemePRGn: scheme$p,
    interpolatePiYG: PiYG,
    schemePiYG: scheme$o,
    interpolatePuOr: PuOr,
    schemePuOr: scheme$n,
    interpolateRdBu: RdBu,
    schemeRdBu: scheme$m,
    interpolateRdGy: RdGy,
    schemeRdGy: scheme$l,
    interpolateRdYlBu: RdYlBu,
    schemeRdYlBu: scheme$k,
    interpolateRdYlGn: RdYlGn,
    schemeRdYlGn: scheme$j,
    interpolateSpectral: Spectral,
    schemeSpectral: scheme$i,
    interpolateBuGn: BuGn,
    schemeBuGn: scheme$h,
    interpolateBuPu: BuPu,
    schemeBuPu: scheme$g,
    interpolateGnBu: GnBu,
    schemeGnBu: scheme$f,
    interpolateOrRd: OrRd,
    schemeOrRd: scheme$e,
    interpolatePuBuGn: PuBuGn,
    schemePuBuGn: scheme$d,
    interpolatePuBu: PuBu,
    schemePuBu: scheme$c,
    interpolatePuRd: PuRd,
    schemePuRd: scheme$b,
    interpolateRdPu: RdPu,
    schemeRdPu: scheme$a,
    interpolateYlGnBu: YlGnBu,
    schemeYlGnBu: scheme$9,
    interpolateYlGn: YlGn,
    schemeYlGn: scheme$8,
    interpolateYlOrBr: YlOrBr,
    schemeYlOrBr: scheme$7,
    interpolateYlOrRd: YlOrRd,
    schemeYlOrRd: scheme$6,
    interpolateBlues: Blues,
    schemeBlues: scheme$5,
    interpolateGreens: Greens,
    schemeGreens: scheme$4,
    interpolateGreys: Greys,
    schemeGreys: scheme$3,
    interpolatePurples: Purples,
    schemePurples: scheme$2,
    interpolateReds: Reds,
    schemeReds: scheme$1,
    interpolateOranges: Oranges,
    schemeOranges: scheme,
    interpolateCividis: cividis,
    interpolateCubehelixDefault: cubehelix,
    interpolateRainbow: rainbow,
    interpolateWarm: warm,
    interpolateCool: cool,
    interpolateSinebow: sinebow,
    interpolateTurbo: turbo,
    interpolateViridis: viridis,
    interpolateMagma: magma,
    interpolateInferno: inferno,
    interpolatePlasma: plasma,
    create: create$2,
    creator,
    local: local$1,
    matcher,
    namespace,
    namespaces,
    pointer,
    pointers,
    select,
    selectAll,
    selection,
    selector,
    selectorAll,
    style: styleValue,
    window: defaultView,
    arc: d3arc,
    area,
    line: line$1,
    pie: d3pie,
    areaRadial,
    radialArea: areaRadial,
    lineRadial: lineRadial$1,
    radialLine: lineRadial$1,
    pointRadial,
    link,
    linkHorizontal,
    linkVertical,
    linkRadial,
    symbol: Symbol$4,
    symbolsStroke,
    symbolsFill,
    symbols: symbolsFill,
    symbolAsterisk: asterisk,
    symbolCircle: circle$2,
    symbolCross: cross$1,
    symbolDiamond: diamond,
    symbolDiamond2: diamond2,
    symbolPlus: plus,
    symbolSquare: square,
    symbolSquare2: square2,
    symbolStar: star,
    symbolTriangle: triangle,
    symbolTriangle2: triangle2,
    symbolWye: wye,
    symbolX: x,
    curveBasisClosed,
    curveBasisOpen,
    curveBasis,
    curveBumpX: bumpX,
    curveBumpY: bumpY,
    curveBundle: bundle,
    curveCardinalClosed: cardinalClosed,
    curveCardinalOpen: cardinalOpen,
    curveCardinal: cardinal,
    curveCatmullRomClosed: catmullRomClosed,
    curveCatmullRomOpen: catmullRomOpen,
    curveCatmullRom: catmullRom,
    curveLinearClosed,
    curveLinear,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural,
    curveStep,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore,
    stack,
    stackOffsetExpand: expand,
    stackOffsetDiverging: diverging,
    stackOffsetNone: none$1,
    stackOffsetSilhouette: silhouette,
    stackOffsetWiggle: wiggle,
    stackOrderAppearance: appearance,
    stackOrderAscending: ascending,
    stackOrderDescending: descending,
    stackOrderInsideOut: insideOut,
    stackOrderNone: none,
    stackOrderReverse: reverse,
    timeInterval: newInterval,
    timeMillisecond: millisecond$1,
    timeMilliseconds: milliseconds,
    utcMillisecond: millisecond$1,
    utcMilliseconds: milliseconds,
    timeSecond: utcSecond,
    timeSeconds: seconds,
    utcSecond,
    utcSeconds: seconds,
    timeMinute,
    timeMinutes: minutes,
    timeHour,
    timeHours: hours,
    timeDay,
    timeDays: days,
    timeWeek: sunday,
    timeWeeks: sundays,
    timeSunday: sunday,
    timeSundays: sundays,
    timeMonday: monday,
    timeMondays: mondays,
    timeTuesday: tuesday,
    timeTuesdays: tuesdays,
    timeWednesday: wednesday,
    timeWednesdays: wednesdays,
    timeThursday: thursday,
    timeThursdays: thursdays,
    timeFriday: friday,
    timeFridays: fridays,
    timeSaturday: saturday,
    timeSaturdays: saturdays,
    timeMonth,
    timeMonths: months,
    timeYear,
    timeYears: years,
    utcMinute: utcMinute$1,
    utcMinutes,
    utcHour: utcHour$1,
    utcHours,
    utcDay: utcDay$1,
    utcDays,
    utcWeek: utcSunday,
    utcWeeks: utcSundays,
    utcSunday,
    utcSundays,
    utcMonday,
    utcMondays,
    utcTuesday,
    utcTuesdays,
    utcWednesday,
    utcWednesdays,
    utcThursday,
    utcThursdays,
    utcFriday,
    utcFridays,
    utcSaturday,
    utcSaturdays,
    utcMonth: utcMonth$1,
    utcMonths,
    utcYear: utcYear$1,
    utcYears,
    utcTicks,
    utcTickInterval,
    timeTicks,
    timeTickInterval,
    timeFormatDefaultLocale: defaultLocale,
    get timeFormat() {
      return timeFormat;
    },
    get timeParse() {
      return timeParse;
    },
    get utcFormat() {
      return utcFormat;
    },
    get utcParse() {
      return utcParse;
    },
    timeFormatLocale: formatLocale,
    isoFormat: formatIso$1,
    isoParse: parseIso$1,
    now,
    timer,
    timerFlush,
    timeout,
    interval,
    transition,
    active,
    interrupt,
    zoom,
    zoomTransform: transform,
    zoomIdentity: identity,
    ZoomTransform: Transform
  }, Symbol.toStringTag, { value: "Module" }));
  /*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var hasOwnProperty$4 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze, seal = Object.seal, create = Object.create;
  var _ref = typeof Reflect !== "undefined" && Reflect, apply$1 = _ref.apply, construct = _ref.construct;
  if (!apply$1) {
    apply$1 = function apply2(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!construct) {
    construct = function construct2(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }
  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return apply$1(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return construct(func, args);
    };
  }
  function addToSet(set2, array2, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    var l = array2.length;
    while (l--) {
      var element = array2[l];
      if (typeof element === "string") {
        var lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array2)) {
            array2[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function clone$1(object2) {
    var newObject = create(null);
    var property;
    for (property in object2) {
      if (apply$1(hasOwnProperty$4, object2, [property])) {
        newObject[property] = object2[property];
      }
    }
    return newObject;
  }
  function lookupGetter(object2, prop) {
    while (object2 !== null) {
      var desc = getOwnPropertyDescriptor(object2, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object2 = getPrototypeOf(object2);
    }
    function fallbackValue(element) {
      console.warn("fallback value for", element);
      return null;
    }
    return fallbackValue;
  }
  var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
  var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  var text = freeze(["#text"]);
  var html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
  var svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  var IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  );
  var DOCTYPE_NAME = seal(/^html$/i);
  var getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
    if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    var suffix = null;
    var ATTR_NAME = "data-tt-policy-suffix";
    if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document2.currentScript.getAttribute(ATTR_NAME);
    }
    var policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html2) {
          return html2;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  function createDOMPurify() {
    var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    var DOMPurify = function DOMPurify2(root2) {
      return createDOMPurify(root2);
    };
    DOMPurify.version = "2.4.0";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    var originalDocument = window2.document;
    var document2 = window2.document;
    var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    var getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      var template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
    var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var documentMode = {};
    try {
      documentMode = clone$1(document2).documentMode ? document2.documentMode : {};
    } catch (_2) {
    }
    var hooks = {};
    DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    var FORBID_TAGS = null;
    var FORBID_ATTR = null;
    var ALLOW_ARIA_ATTR = true;
    var ALLOW_DATA_ATTR = true;
    var ALLOW_UNKNOWN_PROTOCOLS = false;
    var SAFE_FOR_TEMPLATES = false;
    var WHOLE_DOCUMENT = false;
    var SET_CONFIG = false;
    var FORCE_BODY = false;
    var RETURN_DOM = false;
    var RETURN_DOM_FRAGMENT = false;
    var RETURN_TRUSTED_TYPE = false;
    var SANITIZE_DOM = true;
    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    var KEEP_CONTENT = true;
    var IN_PLACE = false;
    var USE_PROFILES = {};
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    var transformCaseFunc;
    var CONFIG = null;
    var formElement = document2.createElement("form");
    var isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    var _parseConfig = function _parseConfig2(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || _typeof(cfg) !== "object") {
        cfg = {};
      }
      cfg = clone$1(cfg);
      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
        return x2;
      } : stringToLowerCase;
      ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
        clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),
        cfg.ADD_URI_SAFE_ATTR,
        transformCaseFunc
      ) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
        clone$1(DEFAULT_DATA_URI_TAGS),
        cfg.ADD_DATA_URI_TAGS,
        transformCaseFunc
      ) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
        }
        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }
      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
        }
        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    var _checkValidNamespace = function _checkValidNamespace2(element) {
      var parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: "template"
        };
      }
      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      return false;
    };
    var _forceRemove = function _forceRemove2(node2) {
      arrayPush(DOMPurify.removed, {
        element: node2
      });
      try {
        node2.parentNode.removeChild(node2);
      } catch (_2) {
        try {
          node2.outerHTML = emptyHTML;
        } catch (_3) {
          node2.remove();
        }
      }
    };
    var _removeAttribute = function _removeAttribute2(name2, node2) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node2.getAttributeNode(name2),
          from: node2
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node2
        });
      }
      node2.removeAttribute(name2);
      if (name2 === "is" && !ALLOWED_ATTR[name2]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node2);
          } catch (_2) {
          }
        } else {
          try {
            node2.setAttribute(name2, "");
          } catch (_2) {
          }
        }
      }
    };
    var _initDocument = function _initDocument2(dirty) {
      var doc;
      var leadingWhitespace;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
        } catch (_2) {
        }
      }
      var body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    var _createIterator = function _createIterator2(root2) {
      return createNodeIterator.call(
        root2.ownerDocument || root2,
        root2,
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
        null,
        false
      );
    };
    var _isClobbered = function _isClobbered2(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
    };
    var _isNode = function _isNode2(object2) {
      return _typeof(Node2) === "object" ? object2 instanceof Node2 : object2 && _typeof(object2) === "object" && typeof object2.nodeType === "number" && typeof object2.nodeName === "string";
    };
    var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }
      arrayForEach(hooks[entryPoint], function(hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    var _sanitizeElements = function _sanitizeElements2(currentNode) {
      var content;
      _executeHook("beforeSanitizeElements", currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
        _forceRemove(currentNode);
        return true;
      }
      var tagName = transformCaseFunc(currentNode.nodeName);
      _executeHook("uponSanitizeElement", currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
            return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
            return false;
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            var childCount = childNodes.length;
            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, " ");
        content = stringReplace(content, ERB_EXPR$1, " ");
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHook("afterSanitizeElements", currentNode, null);
      return false;
    };
    var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
        ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
        ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
          ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName])
        ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
        ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
        ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
        ;
      else if (!value)
        ;
      else {
        return false;
      }
      return true;
    };
    var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
      return tagName.indexOf("-") > 0;
    };
    var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      _executeHook("beforeSanitizeAttributes", currentNode, null);
      var attributes = currentNode.attributes;
      if (!attributes) {
        return;
      }
      var hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      while (l--) {
        attr = attributes[l];
        var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
        value = name2 === "value" ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name2);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        _removeAttribute(name2, currentNode);
        if (!hookEvent.keepAttr) {
          continue;
        }
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name2, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, " ");
          value = stringReplace(value, ERB_EXPR$1, " ");
        }
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name2, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI)
            ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML":
                value = trustedTypesPolicy.createHTML(value);
                break;
              case "TrustedScriptURL":
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name2, value);
          } else {
            currentNode.setAttribute(name2, value);
          }
          arrayPop(DOMPurify.removed);
        } catch (_2) {
        }
      }
      _executeHook("afterSanitizeAttributes", currentNode, null);
    };
    var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      var shadowNode;
      var shadowIterator = _createIterator(fragment);
      _executeHook("beforeSanitizeShadowDOM", fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHook("uponSanitizeShadowNode", shadowNode, null);
        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
        _sanitizeAttributes(shadowNode);
      }
      _executeHook("afterSanitizeShadowDOM", fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var oldNode;
      var returnNode;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString !== "function") {
          throw typeErrorCreate("toString is not a function");
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        }
      }
      if (!DOMPurify.isSupported) {
        if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
          if (typeof dirty === "string") {
            return window2.toStaticHTML(dirty);
          }
          if (_isNode(dirty)) {
            return window2.toStaticHTML(dirty.outerHTML);
          }
        }
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        _sanitizeAttributes(currentNode);
        oldNode = currentNode;
      }
      oldNode = null;
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function(cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    DOMPurify.removeHooks = function(entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    DOMPurify.removeAllHooks = function() {
      hooks = {};
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  const getRows = (s2) => {
    if (!s2)
      return [""];
    const str = breakToPlaceholder(s2).replace(/\\n/g, "#br#");
    return str.split("#br#");
  };
  const removeScript = (txt) => {
    return purify.sanitize(txt);
  };
  const sanitizeMore = (text2, config2) => {
    var _a;
    if (((_a = config2.flowchart) == null ? void 0 : _a.htmlLabels) !== false) {
      const level = config2.securityLevel;
      if (level === "antiscript" || level === "strict") {
        text2 = removeScript(text2);
      } else if (level !== "loose") {
        text2 = breakToPlaceholder(text2);
        text2 = text2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        text2 = text2.replace(/=/g, "&equals;");
        text2 = placeholderToBreak(text2);
      }
    }
    return text2;
  };
  const sanitizeText$5 = (text2, config2) => {
    if (!text2)
      return text2;
    if (config2.dompurifyConfig) {
      text2 = purify.sanitize(sanitizeMore(text2, config2), config2.dompurifyConfig).toString();
    } else {
      text2 = purify.sanitize(sanitizeMore(text2, config2));
    }
    return text2;
  };
  const sanitizeTextOrArray = (a2, config2) => {
    if (typeof a2 === "string")
      return sanitizeText$5(a2, config2);
    return a2.flat().map((x2) => sanitizeText$5(x2, config2));
  };
  const lineBreakRegex = /<br\s*\/?>/gi;
  const hasBreaks = (text2) => {
    return lineBreakRegex.test(text2);
  };
  const splitBreaks = (text2) => {
    return text2.split(lineBreakRegex);
  };
  const placeholderToBreak = (s2) => {
    return s2.replace(/#br#/g, "<br/>");
  };
  const breakToPlaceholder = (s2) => {
    return s2.replace(lineBreakRegex, "#br#");
  };
  const getUrl = (useAbsolute) => {
    let url = "";
    if (useAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replaceAll(/\(/g, "\\(");
      url = url.replaceAll(/\)/g, "\\)");
    }
    return url;
  };
  const evaluate = (val) => val === false || ["false", "null", "0"].includes(String(val).trim().toLowerCase()) ? false : true;
  const parseGenericTypes = function(text2) {
    let cleanedText = text2;
    if (text2.indexOf("~") !== -1) {
      cleanedText = cleanedText.replace(/~([^~].*)/, "<$1");
      cleanedText = cleanedText.replace(/~([^~]*)$/, ">$1");
      return parseGenericTypes(cleanedText);
    } else {
      return cleanedText;
    }
  };
  const common = {
    getRows,
    sanitizeText: sanitizeText$5,
    sanitizeTextOrArray,
    hasBreaks,
    splitBreaks,
    lineBreakRegex,
    removeScript,
    getUrl,
    evaluate
  };
  const Channel = {
    min: {
      r: 0,
      g: 0,
      b: 0,
      s: 0,
      l: 0,
      a: 0
    },
    max: {
      r: 255,
      g: 255,
      b: 255,
      h: 360,
      s: 100,
      l: 100,
      a: 1
    },
    clamp: {
      r: (r) => r >= 255 ? 255 : r < 0 ? 0 : r,
      g: (g) => g >= 255 ? 255 : g < 0 ? 0 : g,
      b: (b) => b >= 255 ? 255 : b < 0 ? 0 : b,
      h: (h) => h % 360,
      s: (s2) => s2 >= 100 ? 100 : s2 < 0 ? 0 : s2,
      l: (l) => l >= 100 ? 100 : l < 0 ? 0 : l,
      a: (a2) => a2 >= 1 ? 1 : a2 < 0 ? 0 : a2
    },
    toLinear: (c2) => {
      const n = c2 / 255;
      return c2 > 0.03928 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
    },
    hue2rgb: (p, q, t) => {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    },
    hsl2rgb: ({ h, s: s2, l }, channel2) => {
      if (!s2)
        return l * 2.55;
      h /= 360;
      s2 /= 100;
      l /= 100;
      const q = l < 0.5 ? l * (1 + s2) : l + s2 - l * s2;
      const p = 2 * l - q;
      switch (channel2) {
        case "r":
          return Channel.hue2rgb(p, q, h + 1 / 3) * 255;
        case "g":
          return Channel.hue2rgb(p, q, h) * 255;
        case "b":
          return Channel.hue2rgb(p, q, h - 1 / 3) * 255;
      }
    },
    rgb2hsl: ({ r, g, b }, channel2) => {
      r /= 255;
      g /= 255;
      b /= 255;
      const max2 = Math.max(r, g, b);
      const min2 = Math.min(r, g, b);
      const l = (max2 + min2) / 2;
      if (channel2 === "l")
        return l * 100;
      if (max2 === min2)
        return 0;
      const d = max2 - min2;
      const s2 = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
      if (channel2 === "s")
        return s2 * 100;
      switch (max2) {
        case r:
          return ((g - b) / d + (g < b ? 6 : 0)) * 60;
        case g:
          return ((b - r) / d + 2) * 60;
        case b:
          return ((r - g) / d + 4) * 60;
        default:
          return -1;
      }
    }
  };
  const channel = Channel;
  const Lang = {
    clamp: (number3, lower2, upper) => {
      if (lower2 > upper)
        return Math.min(lower2, Math.max(upper, number3));
      return Math.min(upper, Math.max(lower2, number3));
    },
    round: (number3) => {
      return Math.round(number3 * 1e10) / 1e10;
    }
  };
  const lang = Lang;
  const Unit = {
    dec2hex: (dec) => {
      const hex2 = Math.round(dec).toString(16);
      return hex2.length > 1 ? hex2 : `0${hex2}`;
    }
  };
  const unit = Unit;
  const Utils = {
    channel,
    lang,
    unit
  };
  const _$e = Utils;
  const DEC2HEX = {};
  for (let i = 0; i <= 255; i++)
    DEC2HEX[i] = _$e.unit.dec2hex(i);
  const TYPE = {
    ALL: 0,
    RGB: 1,
    HSL: 2
  };
  class Type {
    constructor() {
      this.type = TYPE.ALL;
    }
    get() {
      return this.type;
    }
    set(type2) {
      if (this.type && this.type !== type2)
        throw new Error("Cannot change both RGB and HSL channels at the same time");
      this.type = type2;
    }
    reset() {
      this.type = TYPE.ALL;
    }
    is(type2) {
      return this.type === type2;
    }
  }
  const Type$1 = Type;
  class Channels {
    constructor(data, color2) {
      this.color = color2;
      this.changed = false;
      this.data = data;
      this.type = new Type$1();
    }
    set(data, color2) {
      this.color = color2;
      this.changed = false;
      this.data = data;
      this.type.type = TYPE.ALL;
      return this;
    }
    _ensureHSL() {
      const data = this.data;
      const { h, s: s2, l } = data;
      if (h === void 0)
        data.h = _$e.channel.rgb2hsl(data, "h");
      if (s2 === void 0)
        data.s = _$e.channel.rgb2hsl(data, "s");
      if (l === void 0)
        data.l = _$e.channel.rgb2hsl(data, "l");
    }
    _ensureRGB() {
      const data = this.data;
      const { r, g, b } = data;
      if (r === void 0)
        data.r = _$e.channel.hsl2rgb(data, "r");
      if (g === void 0)
        data.g = _$e.channel.hsl2rgb(data, "g");
      if (b === void 0)
        data.b = _$e.channel.hsl2rgb(data, "b");
    }
    get r() {
      const data = this.data;
      const r = data.r;
      if (!this.type.is(TYPE.HSL) && r !== void 0)
        return r;
      this._ensureHSL();
      return _$e.channel.hsl2rgb(data, "r");
    }
    get g() {
      const data = this.data;
      const g = data.g;
      if (!this.type.is(TYPE.HSL) && g !== void 0)
        return g;
      this._ensureHSL();
      return _$e.channel.hsl2rgb(data, "g");
    }
    get b() {
      const data = this.data;
      const b = data.b;
      if (!this.type.is(TYPE.HSL) && b !== void 0)
        return b;
      this._ensureHSL();
      return _$e.channel.hsl2rgb(data, "b");
    }
    get h() {
      const data = this.data;
      const h = data.h;
      if (!this.type.is(TYPE.RGB) && h !== void 0)
        return h;
      this._ensureRGB();
      return _$e.channel.rgb2hsl(data, "h");
    }
    get s() {
      const data = this.data;
      const s2 = data.s;
      if (!this.type.is(TYPE.RGB) && s2 !== void 0)
        return s2;
      this._ensureRGB();
      return _$e.channel.rgb2hsl(data, "s");
    }
    get l() {
      const data = this.data;
      const l = data.l;
      if (!this.type.is(TYPE.RGB) && l !== void 0)
        return l;
      this._ensureRGB();
      return _$e.channel.rgb2hsl(data, "l");
    }
    get a() {
      return this.data.a;
    }
    set r(r) {
      this.type.set(TYPE.RGB);
      this.changed = true;
      this.data.r = r;
    }
    set g(g) {
      this.type.set(TYPE.RGB);
      this.changed = true;
      this.data.g = g;
    }
    set b(b) {
      this.type.set(TYPE.RGB);
      this.changed = true;
      this.data.b = b;
    }
    set h(h) {
      this.type.set(TYPE.HSL);
      this.changed = true;
      this.data.h = h;
    }
    set s(s2) {
      this.type.set(TYPE.HSL);
      this.changed = true;
      this.data.s = s2;
    }
    set l(l) {
      this.type.set(TYPE.HSL);
      this.changed = true;
      this.data.l = l;
    }
    set a(a2) {
      this.changed = true;
      this.data.a = a2;
    }
  }
  const Channels$1 = Channels;
  const channels = new Channels$1({ r: 0, g: 0, b: 0, a: 0 }, "transparent");
  const ChannelsReusable = channels;
  const Hex = {
    re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
    parse: (color2) => {
      if (color2.charCodeAt(0) !== 35)
        return;
      const match = color2.match(Hex.re);
      if (!match)
        return;
      const hex2 = match[1];
      const dec = parseInt(hex2, 16);
      const length2 = hex2.length;
      const hasAlpha = length2 % 4 === 0;
      const isFullLength = length2 > 4;
      const multiplier = isFullLength ? 1 : 17;
      const bits = isFullLength ? 8 : 4;
      const bitsOffset = hasAlpha ? 0 : -1;
      const mask = isFullLength ? 255 : 15;
      return ChannelsReusable.set({
        r: (dec >> bits * (bitsOffset + 3) & mask) * multiplier,
        g: (dec >> bits * (bitsOffset + 2) & mask) * multiplier,
        b: (dec >> bits * (bitsOffset + 1) & mask) * multiplier,
        a: hasAlpha ? (dec & mask) * multiplier / 255 : 1
      }, color2);
    },
    stringify: (channels2) => {
      const { r, g, b, a: a2 } = channels2;
      if (a2 < 1) {
        return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}${DEC2HEX[Math.round(a2 * 255)]}`;
      } else {
        return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}`;
      }
    }
  };
  const Hex$1 = Hex;
  const HSL = {
    re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
    hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
    _hue2deg: (hue2) => {
      const match = hue2.match(HSL.hueRe);
      if (match) {
        const [, number3, unit2] = match;
        switch (unit2) {
          case "grad":
            return _$e.channel.clamp.h(parseFloat(number3) * 0.9);
          case "rad":
            return _$e.channel.clamp.h(parseFloat(number3) * 180 / Math.PI);
          case "turn":
            return _$e.channel.clamp.h(parseFloat(number3) * 360);
        }
      }
      return _$e.channel.clamp.h(parseFloat(hue2));
    },
    parse: (color2) => {
      const charCode = color2.charCodeAt(0);
      if (charCode !== 104 && charCode !== 72)
        return;
      const match = color2.match(HSL.re);
      if (!match)
        return;
      const [, h, s2, l, a2, isAlphaPercentage] = match;
      return ChannelsReusable.set({
        h: HSL._hue2deg(h),
        s: _$e.channel.clamp.s(parseFloat(s2)),
        l: _$e.channel.clamp.l(parseFloat(l)),
        a: a2 ? _$e.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
      }, color2);
    },
    stringify: (channels2) => {
      const { h, s: s2, l, a: a2 } = channels2;
      if (a2 < 1) {
        return `hsla(${_$e.lang.round(h)}, ${_$e.lang.round(s2)}%, ${_$e.lang.round(l)}%, ${a2})`;
      } else {
        return `hsl(${_$e.lang.round(h)}, ${_$e.lang.round(s2)}%, ${_$e.lang.round(l)}%)`;
      }
    }
  };
  const HSL$1 = HSL;
  const Keyword = {
    colors: {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyanaqua: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      transparent: "#00000000",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    },
    parse: (color2) => {
      color2 = color2.toLowerCase();
      const hex2 = Keyword.colors[color2];
      if (!hex2)
        return;
      return Hex$1.parse(hex2);
    },
    stringify: (channels2) => {
      const hex2 = Hex$1.stringify(channels2);
      for (const name2 in Keyword.colors) {
        if (Keyword.colors[name2] === hex2)
          return name2;
      }
      return;
    }
  };
  const Keyword$1 = Keyword;
  const RGB = {
    re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
    parse: (color2) => {
      const charCode = color2.charCodeAt(0);
      if (charCode !== 114 && charCode !== 82)
        return;
      const match = color2.match(RGB.re);
      if (!match)
        return;
      const [, r, isRedPercentage, g, isGreenPercentage, b, isBluePercentage, a2, isAlphaPercentage] = match;
      return ChannelsReusable.set({
        r: _$e.channel.clamp.r(isRedPercentage ? parseFloat(r) * 2.55 : parseFloat(r)),
        g: _$e.channel.clamp.g(isGreenPercentage ? parseFloat(g) * 2.55 : parseFloat(g)),
        b: _$e.channel.clamp.b(isBluePercentage ? parseFloat(b) * 2.55 : parseFloat(b)),
        a: a2 ? _$e.channel.clamp.a(isAlphaPercentage ? parseFloat(a2) / 100 : parseFloat(a2)) : 1
      }, color2);
    },
    stringify: (channels2) => {
      const { r, g, b, a: a2 } = channels2;
      if (a2 < 1) {
        return `rgba(${_$e.lang.round(r)}, ${_$e.lang.round(g)}, ${_$e.lang.round(b)}, ${_$e.lang.round(a2)})`;
      } else {
        return `rgb(${_$e.lang.round(r)}, ${_$e.lang.round(g)}, ${_$e.lang.round(b)})`;
      }
    }
  };
  const RGB$1 = RGB;
  const Color = {
    format: {
      keyword: Keyword$1,
      hex: Hex$1,
      rgb: RGB$1,
      rgba: RGB$1,
      hsl: HSL$1,
      hsla: HSL$1
    },
    parse: (color2) => {
      if (typeof color2 !== "string")
        return color2;
      const channels2 = Hex$1.parse(color2) || RGB$1.parse(color2) || HSL$1.parse(color2) || Keyword$1.parse(color2);
      if (channels2)
        return channels2;
      throw new Error(`Unsupported color format: "${color2}"`);
    },
    stringify: (channels2) => {
      if (!channels2.changed && channels2.color)
        return channels2.color;
      if (channels2.type.is(TYPE.HSL) || channels2.data.r === void 0) {
        return HSL$1.stringify(channels2);
      } else if (channels2.a < 1 || !Number.isInteger(channels2.r) || !Number.isInteger(channels2.g) || !Number.isInteger(channels2.b)) {
        return RGB$1.stringify(channels2);
      } else {
        return Hex$1.stringify(channels2);
      }
    }
  };
  const Color$1 = Color;
  const change = (color2, channels2) => {
    const ch = Color$1.parse(color2);
    for (const c2 in channels2) {
      ch[c2] = _$e.channel.clamp[c2](channels2[c2]);
    }
    return Color$1.stringify(ch);
  };
  const change$1 = change;
  const rgba = (r, g, b = 0, a2 = 1) => {
    if (typeof r !== "number")
      return change$1(r, { a: g });
    const channels2 = ChannelsReusable.set({
      r: _$e.channel.clamp.r(r),
      g: _$e.channel.clamp.g(g),
      b: _$e.channel.clamp.b(b),
      a: _$e.channel.clamp.a(a2)
    });
    return Color$1.stringify(channels2);
  };
  const rgba$1 = rgba;
  const adjustChannel = (color2, channel2, amount) => {
    const channels2 = Color$1.parse(color2);
    const amountCurrent = channels2[channel2];
    const amountNext = _$e.channel.clamp[channel2](amountCurrent + amount);
    if (amountCurrent !== amountNext)
      channels2[channel2] = amountNext;
    return Color$1.stringify(channels2);
  };
  const adjustChannel$1 = adjustChannel;
  const lighten = (color2, amount) => {
    return adjustChannel$1(color2, "l", amount);
  };
  const lighten$1 = lighten;
  const darken = (color2, amount) => {
    return adjustChannel$1(color2, "l", -amount);
  };
  const darken$1 = darken;
  const adjust = (color2, channels2) => {
    const ch = Color$1.parse(color2);
    const changes = {};
    for (const c2 in channels2) {
      if (!channels2[c2])
        continue;
      changes[c2] = ch[c2] + channels2[c2];
    }
    return change$1(color2, changes);
  };
  const adjust$1 = adjust;
  const mix = (color1, color2, weight = 50) => {
    const { r: r1, g: g1, b: b12, a: a1 } = Color$1.parse(color1);
    const { r: r2, g: g2, b: b22, a: a2 } = Color$1.parse(color2);
    const weightScale = weight / 100;
    const weightNormalized = weightScale * 2 - 1;
    const alphaDelta = a1 - a2;
    const weight1combined = weightNormalized * alphaDelta === -1 ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta);
    const weight1 = (weight1combined + 1) / 2;
    const weight2 = 1 - weight1;
    const r = r1 * weight1 + r2 * weight2;
    const g = g1 * weight1 + g2 * weight2;
    const b = b12 * weight1 + b22 * weight2;
    const a3 = a1 * weightScale + a2 * (1 - weightScale);
    return rgba$1(r, g, b, a3);
  };
  const mix$1 = mix;
  const invert = (color2, weight = 100) => {
    const inverse = Color$1.parse(color2);
    inverse.r = 255 - inverse.r;
    inverse.g = 255 - inverse.g;
    inverse.b = 255 - inverse.b;
    return mix$1(inverse, color2, weight);
  };
  const invert$1 = invert;
  const mkBorder = (col, darkMode) => darkMode ? adjust$1(col, { s: -40, l: 10 }) : adjust$1(col, { s: -40, l: -10 });
  const oldAttributeBackgroundColorOdd = "#ffffff";
  const oldAttributeBackgroundColorEven = "#f2f2f2";
  class Theme$4 {
    constructor() {
      this.background = "#f4f4f4";
      this.darkMode = false;
      this.primaryColor = "#fff4dd";
      this.noteBkgColor = "#fff5ad";
      this.noteTextColor = "#333";
      this.THEME_COLOR_LIMIT = 12;
      this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
      this.fontSize = "16px";
    }
    updateColors() {
      this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333");
      this.secondaryColor = this.secondaryColor || adjust$1(this.primaryColor, { h: -120 });
      this.tertiaryColor = this.tertiaryColor || adjust$1(this.primaryColor, { h: 180, l: 5 });
      this.primaryBorderColor = this.primaryBorderColor || mkBorder(this.primaryColor, this.darkMode);
      this.secondaryBorderColor = this.secondaryBorderColor || mkBorder(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = this.tertiaryBorderColor || mkBorder(this.tertiaryColor, this.darkMode);
      this.noteBorderColor = this.noteBorderColor || mkBorder(this.noteBkgColor, this.darkMode);
      this.noteBkgColor = this.noteBkgColor || "#fff5ad";
      this.noteTextColor = this.noteTextColor || "#333";
      this.secondaryTextColor = this.secondaryTextColor || invert$1(this.secondaryColor);
      this.tertiaryTextColor = this.tertiaryTextColor || invert$1(this.tertiaryColor);
      this.lineColor = this.lineColor || invert$1(this.background);
      this.textColor = this.textColor || this.primaryTextColor;
      this.nodeBkg = this.nodeBkg || this.primaryColor;
      this.mainBkg = this.mainBkg || this.primaryColor;
      this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
      this.clusterBkg = this.clusterBkg || this.tertiaryColor;
      this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
      this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
      this.titleColor = this.titleColor || this.tertiaryTextColor;
      this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
      this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
      this.actorBorder = this.actorBorder || this.primaryBorderColor;
      this.actorBkg = this.actorBkg || this.mainBkg;
      this.actorTextColor = this.actorTextColor || this.primaryTextColor;
      this.actorLineColor = this.actorLineColor || "grey";
      this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
      this.signalColor = this.signalColor || this.textColor;
      this.signalTextColor = this.signalTextColor || this.textColor;
      this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
      this.labelTextColor = this.labelTextColor || this.actorTextColor;
      this.loopTextColor = this.loopTextColor || this.actorTextColor;
      this.activationBorderColor = this.activationBorderColor || darken$1(this.secondaryColor, 10);
      this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
      this.sequenceNumberColor = this.sequenceNumberColor || invert$1(this.lineColor);
      this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
      this.altSectionBkgColor = this.altSectionBkgColor || "white";
      this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
      this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
      this.excludeBkgColor = this.excludeBkgColor || "#eeeeee";
      this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
      this.taskBkgColor = this.taskBkgColor || this.primaryColor;
      this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
      this.activeTaskBkgColor = this.activeTaskBkgColor || lighten$1(this.primaryColor, 23);
      this.gridColor = this.gridColor || "lightgrey";
      this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey";
      this.doneTaskBorderColor = this.doneTaskBorderColor || "grey";
      this.critBorderColor = this.critBorderColor || "#ff8888";
      this.critBkgColor = this.critBkgColor || "red";
      this.todayLineColor = this.todayLineColor || "red";
      this.taskTextColor = this.taskTextColor || this.textColor;
      this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
      this.taskTextLightColor = this.taskTextLightColor || this.textColor;
      this.taskTextColor = this.taskTextColor || this.primaryTextColor;
      this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
      this.taskTextClickableColor = this.taskTextClickableColor || "#003163";
      this.personBorder = this.personBorder || this.primaryBorderColor;
      this.personBkg = this.personBkg || this.mainBkg;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || this.tertiaryColor;
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.nodeBorder;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.specialStateColor = this.lineColor;
      this.cScale0 = this.cScale0 || this.primaryColor;
      this.cScale1 = this.cScale1 || this.secondaryColor;
      this.cScale2 = this.cScale2 || this.tertiaryColor;
      this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
      this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
      this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
      this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
      this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
      this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210, l: 150 });
      this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
      this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
      this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
      if (this.darkMode) {
        for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
          this["cScale" + i] = darken$1(this["cScale" + i], 75);
        }
      } else {
        for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
          this["cScale" + i] = darken$1(this["cScale" + i], 25);
        }
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        if (this.darkMode) {
          this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
        } else {
          this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 10);
        }
      }
      this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
      }
      this.classText = this.classText || this.textColor;
      this.fillType0 = this.fillType0 || this.primaryColor;
      this.fillType1 = this.fillType1 || this.secondaryColor;
      this.fillType2 = this.fillType2 || adjust$1(this.primaryColor, { h: 64 });
      this.fillType3 = this.fillType3 || adjust$1(this.secondaryColor, { h: 64 });
      this.fillType4 = this.fillType4 || adjust$1(this.primaryColor, { h: -64 });
      this.fillType5 = this.fillType5 || adjust$1(this.secondaryColor, { h: -64 });
      this.fillType6 = this.fillType6 || adjust$1(this.primaryColor, { h: 128 });
      this.fillType7 = this.fillType7 || adjust$1(this.secondaryColor, { h: 128 });
      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || this.tertiaryColor;
      this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -10 });
      this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -10 });
      this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { l: -10 });
      this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -10 });
      this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -10 });
      this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: 0 });
      this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -20 });
      this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -60, l: -20 });
      this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -10 });
      this.pieTitleTextSize = this.pieTitleTextSize || "25px";
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || "17px";
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || "17px";
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || "black";
      this.pieStrokeWidth = this.pieStrokeWidth || "2px";
      this.pieOpacity = this.pieOpacity || "0.7";
      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
      this.git0 = this.git0 || this.primaryColor;
      this.git1 = this.git1 || this.secondaryColor;
      this.git2 = this.git2 || this.tertiaryColor;
      this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
      this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
      this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
      this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
      this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
      if (this.darkMode) {
        this.git0 = lighten$1(this.git0, 25);
        this.git1 = lighten$1(this.git1, 25);
        this.git2 = lighten$1(this.git2, 25);
        this.git3 = lighten$1(this.git3, 25);
        this.git4 = lighten$1(this.git4, 25);
        this.git5 = lighten$1(this.git5, 25);
        this.git6 = lighten$1(this.git6, 25);
        this.git7 = lighten$1(this.git7, 25);
      } else {
        this.git0 = darken$1(this.git0, 25);
        this.git1 = darken$1(this.git1, 25);
        this.git2 = darken$1(this.git2, 25);
        this.git3 = darken$1(this.git3, 25);
        this.git4 = darken$1(this.git4, 25);
        this.git5 = darken$1(this.git5, 25);
        this.git6 = darken$1(this.git6, 25);
        this.git7 = darken$1(this.git7, 25);
      }
      this.gitInv0 = this.gitInv0 || invert$1(this.git0);
      this.gitInv1 = this.gitInv1 || invert$1(this.git1);
      this.gitInv2 = this.gitInv2 || invert$1(this.git2);
      this.gitInv3 = this.gitInv3 || invert$1(this.git3);
      this.gitInv4 = this.gitInv4 || invert$1(this.git4);
      this.gitInv5 = this.gitInv5 || invert$1(this.git5);
      this.gitInv6 = this.gitInv6 || invert$1(this.git6);
      this.gitInv7 = this.gitInv7 || invert$1(this.git7);
      this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor);
      this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor;
      this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor;
      this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor;
      this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor;
      this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor;
      this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor;
      this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor;
      this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor;
      this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
      this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
      this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
      this.tagLabelFontSize = this.tagLabelFontSize || "10px";
      this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
      this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
      this.commitLabelFontSize = this.commitLabelFontSize || "10px";
      this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
      this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
    }
    calculate(overrides) {
      if (typeof overrides !== "object") {
        this.updateColors();
        return;
      }
      const keys = Object.keys(overrides);
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
      this.updateColors();
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
    }
  }
  const getThemeVariables$4 = (userOverrides) => {
    const theme2 = new Theme$4();
    theme2.calculate(userOverrides);
    return theme2;
  };
  class Theme$3 {
    constructor() {
      this.background = "#333";
      this.primaryColor = "#1f2020";
      this.secondaryColor = lighten$1(this.primaryColor, 16);
      this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
      this.primaryBorderColor = invert$1(this.background);
      this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
      this.primaryTextColor = invert$1(this.primaryColor);
      this.secondaryTextColor = invert$1(this.secondaryColor);
      this.tertiaryTextColor = invert$1(this.tertiaryColor);
      this.lineColor = invert$1(this.background);
      this.textColor = invert$1(this.background);
      this.mainBkg = "#1f2020";
      this.secondBkg = "calculated";
      this.mainContrastColor = "lightgrey";
      this.darkTextColor = lighten$1(invert$1("#323D47"), 10);
      this.lineColor = "calculated";
      this.border1 = "#81B1DB";
      this.border2 = rgba$1(255, 255, 255, 0.25);
      this.arrowheadColor = "calculated";
      this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
      this.fontSize = "16px";
      this.labelBackground = "#181818";
      this.textColor = "#ccc";
      this.THEME_COLOR_LIMIT = 12;
      this.nodeBkg = "calculated";
      this.nodeBorder = "calculated";
      this.clusterBkg = "calculated";
      this.clusterBorder = "calculated";
      this.defaultLinkColor = "calculated";
      this.titleColor = "#F9FFFE";
      this.edgeLabelBackground = "calculated";
      this.actorBorder = "calculated";
      this.actorBkg = "calculated";
      this.actorTextColor = "calculated";
      this.actorLineColor = "calculated";
      this.signalColor = "calculated";
      this.signalTextColor = "calculated";
      this.labelBoxBkgColor = "calculated";
      this.labelBoxBorderColor = "calculated";
      this.labelTextColor = "calculated";
      this.loopTextColor = "calculated";
      this.noteBorderColor = "calculated";
      this.noteBkgColor = "#fff5ad";
      this.noteTextColor = "calculated";
      this.activationBorderColor = "calculated";
      this.activationBkgColor = "calculated";
      this.sequenceNumberColor = "black";
      this.sectionBkgColor = darken$1("#EAE8D9", 30);
      this.altSectionBkgColor = "calculated";
      this.sectionBkgColor2 = "#EAE8D9";
      this.taskBorderColor = rgba$1(255, 255, 255, 70);
      this.taskBkgColor = "calculated";
      this.taskTextColor = "calculated";
      this.taskTextLightColor = "calculated";
      this.taskTextOutsideColor = "calculated";
      this.taskTextClickableColor = "#003163";
      this.activeTaskBorderColor = rgba$1(255, 255, 255, 50);
      this.activeTaskBkgColor = "#81B1DB";
      this.gridColor = "calculated";
      this.doneTaskBkgColor = "calculated";
      this.doneTaskBorderColor = "grey";
      this.critBorderColor = "#E83737";
      this.critBkgColor = "#E83737";
      this.taskTextDarkColor = "calculated";
      this.todayLineColor = "#DB5757";
      this.personBorder = "calculated";
      this.personBkg = "calculated";
      this.labelColor = "calculated";
      this.errorBkgColor = "#a44141";
      this.errorTextColor = "#ddd";
    }
    updateColors() {
      this.secondBkg = lighten$1(this.mainBkg, 16);
      this.lineColor = this.mainContrastColor;
      this.arrowheadColor = this.mainContrastColor;
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.edgeLabelBackground = lighten$1(this.labelBackground, 25);
      this.actorBorder = this.border1;
      this.actorBkg = this.mainBkg;
      this.actorTextColor = this.mainContrastColor;
      this.actorLineColor = this.mainContrastColor;
      this.signalColor = this.mainContrastColor;
      this.signalTextColor = this.mainContrastColor;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.mainContrastColor;
      this.loopTextColor = this.mainContrastColor;
      this.noteBorderColor = this.secondaryBorderColor;
      this.noteBkgColor = this.secondBkg;
      this.noteTextColor = this.secondaryTextColor;
      this.activationBorderColor = this.border1;
      this.activationBkgColor = this.secondBkg;
      this.altSectionBkgColor = this.background;
      this.taskBkgColor = lighten$1(this.mainBkg, 23);
      this.taskTextColor = this.darkTextColor;
      this.taskTextLightColor = this.mainContrastColor;
      this.taskTextOutsideColor = this.taskTextLightColor;
      this.gridColor = this.mainContrastColor;
      this.doneTaskBkgColor = this.mainContrastColor;
      this.taskTextDarkColor = this.darkTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || "#555";
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = "#f4f4f4";
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
      this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
      this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
      this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
      this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
      this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
      this.cScale1 = this.cScale1 || "#0b0000";
      this.cScale2 = this.cScale2 || "#4d1037";
      this.cScale3 = this.cScale3 || "#3f5258";
      this.cScale4 = this.cScale4 || "#4f2f1b";
      this.cScale5 = this.cScale5 || "#6e0a0a";
      this.cScale6 = this.cScale6 || "#3b0048";
      this.cScale7 = this.cScale7 || "#995a01";
      this.cScale8 = this.cScale8 || "#154706";
      this.cScale9 = this.cScale9 || "#161722";
      this.cScale10 = this.cScale10 || "#00296f";
      this.cScale11 = this.cScale11 || "#01629c";
      this.cScale12 = this.cScale12 || "#010029";
      this.cScale0 = this.cScale0 || this.primaryColor;
      this.cScale1 = this.cScale1 || this.secondaryColor;
      this.cScale2 = this.cScale2 || this.tertiaryColor;
      this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
      this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
      this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
      this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
      this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
      this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
      this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
      this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
      this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
      }
      this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["pie" + i] = this["cScale" + i];
      }
      this.pieTitleTextSize = this.pieTitleTextSize || "25px";
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || "17px";
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || "17px";
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || "black";
      this.pieStrokeWidth = this.pieStrokeWidth || "2px";
      this.pieOpacity = this.pieOpacity || "0.7";
      this.classText = this.primaryTextColor;
      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken$1(this.secondaryColor, 30) : this.secondaryColor);
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
      this.git0 = lighten$1(this.secondaryColor, 20);
      this.git1 = lighten$1(this.pie2 || this.secondaryColor, 20);
      this.git2 = lighten$1(this.pie3 || this.tertiaryColor, 20);
      this.git3 = lighten$1(this.pie4 || adjust$1(this.primaryColor, { h: -30 }), 20);
      this.git4 = lighten$1(this.pie5 || adjust$1(this.primaryColor, { h: -60 }), 20);
      this.git5 = lighten$1(this.pie6 || adjust$1(this.primaryColor, { h: -90 }), 10);
      this.git6 = lighten$1(this.pie7 || adjust$1(this.primaryColor, { h: 60 }), 10);
      this.git7 = lighten$1(this.pie8 || adjust$1(this.primaryColor, { h: 120 }), 20);
      this.gitInv0 = this.gitInv0 || invert$1(this.git0);
      this.gitInv1 = this.gitInv1 || invert$1(this.git1);
      this.gitInv2 = this.gitInv2 || invert$1(this.git2);
      this.gitInv3 = this.gitInv3 || invert$1(this.git3);
      this.gitInv4 = this.gitInv4 || invert$1(this.git4);
      this.gitInv5 = this.gitInv5 || invert$1(this.git5);
      this.gitInv6 = this.gitInv6 || invert$1(this.git6);
      this.gitInv7 = this.gitInv7 || invert$1(this.git7);
      this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
      this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
      this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
      this.tagLabelFontSize = this.tagLabelFontSize || "10px";
      this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
      this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
      this.commitLabelFontSize = this.commitLabelFontSize || "10px";
      this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || lighten$1(this.background, 12);
      this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || lighten$1(this.background, 2);
    }
    calculate(overrides) {
      if (typeof overrides !== "object") {
        this.updateColors();
        return;
      }
      const keys = Object.keys(overrides);
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
      this.updateColors();
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
    }
  }
  const getThemeVariables$3 = (userOverrides) => {
    const theme2 = new Theme$3();
    theme2.calculate(userOverrides);
    return theme2;
  };
  class Theme$2 {
    constructor() {
      this.background = "#f4f4f4";
      this.primaryColor = "#ECECFF";
      this.secondaryColor = adjust$1(this.primaryColor, { h: 120 });
      this.secondaryColor = "#ffffde";
      this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
      this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
      this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
      this.primaryTextColor = invert$1(this.primaryColor);
      this.secondaryTextColor = invert$1(this.secondaryColor);
      this.tertiaryTextColor = invert$1(this.tertiaryColor);
      this.lineColor = invert$1(this.background);
      this.textColor = invert$1(this.background);
      this.background = "white";
      this.mainBkg = "#ECECFF";
      this.secondBkg = "#ffffde";
      this.lineColor = "#333333";
      this.border1 = "#9370DB";
      this.border2 = "#aaaa33";
      this.arrowheadColor = "#333333";
      this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
      this.fontSize = "16px";
      this.labelBackground = "#e8e8e8";
      this.textColor = "#333";
      this.THEME_COLOR_LIMIT = 12;
      this.nodeBkg = "calculated";
      this.nodeBorder = "calculated";
      this.clusterBkg = "calculated";
      this.clusterBorder = "calculated";
      this.defaultLinkColor = "calculated";
      this.titleColor = "calculated";
      this.edgeLabelBackground = "calculated";
      this.actorBorder = "calculated";
      this.actorBkg = "calculated";
      this.actorTextColor = "black";
      this.actorLineColor = "grey";
      this.signalColor = "calculated";
      this.signalTextColor = "calculated";
      this.labelBoxBkgColor = "calculated";
      this.labelBoxBorderColor = "calculated";
      this.labelTextColor = "calculated";
      this.loopTextColor = "calculated";
      this.noteBorderColor = "calculated";
      this.noteBkgColor = "#fff5ad";
      this.noteTextColor = "calculated";
      this.activationBorderColor = "#666";
      this.activationBkgColor = "#f4f4f4";
      this.sequenceNumberColor = "white";
      this.sectionBkgColor = "calculated";
      this.altSectionBkgColor = "calculated";
      this.sectionBkgColor2 = "calculated";
      this.excludeBkgColor = "#eeeeee";
      this.taskBorderColor = "calculated";
      this.taskBkgColor = "calculated";
      this.taskTextLightColor = "calculated";
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextDarkColor = "calculated";
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.taskTextClickableColor = "calculated";
      this.activeTaskBorderColor = "calculated";
      this.activeTaskBkgColor = "calculated";
      this.gridColor = "calculated";
      this.doneTaskBkgColor = "calculated";
      this.doneTaskBorderColor = "calculated";
      this.critBorderColor = "calculated";
      this.critBkgColor = "calculated";
      this.todayLineColor = "calculated";
      this.sectionBkgColor = rgba$1(102, 102, 255, 0.49);
      this.altSectionBkgColor = "white";
      this.sectionBkgColor2 = "#fff400";
      this.taskBorderColor = "#534fbc";
      this.taskBkgColor = "#8a90dd";
      this.taskTextLightColor = "white";
      this.taskTextColor = "calculated";
      this.taskTextDarkColor = "black";
      this.taskTextOutsideColor = "calculated";
      this.taskTextClickableColor = "#003163";
      this.activeTaskBorderColor = "#534fbc";
      this.activeTaskBkgColor = "#bfc7ff";
      this.gridColor = "lightgrey";
      this.doneTaskBkgColor = "lightgrey";
      this.doneTaskBorderColor = "grey";
      this.critBorderColor = "#ff8888";
      this.critBkgColor = "red";
      this.todayLineColor = "red";
      this.personBorder = "calculated";
      this.personBkg = "calculated";
      this.labelColor = "black";
      this.errorBkgColor = "#552222";
      this.errorTextColor = "#552222";
      this.updateColors();
    }
    updateColors() {
      this.cScale0 = this.cScale0 || this.primaryColor;
      this.cScale1 = this.cScale1 || this.secondaryColor;
      this.cScale2 = this.cScale2 || this.tertiaryColor;
      this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
      this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
      this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
      this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
      this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
      this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
      this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
      this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
      this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
      this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken$1(this.secondaryColor, 45);
      this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken$1(this.tertiaryColor, 40);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken$1(this["cScale" + i], 10);
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 25);
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$1(this["cScale" + i], { h: 180 });
      }
      this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
      if (this.labelTextColor !== "calculated") {
        this.cScaleLabel0 = this.cScaleLabel0 || invert$1(this.labelTextColor);
        this.cScaleLabel3 = this.cScaleLabel3 || invert$1(this.labelTextColor);
        for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
          this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.labelTextColor;
        }
      }
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.titleColor = this.textColor;
      this.edgeLabelBackground = this.labelBackground;
      this.actorBorder = lighten$1(this.border1, 23);
      this.actorBkg = this.mainBkg;
      this.labelBoxBkgColor = this.actorBkg;
      this.signalColor = this.textColor;
      this.signalTextColor = this.textColor;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.actorTextColor;
      this.loopTextColor = this.actorTextColor;
      this.noteBorderColor = this.border2;
      this.noteTextColor = this.actorTextColor;
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || "#f0f0f0";
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.nodeBorder;
      this.specialStateColor = this.lineColor;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.classText = this.primaryTextColor;
      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
      this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
      this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
      this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
      this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
      this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || adjust$1(this.tertiaryColor, { l: -40 });
      this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -10 });
      this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -30 });
      this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { l: -20 });
      this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -20 });
      this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -40 });
      this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: -40 });
      this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -40 });
      this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -90, l: -40 });
      this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -30 });
      this.pieTitleTextSize = this.pieTitleTextSize || "25px";
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || "17px";
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || "17px";
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || "black";
      this.pieStrokeWidth = this.pieStrokeWidth || "2px";
      this.pieOpacity = this.pieOpacity || "0.7";
      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
      this.git0 = this.git0 || this.primaryColor;
      this.git1 = this.git1 || this.secondaryColor;
      this.git2 = this.git2 || this.tertiaryColor;
      this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
      this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
      this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
      this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
      this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
      if (this.darkMode) {
        this.git0 = lighten$1(this.git0, 25);
        this.git1 = lighten$1(this.git1, 25);
        this.git2 = lighten$1(this.git2, 25);
        this.git3 = lighten$1(this.git3, 25);
        this.git4 = lighten$1(this.git4, 25);
        this.git5 = lighten$1(this.git5, 25);
        this.git6 = lighten$1(this.git6, 25);
        this.git7 = lighten$1(this.git7, 25);
      } else {
        this.git0 = darken$1(this.git0, 25);
        this.git1 = darken$1(this.git1, 25);
        this.git2 = darken$1(this.git2, 25);
        this.git3 = darken$1(this.git3, 25);
        this.git4 = darken$1(this.git4, 25);
        this.git5 = darken$1(this.git5, 25);
        this.git6 = darken$1(this.git6, 25);
        this.git7 = darken$1(this.git7, 25);
      }
      this.gitInv0 = this.gitInv0 || darken$1(invert$1(this.git0), 25);
      this.gitInv1 = this.gitInv1 || invert$1(this.git1);
      this.gitInv2 = this.gitInv2 || invert$1(this.git2);
      this.gitInv3 = this.gitInv3 || invert$1(this.git3);
      this.gitInv4 = this.gitInv4 || invert$1(this.git4);
      this.gitInv5 = this.gitInv5 || invert$1(this.git5);
      this.gitInv6 = this.gitInv6 || invert$1(this.git6);
      this.gitInv7 = this.gitInv7 || invert$1(this.git7);
      this.gitBranchLabel0 = this.gitBranchLabel0 || invert$1(this.labelTextColor);
      this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
      this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
      this.gitBranchLabel3 = this.gitBranchLabel3 || invert$1(this.labelTextColor);
      this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
      this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
      this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
      this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
      this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
      this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
      this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
      this.tagLabelFontSize = this.tagLabelFontSize || "10px";
      this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
      this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
      this.commitLabelFontSize = this.commitLabelFontSize || "10px";
      this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
      this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
    }
    calculate(overrides) {
      if (typeof overrides !== "object") {
        this.updateColors();
        return;
      }
      const keys = Object.keys(overrides);
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
      this.updateColors();
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
    }
  }
  const getThemeVariables$2 = (userOverrides) => {
    const theme2 = new Theme$2();
    theme2.calculate(userOverrides);
    return theme2;
  };
  class Theme$1 {
    constructor() {
      this.background = "#f4f4f4";
      this.primaryColor = "#cde498";
      this.secondaryColor = "#cdffb2";
      this.background = "white";
      this.mainBkg = "#cde498";
      this.secondBkg = "#cdffb2";
      this.lineColor = "green";
      this.border1 = "#13540c";
      this.border2 = "#6eaa49";
      this.arrowheadColor = "green";
      this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
      this.fontSize = "16px";
      this.tertiaryColor = lighten$1("#cde498", 10);
      this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
      this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
      this.primaryTextColor = invert$1(this.primaryColor);
      this.secondaryTextColor = invert$1(this.secondaryColor);
      this.tertiaryTextColor = invert$1(this.primaryColor);
      this.lineColor = invert$1(this.background);
      this.textColor = invert$1(this.background);
      this.THEME_COLOR_LIMIT = 12;
      this.nodeBkg = "calculated";
      this.nodeBorder = "calculated";
      this.clusterBkg = "calculated";
      this.clusterBorder = "calculated";
      this.defaultLinkColor = "calculated";
      this.titleColor = "#333";
      this.edgeLabelBackground = "#e8e8e8";
      this.actorBorder = "calculated";
      this.actorBkg = "calculated";
      this.actorTextColor = "black";
      this.actorLineColor = "grey";
      this.signalColor = "#333";
      this.signalTextColor = "#333";
      this.labelBoxBkgColor = "calculated";
      this.labelBoxBorderColor = "#326932";
      this.labelTextColor = "calculated";
      this.loopTextColor = "calculated";
      this.noteBorderColor = "calculated";
      this.noteBkgColor = "#fff5ad";
      this.noteTextColor = "calculated";
      this.activationBorderColor = "#666";
      this.activationBkgColor = "#f4f4f4";
      this.sequenceNumberColor = "white";
      this.sectionBkgColor = "#6eaa49";
      this.altSectionBkgColor = "white";
      this.sectionBkgColor2 = "#6eaa49";
      this.excludeBkgColor = "#eeeeee";
      this.taskBorderColor = "calculated";
      this.taskBkgColor = "#487e3a";
      this.taskTextLightColor = "white";
      this.taskTextColor = "calculated";
      this.taskTextDarkColor = "black";
      this.taskTextOutsideColor = "calculated";
      this.taskTextClickableColor = "#003163";
      this.activeTaskBorderColor = "calculated";
      this.activeTaskBkgColor = "calculated";
      this.gridColor = "lightgrey";
      this.doneTaskBkgColor = "lightgrey";
      this.doneTaskBorderColor = "grey";
      this.critBorderColor = "#ff8888";
      this.critBkgColor = "red";
      this.todayLineColor = "red";
      this.personBorder = "calculated";
      this.personBkg = "calculated";
      this.labelColor = "black";
      this.errorBkgColor = "#552222";
      this.errorTextColor = "#552222";
    }
    updateColors() {
      this.cScale0 = this.cScale0 || this.primaryColor;
      this.cScale1 = this.cScale1 || this.secondaryColor;
      this.cScale2 = this.cScale2 || this.tertiaryColor;
      this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
      this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
      this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
      this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
      this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
      this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
      this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
      this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
      this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
      this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken$1(this.secondaryColor, 45);
      this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken$1(this.tertiaryColor, 40);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken$1(this["cScale" + i], 10);
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 25);
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$1(this["cScale" + i], { h: 180 });
      }
      this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
      }
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.actorBorder = darken$1(this.mainBkg, 20);
      this.actorBkg = this.mainBkg;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelTextColor = this.actorTextColor;
      this.loopTextColor = this.actorTextColor;
      this.noteBorderColor = this.border2;
      this.noteTextColor = this.actorTextColor;
      this.taskBorderColor = this.border1;
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.activeTaskBorderColor = this.taskBorderColor;
      this.activeTaskBkgColor = this.mainBkg;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || "#f0f0f0";
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.compositeBorder = this.compositeBorder || this.nodeBorder;
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = this.lineColor;
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.transitionColor = this.transitionColor || this.lineColor;
      this.classText = this.primaryTextColor;
      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
      this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
      this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
      this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
      this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
      this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
      this.pie1 = this.pie1 || this.primaryColor;
      this.pie2 = this.pie2 || this.secondaryColor;
      this.pie3 = this.pie3 || this.tertiaryColor;
      this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -30 });
      this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -30 });
      this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { h: 40, l: -40 });
      this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -10 });
      this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -10 });
      this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: 0 });
      this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -50 });
      this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -60, l: -50 });
      this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -50 });
      this.pieTitleTextSize = this.pieTitleTextSize || "25px";
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || "17px";
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || "17px";
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || "black";
      this.pieStrokeWidth = this.pieStrokeWidth || "2px";
      this.pieOpacity = this.pieOpacity || "0.7";
      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
      this.git0 = this.git0 || this.primaryColor;
      this.git1 = this.git1 || this.secondaryColor;
      this.git2 = this.git2 || this.tertiaryColor;
      this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
      this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
      this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
      this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
      this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
      if (this.darkMode) {
        this.git0 = lighten$1(this.git0, 25);
        this.git1 = lighten$1(this.git1, 25);
        this.git2 = lighten$1(this.git2, 25);
        this.git3 = lighten$1(this.git3, 25);
        this.git4 = lighten$1(this.git4, 25);
        this.git5 = lighten$1(this.git5, 25);
        this.git6 = lighten$1(this.git6, 25);
        this.git7 = lighten$1(this.git7, 25);
      } else {
        this.git0 = darken$1(this.git0, 25);
        this.git1 = darken$1(this.git1, 25);
        this.git2 = darken$1(this.git2, 25);
        this.git3 = darken$1(this.git3, 25);
        this.git4 = darken$1(this.git4, 25);
        this.git5 = darken$1(this.git5, 25);
        this.git6 = darken$1(this.git6, 25);
        this.git7 = darken$1(this.git7, 25);
      }
      this.gitInv0 = this.gitInv0 || invert$1(this.git0);
      this.gitInv1 = this.gitInv1 || invert$1(this.git1);
      this.gitInv2 = this.gitInv2 || invert$1(this.git2);
      this.gitInv3 = this.gitInv3 || invert$1(this.git3);
      this.gitInv4 = this.gitInv4 || invert$1(this.git4);
      this.gitInv5 = this.gitInv5 || invert$1(this.git5);
      this.gitInv6 = this.gitInv6 || invert$1(this.git6);
      this.gitInv7 = this.gitInv7 || invert$1(this.git7);
      this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
      this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
      this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
      this.tagLabelFontSize = this.tagLabelFontSize || "10px";
      this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
      this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
      this.commitLabelFontSize = this.commitLabelFontSize || "10px";
      this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
      this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
    }
    calculate(overrides) {
      if (typeof overrides !== "object") {
        this.updateColors();
        return;
      }
      const keys = Object.keys(overrides);
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
      this.updateColors();
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
    }
  }
  const getThemeVariables$1 = (userOverrides) => {
    const theme2 = new Theme$1();
    theme2.calculate(userOverrides);
    return theme2;
  };
  class Theme {
    constructor() {
      this.primaryColor = "#eee";
      this.contrast = "#707070";
      this.secondaryColor = lighten$1(this.contrast, 55);
      this.background = "#ffffff";
      this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
      this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
      this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
      this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
      this.primaryTextColor = invert$1(this.primaryColor);
      this.secondaryTextColor = invert$1(this.secondaryColor);
      this.tertiaryTextColor = invert$1(this.tertiaryColor);
      this.lineColor = invert$1(this.background);
      this.textColor = invert$1(this.background);
      this.mainBkg = "#eee";
      this.secondBkg = "calculated";
      this.lineColor = "#666";
      this.border1 = "#999";
      this.border2 = "calculated";
      this.note = "#ffa";
      this.text = "#333";
      this.critical = "#d42";
      this.done = "#bbb";
      this.arrowheadColor = "#333333";
      this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
      this.fontSize = "16px";
      this.THEME_COLOR_LIMIT = 12;
      this.nodeBkg = "calculated";
      this.nodeBorder = "calculated";
      this.clusterBkg = "calculated";
      this.clusterBorder = "calculated";
      this.defaultLinkColor = "calculated";
      this.titleColor = "calculated";
      this.edgeLabelBackground = "white";
      this.actorBorder = "calculated";
      this.actorBkg = "calculated";
      this.actorTextColor = "calculated";
      this.actorLineColor = "calculated";
      this.signalColor = "calculated";
      this.signalTextColor = "calculated";
      this.labelBoxBkgColor = "calculated";
      this.labelBoxBorderColor = "calculated";
      this.labelTextColor = "calculated";
      this.loopTextColor = "calculated";
      this.noteBorderColor = "calculated";
      this.noteBkgColor = "calculated";
      this.noteTextColor = "calculated";
      this.activationBorderColor = "#666";
      this.activationBkgColor = "#f4f4f4";
      this.sequenceNumberColor = "white";
      this.sectionBkgColor = "calculated";
      this.altSectionBkgColor = "white";
      this.sectionBkgColor2 = "calculated";
      this.excludeBkgColor = "#eeeeee";
      this.taskBorderColor = "calculated";
      this.taskBkgColor = "calculated";
      this.taskTextLightColor = "white";
      this.taskTextColor = "calculated";
      this.taskTextDarkColor = "calculated";
      this.taskTextOutsideColor = "calculated";
      this.taskTextClickableColor = "#003163";
      this.activeTaskBorderColor = "calculated";
      this.activeTaskBkgColor = "calculated";
      this.gridColor = "calculated";
      this.doneTaskBkgColor = "calculated";
      this.doneTaskBorderColor = "calculated";
      this.critBkgColor = "calculated";
      this.critBorderColor = "calculated";
      this.todayLineColor = "calculated";
      this.personBorder = "calculated";
      this.personBkg = "calculated";
      this.labelColor = "black";
      this.errorBkgColor = "#552222";
      this.errorTextColor = "#552222";
    }
    updateColors() {
      this.secondBkg = lighten$1(this.contrast, 55);
      this.border2 = this.contrast;
      this.cScale0 = this.cScale0 || "#555";
      this.cScale1 = this.cScale1 || "#F4F4F4";
      this.cScale2 = this.cScale2 || "#555";
      this.cScale3 = this.cScale3 || "#BBB";
      this.cScale4 = this.cScale4 || "#777";
      this.cScale5 = this.cScale5 || "#999";
      this.cScale6 = this.cScale6 || "#DDD";
      this.cScale7 = this.cScale7 || "#FFF";
      this.cScale8 = this.cScale8 || "#DDD";
      this.cScale9 = this.cScale9 || "#BBB";
      this.cScale10 = this.cScale10 || "#999";
      this.cScale11 = this.cScale11 || "#777";
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleInv" + i] = this["cScaleInv" + i] || invert$1(this["cScale" + i]);
      }
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        if (this.darkMode) {
          this["cScalePeer" + i] = this["cScalePeer" + i] || lighten$1(this["cScale" + i], 10);
        } else {
          this["cScalePeer" + i] = this["cScalePeer" + i] || darken$1(this["cScale" + i], 10);
        }
      }
      this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
      this["cScaleLabel0"] = this["cScaleLabel0"] || this.cScale1;
      this["cScaleLabel2"] = this["cScaleLabel2"] || this.cScale1;
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
      }
      this.nodeBkg = this.mainBkg;
      this.nodeBorder = this.border1;
      this.clusterBkg = this.secondBkg;
      this.clusterBorder = this.border2;
      this.defaultLinkColor = this.lineColor;
      this.titleColor = this.text;
      this.actorBorder = lighten$1(this.border1, 23);
      this.actorBkg = this.mainBkg;
      this.actorTextColor = this.text;
      this.actorLineColor = this.lineColor;
      this.signalColor = this.text;
      this.signalTextColor = this.text;
      this.labelBoxBkgColor = this.actorBkg;
      this.labelBoxBorderColor = this.actorBorder;
      this.labelTextColor = this.text;
      this.loopTextColor = this.text;
      this.noteBorderColor = "#999";
      this.noteBkgColor = "#666";
      this.noteTextColor = "#fff";
      this.sectionBkgColor = lighten$1(this.contrast, 30);
      this.sectionBkgColor2 = lighten$1(this.contrast, 30);
      this.taskBorderColor = darken$1(this.contrast, 10);
      this.taskBkgColor = this.contrast;
      this.taskTextColor = this.taskTextLightColor;
      this.taskTextDarkColor = this.text;
      this.taskTextOutsideColor = this.taskTextDarkColor;
      this.activeTaskBorderColor = this.taskBorderColor;
      this.activeTaskBkgColor = this.mainBkg;
      this.gridColor = lighten$1(this.border1, 30);
      this.doneTaskBkgColor = this.done;
      this.doneTaskBorderColor = this.lineColor;
      this.critBkgColor = this.critical;
      this.critBorderColor = darken$1(this.critBkgColor, 10);
      this.todayLineColor = this.critBkgColor;
      this.transitionColor = this.transitionColor || "#000";
      this.transitionLabelColor = this.transitionLabelColor || this.textColor;
      this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
      this.stateBkg = this.stateBkg || this.mainBkg;
      this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
      this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
      this.altBackground = this.altBackground || "#f4f4f4";
      this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
      this.stateBorder = this.stateBorder || "#000";
      this.innerEndBackground = this.primaryBorderColor;
      this.specialStateColor = "#222";
      this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
      this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
      this.classText = this.primaryTextColor;
      this.fillType0 = this.primaryColor;
      this.fillType1 = this.secondaryColor;
      this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
      this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
      this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
      this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
      this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
      this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["pie" + i] = this["cScale" + i];
      }
      this.pie12 = this.pie0;
      this.pieTitleTextSize = this.pieTitleTextSize || "25px";
      this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
      this.pieSectionTextSize = this.pieSectionTextSize || "17px";
      this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
      this.pieLegendTextSize = this.pieLegendTextSize || "17px";
      this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
      this.pieStrokeColor = this.pieStrokeColor || "black";
      this.pieStrokeWidth = this.pieStrokeWidth || "2px";
      this.pieOpacity = this.pieOpacity || "0.7";
      this.requirementBackground = this.requirementBackground || this.primaryColor;
      this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
      this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
      this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
      this.relationColor = this.relationColor || this.lineColor;
      this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
      this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
      this.git0 = darken$1(this.pie1, 25) || this.primaryColor;
      this.git1 = this.pie2 || this.secondaryColor;
      this.git2 = this.pie3 || this.tertiaryColor;
      this.git3 = this.pie4 || adjust$1(this.primaryColor, { h: -30 });
      this.git4 = this.pie5 || adjust$1(this.primaryColor, { h: -60 });
      this.git5 = this.pie6 || adjust$1(this.primaryColor, { h: -90 });
      this.git6 = this.pie7 || adjust$1(this.primaryColor, { h: 60 });
      this.git7 = this.pie8 || adjust$1(this.primaryColor, { h: 120 });
      this.gitInv0 = this.gitInv0 || invert$1(this.git0);
      this.gitInv1 = this.gitInv1 || invert$1(this.git1);
      this.gitInv2 = this.gitInv2 || invert$1(this.git2);
      this.gitInv3 = this.gitInv3 || invert$1(this.git3);
      this.gitInv4 = this.gitInv4 || invert$1(this.git4);
      this.gitInv5 = this.gitInv5 || invert$1(this.git5);
      this.gitInv6 = this.gitInv6 || invert$1(this.git6);
      this.gitInv7 = this.gitInv7 || invert$1(this.git7);
      this.branchLabelColor = this.branchLabelColor || this.labelTextColor;
      this.gitBranchLabel0 = this.branchLabelColor;
      this.gitBranchLabel1 = "white";
      this.gitBranchLabel2 = this.branchLabelColor;
      this.gitBranchLabel3 = "white";
      this.gitBranchLabel4 = this.branchLabelColor;
      this.gitBranchLabel5 = this.branchLabelColor;
      this.gitBranchLabel6 = this.branchLabelColor;
      this.gitBranchLabel7 = this.branchLabelColor;
      this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
      this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
      this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
      this.tagLabelFontSize = this.tagLabelFontSize || "10px";
      this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
      this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
      this.commitLabelFontSize = this.commitLabelFontSize || "10px";
      this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
      this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
    }
    calculate(overrides) {
      if (typeof overrides !== "object") {
        this.updateColors();
        return;
      }
      const keys = Object.keys(overrides);
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
      this.updateColors();
      keys.forEach((k2) => {
        this[k2] = overrides[k2];
      });
    }
  }
  const getThemeVariables = (userOverrides) => {
    const theme2 = new Theme();
    theme2.calculate(userOverrides);
    return theme2;
  };
  const theme = {
    base: {
      getThemeVariables: getThemeVariables$4
    },
    dark: {
      getThemeVariables: getThemeVariables$3
    },
    default: {
      getThemeVariables: getThemeVariables$2
    },
    forest: {
      getThemeVariables: getThemeVariables$1
    },
    neutral: {
      getThemeVariables
    }
  };
  const config$1 = {
    theme: "default",
    themeVariables: theme["default"].getThemeVariables(),
    themeCSS: void 0,
    maxTextSize: 5e4,
    darkMode: false,
    fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
    logLevel: 5,
    securityLevel: "strict",
    startOnLoad: true,
    arrowMarkerAbsolute: false,
    secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize"],
    lazyLoadedDiagrams: [],
    deterministicIds: false,
    deterministicIDSeed: void 0,
    flowchart: {
      diagramPadding: 8,
      htmlLabels: true,
      nodeSpacing: 50,
      rankSpacing: 50,
      curve: "basis",
      padding: 15,
      useMaxWidth: true,
      defaultRenderer: "dagre-wrapper"
    },
    sequence: {
      hideUnusedParticipants: false,
      activationWidth: 10,
      diagramMarginX: 50,
      diagramMarginY: 10,
      actorMargin: 50,
      width: 150,
      height: 65,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: "center",
      mirrorActors: true,
      forceMenus: false,
      bottomMarginAdj: 1,
      useMaxWidth: true,
      rightAngles: false,
      showSequenceNumbers: false,
      actorFontSize: 14,
      actorFontFamily: '"Open Sans", sans-serif',
      actorFontWeight: 400,
      noteFontSize: 14,
      noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      noteFontWeight: 400,
      noteAlign: "center",
      messageFontSize: 16,
      messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
      messageFontWeight: 400,
      wrap: false,
      wrapPadding: 10,
      labelBoxWidth: 50,
      labelBoxHeight: 20,
      messageFont: function() {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight
        };
      },
      noteFont: function() {
        return {
          fontFamily: this.noteFontFamily,
          fontSize: this.noteFontSize,
          fontWeight: this.noteFontWeight
        };
      },
      actorFont: function() {
        return {
          fontFamily: this.actorFontFamily,
          fontSize: this.actorFontSize,
          fontWeight: this.actorFontWeight
        };
      }
    },
    gantt: {
      titleTopMargin: 25,
      barHeight: 20,
      barGap: 4,
      topPadding: 50,
      rightPadding: 75,
      leftPadding: 75,
      gridLineStartPadding: 35,
      fontSize: 11,
      sectionFontSize: 11,
      numberSectionStyles: 4,
      axisFormat: "%Y-%m-%d",
      useMaxWidth: true,
      topAxis: false,
      useWidth: void 0
    },
    journey: {
      diagramMarginX: 50,
      diagramMarginY: 10,
      leftMargin: 150,
      width: 150,
      height: 50,
      boxMargin: 10,
      boxTextMargin: 5,
      noteMargin: 10,
      messageMargin: 35,
      messageAlign: "center",
      bottomMarginAdj: 1,
      useMaxWidth: true,
      rightAngles: false,
      taskFontSize: 14,
      taskFontFamily: '"Open Sans", sans-serif',
      taskMargin: 50,
      activationWidth: 10,
      textPlacement: "fo",
      actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
      sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
      sectionColours: ["#fff"]
    },
    class: {
      arrowMarkerAbsolute: false,
      dividerMargin: 10,
      padding: 5,
      textHeight: 10,
      useMaxWidth: true,
      defaultRenderer: "dagre-wrapper"
    },
    state: {
      dividerMargin: 10,
      sizeUnit: 5,
      padding: 8,
      textHeight: 10,
      titleShift: -15,
      noteMargin: 10,
      forkWidth: 70,
      forkHeight: 7,
      miniPadding: 2,
      fontSizeFactor: 5.02,
      fontSize: 24,
      labelHeight: 16,
      edgeLengthFactor: "20",
      compositTitleSize: 35,
      radius: 5,
      useMaxWidth: true,
      defaultRenderer: "dagre-wrapper"
    },
    er: {
      diagramPadding: 20,
      layoutDirection: "TB",
      minEntityWidth: 100,
      minEntityHeight: 75,
      entityPadding: 15,
      stroke: "gray",
      fill: "honeydew",
      fontSize: 12,
      useMaxWidth: true
    },
    pie: {
      useWidth: void 0,
      useMaxWidth: true
    },
    requirement: {
      useWidth: void 0,
      useMaxWidth: true,
      rect_fill: "#f9f9f9",
      text_color: "#333",
      rect_border_size: "0.5px",
      rect_border_color: "#bbb",
      rect_min_width: 200,
      rect_min_height: 200,
      fontSize: 14,
      rect_padding: 10,
      line_height: 20
    },
    gitGraph: {
      diagramPadding: 8,
      nodeLabel: {
        width: 75,
        height: 100,
        x: -25,
        y: 0
      },
      mainBranchName: "main",
      mainBranchOrder: 0,
      showCommitLabel: true,
      showBranches: true,
      rotateCommitLabel: true
    },
    c4: {
      useWidth: void 0,
      diagramMarginX: 50,
      diagramMarginY: 10,
      c4ShapeMargin: 50,
      c4ShapePadding: 20,
      width: 216,
      height: 60,
      boxMargin: 10,
      useMaxWidth: true,
      c4ShapeInRow: 4,
      nextLinePaddingX: 0,
      c4BoundaryInRow: 2,
      personFontSize: 14,
      personFontFamily: '"Open Sans", sans-serif',
      personFontWeight: "normal",
      external_personFontSize: 14,
      external_personFontFamily: '"Open Sans", sans-serif',
      external_personFontWeight: "normal",
      systemFontSize: 14,
      systemFontFamily: '"Open Sans", sans-serif',
      systemFontWeight: "normal",
      external_systemFontSize: 14,
      external_systemFontFamily: '"Open Sans", sans-serif',
      external_systemFontWeight: "normal",
      system_dbFontSize: 14,
      system_dbFontFamily: '"Open Sans", sans-serif',
      system_dbFontWeight: "normal",
      external_system_dbFontSize: 14,
      external_system_dbFontFamily: '"Open Sans", sans-serif',
      external_system_dbFontWeight: "normal",
      system_queueFontSize: 14,
      system_queueFontFamily: '"Open Sans", sans-serif',
      system_queueFontWeight: "normal",
      external_system_queueFontSize: 14,
      external_system_queueFontFamily: '"Open Sans", sans-serif',
      external_system_queueFontWeight: "normal",
      boundaryFontSize: 14,
      boundaryFontFamily: '"Open Sans", sans-serif',
      boundaryFontWeight: "normal",
      messageFontSize: 12,
      messageFontFamily: '"Open Sans", sans-serif',
      messageFontWeight: "normal",
      containerFontSize: 14,
      containerFontFamily: '"Open Sans", sans-serif',
      containerFontWeight: "normal",
      external_containerFontSize: 14,
      external_containerFontFamily: '"Open Sans", sans-serif',
      external_containerFontWeight: "normal",
      container_dbFontSize: 14,
      container_dbFontFamily: '"Open Sans", sans-serif',
      container_dbFontWeight: "normal",
      external_container_dbFontSize: 14,
      external_container_dbFontFamily: '"Open Sans", sans-serif',
      external_container_dbFontWeight: "normal",
      container_queueFontSize: 14,
      container_queueFontFamily: '"Open Sans", sans-serif',
      container_queueFontWeight: "normal",
      external_container_queueFontSize: 14,
      external_container_queueFontFamily: '"Open Sans", sans-serif',
      external_container_queueFontWeight: "normal",
      componentFontSize: 14,
      componentFontFamily: '"Open Sans", sans-serif',
      componentFontWeight: "normal",
      external_componentFontSize: 14,
      external_componentFontFamily: '"Open Sans", sans-serif',
      external_componentFontWeight: "normal",
      component_dbFontSize: 14,
      component_dbFontFamily: '"Open Sans", sans-serif',
      component_dbFontWeight: "normal",
      external_component_dbFontSize: 14,
      external_component_dbFontFamily: '"Open Sans", sans-serif',
      external_component_dbFontWeight: "normal",
      component_queueFontSize: 14,
      component_queueFontFamily: '"Open Sans", sans-serif',
      component_queueFontWeight: "normal",
      external_component_queueFontSize: 14,
      external_component_queueFontFamily: '"Open Sans", sans-serif',
      external_component_queueFontWeight: "normal",
      wrap: true,
      wrapPadding: 10,
      personFont: function() {
        return {
          fontFamily: this.personFontFamily,
          fontSize: this.personFontSize,
          fontWeight: this.personFontWeight
        };
      },
      external_personFont: function() {
        return {
          fontFamily: this.external_personFontFamily,
          fontSize: this.external_personFontSize,
          fontWeight: this.external_personFontWeight
        };
      },
      systemFont: function() {
        return {
          fontFamily: this.systemFontFamily,
          fontSize: this.systemFontSize,
          fontWeight: this.systemFontWeight
        };
      },
      external_systemFont: function() {
        return {
          fontFamily: this.external_systemFontFamily,
          fontSize: this.external_systemFontSize,
          fontWeight: this.external_systemFontWeight
        };
      },
      system_dbFont: function() {
        return {
          fontFamily: this.system_dbFontFamily,
          fontSize: this.system_dbFontSize,
          fontWeight: this.system_dbFontWeight
        };
      },
      external_system_dbFont: function() {
        return {
          fontFamily: this.external_system_dbFontFamily,
          fontSize: this.external_system_dbFontSize,
          fontWeight: this.external_system_dbFontWeight
        };
      },
      system_queueFont: function() {
        return {
          fontFamily: this.system_queueFontFamily,
          fontSize: this.system_queueFontSize,
          fontWeight: this.system_queueFontWeight
        };
      },
      external_system_queueFont: function() {
        return {
          fontFamily: this.external_system_queueFontFamily,
          fontSize: this.external_system_queueFontSize,
          fontWeight: this.external_system_queueFontWeight
        };
      },
      containerFont: function() {
        return {
          fontFamily: this.containerFontFamily,
          fontSize: this.containerFontSize,
          fontWeight: this.containerFontWeight
        };
      },
      external_containerFont: function() {
        return {
          fontFamily: this.external_containerFontFamily,
          fontSize: this.external_containerFontSize,
          fontWeight: this.external_containerFontWeight
        };
      },
      container_dbFont: function() {
        return {
          fontFamily: this.container_dbFontFamily,
          fontSize: this.container_dbFontSize,
          fontWeight: this.container_dbFontWeight
        };
      },
      external_container_dbFont: function() {
        return {
          fontFamily: this.external_container_dbFontFamily,
          fontSize: this.external_container_dbFontSize,
          fontWeight: this.external_container_dbFontWeight
        };
      },
      container_queueFont: function() {
        return {
          fontFamily: this.container_queueFontFamily,
          fontSize: this.container_queueFontSize,
          fontWeight: this.container_queueFontWeight
        };
      },
      external_container_queueFont: function() {
        return {
          fontFamily: this.external_container_queueFontFamily,
          fontSize: this.external_container_queueFontSize,
          fontWeight: this.external_container_queueFontWeight
        };
      },
      componentFont: function() {
        return {
          fontFamily: this.componentFontFamily,
          fontSize: this.componentFontSize,
          fontWeight: this.componentFontWeight
        };
      },
      external_componentFont: function() {
        return {
          fontFamily: this.external_componentFontFamily,
          fontSize: this.external_componentFontSize,
          fontWeight: this.external_componentFontWeight
        };
      },
      component_dbFont: function() {
        return {
          fontFamily: this.component_dbFontFamily,
          fontSize: this.component_dbFontSize,
          fontWeight: this.component_dbFontWeight
        };
      },
      external_component_dbFont: function() {
        return {
          fontFamily: this.external_component_dbFontFamily,
          fontSize: this.external_component_dbFontSize,
          fontWeight: this.external_component_dbFontWeight
        };
      },
      component_queueFont: function() {
        return {
          fontFamily: this.component_queueFontFamily,
          fontSize: this.component_queueFontSize,
          fontWeight: this.component_queueFontWeight
        };
      },
      external_component_queueFont: function() {
        return {
          fontFamily: this.external_component_queueFontFamily,
          fontSize: this.external_component_queueFontSize,
          fontWeight: this.external_component_queueFontWeight
        };
      },
      boundaryFont: function() {
        return {
          fontFamily: this.boundaryFontFamily,
          fontSize: this.boundaryFontSize,
          fontWeight: this.boundaryFontWeight
        };
      },
      messageFont: function() {
        return {
          fontFamily: this.messageFontFamily,
          fontSize: this.messageFontSize,
          fontWeight: this.messageFontWeight
        };
      },
      person_bg_color: "#08427B",
      person_border_color: "#073B6F",
      external_person_bg_color: "#686868",
      external_person_border_color: "#8A8A8A",
      system_bg_color: "#1168BD",
      system_border_color: "#3C7FC0",
      system_db_bg_color: "#1168BD",
      system_db_border_color: "#3C7FC0",
      system_queue_bg_color: "#1168BD",
      system_queue_border_color: "#3C7FC0",
      external_system_bg_color: "#999999",
      external_system_border_color: "#8A8A8A",
      external_system_db_bg_color: "#999999",
      external_system_db_border_color: "#8A8A8A",
      external_system_queue_bg_color: "#999999",
      external_system_queue_border_color: "#8A8A8A",
      container_bg_color: "#438DD5",
      container_border_color: "#3C7FC0",
      container_db_bg_color: "#438DD5",
      container_db_border_color: "#3C7FC0",
      container_queue_bg_color: "#438DD5",
      container_queue_border_color: "#3C7FC0",
      external_container_bg_color: "#B3B3B3",
      external_container_border_color: "#A6A6A6",
      external_container_db_bg_color: "#B3B3B3",
      external_container_db_border_color: "#A6A6A6",
      external_container_queue_bg_color: "#B3B3B3",
      external_container_queue_border_color: "#A6A6A6",
      component_bg_color: "#85BBF0",
      component_border_color: "#78A8D8",
      component_db_bg_color: "#85BBF0",
      component_db_border_color: "#78A8D8",
      component_queue_bg_color: "#85BBF0",
      component_queue_border_color: "#78A8D8",
      external_component_bg_color: "#CCCCCC",
      external_component_border_color: "#BFBFBF",
      external_component_db_bg_color: "#CCCCCC",
      external_component_db_border_color: "#BFBFBF",
      external_component_queue_bg_color: "#CCCCCC",
      external_component_queue_border_color: "#BFBFBF"
    },
    mindmap: {
      useMaxWidth: true,
      padding: 10,
      maxNodeWidth: 200
    },
    fontSize: 16
  };
  if (config$1.class)
    config$1.class.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
  if (config$1.gitGraph)
    config$1.gitGraph.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
  const keyify = (obj, prefix = "") => Object.keys(obj).reduce((res, el) => {
    if (Array.isArray(obj[el])) {
      return res;
    } else if (typeof obj[el] === "object" && obj[el] !== null) {
      return [...res, prefix + el, ...keyify(obj[el], "")];
    }
    return [...res, prefix + el];
  }, []);
  const configKeys = keyify(config$1, "");
  const directive$1 = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
  const anyComment = /\s*%%.*\n/gm;
  const detectors = {};
  const detectType = function(text2, config2) {
    text2 = text2.replace(directive$1, "").replace(anyComment, "\n");
    for (const [key, { detector }] of Object.entries(detectors)) {
      const diagram = detector(text2, config2);
      if (diagram) {
        return key;
      }
    }
    throw new Error(`No diagram type detected for text: ${text2}`);
  };
  const addDetector = (key, detector, loader) => {
    if (detectors[key]) {
      throw new Error(`Detector with key ${key} already exists`);
    }
    detectors[key] = { detector, loader };
    log$3.debug(`Detector with key ${key} added${loader ? " with loader" : ""}`);
  };
  const getDiagramLoader = (key) => detectors[key].loader;
  const assignWithDepth = function(dst, src2, config2) {
    const { depth, clobber } = Object.assign({ depth: 2, clobber: false }, config2);
    if (Array.isArray(src2) && !Array.isArray(dst)) {
      src2.forEach((s2) => assignWithDepth(dst, s2, config2));
      return dst;
    } else if (Array.isArray(src2) && Array.isArray(dst)) {
      src2.forEach((s2) => {
        if (dst.indexOf(s2) === -1) {
          dst.push(s2);
        }
      });
      return dst;
    }
    if (typeof dst === "undefined" || depth <= 0) {
      if (dst !== void 0 && dst !== null && typeof dst === "object" && typeof src2 === "object") {
        return Object.assign(dst, src2);
      } else {
        return src2;
      }
    }
    if (typeof src2 !== "undefined" && typeof dst === "object" && typeof src2 === "object") {
      Object.keys(src2).forEach((key) => {
        if (typeof src2[key] === "object" && (dst[key] === void 0 || typeof dst[key] === "object")) {
          if (dst[key] === void 0) {
            dst[key] = Array.isArray(src2[key]) ? [] : {};
          }
          dst[key] = assignWithDepth(dst[key], src2[key], { depth: depth - 1, clobber });
        } else if (clobber || typeof dst[key] !== "object" && typeof src2[key] !== "object") {
          dst[key] = src2[key];
        }
      });
    }
    return dst;
  };
  var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;
  var freeGlobal = _freeGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root$3 = freeGlobal || freeSelf || Function("return this")();
  var _root = root$3;
  var root$2 = _root;
  var Symbol$3 = root$2.Symbol;
  var _Symbol = Symbol$3;
  var Symbol$2 = _Symbol;
  var objectProto$4 = Object.prototype;
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
  var nativeObjectToString$1 = objectProto$4.toString;
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$3.call(value, symToStringTag$1), tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;
  var objectProto$3 = Object.prototype;
  var nativeObjectToString = objectProto$3.toString;
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }
  var _objectToString = objectToString$1;
  var Symbol$1 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
  function baseGetTag$1(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var _baseGetTag = baseGetTag$1;
  function isObject$2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  var isObject_1 = isObject$2;
  var baseGetTag = _baseGetTag, isObject$1 = isObject_1;
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$1;
  var root$1 = _root;
  var coreJsData$1 = root$1["__core-js_shared__"];
  var _coreJsData = coreJsData$1;
  var coreJsData = _coreJsData;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;
  var funcProto$1 = Function.prototype;
  var funcToString$1 = funcProto$1.toString;
  function toSource$1(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var _toSource = toSource$1;
  var isFunction = isFunction_1, isMasked = _isMasked, isObject = isObject_1, toSource = _toSource;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto$2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty$2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative$1(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  var _baseIsNative = baseIsNative$1;
  function getValue$1(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  var _getValue = getValue$1;
  var baseIsNative = _baseIsNative, getValue = _getValue;
  function getNative$2(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  var _getNative = getNative$2;
  var getNative$1 = _getNative;
  var nativeCreate$4 = getNative$1(Object, "create");
  var _nativeCreate = nativeCreate$4;
  var nativeCreate$3 = _nativeCreate;
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;
  var nativeCreate$2 = _nativeCreate;
  var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
  var objectProto$1 = Object.prototype;
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$1 ? void 0 : result;
    }
    return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
  }
  var _hashGet = hashGet$1;
  var nativeCreate$1 = _nativeCreate;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  var _hashHas = hashHas$1;
  var nativeCreate = _nativeCreate;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  var _hashSet = hashSet$1;
  var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
  function Hash$1(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype["delete"] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;
  function eq$1(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_1 = eq$1;
  var eq = eq_1;
  function assocIndexOf$4(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;
  var assocIndexOf$3 = _assocIndexOf;
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete$1(key) {
    var data = this.__data__, index2 = assocIndexOf$3(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;
  var assocIndexOf$2 = _assocIndexOf;
  function listCacheGet$1(key) {
    var data = this.__data__, index2 = assocIndexOf$2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  var _listCacheGet = listCacheGet$1;
  var assocIndexOf$1 = _assocIndexOf;
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;
  var assocIndexOf = _assocIndexOf;
  function listCacheSet$1(key, value) {
    var data = this.__data__, index2 = assocIndexOf(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;
  var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
  function ListCache$1(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache$1.prototype.clear = listCacheClear;
  ListCache$1.prototype["delete"] = listCacheDelete;
  ListCache$1.prototype.get = listCacheGet;
  ListCache$1.prototype.has = listCacheHas;
  ListCache$1.prototype.set = listCacheSet;
  var _ListCache = ListCache$1;
  var getNative = _getNative, root = _root;
  var Map$2 = getNative(root, "Map");
  var _Map = Map$2;
  var Hash = _Hash, ListCache = _ListCache, Map$1 = _Map;
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map$1 || ListCache)(),
      "string": new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;
  function isKeyable$1(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  var _isKeyable = isKeyable$1;
  var isKeyable = _isKeyable;
  function getMapData$4(map2, key) {
    var data = map2.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  var _getMapData = getMapData$4;
  var getMapData$3 = _getMapData;
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;
  var getMapData$2 = _getMapData;
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;
  var getMapData$1 = _getMapData;
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;
  var getMapData = _getMapData;
  function mapCacheSet$1(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;
  var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
  function MapCache$1(entries) {
    var index2 = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache$1.prototype.clear = mapCacheClear;
  MapCache$1.prototype["delete"] = mapCacheDelete;
  MapCache$1.prototype.get = mapCacheGet;
  MapCache$1.prototype.has = mapCacheHas;
  MapCache$1.prototype.set = mapCacheSet;
  var _MapCache = MapCache$1;
  var MapCache = _MapCache;
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  var memoize_1 = memoize;
  const d3CurveTypes = {
    curveBasis,
    curveBasisClosed,
    curveBasisOpen,
    curveLinear,
    curveLinearClosed,
    curveMonotoneX: monotoneX,
    curveMonotoneY: monotoneY,
    curveNatural,
    curveStep,
    curveStepAfter: stepAfter,
    curveStepBefore: stepBefore
  };
  const directive = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
  const directiveWithoutOpen = /\s*(?:(?:(\w+)(?=:):|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
  const detectInit = function(text2, config2) {
    const inits = detectDirective(text2, /(?:init\b)|(?:initialize\b)/);
    let results = {};
    if (Array.isArray(inits)) {
      const args = inits.map((init2) => init2.args);
      directiveSanitizer(args);
      results = assignWithDepth(results, [...args]);
    } else {
      results = inits.args;
    }
    if (results) {
      let type2 = detectType(text2, config2);
      ["config"].forEach((prop) => {
        if (typeof results[prop] !== "undefined") {
          if (type2 === "flowchart-v2") {
            type2 = "flowchart";
          }
          results[type2] = results[prop];
          delete results[prop];
        }
      });
    }
    return results;
  };
  const detectDirective = function(text2, type2 = null) {
    try {
      const commentWithoutDirectives = new RegExp(
        `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*
`,
        "ig"
      );
      text2 = text2.trim().replace(commentWithoutDirectives, "").replace(/'/gm, '"');
      log$3.debug(
        `Detecting diagram directive${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
      );
      let match;
      const result = [];
      while ((match = directive.exec(text2)) !== null) {
        if (match.index === directive.lastIndex) {
          directive.lastIndex++;
        }
        if (match && !type2 || type2 && match[1] && match[1].match(type2) || type2 && match[2] && match[2].match(type2)) {
          const type22 = match[1] ? match[1] : match[2];
          const args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;
          result.push({ type: type22, args });
        }
      }
      if (result.length === 0) {
        result.push({ type: text2, args: null });
      }
      return result.length === 1 ? result[0] : result;
    } catch (error) {
      log$3.error(
        `ERROR: ${error.message} - Unable to parse directive
      ${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
      );
      return { type: null, args: null };
    }
  };
  const isSubstringInArray = function(str, arr) {
    for (let i = 0; i < arr.length; i++) {
      if (arr[i].match(str))
        return i;
    }
    return -1;
  };
  const interpolateToCurve = (interpolate2, defaultCurve) => {
    if (!interpolate2) {
      return defaultCurve;
    }
    const curveName = `curve${interpolate2.charAt(0).toUpperCase() + interpolate2.slice(1)}`;
    return d3CurveTypes[curveName] || defaultCurve;
  };
  const formatUrl = (linkStr, config2) => {
    const url = linkStr.trim();
    if (url) {
      if (config2.securityLevel !== "loose") {
        return sanitizeUrl_1(url);
      }
      return url;
    }
  };
  const runFunc = (functionName, ...params) => {
    const arrPaths = functionName.split(".");
    const len = arrPaths.length - 1;
    const fnName = arrPaths[len];
    let obj = window;
    for (let i = 0; i < len; i++) {
      obj = obj[arrPaths[i]];
      if (!obj)
        return;
    }
    obj[fnName](...params);
  };
  const distance = (p1, p2) => p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;
  const traverseEdge = (points) => {
    let prevPoint;
    let totalDistance2 = 0;
    points.forEach((point2) => {
      totalDistance2 += distance(point2, prevPoint);
      prevPoint = point2;
    });
    let remainingDistance = totalDistance2 / 2;
    let center2 = void 0;
    prevPoint = void 0;
    points.forEach((point2) => {
      if (prevPoint && !center2) {
        const vectorDistance = distance(point2, prevPoint);
        if (vectorDistance < remainingDistance) {
          remainingDistance -= vectorDistance;
        } else {
          const distanceRatio = remainingDistance / vectorDistance;
          if (distanceRatio <= 0)
            center2 = prevPoint;
          if (distanceRatio >= 1)
            center2 = { x: point2.x, y: point2.y };
          if (distanceRatio > 0 && distanceRatio < 1) {
            center2 = {
              x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
              y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
            };
          }
        }
      }
      prevPoint = point2;
    });
    return center2;
  };
  const calcLabelPosition = (points) => {
    if (points.length === 1) {
      return points[0];
    }
    return traverseEdge(points);
  };
  const calcCardinalityPosition = (isRelationTypePresent, points, initialPosition) => {
    let prevPoint;
    log$3.info("our points", points);
    if (points[0] !== initialPosition) {
      points = points.reverse();
    }
    points.forEach((point2) => {
      totalDistance += distance(point2, prevPoint);
      prevPoint = point2;
    });
    const distanceToCardinalityPoint = 25;
    let remainingDistance = distanceToCardinalityPoint;
    let center2;
    prevPoint = void 0;
    points.forEach((point2) => {
      if (prevPoint && !center2) {
        const vectorDistance = distance(point2, prevPoint);
        if (vectorDistance < remainingDistance) {
          remainingDistance -= vectorDistance;
        } else {
          const distanceRatio = remainingDistance / vectorDistance;
          if (distanceRatio <= 0)
            center2 = prevPoint;
          if (distanceRatio >= 1)
            center2 = { x: point2.x, y: point2.y };
          if (distanceRatio > 0 && distanceRatio < 1) {
            center2 = {
              x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
              y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
            };
          }
        }
      }
      prevPoint = point2;
    });
    const d = isRelationTypePresent ? 10 : 5;
    const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
    const cardinalityPosition = { x: 0, y: 0 };
    cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
    cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
    return cardinalityPosition;
  };
  const calcTerminalLabelPosition = (terminalMarkerSize, position2, _points) => {
    let points = JSON.parse(JSON.stringify(_points));
    let prevPoint;
    log$3.info("our points", points);
    if (position2 !== "start_left" && position2 !== "start_right") {
      points = points.reverse();
    }
    points.forEach((point2) => {
      prevPoint = point2;
    });
    const distanceToCardinalityPoint = 25 + terminalMarkerSize;
    let remainingDistance = distanceToCardinalityPoint;
    let center2;
    prevPoint = void 0;
    points.forEach((point2) => {
      if (prevPoint && !center2) {
        const vectorDistance = distance(point2, prevPoint);
        if (vectorDistance < remainingDistance) {
          remainingDistance -= vectorDistance;
        } else {
          const distanceRatio = remainingDistance / vectorDistance;
          if (distanceRatio <= 0)
            center2 = prevPoint;
          if (distanceRatio >= 1)
            center2 = { x: point2.x, y: point2.y };
          if (distanceRatio > 0 && distanceRatio < 1) {
            center2 = {
              x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
              y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
            };
          }
        }
      }
      prevPoint = point2;
    });
    const d = 10 + terminalMarkerSize * 0.5;
    const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
    const cardinalityPosition = { x: 0, y: 0 };
    cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
    cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
    if (position2 === "start_left") {
      cardinalityPosition.x = Math.sin(angle2 + Math.PI) * d + (points[0].x + center2.x) / 2;
      cardinalityPosition.y = -Math.cos(angle2 + Math.PI) * d + (points[0].y + center2.y) / 2;
    }
    if (position2 === "end_right") {
      cardinalityPosition.x = Math.sin(angle2 - Math.PI) * d + (points[0].x + center2.x) / 2 - 5;
      cardinalityPosition.y = -Math.cos(angle2 - Math.PI) * d + (points[0].y + center2.y) / 2 - 5;
    }
    if (position2 === "end_left") {
      cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2 - 5;
      cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2 - 5;
    }
    return cardinalityPosition;
  };
  const getStylesFromArray = (arr) => {
    let style = "";
    let labelStyle = "";
    for (let i = 0; i < arr.length; i++) {
      if (typeof arr[i] !== "undefined") {
        if (arr[i].startsWith("color:") || arr[i].startsWith("text-align:")) {
          labelStyle = labelStyle + arr[i] + ";";
        } else {
          style = style + arr[i] + ";";
        }
      }
    }
    return { style, labelStyle };
  };
  let cnt$1 = 0;
  const generateId$1 = () => {
    cnt$1++;
    return "id-" + Math.random().toString(36).substr(2, 12) + "-" + cnt$1;
  };
  function makeid(length2) {
    let result = "";
    const characters2 = "0123456789abcdef";
    const charactersLength = characters2.length;
    for (let i = 0; i < length2; i++) {
      result += characters2.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  }
  const random = (options2) => {
    return makeid(options2.length);
  };
  const getTextObj$3 = function() {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      anchor: "start",
      style: "#666",
      width: 100,
      height: 100,
      textMargin: 0,
      rx: 0,
      ry: 0,
      valign: void 0
    };
  };
  const drawSimpleText = function(elem, textData) {
    const nText = textData.text.replace(common.lineBreakRegex, " ");
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", textData.y);
    textElem.style("text-anchor", textData.anchor);
    textElem.style("font-family", textData.fontFamily);
    textElem.style("font-size", textData.fontSize);
    textElem.style("font-weight", textData.fontWeight);
    textElem.attr("fill", textData.fill);
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    const span = textElem.append("tspan");
    span.attr("x", textData.x + textData.textMargin * 2);
    span.attr("fill", textData.fill);
    span.text(nText);
    return textElem;
  };
  const wrapLabel = memoize_1(
    (label, maxWidth, config2) => {
      if (!label) {
        return label;
      }
      config2 = Object.assign(
        { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
        config2
      );
      if (common.lineBreakRegex.test(label)) {
        return label;
      }
      const words = label.split(" ");
      const completedLines = [];
      let nextLine = "";
      words.forEach((word, index2) => {
        const wordLength = calculateTextWidth(`${word} `, config2);
        const nextLineLength = calculateTextWidth(nextLine, config2);
        if (wordLength > maxWidth) {
          const { hyphenatedStrings, remainingWord } = breakString(word, maxWidth, "-", config2);
          completedLines.push(nextLine, ...hyphenatedStrings);
          nextLine = remainingWord;
        } else if (nextLineLength + wordLength >= maxWidth) {
          completedLines.push(nextLine);
          nextLine = word;
        } else {
          nextLine = [nextLine, word].filter(Boolean).join(" ");
        }
        const currentWord = index2 + 1;
        const isLastWord = currentWord === words.length;
        if (isLastWord) {
          completedLines.push(nextLine);
        }
      });
      return completedLines.filter((line2) => line2 !== "").join(config2.joinWith);
    },
    (label, maxWidth, config2) => `${label}${maxWidth}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}${config2.joinWith}`
  );
  const breakString = memoize_1(
    (word, maxWidth, hyphenCharacter = "-", config2) => {
      config2 = Object.assign(
        { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
        config2
      );
      const characters2 = word.split("");
      const lines = [];
      let currentLine = "";
      characters2.forEach((character2, index2) => {
        const nextLine = `${currentLine}${character2}`;
        const lineWidth = calculateTextWidth(nextLine, config2);
        if (lineWidth >= maxWidth) {
          const currentCharacter = index2 + 1;
          const isLastLine = characters2.length === currentCharacter;
          const hyphenatedNextLine = `${nextLine}${hyphenCharacter}`;
          lines.push(isLastLine ? nextLine : hyphenatedNextLine);
          currentLine = "";
        } else {
          currentLine = nextLine;
        }
      });
      return { hyphenatedStrings: lines, remainingWord: currentLine };
    },
    (word, maxWidth, hyphenCharacter = "-", config2) => `${word}${maxWidth}${hyphenCharacter}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
  );
  const calculateTextHeight = function(text2, config2) {
    config2 = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 15 },
      config2
    );
    return calculateTextDimensions(text2, config2).height;
  };
  const calculateTextWidth = function(text2, config2) {
    config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
    return calculateTextDimensions(text2, config2).width;
  };
  const calculateTextDimensions = memoize_1(
    function(text2, config2) {
      config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
      const { fontSize, fontFamily, fontWeight } = config2;
      if (!text2) {
        return { width: 0, height: 0 };
      }
      const fontFamilies = ["sans-serif", fontFamily];
      const lines = text2.split(common.lineBreakRegex);
      const dims = [];
      const body = select("body");
      if (!body.remove) {
        return { width: 0, height: 0, lineHeight: 0 };
      }
      const g = body.append("svg");
      for (const fontFamily2 of fontFamilies) {
        let cheight = 0;
        const dim = { width: 0, height: 0, lineHeight: 0 };
        for (const line2 of lines) {
          const textObj = getTextObj$3();
          textObj.text = line2;
          const textElem = drawSimpleText(g, textObj).style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily2);
          const bBox = (textElem._groups || textElem)[0][0].getBBox();
          dim.width = Math.round(Math.max(dim.width, bBox.width));
          cheight = Math.round(bBox.height);
          dim.height += cheight;
          dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));
        }
        dims.push(dim);
      }
      g.remove();
      const index2 = isNaN(dims[1].height) || isNaN(dims[1].width) || isNaN(dims[1].lineHeight) || dims[0].height > dims[1].height && dims[0].width > dims[1].width && dims[0].lineHeight > dims[1].lineHeight ? 0 : 1;
      return dims[index2];
    },
    (text2, config2) => `${text2}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
  );
  const initIdGenerator = class iterator {
    constructor(deterministic, seed) {
      this.deterministic = deterministic;
      this.seed = seed;
      this.count = seed ? seed.length : 0;
    }
    next() {
      if (!this.deterministic)
        return Date.now();
      return this.count++;
    }
  };
  let decoder;
  const entityDecode = function(html2) {
    decoder = decoder || document.createElement("div");
    html2 = escape(html2).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";");
    decoder.innerHTML = html2;
    return unescape(decoder.textContent);
  };
  const directiveSanitizer = (args) => {
    log$3.debug("directiveSanitizer called with", args);
    if (typeof args === "object") {
      if (args.length) {
        args.forEach((arg) => directiveSanitizer(arg));
      } else {
        Object.keys(args).forEach((key) => {
          log$3.debug("Checking key", key);
          if (key.indexOf("__") === 0) {
            log$3.debug("sanitize deleting __ option", key);
            delete args[key];
          }
          if (key.indexOf("proto") >= 0) {
            log$3.debug("sanitize deleting proto option", key);
            delete args[key];
          }
          if (key.indexOf("constr") >= 0) {
            log$3.debug("sanitize deleting constr option", key);
            delete args[key];
          }
          if (key.indexOf("themeCSS") >= 0) {
            log$3.debug("sanitizing themeCss option");
            args[key] = sanitizeCss(args[key]);
          }
          if (key.indexOf("fontFamily") >= 0) {
            log$3.debug("sanitizing fontFamily option");
            args[key] = sanitizeCss(args[key]);
          }
          if (key.indexOf("altFontFamily") >= 0) {
            log$3.debug("sanitizing altFontFamily option");
            args[key] = sanitizeCss(args[key]);
          }
          if (configKeys.indexOf(key) < 0) {
            log$3.debug("sanitize deleting option", key);
            delete args[key];
          } else {
            if (typeof args[key] === "object") {
              log$3.debug("sanitize deleting object", key);
              directiveSanitizer(args[key]);
            }
          }
        });
      }
    }
    if (args.themeVariables) {
      const kArr = Object.keys(args.themeVariables);
      for (let i = 0; i < kArr.length; i++) {
        const k2 = kArr[i];
        const val = args.themeVariables[k2];
        if (val && val.match && !val.match(/^[a-zA-Z0-9#,";()%. ]+$/)) {
          args.themeVariables[k2] = "";
        }
      }
    }
    log$3.debug("After sanitization", args);
  };
  const sanitizeCss = (str) => {
    let startCnt2 = 0;
    let endCnt = 0;
    for (let i = 0; i < str.length; i++) {
      if (startCnt2 < endCnt) {
        return "{ /* ERROR: Unbalanced CSS */ }";
      }
      if (str[i] === "{") {
        startCnt2++;
      } else if (str[i] === "}") {
        endCnt++;
      }
    }
    if (startCnt2 !== endCnt) {
      return "{ /* ERROR: Unbalanced CSS */ }";
    }
    return str;
  };
  function isDetailedError(error) {
    return "str" in error;
  }
  function getErrorMessage(error) {
    if (error instanceof Error)
      return error.message;
    return String(error);
  }
  const utils = {
    assignWithDepth,
    wrapLabel,
    calculateTextHeight,
    calculateTextWidth,
    calculateTextDimensions,
    detectInit,
    detectDirective,
    isSubstringInArray,
    interpolateToCurve,
    calcLabelPosition,
    calcCardinalityPosition,
    calcTerminalLabelPosition,
    formatUrl,
    getStylesFromArray,
    generateId: generateId$1,
    random,
    runFunc,
    entityDecode,
    initIdGenerator,
    directiveSanitizer,
    sanitizeCss
  };
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var abs = Math.abs;
  var from = String.fromCharCode;
  function trim(value) {
    return value.trim();
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array2) {
    return array2.push(value), value;
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type2, props, children2, length2) {
    return { value, root: root2, parent, type: type2, props, children: children2, line, column, length: length2, return: "" };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type2) {
    switch (type2) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type2) {
    return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
  }
  function whitespace(type2) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type2) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count2) {
    while (--count2 && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type2) {
    while (next())
      switch (character) {
        case type2:
          return position;
        case 34:
        case 39:
          if (type2 !== 34 && type2 !== 39)
            delimiter(character);
          break;
        case 40:
          if (type2 === 41)
            delimiter(type2);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type2, index2) {
    while (next())
      if (type2 + character === 47 + 10)
        break;
      else if (type2 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position - 1) + "*" + from(type2 === 47 ? type2 : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position);
  }
  function compile(value) {
    return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse$2(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type2 = "";
    var props = rules;
    var children2 = rulesets;
    var reference = rule;
    var characters2 = type2;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset:
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children2 = [], length2), rulesets);
              if (character2 === 123)
                if (offset === 0)
                  parse$2(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
                else
                  switch (atrule) {
                    case 100:
                    case 109:
                    case 115:
                      parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                      break;
                    default:
                      parse$2(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                  }
          }
          index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children2, length2) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z = value; x2 < size; ++x2)
        if (z = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z;
    return node(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }
  function serialize(children2, callback) {
    var output = "";
    var length2 = sizeof(children2);
    for (var i = 0; i < length2; i++)
      output += callback(children2[i], i, children2, callback) || "";
    return output;
  }
  function stringify(element, index2, children2, callback) {
    switch (element.type) {
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children2 = serialize(element.children, callback)) ? element.return = element.value + "{" + children2 + "}" : "";
  }
  const name = "mermaid";
  const version$4 = "9.2.0";
  const description$1 = "Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.";
  const main = "./dist/mermaid.core.mjs";
  const module2 = "./dist/mermaid.core.mjs";
  const types = "./dist/mermaid.d.ts";
  const type = "module";
  const exports$1 = {
    ".": {
      require: "./dist/mermaid.min.js",
      "import": "./dist/mermaid.core.mjs",
      types: "./dist/mermaid.d.ts"
    },
    "./*": "./*"
  };
  const keywords = [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph"
  ];
  const scripts = {
    clean: "rimraf dist",
    "build:code": "node .esbuild/esbuild.cjs",
    "build:types": "tsc -p ./tsconfig.json --emitDeclarationOnly",
    "build:watch": "yarn build:code --watch",
    "build:esbuild": 'concurrently "yarn build:code" "yarn build:types"',
    build: "yarn clean; yarn build:esbuild",
    dev: "node .esbuild/serve.cjs",
    "docs:build": "ts-node-esm src/docs.mts",
    "docs:verify": "yarn docs:build --verify",
    "todo-postbuild": "documentation build src/mermaidAPI.ts src/config.ts src/defaultConfig.ts --shallow -f md --markdown-toc false > src/docs/Setup.md && prettier --write src/docs/Setup.md",
    release: "yarn build",
    lint: "eslint --cache --ignore-path .gitignore . && yarn lint:jison && prettier --check .",
    "lint:fix": "eslint --fix --ignore-path .gitignore . && prettier --write .",
    "lint:jison": "ts-node-esm src/jison/lint.mts",
    cypress: "cypress run",
    "cypress:open": "cypress open",
    e2e: "start-server-and-test dev http://localhost:9000/ cypress",
    "todo-prepare": 'concurrently "husky install" "yarn build"',
    "pre-commit": "lint-staged"
  };
  const repository = {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  };
  const author = "Knut Sveidqvist";
  const license = "MIT";
  const standard = {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  };
  const dependencies = {
    "@braintree/sanitize-url": "^6.0.0",
    d3: "^7.0.0",
    dagre: "^0.8.5",
    "dagre-d3": "^0.6.4",
    dompurify: "2.4.0",
    "fast-clone": "^1.5.13",
    graphlib: "^2.1.8",
    khroma: "^2.0.0",
    lodash: "^4.17.21",
    "moment-mini": "^2.24.0",
    "non-layered-tidy-tree-layout": "^2.0.2",
    stylis: "^4.1.2",
    uuid: "^9.0.0"
  };
  const devDependencies = {
    "@applitools/eyes-cypress": "^3.25.7",
    "@commitlint/cli": "^17.1.2",
    "@commitlint/config-conventional": "^17.0.0",
    "@types/d3": "^7.4.0",
    "@types/dompurify": "^2.3.4",
    "@types/eslint": "^8.4.6",
    "@types/express": "^4.17.13",
    "@types/jsdom": "^20.0.0",
    "@types/lodash": "^4.14.185",
    "@types/prettier": "^2.7.0",
    "@types/stylis": "^4.0.2",
    "@types/uuid": "^8.3.4",
    "@typescript-eslint/eslint-plugin": "^5.37.0",
    "@typescript-eslint/parser": "^5.37.0",
    concurrently: "^7.4.0",
    coveralls: "^3.1.1",
    cypress: "^10.0.0",
    "cypress-image-snapshot": "^4.0.1",
    documentation: "13.2.0",
    esbuild: "^0.15.8",
    eslint: "^8.23.1",
    "eslint-config-prettier": "^8.5.0",
    "eslint-plugin-cypress": "^2.12.1",
    "eslint-plugin-html": "^7.1.0",
    "eslint-plugin-jest": "^27.0.4",
    "eslint-plugin-jsdoc": "^39.3.6",
    "eslint-plugin-json": "^3.1.0",
    "eslint-plugin-markdown": "^3.0.0",
    express: "^4.18.1",
    globby: "^13.1.2",
    husky: "^8.0.0",
    "identity-obj-proxy": "^3.0.0",
    jison: "^0.4.18",
    "js-base64": "3.7.2",
    jsdom: "^20.0.0",
    "lint-staged": "^13.0.0",
    moment: "^2.23.0",
    "path-browserify": "^1.0.1",
    prettier: "^2.7.1",
    "prettier-plugin-jsdoc": "^0.4.2",
    remark: "^14.0.2",
    rimraf: "^3.0.2",
    "start-server-and-test": "^1.12.6",
    "ts-node": "^10.9.1",
    typescript: "^4.8.3",
    "unist-util-flatmap": "^1.0.0"
  };
  const resolutions = {
    d3: "^7.0.0"
  };
  const files = [
    "dist"
  ];
  const sideEffects = [
    "**/*.css",
    "**/*.scss"
  ];
  const pkg = {
    name,
    version: version$4,
    description: description$1,
    main,
    module: module2,
    types,
    type,
    exports: exports$1,
    keywords,
    scripts,
    repository,
    author,
    license,
    standard,
    dependencies,
    devDependencies,
    resolutions,
    files,
    sideEffects
  };
  const defaultConfig = Object.freeze(config$1);
  let siteConfig = assignWithDepth({}, defaultConfig);
  let configFromInitialize;
  let directives = [];
  let currentConfig = assignWithDepth({}, defaultConfig);
  const updateCurrentConfig = (siteCfg, _directives) => {
    let cfg = assignWithDepth({}, siteCfg);
    let sumOfDirectives = {};
    for (let i = 0; i < _directives.length; i++) {
      const d = _directives[i];
      sanitize(d);
      sumOfDirectives = assignWithDepth(sumOfDirectives, d);
    }
    cfg = assignWithDepth(cfg, sumOfDirectives);
    if (sumOfDirectives.theme && sumOfDirectives.theme in theme) {
      const tmpConfigFromInitialize = assignWithDepth({}, configFromInitialize);
      const themeVariables = assignWithDepth(
        tmpConfigFromInitialize.themeVariables || {},
        sumOfDirectives.themeVariables
      );
      if (cfg.theme && cfg.theme in theme) {
        cfg.themeVariables = theme[cfg.theme].getThemeVariables(themeVariables);
      }
    }
    currentConfig = cfg;
    return cfg;
  };
  const setSiteConfig = (conf2) => {
    siteConfig = assignWithDepth({}, defaultConfig);
    siteConfig = assignWithDepth(siteConfig, conf2);
    if (conf2.theme && theme[conf2.theme]) {
      siteConfig.themeVariables = theme[conf2.theme].getThemeVariables(conf2.themeVariables);
    }
    currentConfig = updateCurrentConfig(siteConfig, directives);
    return siteConfig;
  };
  const saveConfigFromInitialize = (conf2) => {
    configFromInitialize = assignWithDepth({}, conf2);
  };
  const updateSiteConfig = (conf2) => {
    siteConfig = assignWithDepth(siteConfig, conf2);
    updateCurrentConfig(siteConfig, directives);
    return siteConfig;
  };
  const getSiteConfig = () => {
    return assignWithDepth({}, siteConfig);
  };
  const setConfig = (conf2) => {
    assignWithDepth(currentConfig, conf2);
    return getConfig$1();
  };
  const getConfig$1 = () => {
    return assignWithDepth({}, currentConfig);
  };
  const sanitize = (options2) => {
    var _a;
    ["secure", ...(_a = siteConfig.secure) != null ? _a : []].forEach((key) => {
      if (typeof options2[key] !== "undefined") {
        log$3.debug(`Denied attempt to modify a secure key ${key}`, options2[key]);
        delete options2[key];
      }
    });
    Object.keys(options2).forEach((key) => {
      if (key.indexOf("__") === 0) {
        delete options2[key];
      }
    });
    Object.keys(options2).forEach((key) => {
      if (typeof options2[key] === "string") {
        if (options2[key].indexOf("<") > -1 || options2[key].indexOf(">") > -1 || options2[key].indexOf("url(data:") > -1) {
          delete options2[key];
        }
      }
      if (typeof options2[key] === "object") {
        sanitize(options2[key]);
      }
    });
  };
  const addDirective = (directive2) => {
    if (directive2.fontFamily) {
      if (!directive2.themeVariables) {
        directive2.themeVariables = { fontFamily: directive2.fontFamily };
      } else {
        if (!directive2.themeVariables.fontFamily) {
          directive2.themeVariables = { fontFamily: directive2.fontFamily };
        }
      }
    }
    directives.push(directive2);
    updateCurrentConfig(siteConfig, directives);
  };
  const reset = (config2 = siteConfig) => {
    directives = [];
    updateCurrentConfig(config2, directives);
  };
  const d3Attrs = function(d3Elem, attrs) {
    for (let attr of attrs) {
      d3Elem.attr(attr[0], attr[1]);
    }
  };
  const calculateSvgSizeAttrs = function(height2, width2, useMaxWidth) {
    let attrs = /* @__PURE__ */ new Map();
    if (useMaxWidth) {
      attrs.set("width", "100%");
      attrs.set("style", `max-width: ${width2}px;`);
    } else {
      attrs.set("width", width2);
    }
    return attrs;
  };
  const configureSvgSize = function(svgElem, height2, width2, useMaxWidth) {
    const attrs = calculateSvgSizeAttrs(height2, width2, useMaxWidth);
    d3Attrs(svgElem, attrs);
  };
  const setupGraphViewbox$1 = function(graph2, svgElem, padding2, useMaxWidth) {
    const svgBounds = svgElem.node().getBBox();
    const sWidth = svgBounds.width;
    const sHeight = svgBounds.height;
    log$3.info(`SVG bounds: ${sWidth}x${sHeight}`, svgBounds);
    let width2 = 0;
    let height2 = 0;
    log$3.info(`Graph bounds: ${width2}x${height2}`, graph2);
    width2 = sWidth + padding2 * 2;
    height2 = sHeight + padding2 * 2;
    log$3.info(`Calculated bounds: ${width2}x${height2}`);
    configureSvgSize(svgElem, height2, width2, useMaxWidth);
    const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${svgBounds.width + 2 * padding2} ${svgBounds.height + 2 * padding2}`;
    svgElem.attr("viewBox", vBox);
  };
  const getStyles$d = (options2) => `g.classGroup text {
  fill: ${options2.nodeBorder};
  fill: ${options2.classText};
  stroke: none;
  font-family: ${options2.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${options2.classText};
}
.edgeLabel .label rect {
  fill: ${options2.mainBkg};
}
.label text {
  fill: ${options2.classText};
}
.edgeLabel .label span {
  background: ${options2.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${options2.nodeBorder};
  stroke: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.classGroup line {
  stroke: ${options2.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${options2.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${options2.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

#compositionStart, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
}

`;
  const getStyles$c = (options2) => `
  .entityBox {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxOdd {
    fill: ${options2.attributeBackgroundColorOdd};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxEven {
    fill:  ${options2.attributeBackgroundColorEven};
    stroke: ${options2.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${options2.tertiaryColor};
    opacity: 0.7;
    background-color: ${options2.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

    .relationshipLine {
      stroke: ${options2.lineColor};
    }
`;
  const getStyles$b = () => ``;
  const getStyles$a = (options2) => `.label {
    font-family: ${options2.fontFamily};
    color: ${options2.nodeTextColor || options2.textColor};
  }
  .cluster-label text {
    fill: ${options2.titleColor};
  }
  .cluster-label span {
    color: ${options2.titleColor};
  }

  .label text,span {
    fill: ${options2.nodeTextColor || options2.textColor};
    color: ${options2.nodeTextColor || options2.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${options2.edgeLabelBackground};
      fill: ${options2.edgeLabelBackground};
    }
    text-align: center;
  }

  .cluster rect {
    fill: ${options2.clusterBkg};
    stroke: ${options2.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  .cluster span {
    color: ${options2.titleColor};
  }
  /* .cluster div {
    color: ${options2.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${options2.fontFamily};
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }
`;
  const getStyles$9 = (options2) => `
  .mermaid-main-font {
    font-family: "trebuchet ms", verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  .exclude-range {
    fill: ${options2.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${options2.sectionBkgColor};
  }

  .section2 {
    fill: ${options2.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${options2.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${options2.titleColor};
  }

  .sectionTitle1 {
    fill: ${options2.titleColor};
  }

  .sectionTitle2 {
    fill: ${options2.titleColor};
  }

  .sectionTitle3 {
    fill: ${options2.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    // text-height: 14px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${options2.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
    text {
      font-family: ${options2.fontFamily};
      fill: ${options2.textColor};
    }
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${options2.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }

  // .taskText:not([font-size]) {
  //   font-size: ${options2.ganttFontSize};
  // }

  .taskTextOutsideRight {
    fill: ${options2.taskTextDarkColor};
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }

  .taskTextOutsideLeft {
    fill: ${options2.taskTextDarkColor};
    text-anchor: end;
    // font-size: ${options2.ganttFontSize};
  }

  /* Special case clickable */
  .task.clickable {
    cursor: pointer;
  }
  .taskText.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${options2.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${options2.taskBkgColor};
    stroke: ${options2.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${options2.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${options2.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${options2.activeTaskBkgColor};
    stroke: ${options2.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${options2.doneTaskBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${options2.textColor}    ;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
`;
  const getStyles$8 = () => ``;
  const getStyles$7 = (options2) => `
  .pieCircle{
    stroke: ${options2.pieStrokeColor};
    stroke-width : ${options2.pieStrokeWidth};
    opacity : ${options2.pieOpacity};
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${options2.pieTitleTextSize};
    fill: ${options2.pieTitleTextColor};
    font-family: ${options2.fontFamily};
  }
  .slice {
    font-family: ${options2.fontFamily};
    fill: ${options2.pieSectionTextColor};
    font-size:${options2.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${options2.pieLegendTextColor};
    font-family: ${options2.fontFamily};
    font-size: ${options2.pieLegendTextSize};
  }
`;
  const getStyles$6 = (options2) => `

  marker {
    fill: ${options2.relationColor};
    stroke: ${options2.relationColor};
  }

  marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  .reqBox {
    fill: ${options2.requirementBackground};
    fill-opacity: 100%;
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }

  .reqTitle, .reqLabel{
    fill:  ${options2.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${options2.relationLabelBackground};
    fill-opacity: 100%;
  }

  .req-title-line {
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${options2.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${options2.relationLabelColor};
  }

`;
  const getStyles$5 = (options2) => `.actor {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }

  text.actor > tspan {
    fill: ${options2.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${options2.actorLineColor};
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${options2.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${options2.signalColor};
  }

  #arrowhead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .sequenceNumber {
    fill: ${options2.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${options2.signalColor};
  }

  #crosshead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .messageText {
    fill: ${options2.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${options2.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${options2.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${options2.noteBorderColor};
    fill: ${options2.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${options2.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation1 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation2 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${options2.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
    stroke-width: 2px;
  }
`;
  const getStyles$4 = (options2) => `
defs #statediagram-barbEnd {
    fill: ${options2.transitionColor};
    stroke: ${options2.transitionColor};
  }
g.stateGroup text {
  fill: ${options2.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${options2.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${options2.stateLabelColor};
}

g.stateGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.stateGroup line {
  stroke: ${options2.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${options2.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${options2.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${options2.noteBorderColor};
  fill: ${options2.noteBkgColor};

  text {
    fill: ${options2.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${options2.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}

.stateLabel text {
  fill: ${options2.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node .fork-join {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node circle.state-end {
  fill: ${options2.innerEndBackground};
  stroke: ${options2.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${options2.compositeBackground || options2.background};
  // stroke: ${options2.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${options2.stateBkg || options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${options2.lineColor};
}

.statediagram-cluster rect {
  fill: ${options2.compositeTitleBackground};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${options2.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${options2.stateBorder || options2.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${options2.compositeBackground || options2.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${options2.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${options2.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${options2.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${options2.lineColor};
  stroke: ${options2.lineColor};
  stroke-width: 1;
}
`;
  const getStyles$3 = (options2) => `.label {
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    color: ${options2.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${options2.textColor}
  }

  .legend {
    fill: ${options2.textColor};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${options2.textColor}
  }

  .face {
    ${options2.faceColor ? `fill: ${options2.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${options2.fillType0 ? `fill: ${options2.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${options2.fillType0 ? `fill: ${options2.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${options2.fillType0 ? `fill: ${options2.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${options2.fillType0 ? `fill: ${options2.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${options2.fillType0 ? `fill: ${options2.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${options2.fillType0 ? `fill: ${options2.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${options2.fillType0 ? `fill: ${options2.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${options2.fillType0 ? `fill: ${options2.fillType7}` : ""};
  }

  .actor-0 {
    ${options2.actor0 ? `fill: ${options2.actor0}` : ""};
  }
  .actor-1 {
    ${options2.actor1 ? `fill: ${options2.actor1}` : ""};
  }
  .actor-2 {
    ${options2.actor2 ? `fill: ${options2.actor2}` : ""};
  }
  .actor-3 {
    ${options2.actor3 ? `fill: ${options2.actor3}` : ""};
  }
  .actor-4 {
    ${options2.actor4 ? `fill: ${options2.actor4}` : ""};
  }
  .actor-5 {
    ${options2.actor5 ? `fill: ${options2.actor5}` : ""};
  }
`;
  const getStyles$2 = (options2) => `.person {
    stroke: ${options2.personBorder};
    fill: ${options2.personBkg};
  }
`;
  const themes = {
    flowchart: getStyles$a,
    "flowchart-v2": getStyles$a,
    sequence: getStyles$5,
    gantt: getStyles$9,
    classDiagram: getStyles$d,
    "classDiagram-v2": getStyles$d,
    class: getStyles$d,
    stateDiagram: getStyles$4,
    state: getStyles$4,
    info: getStyles$8,
    pie: getStyles$7,
    er: getStyles$c,
    error: getStyles$b,
    journey: getStyles$3,
    requirement: getStyles$6,
    c4: getStyles$2
  };
  const getStyles$1 = (type2, userStyles, options2) => {
    let diagramStyles = "";
    if (type2 in themes && themes[type2]) {
      diagramStyles = themes[type2](options2);
    } else {
      log$3.warn(`No theme found for ${type2}`);
    }
    return ` {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
    fill: ${options2.textColor}
  }

  /* Classes common for multiple diagrams */

  .error-icon {
    fill: ${options2.errorBkgColor};
  }
  .error-text {
    fill: ${options2.errorTextColor};
    stroke: ${options2.errorTextColor};
  }

  .edge-thickness-normal {
    stroke-width: 2px;
  }
  .edge-thickness-thick {
    stroke-width: 3.5px
  }
  .edge-pattern-solid {
    stroke-dasharray: 0;
  }

  .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  .marker {
    fill: ${options2.lineColor};
    stroke: ${options2.lineColor};
  }
  .marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  ${diagramStyles}

  ${userStyles}
`;
  };
  const addStylesForDiagram = (type2, diagramTheme) => {
    themes[type2] = diagramTheme;
  };
  const log = log$3;
  const setLogLevel = setLogLevel$1;
  const getConfig = getConfig$1;
  const sanitizeText$4 = (text2) => sanitizeText$5(text2, getConfig());
  const setupGraphViewbox = setupGraphViewbox$1;
  const diagrams = {};
  const registerDiagram = (id2, diagram, detector, callback) => {
    log.debug(`Registering diagram ${id2}`);
    if (diagrams[id2]) {
      log.warn(`Diagram ${id2} already registered.`);
    }
    diagrams[id2] = diagram;
    if (detector) {
      addDetector(id2, detector);
    }
    addStylesForDiagram(id2, diagram.styles);
    if (typeof callback !== "undefined") {
      callback(log, setLogLevel, getConfig, sanitizeText$4, setupGraphViewbox);
    }
    log.debug(`Registered diagram ${id2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
  };
  const getDiagram = (name2) => {
    log.debug(`Getting diagram ${name2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
    if (name2 in diagrams) {
      return diagrams[name2];
    }
    throw new DiagramNotFoundError(name2);
  };
  class DiagramNotFoundError extends Error {
    constructor(message2) {
      super(`Diagram ${message2} not found.`);
    }
  }
  var parser$b = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 4], $V1 = [1, 7], $V2 = [1, 5], $V3 = [1, 9], $V4 = [1, 6], $V5 = [2, 6], $V6 = [1, 16], $V7 = [6, 8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40, 50, 54], $V8 = [8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $V9 = [8, 13, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $Va = [1, 26], $Vb = [6, 8, 14, 50, 54], $Vc = [8, 14, 54], $Vd = [1, 65], $Ve = [1, 66], $Vf = [1, 67], $Vg = [8, 14, 33, 35, 42, 54];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "GG": 6, "document": 7, "EOF": 8, ":": 9, "DIR": 10, "options": 11, "body": 12, "OPT": 13, "NL": 14, "line": 15, "statement": 16, "commitStatement": 17, "mergeStatement": 18, "cherryPickStatement": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "branchStatement": 26, "CHECKOUT": 27, "ID": 28, "BRANCH": 29, "ORDER": 30, "NUM": 31, "CHERRY_PICK": 32, "COMMIT_ID": 33, "STR": 34, "COMMIT_TAG": 35, "EMPTYSTR": 36, "MERGE": 37, "COMMIT_TYPE": 38, "commitType": 39, "COMMIT": 40, "commit_arg": 41, "COMMIT_MSG": 42, "NORMAL": 43, "REVERSE": 44, "HIGHLIGHT": 45, "openDirective": 46, "typeDirective": 47, "closeDirective": 48, "argDirective": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, ";": 54, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 6: "GG", 8: "EOF", 9: ":", 10: "DIR", 13: "OPT", 14: "NL", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "CHECKOUT", 28: "ID", 29: "BRANCH", 30: "ORDER", 31: "NUM", 32: "CHERRY_PICK", 33: "COMMIT_ID", 34: "STR", 35: "COMMIT_TAG", 36: "EMPTYSTR", 37: "MERGE", 38: "COMMIT_TYPE", 40: "COMMIT", 42: "COMMIT_MSG", 43: "NORMAL", 44: "REVERSE", 45: "HIGHLIGHT", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive", 54: ";" },
      productions_: [0, [3, 2], [3, 2], [3, 3], [3, 4], [3, 5], [7, 0], [7, 2], [11, 2], [11, 1], [12, 0], [12, 2], [15, 2], [15, 1], [16, 1], [16, 1], [16, 1], [16, 2], [16, 2], [16, 1], [16, 1], [16, 1], [16, 2], [26, 2], [26, 4], [19, 3], [19, 5], [19, 5], [19, 5], [19, 5], [18, 2], [18, 4], [18, 4], [18, 4], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [17, 2], [17, 3], [17, 3], [17, 5], [17, 5], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [41, 0], [41, 1], [39, 1], [39, 1], [39, 1], [5, 3], [5, 5], [46, 1], [47, 1], [49, 1], [48, 1], [4, 1], [4, 1], [4, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 3:
            return $$[$0];
          case 4:
            return $$[$0 - 1];
          case 5:
            yy.setDirection($$[$0 - 3]);
            return $$[$0 - 1];
          case 7:
            yy.setOptions($$[$0 - 1]);
            this.$ = $$[$0];
            break;
          case 8:
            $$[$0 - 1] += $$[$0];
            this.$ = $$[$0 - 1];
            break;
          case 10:
            this.$ = [];
            break;
          case 11:
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
            break;
          case 12:
            this.$ = $$[$0 - 1];
            break;
          case 17:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 18:
          case 19:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 20:
            yy.addSection($$[$0].substr(8));
            this.$ = $$[$0].substr(8);
            break;
          case 22:
            yy.checkout($$[$0]);
            break;
          case 23:
            yy.branch($$[$0]);
            break;
          case 24:
            yy.branch($$[$0 - 2], $$[$0]);
            break;
          case 25:
            yy.cherryPick($$[$0], "", void 0);
            break;
          case 26:
            yy.cherryPick($$[$0 - 2], "", $$[$0]);
            break;
          case 27:
          case 29:
            yy.cherryPick($$[$0 - 2], "", "");
            break;
          case 28:
            yy.cherryPick($$[$0], "", $$[$0 - 2]);
            break;
          case 30:
            yy.merge($$[$0], "", "", "");
            break;
          case 31:
            yy.merge($$[$0 - 2], $$[$0], "", "");
            break;
          case 32:
            yy.merge($$[$0 - 2], "", $$[$0], "");
            break;
          case 33:
            yy.merge($$[$0 - 2], "", "", $$[$0]);
            break;
          case 34:
            yy.merge($$[$0 - 4], $$[$0], "", $$[$0 - 2]);
            break;
          case 35:
            yy.merge($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
            break;
          case 36:
            yy.merge($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
            break;
          case 37:
            yy.merge($$[$0 - 4], $$[$0 - 2], $$[$0], "");
            break;
          case 38:
            yy.merge($$[$0 - 4], $$[$0 - 2], "", $$[$0]);
            break;
          case 39:
            yy.merge($$[$0 - 4], $$[$0], $$[$0 - 2], "");
            break;
          case 40:
            yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
            break;
          case 41:
            yy.merge($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
            break;
          case 42:
            yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
            break;
          case 43:
            yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
            break;
          case 44:
            yy.merge($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
            break;
          case 45:
            yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
            break;
          case 46:
            yy.commit($$[$0]);
            break;
          case 47:
            yy.commit("", "", yy.commitType.NORMAL, $$[$0]);
            break;
          case 48:
            yy.commit("", "", $$[$0], "");
            break;
          case 49:
            yy.commit("", "", $$[$0], $$[$0 - 2]);
            break;
          case 50:
            yy.commit("", "", $$[$0 - 2], $$[$0]);
            break;
          case 51:
            yy.commit("", $$[$0], yy.commitType.NORMAL, "");
            break;
          case 52:
            yy.commit("", $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
            break;
          case 53:
            yy.commit("", $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
            break;
          case 54:
            yy.commit("", $$[$0 - 2], $$[$0], "");
            break;
          case 55:
            yy.commit("", $$[$0], $$[$0 - 2], "");
            break;
          case 56:
            yy.commit("", $$[$0 - 4], $$[$0 - 2], $$[$0]);
            break;
          case 57:
            yy.commit("", $$[$0 - 4], $$[$0], $$[$0 - 2]);
            break;
          case 58:
            yy.commit("", $$[$0 - 2], $$[$0 - 4], $$[$0]);
            break;
          case 59:
            yy.commit("", $$[$0], $$[$0 - 4], $$[$0 - 2]);
            break;
          case 60:
            yy.commit("", $$[$0], $$[$0 - 2], $$[$0 - 4]);
            break;
          case 61:
            yy.commit("", $$[$0 - 2], $$[$0], $$[$0 - 4]);
            break;
          case 62:
            yy.commit($$[$0], "", yy.commitType.NORMAL, "");
            break;
          case 63:
            yy.commit($$[$0], "", yy.commitType.NORMAL, $$[$0 - 2]);
            break;
          case 64:
            yy.commit($$[$0 - 2], "", yy.commitType.NORMAL, $$[$0]);
            break;
          case 65:
            yy.commit($$[$0 - 2], "", $$[$0], "");
            break;
          case 66:
            yy.commit($$[$0], "", $$[$0 - 2], "");
            break;
          case 67:
            yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, "");
            break;
          case 68:
            yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, "");
            break;
          case 69:
            yy.commit($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
            break;
          case 70:
            yy.commit($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
            break;
          case 71:
            yy.commit($$[$0 - 2], "", $$[$0 - 4], $$[$0]);
            break;
          case 72:
            yy.commit($$[$0], "", $$[$0 - 4], $$[$0 - 2]);
            break;
          case 73:
            yy.commit($$[$0], "", $$[$0 - 2], $$[$0 - 4]);
            break;
          case 74:
            yy.commit($$[$0 - 2], "", $$[$0], $$[$0 - 4]);
            break;
          case 75:
            yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], "");
            break;
          case 76:
            yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], "");
            break;
          case 77:
            yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], "");
            break;
          case 78:
            yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], "");
            break;
          case 79:
            yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], "");
            break;
          case 80:
            yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], "");
            break;
          case 81:
            yy.commit($$[$0 - 4], $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
            break;
          case 82:
            yy.commit($$[$0 - 4], $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
            break;
          case 83:
            yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, $$[$0 - 4]);
            break;
          case 84:
            yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, $$[$0 - 4]);
            break;
          case 85:
            yy.commit($$[$0], $$[$0 - 4], yy.commitType.NORMAL, $$[$0 - 2]);
            break;
          case 86:
            yy.commit($$[$0 - 2], $$[$0 - 4], yy.commitType.NORMAL, $$[$0]);
            break;
          case 87:
            yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
            break;
          case 88:
            yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
            break;
          case 89:
            yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
            break;
          case 90:
            yy.commit($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
            break;
          case 91:
            yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
            break;
          case 92:
            yy.commit($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
            break;
          case 93:
            yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0 - 2], $$[$0]);
            break;
          case 94:
            yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0], $$[$0 - 2]);
            break;
          case 95:
            yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0 - 4], $$[$0]);
            break;
          case 96:
            yy.commit($$[$0], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]);
            break;
          case 97:
            yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0], $$[$0 - 4]);
            break;
          case 98:
            yy.commit($$[$0], $$[$0 - 6], $$[$0 - 2], $$[$0 - 4]);
            break;
          case 99:
            yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], $$[$0 - 6]);
            break;
          case 100:
            yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], $$[$0 - 6]);
            break;
          case 101:
            yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], $$[$0 - 6]);
            break;
          case 102:
            yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], $$[$0 - 6]);
            break;
          case 103:
            yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], $$[$0 - 6]);
            break;
          case 104:
            yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 6]);
            break;
          case 105:
            yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0 - 6], $$[$0]);
            break;
          case 106:
            yy.commit($$[$0], $$[$0 - 4], $$[$0 - 6], $$[$0 - 2]);
            break;
          case 107:
            yy.commit($$[$0 - 2], $$[$0], $$[$0 - 6], $$[$0 - 4]);
            break;
          case 108:
            yy.commit($$[$0], $$[$0 - 2], $$[$0 - 6], $$[$0 - 4]);
            break;
          case 109:
            yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0 - 6], $$[$0]);
            break;
          case 110:
            yy.commit($$[$0 - 4], $$[$0], $$[$0 - 6], $$[$0 - 2]);
            break;
          case 111:
            this.$ = "";
            break;
          case 112:
            this.$ = $$[$0];
            break;
          case 113:
            this.$ = yy.commitType.NORMAL;
            break;
          case 114:
            this.$ = yy.commitType.REVERSE;
            break;
          case 115:
            this.$ = yy.commitType.HIGHLIGHT;
            break;
          case 118:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 119:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 120:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 121:
            yy.parseDirective("}%%", "close_directive", "gitGraph");
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 7: 12, 8: $V5, 9: [1, 13], 10: [1, 14], 11: 15, 14: $V6 }, o($V7, [2, 122]), o($V7, [2, 123]), o($V7, [2, 124]), { 47: 17, 51: [1, 18] }, { 51: [2, 118] }, { 1: [2, 1] }, { 1: [2, 2] }, { 8: [1, 19] }, { 7: 20, 8: $V5, 11: 15, 14: $V6 }, { 9: [1, 21] }, o($V8, [2, 10], { 12: 22, 13: [1, 23] }), o($V9, [2, 9]), { 9: [1, 25], 48: 24, 53: $Va }, o([9, 53], [2, 119]), { 1: [2, 3] }, { 8: [1, 27] }, { 7: 28, 8: $V5, 11: 15, 14: $V6 }, { 8: [2, 7], 14: [1, 31], 15: 29, 16: 30, 17: 32, 18: 33, 19: 34, 20: [1, 35], 22: [1, 36], 24: [1, 37], 25: [1, 38], 26: 39, 27: [1, 40], 29: [1, 44], 32: [1, 43], 37: [1, 42], 40: [1, 41] }, o($V9, [2, 8]), o($Vb, [2, 116]), { 49: 45, 52: [1, 46] }, o($Vb, [2, 121]), { 1: [2, 4] }, { 8: [1, 47] }, o($V8, [2, 11]), { 4: 48, 8: $V1, 14: $V2, 54: $V4 }, o($V8, [2, 13]), o($Vc, [2, 14]), o($Vc, [2, 15]), o($Vc, [2, 16]), { 21: [1, 49] }, { 23: [1, 50] }, o($Vc, [2, 19]), o($Vc, [2, 20]), o($Vc, [2, 21]), { 28: [1, 51] }, o($Vc, [2, 111], { 41: 52, 33: [1, 55], 34: [1, 57], 35: [1, 53], 38: [1, 54], 42: [1, 56] }), { 28: [1, 58] }, { 33: [1, 59], 35: [1, 60] }, { 28: [1, 61] }, { 48: 62, 53: $Va }, { 53: [2, 120] }, { 1: [2, 5] }, o($V8, [2, 12]), o($Vc, [2, 17]), o($Vc, [2, 18]), o($Vc, [2, 22]), o($Vc, [2, 46]), { 34: [1, 63] }, { 39: 64, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 68] }, { 34: [1, 69] }, o($Vc, [2, 112]), o($Vc, [2, 30], { 33: [1, 70], 35: [1, 72], 38: [1, 71] }), { 34: [1, 73] }, { 34: [1, 74], 36: [1, 75] }, o($Vc, [2, 23], { 30: [1, 76] }), o($Vb, [2, 117]), o($Vc, [2, 47], { 33: [1, 78], 38: [1, 77], 42: [1, 79] }), o($Vc, [2, 48], { 33: [1, 81], 35: [1, 80], 42: [1, 82] }), o($Vg, [2, 113]), o($Vg, [2, 114]), o($Vg, [2, 115]), o($Vc, [2, 51], { 35: [1, 83], 38: [1, 84], 42: [1, 85] }), o($Vc, [2, 62], { 33: [1, 88], 35: [1, 86], 38: [1, 87] }), { 34: [1, 89] }, { 39: 90, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 91] }, o($Vc, [2, 25], { 35: [1, 92] }), { 33: [1, 93] }, { 33: [1, 94] }, { 31: [1, 95] }, { 39: 96, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 97] }, { 34: [1, 98] }, { 34: [1, 99] }, { 34: [1, 100] }, { 34: [1, 101] }, { 34: [1, 102] }, { 39: 103, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 104] }, { 34: [1, 105] }, { 39: 106, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 107] }, o($Vc, [2, 31], { 35: [1, 109], 38: [1, 108] }), o($Vc, [2, 32], { 33: [1, 111], 35: [1, 110] }), o($Vc, [2, 33], { 33: [1, 112], 38: [1, 113] }), { 34: [1, 114], 36: [1, 115] }, { 34: [1, 116] }, { 34: [1, 117] }, o($Vc, [2, 24]), o($Vc, [2, 49], { 33: [1, 118], 42: [1, 119] }), o($Vc, [2, 53], { 38: [1, 120], 42: [1, 121] }), o($Vc, [2, 63], { 33: [1, 123], 38: [1, 122] }), o($Vc, [2, 50], { 33: [1, 124], 42: [1, 125] }), o($Vc, [2, 55], { 35: [1, 126], 42: [1, 127] }), o($Vc, [2, 66], { 33: [1, 129], 35: [1, 128] }), o($Vc, [2, 52], { 38: [1, 130], 42: [1, 131] }), o($Vc, [2, 54], { 35: [1, 132], 42: [1, 133] }), o($Vc, [2, 67], { 35: [1, 135], 38: [1, 134] }), o($Vc, [2, 64], { 33: [1, 137], 38: [1, 136] }), o($Vc, [2, 65], { 33: [1, 139], 35: [1, 138] }), o($Vc, [2, 68], { 35: [1, 141], 38: [1, 140] }), { 39: 142, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 143] }, { 34: [1, 144] }, { 34: [1, 145] }, { 34: [1, 146] }, { 39: 147, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 26]), o($Vc, [2, 27]), o($Vc, [2, 28]), o($Vc, [2, 29]), { 34: [1, 148] }, { 34: [1, 149] }, { 39: 150, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 151] }, { 39: 152, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 153] }, { 34: [1, 154] }, { 34: [1, 155] }, { 34: [1, 156] }, { 34: [1, 157] }, { 34: [1, 158] }, { 34: [1, 159] }, { 39: 160, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 161] }, { 34: [1, 162] }, { 34: [1, 163] }, { 39: 164, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 165] }, { 39: 166, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 167] }, { 34: [1, 168] }, { 34: [1, 169] }, { 39: 170, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 171] }, o($Vc, [2, 37], { 35: [1, 172] }), o($Vc, [2, 38], { 38: [1, 173] }), o($Vc, [2, 36], { 33: [1, 174] }), o($Vc, [2, 39], { 35: [1, 175] }), o($Vc, [2, 34], { 38: [1, 176] }), o($Vc, [2, 35], { 33: [1, 177] }), o($Vc, [2, 60], { 42: [1, 178] }), o($Vc, [2, 73], { 33: [1, 179] }), o($Vc, [2, 61], { 42: [1, 180] }), o($Vc, [2, 84], { 38: [1, 181] }), o($Vc, [2, 74], { 33: [1, 182] }), o($Vc, [2, 83], { 38: [1, 183] }), o($Vc, [2, 59], { 42: [1, 184] }), o($Vc, [2, 72], { 33: [1, 185] }), o($Vc, [2, 58], { 42: [1, 186] }), o($Vc, [2, 78], { 35: [1, 187] }), o($Vc, [2, 71], { 33: [1, 188] }), o($Vc, [2, 77], { 35: [1, 189] }), o($Vc, [2, 57], { 42: [1, 190] }), o($Vc, [2, 85], { 38: [1, 191] }), o($Vc, [2, 56], { 42: [1, 192] }), o($Vc, [2, 79], { 35: [1, 193] }), o($Vc, [2, 80], { 35: [1, 194] }), o($Vc, [2, 86], { 38: [1, 195] }), o($Vc, [2, 70], { 33: [1, 196] }), o($Vc, [2, 81], { 38: [1, 197] }), o($Vc, [2, 69], { 33: [1, 198] }), o($Vc, [2, 75], { 35: [1, 199] }), o($Vc, [2, 76], { 35: [1, 200] }), o($Vc, [2, 82], { 38: [1, 201] }), { 34: [1, 202] }, { 39: 203, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 204] }, { 34: [1, 205] }, { 39: 206, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 207] }, { 34: [1, 208] }, { 34: [1, 209] }, { 34: [1, 210] }, { 39: 211, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 212] }, { 39: 213, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 214] }, { 34: [1, 215] }, { 34: [1, 216] }, { 34: [1, 217] }, { 34: [1, 218] }, { 34: [1, 219] }, { 34: [1, 220] }, { 39: 221, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 222] }, { 34: [1, 223] }, { 34: [1, 224] }, { 39: 225, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 226] }, { 39: 227, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 228] }, { 34: [1, 229] }, { 34: [1, 230] }, { 39: 231, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 40]), o($Vc, [2, 42]), o($Vc, [2, 41]), o($Vc, [2, 43]), o($Vc, [2, 45]), o($Vc, [2, 44]), o($Vc, [2, 101]), o($Vc, [2, 102]), o($Vc, [2, 99]), o($Vc, [2, 100]), o($Vc, [2, 104]), o($Vc, [2, 103]), o($Vc, [2, 108]), o($Vc, [2, 107]), o($Vc, [2, 106]), o($Vc, [2, 105]), o($Vc, [2, 110]), o($Vc, [2, 109]), o($Vc, [2, 98]), o($Vc, [2, 97]), o($Vc, [2, 96]), o($Vc, [2, 95]), o($Vc, [2, 93]), o($Vc, [2, 94]), o($Vc, [2, 92]), o($Vc, [2, 91]), o($Vc, [2, 90]), o($Vc, [2, 89]), o($Vc, [2, 87]), o($Vc, [2, 88])],
      defaultActions: { 9: [2, 118], 10: [2, 1], 11: [2, 2], 19: [2, 3], 27: [2, 4], 46: [2, 120], 47: [2, 5] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 50;
            case 1:
              this.begin("type_directive");
              return 51;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 9;
            case 3:
              this.popState();
              this.popState();
              return 53;
            case 4:
              return 52;
            case 5:
              this.begin("acc_title");
              return 20;
            case 6:
              this.popState();
              return "acc_title_value";
            case 7:
              this.begin("acc_descr");
              return 22;
            case 8:
              this.popState();
              return "acc_descr_value";
            case 9:
              this.begin("acc_descr_multiline");
              break;
            case 10:
              this.popState();
              break;
            case 11:
              return "acc_descr_multiline_value";
            case 12:
              return 14;
            case 13:
              break;
            case 14:
              break;
            case 15:
              return 6;
            case 16:
              return 40;
            case 17:
              return 33;
            case 18:
              return 38;
            case 19:
              return 42;
            case 20:
              return 43;
            case 21:
              return 44;
            case 22:
              return 45;
            case 23:
              return 35;
            case 24:
              return 29;
            case 25:
              return 30;
            case 26:
              return 37;
            case 27:
              return 32;
            case 28:
              return 27;
            case 29:
              return 10;
            case 30:
              return 10;
            case 31:
              return 9;
            case 32:
              return "CARET";
            case 33:
              this.begin("options");
              break;
            case 34:
              this.popState();
              break;
            case 35:
              return 13;
            case 36:
              return 36;
            case 37:
              this.begin("string");
              break;
            case 38:
              this.popState();
              break;
            case 39:
              return 34;
            case 40:
              return 31;
            case 41:
              return 28;
            case 42:
              return 8;
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:gitGraph\b)/i, /^(?:commit(?=\s|$))/i, /^(?:id:)/i, /^(?:type:)/i, /^(?:msg:)/i, /^(?:NORMAL\b)/i, /^(?:REVERSE\b)/i, /^(?:HIGHLIGHT\b)/i, /^(?:tag:)/i, /^(?:branch(?=\s|$))/i, /^(?:order:)/i, /^(?:merge(?=\s|$))/i, /^(?:cherry-pick(?=\s|$))/i, /^(?:checkout(?=\s|$))/i, /^(?:LR\b)/i, /^(?:BT\b)/i, /^(?::)/i, /^(?:\^)/i, /^(?:options\r?\n)/i, /^(?:[ \r\n\t]+end\b)/i, /^(?:[\s\S]+(?=[ \r\n\t]+end))/i, /^(?:["]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[0-9]+(?=\s|$))/i, /^(?:\w([-\./\w]*[-\w])?)/i, /^(?:$)/i, /^(?:\s+)/i],
        conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "options": { "rules": [34, 35], "inclusive": false }, "string": { "rules": [38, 39], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36, 37, 40, 41, 42, 43], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$b.parser = parser$b;
  const gitGraphDetector = (txt) => {
    return txt.match(/^\s*gitGraph/) !== null;
  };
  let title$1 = "";
  let diagramTitle = "";
  let description = "";
  const sanitizeText$3 = (txt) => sanitizeText$5(txt, getConfig$1());
  const clear$g = function() {
    title$1 = "";
    description = "";
    diagramTitle = "";
  };
  const setAccTitle = function(txt) {
    title$1 = sanitizeText$3(txt).replace(/^\s+/g, "");
  };
  const getAccTitle = function() {
    return title$1 || diagramTitle;
  };
  const setAccDescription = function(txt) {
    description = sanitizeText$3(txt).replace(/\n\s+/g, "\n");
  };
  const getAccDescription = function() {
    return description;
  };
  const setDiagramTitle = function(txt) {
    diagramTitle = sanitizeText$3(txt);
  };
  const getDiagramTitle = function() {
    return diagramTitle;
  };
  let mainBranchName = getConfig$1().gitGraph.mainBranchName;
  let mainBranchOrder = getConfig$1().gitGraph.mainBranchOrder;
  let commits = {};
  let head = null;
  let branchesConfig = {};
  branchesConfig[mainBranchName] = { name: mainBranchName, order: mainBranchOrder };
  let branches = {};
  branches[mainBranchName] = head;
  let curBranch = mainBranchName;
  let direction$3 = "LR";
  let seq = 0;
  function getId() {
    return random({ length: 7 });
  }
  const parseDirective$b = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  function uniqBy(list2, fn) {
    const recordMap = /* @__PURE__ */ Object.create(null);
    return list2.reduce((out, item) => {
      const key = fn(item);
      if (!recordMap[key]) {
        recordMap[key] = true;
        out.push(item);
      }
      return out;
    }, []);
  }
  const setDirection$3 = function(dir) {
    direction$3 = dir;
  };
  let options = {};
  const setOptions = function(rawOptString) {
    log$3.debug("options str", rawOptString);
    rawOptString = rawOptString && rawOptString.trim();
    rawOptString = rawOptString || "{}";
    try {
      options = JSON.parse(rawOptString);
    } catch (e) {
      log$3.error("error while parsing gitGraph options", e.message);
    }
  };
  const getOptions = function() {
    return options;
  };
  const commit = function(msg, id2, type2, tag) {
    log$3.debug("Entering commit:", msg, id2, type2, tag);
    id2 = common.sanitizeText(id2, getConfig$1());
    msg = common.sanitizeText(msg, getConfig$1());
    tag = common.sanitizeText(tag, getConfig$1());
    const commit2 = {
      id: id2 ? id2 : seq + "-" + getId(),
      message: msg,
      seq: seq++,
      type: type2 ? type2 : commitType$1.NORMAL,
      tag: tag ? tag : "",
      parents: head == null ? [] : [head.id],
      branch: curBranch
    };
    head = commit2;
    commits[commit2.id] = commit2;
    branches[curBranch] = commit2.id;
    log$3.debug("in pushCommit " + commit2.id);
  };
  const branch = function(name2, order) {
    name2 = common.sanitizeText(name2, getConfig$1());
    if (typeof branches[name2] === "undefined") {
      branches[name2] = head != null ? head.id : null;
      branchesConfig[name2] = { name: name2, order: order ? parseInt(order, 10) : null };
      checkout(name2);
      log$3.debug("in createBranch");
    } else {
      let error = new Error(
        'Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ' + name2 + '")'
      );
      error.hash = {
        text: "branch " + name2,
        token: "branch " + name2,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ['"checkout ' + name2 + '"']
      };
      throw error;
    }
  };
  const merge = function(otherBranch, custom_id, override_type, custom_tag) {
    otherBranch = common.sanitizeText(otherBranch, getConfig$1());
    custom_id = common.sanitizeText(custom_id, getConfig$1());
    const currentCommit = commits[branches[curBranch]];
    const otherCommit = commits[branches[otherBranch]];
    if (curBranch === otherBranch) {
      let error = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
      error.hash = {
        text: "merge " + otherBranch,
        token: "merge " + otherBranch,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["branch abc"]
      };
      throw error;
    } else if (typeof currentCommit === "undefined" || !currentCommit) {
      let error = new Error(
        'Incorrect usage of "merge". Current branch (' + curBranch + ")has no commits"
      );
      error.hash = {
        text: "merge " + otherBranch,
        token: "merge " + otherBranch,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["commit"]
      };
      throw error;
    } else if (typeof branches[otherBranch] === "undefined") {
      let error = new Error(
        'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") does not exist"
      );
      error.hash = {
        text: "merge " + otherBranch,
        token: "merge " + otherBranch,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["branch " + otherBranch]
      };
      throw error;
    } else if (typeof otherCommit === "undefined" || !otherCommit) {
      let error = new Error(
        'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") has no commits"
      );
      error.hash = {
        text: "merge " + otherBranch,
        token: "merge " + otherBranch,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ['"commit"']
      };
      throw error;
    } else if (currentCommit === otherCommit) {
      let error = new Error('Incorrect usage of "merge". Both branches have same head');
      error.hash = {
        text: "merge " + otherBranch,
        token: "merge " + otherBranch,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["branch abc"]
      };
      throw error;
    } else if (custom_id && typeof commits[custom_id] !== "undefined") {
      let error = new Error(
        'Incorrect usage of "merge". Commit with id:' + custom_id + " already exists, use different custom Id"
      );
      error.hash = {
        text: "merge " + otherBranch + custom_id + override_type + custom_tag,
        token: "merge " + otherBranch + custom_id + override_type + custom_tag,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: [
          "merge " + otherBranch + " " + custom_id + "_UNIQUE " + override_type + " " + custom_tag
        ]
      };
      throw error;
    }
    const commit2 = {
      id: custom_id ? custom_id : seq + "-" + getId(),
      message: "merged branch " + otherBranch + " into " + curBranch,
      seq: seq++,
      parents: [head == null ? null : head.id, branches[otherBranch]],
      branch: curBranch,
      type: commitType$1.MERGE,
      customType: override_type,
      customId: custom_id ? true : false,
      tag: custom_tag ? custom_tag : ""
    };
    head = commit2;
    commits[commit2.id] = commit2;
    branches[curBranch] = commit2.id;
    log$3.debug(branches);
    log$3.debug("in mergeBranch");
  };
  const cherryPick = function(sourceId, targetId, tag) {
    log$3.debug("Entering cherryPick:", sourceId, targetId, tag);
    sourceId = common.sanitizeText(sourceId, getConfig$1());
    targetId = common.sanitizeText(targetId, getConfig$1());
    tag = common.sanitizeText(tag, getConfig$1());
    if (!sourceId || typeof commits[sourceId] === "undefined") {
      let error = new Error(
        'Incorrect usage of "cherryPick". Source commit id should exist and provided'
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    let sourceCommit = commits[sourceId];
    let sourceCommitBranch = sourceCommit.branch;
    if (sourceCommit.type === commitType$1.MERGE) {
      let error = new Error(
        'Incorrect usage of "cherryPick". Source commit should not be a merge commit'
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    if (!targetId || typeof commits[targetId] === "undefined") {
      if (sourceCommitBranch === curBranch) {
        let error = new Error(
          'Incorrect usage of "cherryPick". Source commit is already on current branch'
        );
        error.hash = {
          text: "cherryPick " + sourceId + " " + targetId,
          token: "cherryPick " + sourceId + " " + targetId,
          line: "1",
          loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
          expected: ["cherry-pick abc"]
        };
        throw error;
      }
      const currentCommit = commits[branches[curBranch]];
      if (typeof currentCommit === "undefined" || !currentCommit) {
        let error = new Error(
          'Incorrect usage of "cherry-pick". Current branch (' + curBranch + ")has no commits"
        );
        error.hash = {
          text: "cherryPick " + sourceId + " " + targetId,
          token: "cherryPick " + sourceId + " " + targetId,
          line: "1",
          loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
          expected: ["cherry-pick abc"]
        };
        throw error;
      }
      const commit2 = {
        id: seq + "-" + getId(),
        message: "cherry-picked " + sourceCommit + " into " + curBranch,
        seq: seq++,
        parents: [head == null ? null : head.id, sourceCommit.id],
        branch: curBranch,
        type: commitType$1.CHERRY_PICK,
        tag: tag != null ? tag : "cherry-pick:" + sourceCommit.id
      };
      head = commit2;
      commits[commit2.id] = commit2;
      branches[curBranch] = commit2.id;
      log$3.debug(branches);
      log$3.debug("in cherryPick");
    }
  };
  const checkout = function(branch2) {
    branch2 = common.sanitizeText(branch2, getConfig$1());
    if (typeof branches[branch2] === "undefined") {
      let error = new Error(
        'Trying to checkout branch which is not yet created. (Help try using "branch ' + branch2 + '")'
      );
      error.hash = {
        text: "checkout " + branch2,
        token: "checkout " + branch2,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ['"branch ' + branch2 + '"']
      };
      throw error;
    } else {
      curBranch = branch2;
      const id2 = branches[curBranch];
      head = commits[id2];
    }
  };
  function upsert(arr, key, newval) {
    const index2 = arr.indexOf(key);
    if (index2 === -1) {
      arr.push(newval);
    } else {
      arr.splice(index2, 1, newval);
    }
  }
  function prettyPrintCommitHistory(commitArr) {
    const commit2 = commitArr.reduce((out, commit3) => {
      if (out.seq > commit3.seq)
        return out;
      return commit3;
    }, commitArr[0]);
    let line2 = "";
    commitArr.forEach(function(c2) {
      if (c2 === commit2) {
        line2 += "	*";
      } else {
        line2 += "	|";
      }
    });
    const label = [line2, commit2.id, commit2.seq];
    for (let branch2 in branches) {
      if (branches[branch2] === commit2.id)
        label.push(branch2);
    }
    log$3.debug(label.join(" "));
    if (commit2.parents && commit2.parents.length == 2) {
      const newCommit = commits[commit2.parents[0]];
      upsert(commitArr, commit2, newCommit);
      commitArr.push(commits[commit2.parents[1]]);
    } else if (commit2.parents.length == 0) {
      return;
    } else {
      const nextCommit = commits[commit2.parents];
      upsert(commitArr, commit2, nextCommit);
    }
    commitArr = uniqBy(commitArr, (c2) => c2.id);
    prettyPrintCommitHistory(commitArr);
  }
  const prettyPrint = function() {
    log$3.debug(commits);
    const node2 = getCommitsArray()[0];
    prettyPrintCommitHistory([node2]);
  };
  const clear$f = function() {
    commits = {};
    head = null;
    let mainBranch = getConfig$1().gitGraph.mainBranchName;
    let mainBranchOrder2 = getConfig$1().gitGraph.mainBranchOrder;
    branches = {};
    branches[mainBranch] = null;
    branchesConfig = {};
    branchesConfig[mainBranch] = { name: mainBranch, order: mainBranchOrder2 };
    curBranch = mainBranch;
    seq = 0;
    clear$g();
  };
  const getBranchesAsObjArray = function() {
    const branchesArray = Object.values(branchesConfig).map((branchConfig, i) => {
      if (branchConfig.order !== null)
        return branchConfig;
      return {
        ...branchConfig,
        order: parseFloat(`0.${i}`, 10)
      };
    }).sort((a2, b) => a2.order - b.order).map(({ name: name2 }) => ({ name: name2 }));
    return branchesArray;
  };
  const getBranches = function() {
    return branches;
  };
  const getCommits = function() {
    return commits;
  };
  const getCommitsArray = function() {
    const commitArr = Object.keys(commits).map(function(key) {
      return commits[key];
    });
    commitArr.forEach(function(o) {
      log$3.debug(o.id);
    });
    commitArr.sort((a2, b) => a2.seq - b.seq);
    return commitArr;
  };
  const getCurrentBranch = function() {
    return curBranch;
  };
  const getDirection$3 = function() {
    return direction$3;
  };
  const getHead = function() {
    return head;
  };
  const commitType$1 = {
    NORMAL: 0,
    REVERSE: 1,
    HIGHLIGHT: 2,
    MERGE: 3,
    CHERRY_PICK: 4
  };
  const gitGraphDb = {
    parseDirective: parseDirective$b,
    getConfig: () => getConfig$1().gitGraph,
    setDirection: setDirection$3,
    setOptions,
    getOptions,
    commit,
    branch,
    merge,
    cherryPick,
    checkout,
    prettyPrint,
    clear: clear$f,
    getBranchesAsObjArray,
    getBranches,
    getCommits,
    getCommitsArray,
    getCurrentBranch,
    getDirection: getDirection$3,
    getHead,
    setAccTitle,
    getAccTitle,
    getAccDescription,
    setAccDescription,
    commitType: commitType$1
  };
  function addSVGAccessibilityFields(yy_parser, svg2, id2) {
    if (typeof svg2.insert === "undefined") {
      return;
    }
    let title_string = yy_parser.getAccTitle();
    let description2 = yy_parser.getAccDescription();
    svg2.attr("role", "img").attr("aria-labelledby", "chart-title-" + id2 + " chart-desc-" + id2);
    svg2.insert("desc", ":first-child").attr("id", "chart-desc-" + id2).text(description2);
    svg2.insert("title", ":first-child").attr("id", "chart-title-" + id2).text(title_string);
  }
  let allCommitsDict = {};
  const commitType = {
    NORMAL: 0,
    REVERSE: 1,
    HIGHLIGHT: 2,
    MERGE: 3,
    CHERRY_PICK: 4
  };
  const THEME_COLOR_LIMIT = 8;
  let branchPos = {};
  let commitPos = {};
  let lanes = [];
  let maxPos = 0;
  const clear$e = () => {
    branchPos = {};
    commitPos = {};
    allCommitsDict = {};
    maxPos = 0;
    lanes = [];
  };
  const drawText$3 = (txt) => {
    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    let rows = [];
    if (typeof txt === "string") {
      rows = txt.split(/\\n|\n|<br\s*\/?>/gi);
    } else if (Array.isArray(txt)) {
      rows = txt;
    } else {
      rows = [];
    }
    for (let j = 0; j < rows.length; j++) {
      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
      tspan.setAttribute("dy", "1em");
      tspan.setAttribute("x", "0");
      tspan.setAttribute("class", "row");
      tspan.textContent = rows[j].trim();
      svgLabel.appendChild(tspan);
    }
    return svgLabel;
  };
  const drawCommits = (svg2, commits2, modifyGraph) => {
    const gitGraphConfig = getConfig().gitGraph;
    const gBullets = svg2.append("g").attr("class", "commit-bullets");
    const gLabels = svg2.append("g").attr("class", "commit-labels");
    let pos = 0;
    const keys = Object.keys(commits2);
    const sortedKeys = keys.sort((a2, b) => {
      return commits2[a2].seq - commits2[b].seq;
    });
    sortedKeys.forEach((key) => {
      const commit2 = commits2[key];
      const y2 = branchPos[commit2.branch].pos;
      const x2 = pos + 10;
      if (modifyGraph) {
        let typeClass;
        let commitSymbolType = typeof commit2.customType !== "undefined" && commit2.customType !== "" ? commit2.customType : commit2.type;
        switch (commitSymbolType) {
          case commitType.NORMAL:
            typeClass = "commit-normal";
            break;
          case commitType.REVERSE:
            typeClass = "commit-reverse";
            break;
          case commitType.HIGHLIGHT:
            typeClass = "commit-highlight";
            break;
          case commitType.MERGE:
            typeClass = "commit-merge";
            break;
          case commitType.CHERRY_PICK:
            typeClass = "commit-cherry-pick";
            break;
          default:
            typeClass = "commit-normal";
        }
        if (commitSymbolType === commitType.HIGHLIGHT) {
          const circle2 = gBullets.append("rect");
          circle2.attr("x", x2 - 10);
          circle2.attr("y", y2 - 10);
          circle2.attr("height", 20);
          circle2.attr("width", 20);
          circle2.attr(
            "class",
            `commit ${commit2.id} commit-highlight${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-outer`
          );
          gBullets.append("rect").attr("x", x2 - 6).attr("y", y2 - 6).attr("height", 12).attr("width", 12).attr(
            "class",
            `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-inner`
          );
        } else if (commitSymbolType === commitType.CHERRY_PICK) {
          gBullets.append("circle").attr("cx", x2).attr("cy", y2).attr("r", 10).attr("class", `commit ${commit2.id} ${typeClass}`);
          gBullets.append("circle").attr("cx", x2 - 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
          gBullets.append("circle").attr("cx", x2 + 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
          gBullets.append("line").attr("x1", x2 + 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
          gBullets.append("line").attr("x1", x2 - 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        } else {
          const circle2 = gBullets.append("circle");
          circle2.attr("cx", x2);
          circle2.attr("cy", y2);
          circle2.attr("r", commit2.type === commitType.MERGE ? 9 : 10);
          circle2.attr(
            "class",
            `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
          );
          if (commitSymbolType === commitType.MERGE) {
            const circle22 = gBullets.append("circle");
            circle22.attr("cx", x2);
            circle22.attr("cy", y2);
            circle22.attr("r", 6);
            circle22.attr(
              "class",
              `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
            );
          }
          if (commitSymbolType === commitType.REVERSE) {
            const cross2 = gBullets.append("path");
            cross2.attr("d", `M ${x2 - 5},${y2 - 5}L${x2 + 5},${y2 + 5}M${x2 - 5},${y2 + 5}L${x2 + 5},${y2 - 5}`).attr(
              "class",
              `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
            );
          }
        }
      }
      commitPos[commit2.id] = { x: pos + 10, y: y2 };
      if (modifyGraph) {
        const px = 4;
        const py = 2;
        if (commit2.type !== commitType.CHERRY_PICK && (commit2.customId && commit2.type === commitType.MERGE || commit2.type !== commitType.MERGE) && gitGraphConfig.showCommitLabel) {
          const wrapper = gLabels.append("g");
          const labelBkg = wrapper.insert("rect").attr("class", "commit-label-bkg");
          const text2 = wrapper.append("text").attr("x", pos).attr("y", y2 + 25).attr("class", "commit-label").text(commit2.id);
          let bbox = text2.node().getBBox();
          labelBkg.attr("x", pos + 10 - bbox.width / 2 - py).attr("y", y2 + 13.5).attr("width", bbox.width + 2 * py).attr("height", bbox.height + 2 * py);
          text2.attr("x", pos + 10 - bbox.width / 2);
          if (gitGraphConfig.rotateCommitLabel) {
            let r_x = -7.5 - (bbox.width + 10) / 25 * 9.5;
            let r_y = 10 + bbox.width / 25 * 8.5;
            wrapper.attr(
              "transform",
              "translate(" + r_x + ", " + r_y + ") rotate(" + -45 + ", " + pos + ", " + y2 + ")"
            );
          }
        }
        if (commit2.tag) {
          const rect2 = gLabels.insert("polygon");
          const hole = gLabels.append("circle");
          const tag = gLabels.append("text").attr("y", y2 - 16).attr("class", "tag-label").text(commit2.tag);
          let tagBbox = tag.node().getBBox();
          tag.attr("x", pos + 10 - tagBbox.width / 2);
          const h2 = tagBbox.height / 2;
          const ly = y2 - 19.2;
          rect2.attr("class", "tag-label-bkg").attr(
            "points",
            `
          ${pos - tagBbox.width / 2 - px / 2},${ly + py}
          ${pos - tagBbox.width / 2 - px / 2},${ly - py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly + h2 + py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly + h2 + py}`
          );
          hole.attr("cx", pos - tagBbox.width / 2 + px / 2).attr("cy", ly).attr("r", 1.5).attr("class", "tag-hole");
        }
      }
      pos += 50;
      if (pos > maxPos) {
        maxPos = pos;
      }
    });
  };
  const hasOverlappingCommits = (commit1, commit2, allCommits) => {
    const keys = Object.keys(allCommits);
    const overlappingComits = keys.filter((key) => {
      return allCommits[key].branch === commit2.branch && allCommits[key].seq > commit1.seq && allCommits[key].seq < commit2.seq;
    });
    return overlappingComits.length > 0;
  };
  const findLane = (y12, y2, _depth) => {
    const depth = _depth || 0;
    const candidate = y12 + Math.abs(y12 - y2) / 2;
    if (depth > 5) {
      return candidate;
    }
    let ok = true;
    for (let i = 0; i < lanes.length; i++) {
      if (Math.abs(lanes[i] - candidate) < 10) {
        ok = false;
      }
    }
    if (ok) {
      lanes.push(candidate);
      return candidate;
    }
    const diff = Math.abs(y12 - y2);
    return findLane(y12, y2 - diff / 5, depth + 1);
  };
  const drawArrow = (svg2, commit1, commit2, allCommits) => {
    const p1 = commitPos[commit1.id];
    const p2 = commitPos[commit2.id];
    const overlappingCommits = hasOverlappingCommits(commit1, commit2, allCommits);
    let arc = "";
    let arc2 = "";
    let radius = 0;
    let offset = 0;
    let colorClassNum = branchPos[commit2.branch].index;
    let lineDef;
    if (overlappingCommits) {
      arc = "A 10 10, 0, 0, 0,";
      arc2 = "A 10 10, 0, 0, 1,";
      radius = 10;
      offset = 10;
      colorClassNum = branchPos[commit2.branch].index;
      const lineY = p1.y < p2.y ? findLane(p1.y, p2.y) : findLane(p2.y, p1.y);
      if (p1.y < p2.y) {
        lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY - radius} ${arc} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc2} ${p2.x} ${lineY + offset} L ${p2.x} ${p2.y}`;
      } else {
        lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY + radius} ${arc2} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc} ${p2.x} ${lineY - offset} L ${p2.x} ${p2.y}`;
      }
    } else {
      if (p1.y < p2.y) {
        arc = "A 20 20, 0, 0, 0,";
        radius = 20;
        offset = 20;
        colorClassNum = branchPos[commit2.branch].index;
        lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
      }
      if (p1.y > p2.y) {
        arc = "A 20 20, 0, 0, 0,";
        radius = 20;
        offset = 20;
        colorClassNum = branchPos[commit1.branch].index;
        lineDef = `M ${p1.x} ${p1.y} L ${p2.x - radius} ${p1.y} ${arc} ${p2.x} ${p1.y - offset} L ${p2.x} ${p2.y}`;
      }
      if (p1.y === p2.y) {
        colorClassNum = branchPos[commit1.branch].index;
        lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
      }
    }
    svg2.append("path").attr("d", lineDef).attr("class", "arrow arrow" + colorClassNum % THEME_COLOR_LIMIT);
  };
  const drawArrows = (svg2, commits2) => {
    const gArrows = svg2.append("g").attr("class", "commit-arrows");
    Object.keys(commits2).forEach((key) => {
      const commit2 = commits2[key];
      if (commit2.parents && commit2.parents.length > 0) {
        commit2.parents.forEach((parent) => {
          drawArrow(gArrows, commits2[parent], commit2, commits2);
        });
      }
    });
  };
  const drawBranches = (svg2, branches2) => {
    const gitGraphConfig = getConfig().gitGraph;
    const g = svg2.append("g");
    branches2.forEach((branch2, index2) => {
      const adjustIndexForTheme = index2 % THEME_COLOR_LIMIT;
      const pos = branchPos[branch2.name].pos;
      const line2 = g.append("line");
      line2.attr("x1", 0);
      line2.attr("y1", pos);
      line2.attr("x2", maxPos);
      line2.attr("y2", pos);
      line2.attr("class", "branch branch" + adjustIndexForTheme);
      lanes.push(pos);
      let name2 = branch2.name;
      const labelElement = drawText$3(name2);
      const bkg = g.insert("rect");
      const branchLabel = g.insert("g").attr("class", "branchLabel");
      const label = branchLabel.insert("g").attr("class", "label branch-label" + adjustIndexForTheme);
      label.node().appendChild(labelElement);
      let bbox = labelElement.getBBox();
      bkg.attr("class", "branchLabelBkg label" + adjustIndexForTheme).attr("rx", 4).attr("ry", 4).attr("x", -bbox.width - 4 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)).attr("y", -bbox.height / 2 + 8).attr("width", bbox.width + 18).attr("height", bbox.height + 4);
      label.attr(
        "transform",
        "translate(" + (-bbox.width - 14 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)) + ", " + (pos - bbox.height / 2 - 1) + ")"
      );
      bkg.attr("transform", "translate(" + -19 + ", " + (pos - bbox.height / 2) + ")");
    });
  };
  const draw$f = function(txt, id2, ver, diagObj) {
    clear$e();
    const conf2 = getConfig();
    const gitGraphConfig = getConfig().gitGraph;
    log$3.debug("in gitgraph renderer", txt + "\n", "id:", id2, ver);
    allCommitsDict = diagObj.db.getCommits();
    const branches2 = diagObj.db.getBranchesAsObjArray();
    let pos = 0;
    branches2.forEach((branch2, index2) => {
      branchPos[branch2.name] = { pos, index: index2 };
      pos += 50 + (gitGraphConfig.rotateCommitLabel ? 40 : 0);
    });
    const diagram = select(`[id="${id2}"]`);
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
    drawCommits(diagram, allCommitsDict, false);
    if (gitGraphConfig.showBranches) {
      drawBranches(diagram, branches2);
    }
    drawArrows(diagram, allCommitsDict);
    drawCommits(diagram, allCommitsDict, true);
    setupGraphViewbox(void 0, diagram, gitGraphConfig.diagramPadding, conf2.useMaxWidth);
  };
  const gitGraphRenderer = {
    draw: draw$f
  };
  const getStyles = (options2) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
    (i) => `
        .branch-label${i} { fill: ${options2["gitBranchLabel" + i]}; }
        .commit${i} { stroke: ${options2["git" + i]}; fill: ${options2["git" + i]}; }
        .commit-highlight${i} { stroke: ${options2["gitInv" + i]}; fill: ${options2["gitInv" + i]}; }
        .label${i}  { fill: ${options2["git" + i]}; }
        .arrow${i} { stroke: ${options2["git" + i]}; }
        `
  ).join("\n")}

  .branch {
    stroke-width: 1;
    stroke: ${options2.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelColor};}
  .commit-label-bkg { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${options2.tagLabelFontSize}; fill: ${options2.tagLabelColor};}
  .tag-label-bkg { fill: ${options2.tagLabelBackground}; stroke: ${options2.tagLabelBorder}; }
  .tag-hole { fill: ${options2.textColor}; }

  .commit-merge {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }
  .commit-reverse {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  }
`;
  var parser$a = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 6], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 16], $V5 = [1, 11], $V6 = [1, 12], $V7 = [1, 13], $V8 = [1, 14], $V9 = [1, 15], $Va = [1, 27], $Vb = [1, 33], $Vc = [1, 34], $Vd = [1, 35], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 72], $Vh = [1, 73], $Vi = [1, 74], $Vj = [1, 75], $Vk = [1, 76], $Vl = [1, 77], $Vm = [1, 78], $Vn = [1, 38], $Vo = [1, 39], $Vp = [1, 40], $Vq = [1, 41], $Vr = [1, 42], $Vs = [1, 43], $Vt = [1, 44], $Vu = [1, 45], $Vv = [1, 46], $Vw = [1, 47], $Vx = [1, 48], $Vy = [1, 49], $Vz = [1, 50], $VA = [1, 51], $VB = [1, 52], $VC = [1, 53], $VD = [1, 54], $VE = [1, 55], $VF = [1, 56], $VG = [1, 57], $VH = [1, 59], $VI = [1, 60], $VJ = [1, 61], $VK = [1, 62], $VL = [1, 63], $VM = [1, 64], $VN = [1, 65], $VO = [1, 66], $VP = [1, 67], $VQ = [1, 68], $VR = [1, 69], $VS = [24, 52], $VT = [24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VU = [15, 24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VV = [1, 94], $VW = [1, 95], $VX = [1, 96], $VY = [1, 97], $VZ = [15, 24, 52], $V_ = [7, 8, 9, 10, 18, 22, 25, 26, 27, 28], $V$ = [15, 24, 43, 52], $V01 = [15, 24, 43, 52, 86, 87, 89, 90], $V11 = [15, 43], $V21 = [44, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "direction": 5, "directive": 6, "direction_tb": 7, "direction_bt": 8, "direction_rl": 9, "direction_lr": 10, "graphConfig": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, "NEWLINE": 15, ":": 16, "argDirective": 17, "open_directive": 18, "type_directive": 19, "arg_directive": 20, "close_directive": 21, "C4_CONTEXT": 22, "statements": 23, "EOF": 24, "C4_CONTAINER": 25, "C4_COMPONENT": 26, "C4_DYNAMIC": 27, "C4_DEPLOYMENT": 28, "otherStatements": 29, "diagramStatements": 30, "otherStatement": 31, "title": 32, "accDescription": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "boundaryStatement": 39, "boundaryStartStatement": 40, "boundaryStopStatement": 41, "boundaryStart": 42, "LBRACE": 43, "ENTERPRISE_BOUNDARY": 44, "attributes": 45, "SYSTEM_BOUNDARY": 46, "BOUNDARY": 47, "CONTAINER_BOUNDARY": 48, "NODE": 49, "NODE_L": 50, "NODE_R": 51, "RBRACE": 52, "diagramStatement": 53, "PERSON": 54, "PERSON_EXT": 55, "SYSTEM": 56, "SYSTEM_DB": 57, "SYSTEM_QUEUE": 58, "SYSTEM_EXT": 59, "SYSTEM_EXT_DB": 60, "SYSTEM_EXT_QUEUE": 61, "CONTAINER": 62, "CONTAINER_DB": 63, "CONTAINER_QUEUE": 64, "CONTAINER_EXT": 65, "CONTAINER_EXT_DB": 66, "CONTAINER_EXT_QUEUE": 67, "COMPONENT": 68, "COMPONENT_DB": 69, "COMPONENT_QUEUE": 70, "COMPONENT_EXT": 71, "COMPONENT_EXT_DB": 72, "COMPONENT_EXT_QUEUE": 73, "REL": 74, "BIREL": 75, "REL_U": 76, "REL_D": 77, "REL_L": 78, "REL_R": 79, "REL_B": 80, "REL_INDEX": 81, "UPDATE_EL_STYLE": 82, "UPDATE_REL_STYLE": 83, "UPDATE_LAYOUT_CONFIG": 84, "attribute": 85, "STR": 86, "STR_KEY": 87, "STR_VALUE": 88, "ATTRIBUTE": 89, "ATTRIBUTE_EMPTY": 90, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 7: "direction_tb", 8: "direction_bt", 9: "direction_rl", 10: "direction_lr", 15: "NEWLINE", 16: ":", 18: "open_directive", 19: "type_directive", 20: "arg_directive", 21: "close_directive", 22: "C4_CONTEXT", 24: "EOF", 25: "C4_CONTAINER", 26: "C4_COMPONENT", 27: "C4_DYNAMIC", 28: "C4_DEPLOYMENT", 32: "title", 33: "accDescription", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 43: "LBRACE", 44: "ENTERPRISE_BOUNDARY", 46: "SYSTEM_BOUNDARY", 47: "BOUNDARY", 48: "CONTAINER_BOUNDARY", 49: "NODE", 50: "NODE_L", 51: "NODE_R", 52: "RBRACE", 54: "PERSON", 55: "PERSON_EXT", 56: "SYSTEM", 57: "SYSTEM_DB", 58: "SYSTEM_QUEUE", 59: "SYSTEM_EXT", 60: "SYSTEM_EXT_DB", 61: "SYSTEM_EXT_QUEUE", 62: "CONTAINER", 63: "CONTAINER_DB", 64: "CONTAINER_QUEUE", 65: "CONTAINER_EXT", 66: "CONTAINER_EXT_DB", 67: "CONTAINER_EXT_QUEUE", 68: "COMPONENT", 69: "COMPONENT_DB", 70: "COMPONENT_QUEUE", 71: "COMPONENT_EXT", 72: "COMPONENT_EXT_DB", 73: "COMPONENT_EXT_QUEUE", 74: "REL", 75: "BIREL", 76: "REL_U", 77: "REL_D", 78: "REL_L", 79: "REL_R", 80: "REL_B", 81: "REL_INDEX", 82: "UPDATE_EL_STYLE", 83: "UPDATE_REL_STYLE", 84: "UPDATE_LAYOUT_CONFIG", 86: "STR", 87: "STR_KEY", 88: "STR_VALUE", 89: "ATTRIBUTE", 90: "ATTRIBUTE_EMPTY" },
      productions_: [0, [3, 1], [3, 1], [3, 2], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [6, 4], [6, 6], [12, 1], [13, 1], [17, 1], [14, 1], [11, 4], [11, 4], [11, 4], [11, 4], [11, 4], [23, 1], [23, 1], [23, 2], [29, 1], [29, 2], [29, 3], [31, 1], [31, 1], [31, 2], [31, 2], [31, 1], [39, 3], [40, 3], [40, 3], [40, 4], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [41, 1], [30, 1], [30, 2], [30, 3], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 1], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [45, 1], [45, 2], [85, 1], [85, 2], [85, 1], [85, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 4:
            yy.setDirection("TB");
            break;
          case 5:
            yy.setDirection("BT");
            break;
          case 6:
            yy.setDirection("RL");
            break;
          case 7:
            yy.setDirection("LR");
            break;
          case 11:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 12:
            break;
          case 13:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 14:
            yy.parseDirective("}%%", "close_directive", "c4Context");
            break;
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
            yy.setC4Type($$[$0 - 3]);
            break;
          case 26:
            yy.setTitle($$[$0].substring(6));
            this.$ = $$[$0].substring(6);
            break;
          case 27:
            yy.setAccDescription($$[$0].substring(15));
            this.$ = $$[$0].substring(15);
            break;
          case 28:
            this.$ = $$[$0].trim();
            yy.setTitle(this.$);
            break;
          case 29:
          case 30:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 35:
          case 36:
            $$[$0].splice(2, 0, "ENTERPRISE");
            yy.addPersonOrSystemBoundary(...$$[$0]);
            this.$ = $$[$0];
            break;
          case 37:
            yy.addPersonOrSystemBoundary(...$$[$0]);
            this.$ = $$[$0];
            break;
          case 38:
            $$[$0].splice(2, 0, "CONTAINER");
            yy.addContainerBoundary(...$$[$0]);
            this.$ = $$[$0];
            break;
          case 39:
            yy.addDeploymentNode("node", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 40:
            yy.addDeploymentNode("nodeL", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 41:
            yy.addDeploymentNode("nodeR", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 42:
            yy.popBoundaryParseStack();
            break;
          case 46:
            yy.addPersonOrSystem("person", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 47:
            yy.addPersonOrSystem("external_person", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 48:
            yy.addPersonOrSystem("system", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 49:
            yy.addPersonOrSystem("system_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 50:
            yy.addPersonOrSystem("system_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 51:
            yy.addPersonOrSystem("external_system", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 52:
            yy.addPersonOrSystem("external_system_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 53:
            yy.addPersonOrSystem("external_system_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 54:
            yy.addContainer("container", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 55:
            yy.addContainer("container_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 56:
            yy.addContainer("container_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 57:
            yy.addContainer("external_container", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 58:
            yy.addContainer("external_container_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 59:
            yy.addContainer("external_container_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 60:
            yy.addComponent("component", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 61:
            yy.addComponent("component_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 62:
            yy.addComponent("component_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 63:
            yy.addComponent("external_component", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 64:
            yy.addComponent("external_component_db", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 65:
            yy.addComponent("external_component_queue", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 67:
            yy.addRel("rel", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 68:
            yy.addRel("birel", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 69:
            yy.addRel("rel_u", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 70:
            yy.addRel("rel_d", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 71:
            yy.addRel("rel_l", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 72:
            yy.addRel("rel_r", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 73:
            yy.addRel("rel_b", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 74:
            $$[$0].splice(0, 1);
            yy.addRel("rel", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 75:
            yy.updateElStyle("update_el_style", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 76:
            yy.updateRelStyle("update_rel_style", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 77:
            yy.updateLayoutConfig("update_layout_config", ...$$[$0]);
            this.$ = $$[$0];
            break;
          case 78:
            this.$ = [$$[$0]];
            break;
          case 79:
            $$[$0].unshift($$[$0 - 1]);
            this.$ = $$[$0];
            break;
          case 80:
          case 82:
            this.$ = $$[$0].trim();
            break;
          case 81:
            let kv = {};
            kv[$$[$0 - 1].trim()] = $$[$0].trim();
            this.$ = kv;
            break;
          case 83:
            this.$ = "";
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 3: 17, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [2, 8] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 13: 18, 19: [1, 19] }, { 15: [1, 20] }, { 15: [1, 21] }, { 15: [1, 22] }, { 15: [1, 23] }, { 15: [1, 24] }, { 19: [2, 11] }, { 1: [2, 3] }, { 14: 25, 16: [1, 26], 21: $Va }, o([16, 21], [2, 12]), { 23: 28, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 79, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 80, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 81, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 82, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 83] }, { 17: 84, 20: [1, 85] }, { 15: [2, 14] }, { 24: [1, 86] }, o($VS, [2, 20], { 53: 32, 39: 58, 40: 70, 42: 71, 30: 87, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VS, [2, 21]), o($VT, [2, 23], { 15: [1, 88] }), o($VS, [2, 43], { 15: [1, 89] }), o($VU, [2, 26]), o($VU, [2, 27]), { 35: [1, 90] }, { 37: [1, 91] }, o($VU, [2, 30]), { 45: 92, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 98, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 99, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 100, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 101, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 102, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 103, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 104, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 105, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 106, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 107, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 108, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 109, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 110, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 111, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 112, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 113, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 114, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 115, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 116, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, o($VZ, [2, 66]), { 45: 117, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 118, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 119, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 120, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 121, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 122, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 123, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 124, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 125, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 126, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 127, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 30: 128, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 130], 43: [1, 129] }, { 45: 131, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 132, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 133, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 134, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 135, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 136, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 137, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 24: [1, 138] }, { 24: [1, 139] }, { 24: [1, 140] }, { 24: [1, 141] }, o($V_, [2, 9]), { 14: 142, 21: $Va }, { 21: [2, 13] }, { 1: [2, 15] }, o($VS, [2, 22]), o($VT, [2, 24], { 31: 31, 29: 143, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf }), o($VS, [2, 44], { 29: 29, 30: 30, 31: 31, 53: 32, 39: 58, 40: 70, 42: 71, 23: 144, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VU, [2, 28]), o($VU, [2, 29]), o($VZ, [2, 46]), o($V$, [2, 78], { 85: 93, 45: 145, 86: $VV, 87: $VW, 89: $VX, 90: $VY }), o($V01, [2, 80]), { 88: [1, 146] }, o($V01, [2, 82]), o($V01, [2, 83]), o($VZ, [2, 47]), o($VZ, [2, 48]), o($VZ, [2, 49]), o($VZ, [2, 50]), o($VZ, [2, 51]), o($VZ, [2, 52]), o($VZ, [2, 53]), o($VZ, [2, 54]), o($VZ, [2, 55]), o($VZ, [2, 56]), o($VZ, [2, 57]), o($VZ, [2, 58]), o($VZ, [2, 59]), o($VZ, [2, 60]), o($VZ, [2, 61]), o($VZ, [2, 62]), o($VZ, [2, 63]), o($VZ, [2, 64]), o($VZ, [2, 65]), o($VZ, [2, 67]), o($VZ, [2, 68]), o($VZ, [2, 69]), o($VZ, [2, 70]), o($VZ, [2, 71]), o($VZ, [2, 72]), o($VZ, [2, 73]), o($VZ, [2, 74]), o($VZ, [2, 75]), o($VZ, [2, 76]), o($VZ, [2, 77]), { 41: 147, 52: [1, 148] }, { 15: [1, 149] }, { 43: [1, 150] }, o($V11, [2, 35]), o($V11, [2, 36]), o($V11, [2, 37]), o($V11, [2, 38]), o($V11, [2, 39]), o($V11, [2, 40]), o($V11, [2, 41]), { 1: [2, 16] }, { 1: [2, 17] }, { 1: [2, 18] }, { 1: [2, 19] }, { 15: [1, 151] }, o($VT, [2, 25]), o($VS, [2, 45]), o($V$, [2, 79]), o($V01, [2, 81]), o($VZ, [2, 31]), o($VZ, [2, 42]), o($V21, [2, 32]), o($V21, [2, 33], { 15: [1, 152] }), o($V_, [2, 10]), o($V21, [2, 34])],
      defaultActions: { 2: [2, 1], 3: [2, 2], 5: [2, 8], 6: [2, 4], 7: [2, 5], 8: [2, 6], 9: [2, 7], 16: [2, 11], 17: [2, 3], 27: [2, 14], 85: [2, 13], 86: [2, 15], 138: [2, 16], 139: [2, 17], 140: [2, 18], 141: [2, 19] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 18;
            case 1:
              return 7;
            case 2:
              return 8;
            case 3:
              return 9;
            case 4:
              return 10;
            case 5:
              this.begin("type_directive");
              return 19;
            case 6:
              this.popState();
              this.begin("arg_directive");
              return 16;
            case 7:
              this.popState();
              this.popState();
              return 21;
            case 8:
              return 20;
            case 9:
              return 32;
            case 10:
              return 33;
            case 11:
              this.begin("acc_title");
              return 34;
            case 12:
              this.popState();
              return "acc_title_value";
            case 13:
              this.begin("acc_descr");
              return 36;
            case 14:
              this.popState();
              return "acc_descr_value";
            case 15:
              this.begin("acc_descr_multiline");
              break;
            case 16:
              this.popState();
              break;
            case 17:
              return "acc_descr_multiline_value";
            case 18:
              break;
            case 19:
              c;
              break;
            case 20:
              return 15;
            case 21:
              break;
            case 22:
              return 22;
            case 23:
              return 25;
            case 24:
              return 26;
            case 25:
              return 27;
            case 26:
              return 28;
            case 27:
              this.begin("person_ext");
              return 55;
            case 28:
              this.begin("person");
              return 54;
            case 29:
              this.begin("system_ext_queue");
              return 61;
            case 30:
              this.begin("system_ext_db");
              return 60;
            case 31:
              this.begin("system_ext");
              return 59;
            case 32:
              this.begin("system_queue");
              return 58;
            case 33:
              this.begin("system_db");
              return 57;
            case 34:
              this.begin("system");
              return 56;
            case 35:
              this.begin("boundary");
              return 47;
            case 36:
              this.begin("enterprise_boundary");
              return 44;
            case 37:
              this.begin("system_boundary");
              return 46;
            case 38:
              this.begin("container_ext_queue");
              return 67;
            case 39:
              this.begin("container_ext_db");
              return 66;
            case 40:
              this.begin("container_ext");
              return 65;
            case 41:
              this.begin("container_queue");
              return 64;
            case 42:
              this.begin("container_db");
              return 63;
            case 43:
              this.begin("container");
              return 62;
            case 44:
              this.begin("container_boundary");
              return 48;
            case 45:
              this.begin("component_ext_queue");
              return 73;
            case 46:
              this.begin("component_ext_db");
              return 72;
            case 47:
              this.begin("component_ext");
              return 71;
            case 48:
              this.begin("component_queue");
              return 70;
            case 49:
              this.begin("component_db");
              return 69;
            case 50:
              this.begin("component");
              return 68;
            case 51:
              this.begin("node");
              return 49;
            case 52:
              this.begin("node");
              return 49;
            case 53:
              this.begin("node_l");
              return 50;
            case 54:
              this.begin("node_r");
              return 51;
            case 55:
              this.begin("rel");
              return 74;
            case 56:
              this.begin("birel");
              return 75;
            case 57:
              this.begin("rel_u");
              return 76;
            case 58:
              this.begin("rel_u");
              return 76;
            case 59:
              this.begin("rel_d");
              return 77;
            case 60:
              this.begin("rel_d");
              return 77;
            case 61:
              this.begin("rel_l");
              return 78;
            case 62:
              this.begin("rel_l");
              return 78;
            case 63:
              this.begin("rel_r");
              return 79;
            case 64:
              this.begin("rel_r");
              return 79;
            case 65:
              this.begin("rel_b");
              return 80;
            case 66:
              this.begin("rel_index");
              return 81;
            case 67:
              this.begin("update_el_style");
              return 82;
            case 68:
              this.begin("update_rel_style");
              return 83;
            case 69:
              this.begin("update_layout_config");
              return 84;
            case 70:
              return "EOF_IN_STRUCT";
            case 71:
              this.begin("attribute");
              return "ATTRIBUTE_EMPTY";
            case 72:
              this.begin("attribute");
              break;
            case 73:
              this.popState();
              this.popState();
              break;
            case 74:
              return 90;
            case 75:
              break;
            case 76:
              return 90;
            case 77:
              this.begin("string");
              break;
            case 78:
              this.popState();
              break;
            case 79:
              return "STR";
            case 80:
              this.begin("string_kv");
              break;
            case 81:
              this.begin("string_kv_key");
              return "STR_KEY";
            case 82:
              this.popState();
              this.begin("string_kv_value");
              break;
            case 83:
              return "STR_VALUE";
            case 84:
              this.popState();
              this.popState();
              break;
            case 85:
              return "STR";
            case 86:
              return "LBRACE";
            case 87:
              return "RBRACE";
            case 88:
              return "SPACE";
            case 89:
              return "EOL";
            case 90:
              return 24;
          }
        },
        rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
        conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "string_kv_value": { "rules": [83, 84], "inclusive": false }, "string_kv_key": { "rules": [82], "inclusive": false }, "string_kv": { "rules": [81], "inclusive": false }, "string": { "rules": [78, 79], "inclusive": false }, "attribute": { "rules": [73, 74, 75, 76, 77, 80, 85], "inclusive": false }, "update_layout_config": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_rel_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_el_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_b": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_d": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_u": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_bi": { "rules": [], "inclusive": false }, "rel": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "node": { "rules": [70, 71, 72, 73], "inclusive": false }, "index": { "rules": [], "inclusive": false }, "rel_index": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext_queue": { "rules": [], "inclusive": false }, "component_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext_queue": { "rules": [], "inclusive": false }, "container_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container": { "rules": [70, 71, 72, 73], "inclusive": false }, "birel": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "enterprise_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system": { "rules": [70, 71, 72, 73], "inclusive": false }, "person_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "person": { "rules": [70, 71, 72, 73], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 86, 87, 88, 89, 90], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$a.parser = parser$a;
  const c4Detector = (txt) => {
    return txt.match(/^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/) !== null;
  };
  let c4ShapeArray = [];
  let boundaryParseStack = [""];
  let currentBoundaryParse = "global";
  let parentBoundaryParse = "";
  let boundarys = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ];
  let rels = [];
  let title = "";
  let wrapEnabled$1 = false;
  let c4ShapeInRow$1 = 4;
  let c4BoundaryInRow$1 = 2;
  var c4Type;
  const getC4Type = function() {
    return c4Type;
  };
  const setC4Type = function(c4TypeParam) {
    let sanitizedText = sanitizeText$5(c4TypeParam, getConfig$1());
    c4Type = sanitizedText;
  };
  const parseDirective$a = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const addRel = function(type2, from2, to, label, techn, descr, sprite, tags2, link2) {
    if (type2 === void 0 || type2 === null || from2 === void 0 || from2 === null || to === void 0 || to === null || label === void 0 || label === null)
      return;
    let rel = {};
    const old = rels.find((rel2) => rel2.from === from2 && rel2.to === to);
    if (old) {
      rel = old;
    } else {
      rels.push(rel);
    }
    rel.type = type2;
    rel.from = from2;
    rel.to = to;
    rel.label = { text: label };
    if (techn === void 0 || techn === null) {
      rel.techn = { text: "" };
    } else {
      if (typeof techn === "object") {
        let [key, value] = Object.entries(techn)[0];
        rel[key] = { text: value };
      } else {
        rel.techn = { text: techn };
      }
    }
    if (descr === void 0 || descr === null) {
      rel.descr = { text: "" };
    } else {
      if (typeof descr === "object") {
        let [key, value] = Object.entries(descr)[0];
        rel[key] = { text: value };
      } else {
        rel.descr = { text: descr };
      }
    }
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      rel[key] = value;
    } else {
      rel.sprite = sprite;
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      rel[key] = value;
    } else {
      rel.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      rel[key] = value;
    } else {
      rel.link = link2;
    }
    rel.wrap = autoWrap$1();
  };
  const addPersonOrSystem = function(typeC4Shape, alias, label, descr, sprite, tags2, link2) {
    if (alias === null || label === null)
      return;
    let personOrSystem = {};
    const old = c4ShapeArray.find((personOrSystem2) => personOrSystem2.alias === alias);
    if (old && alias === old.alias) {
      personOrSystem = old;
    } else {
      personOrSystem.alias = alias;
      c4ShapeArray.push(personOrSystem);
    }
    if (label === void 0 || label === null) {
      personOrSystem.label = { text: "" };
    } else {
      personOrSystem.label = { text: label };
    }
    if (descr === void 0 || descr === null) {
      personOrSystem.descr = { text: "" };
    } else {
      if (typeof descr === "object") {
        let [key, value] = Object.entries(descr)[0];
        personOrSystem[key] = { text: value };
      } else {
        personOrSystem.descr = { text: descr };
      }
    }
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      personOrSystem[key] = value;
    } else {
      personOrSystem.sprite = sprite;
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      personOrSystem[key] = value;
    } else {
      personOrSystem.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      personOrSystem[key] = value;
    } else {
      personOrSystem.link = link2;
    }
    personOrSystem.typeC4Shape = { text: typeC4Shape };
    personOrSystem.parentBoundary = currentBoundaryParse;
    personOrSystem.wrap = autoWrap$1();
  };
  const addContainer = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
    if (alias === null || label === null)
      return;
    let container = {};
    const old = c4ShapeArray.find((container2) => container2.alias === alias);
    if (old && alias === old.alias) {
      container = old;
    } else {
      container.alias = alias;
      c4ShapeArray.push(container);
    }
    if (label === void 0 || label === null) {
      container.label = { text: "" };
    } else {
      container.label = { text: label };
    }
    if (techn === void 0 || techn === null) {
      container.techn = { text: "" };
    } else {
      if (typeof techn === "object") {
        let [key, value] = Object.entries(techn)[0];
        container[key] = { text: value };
      } else {
        container.techn = { text: techn };
      }
    }
    if (descr === void 0 || descr === null) {
      container.descr = { text: "" };
    } else {
      if (typeof descr === "object") {
        let [key, value] = Object.entries(descr)[0];
        container[key] = { text: value };
      } else {
        container.descr = { text: descr };
      }
    }
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      container[key] = value;
    } else {
      container.sprite = sprite;
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      container[key] = value;
    } else {
      container.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      container[key] = value;
    } else {
      container.link = link2;
    }
    container.wrap = autoWrap$1();
    container.typeC4Shape = { text: typeC4Shape };
    container.parentBoundary = currentBoundaryParse;
  };
  const addComponent = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
    if (alias === null || label === null)
      return;
    let component = {};
    const old = c4ShapeArray.find((component2) => component2.alias === alias);
    if (old && alias === old.alias) {
      component = old;
    } else {
      component.alias = alias;
      c4ShapeArray.push(component);
    }
    if (label === void 0 || label === null) {
      component.label = { text: "" };
    } else {
      component.label = { text: label };
    }
    if (techn === void 0 || techn === null) {
      component.techn = { text: "" };
    } else {
      if (typeof techn === "object") {
        let [key, value] = Object.entries(techn)[0];
        component[key] = { text: value };
      } else {
        component.techn = { text: techn };
      }
    }
    if (descr === void 0 || descr === null) {
      component.descr = { text: "" };
    } else {
      if (typeof descr === "object") {
        let [key, value] = Object.entries(descr)[0];
        component[key] = { text: value };
      } else {
        component.descr = { text: descr };
      }
    }
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      component[key] = value;
    } else {
      component.sprite = sprite;
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      component[key] = value;
    } else {
      component.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      component[key] = value;
    } else {
      component.link = link2;
    }
    component.wrap = autoWrap$1();
    component.typeC4Shape = { text: typeC4Shape };
    component.parentBoundary = currentBoundaryParse;
  };
  const addPersonOrSystemBoundary = function(alias, label, type2, tags2, link2) {
    if (alias === null || label === null)
      return;
    let boundary = {};
    const old = boundarys.find((boundary2) => boundary2.alias === alias);
    if (old && alias === old.alias) {
      boundary = old;
    } else {
      boundary.alias = alias;
      boundarys.push(boundary);
    }
    if (label === void 0 || label === null) {
      boundary.label = { text: "" };
    } else {
      boundary.label = { text: label };
    }
    if (type2 === void 0 || type2 === null) {
      boundary.type = { text: "system" };
    } else {
      if (typeof type2 === "object") {
        let [key, value] = Object.entries(type2)[0];
        boundary[key] = { text: value };
      } else {
        boundary.type = { text: type2 };
      }
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      boundary[key] = value;
    } else {
      boundary.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      boundary[key] = value;
    } else {
      boundary.link = link2;
    }
    boundary.parentBoundary = currentBoundaryParse;
    boundary.wrap = autoWrap$1();
    parentBoundaryParse = currentBoundaryParse;
    currentBoundaryParse = alias;
    boundaryParseStack.push(parentBoundaryParse);
  };
  const addContainerBoundary = function(alias, label, type2, tags2, link2) {
    if (alias === null || label === null)
      return;
    let boundary = {};
    const old = boundarys.find((boundary2) => boundary2.alias === alias);
    if (old && alias === old.alias) {
      boundary = old;
    } else {
      boundary.alias = alias;
      boundarys.push(boundary);
    }
    if (label === void 0 || label === null) {
      boundary.label = { text: "" };
    } else {
      boundary.label = { text: label };
    }
    if (type2 === void 0 || type2 === null) {
      boundary.type = { text: "container" };
    } else {
      if (typeof type2 === "object") {
        let [key, value] = Object.entries(type2)[0];
        boundary[key] = { text: value };
      } else {
        boundary.type = { text: type2 };
      }
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      boundary[key] = value;
    } else {
      boundary.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      boundary[key] = value;
    } else {
      boundary.link = link2;
    }
    boundary.parentBoundary = currentBoundaryParse;
    boundary.wrap = autoWrap$1();
    parentBoundaryParse = currentBoundaryParse;
    currentBoundaryParse = alias;
    boundaryParseStack.push(parentBoundaryParse);
  };
  const addDeploymentNode = function(nodeType, alias, label, type2, descr, sprite, tags2, link2) {
    if (alias === null || label === null)
      return;
    let boundary = {};
    const old = boundarys.find((boundary2) => boundary2.alias === alias);
    if (old && alias === old.alias) {
      boundary = old;
    } else {
      boundary.alias = alias;
      boundarys.push(boundary);
    }
    if (label === void 0 || label === null) {
      boundary.label = { text: "" };
    } else {
      boundary.label = { text: label };
    }
    if (type2 === void 0 || type2 === null) {
      boundary.type = { text: "node" };
    } else {
      if (typeof type2 === "object") {
        let [key, value] = Object.entries(type2)[0];
        boundary[key] = { text: value };
      } else {
        boundary.type = { text: type2 };
      }
    }
    if (descr === void 0 || descr === null) {
      boundary.descr = { text: "" };
    } else {
      if (typeof descr === "object") {
        let [key, value] = Object.entries(descr)[0];
        boundary[key] = { text: value };
      } else {
        boundary.descr = { text: descr };
      }
    }
    if (typeof tags2 === "object") {
      let [key, value] = Object.entries(tags2)[0];
      boundary[key] = value;
    } else {
      boundary.tags = tags2;
    }
    if (typeof link2 === "object") {
      let [key, value] = Object.entries(link2)[0];
      boundary[key] = value;
    } else {
      boundary.link = link2;
    }
    boundary.nodeType = nodeType;
    boundary.parentBoundary = currentBoundaryParse;
    boundary.wrap = autoWrap$1();
    parentBoundaryParse = currentBoundaryParse;
    currentBoundaryParse = alias;
    boundaryParseStack.push(parentBoundaryParse);
  };
  const popBoundaryParseStack = function() {
    currentBoundaryParse = parentBoundaryParse;
    boundaryParseStack.pop();
    parentBoundaryParse = boundaryParseStack.pop();
    boundaryParseStack.push(parentBoundaryParse);
  };
  const updateElStyle = function(typeC4Shape, elementName, bgColor, fontColor, borderColor, shadowing, shape, sprite, techn, legendText, legendSprite) {
    let old = c4ShapeArray.find((element) => element.alias === elementName);
    if (old === void 0) {
      old = boundarys.find((element) => element.alias === elementName);
      if (old === void 0) {
        return;
      }
    }
    if (bgColor !== void 0 && bgColor !== null) {
      if (typeof bgColor === "object") {
        let [key, value] = Object.entries(bgColor)[0];
        old[key] = value;
      } else {
        old.bgColor = bgColor;
      }
    }
    if (fontColor !== void 0 && fontColor !== null) {
      if (typeof fontColor === "object") {
        let [key, value] = Object.entries(fontColor)[0];
        old[key] = value;
      } else {
        old.fontColor = fontColor;
      }
    }
    if (borderColor !== void 0 && borderColor !== null) {
      if (typeof borderColor === "object") {
        let [key, value] = Object.entries(borderColor)[0];
        old[key] = value;
      } else {
        old.borderColor = borderColor;
      }
    }
    if (shadowing !== void 0 && shadowing !== null) {
      if (typeof shadowing === "object") {
        let [key, value] = Object.entries(shadowing)[0];
        old[key] = value;
      } else {
        old.shadowing = shadowing;
      }
    }
    if (shape !== void 0 && shape !== null) {
      if (typeof shape === "object") {
        let [key, value] = Object.entries(shape)[0];
        old[key] = value;
      } else {
        old.shape = shape;
      }
    }
    if (sprite !== void 0 && sprite !== null) {
      if (typeof sprite === "object") {
        let [key, value] = Object.entries(sprite)[0];
        old[key] = value;
      } else {
        old.sprite = sprite;
      }
    }
    if (techn !== void 0 && techn !== null) {
      if (typeof techn === "object") {
        let [key, value] = Object.entries(techn)[0];
        old[key] = value;
      } else {
        old.techn = techn;
      }
    }
    if (legendText !== void 0 && legendText !== null) {
      if (typeof legendText === "object") {
        let [key, value] = Object.entries(legendText)[0];
        old[key] = value;
      } else {
        old.legendText = legendText;
      }
    }
    if (legendSprite !== void 0 && legendSprite !== null) {
      if (typeof legendSprite === "object") {
        let [key, value] = Object.entries(legendSprite)[0];
        old[key] = value;
      } else {
        old.legendSprite = legendSprite;
      }
    }
  };
  const updateRelStyle = function(typeC4Shape, from2, to, textColor, lineColor, offsetX, offsetY) {
    const old = rels.find((rel) => rel.from === from2 && rel.to === to);
    if (old === void 0) {
      return;
    }
    if (textColor !== void 0 && textColor !== null) {
      if (typeof textColor === "object") {
        let [key, value] = Object.entries(textColor)[0];
        old[key] = value;
      } else {
        old.textColor = textColor;
      }
    }
    if (lineColor !== void 0 && lineColor !== null) {
      if (typeof lineColor === "object") {
        let [key, value] = Object.entries(lineColor)[0];
        old[key] = value;
      } else {
        old.lineColor = lineColor;
      }
    }
    if (offsetX !== void 0 && offsetX !== null) {
      if (typeof offsetX === "object") {
        let [key, value] = Object.entries(offsetX)[0];
        old[key] = parseInt(value);
      } else {
        old.offsetX = parseInt(offsetX);
      }
    }
    if (offsetY !== void 0 && offsetY !== null) {
      if (typeof offsetY === "object") {
        let [key, value] = Object.entries(offsetY)[0];
        old[key] = parseInt(value);
      } else {
        old.offsetY = parseInt(offsetY);
      }
    }
  };
  const updateLayoutConfig = function(typeC4Shape, c4ShapeInRowParam, c4BoundaryInRowParam) {
    let c4ShapeInRowValue = c4ShapeInRow$1;
    let c4BoundaryInRowValue = c4BoundaryInRow$1;
    if (typeof c4ShapeInRowParam === "object") {
      const value = Object.values(c4ShapeInRowParam)[0];
      c4ShapeInRowValue = parseInt(value);
    } else {
      c4ShapeInRowValue = parseInt(c4ShapeInRowParam);
    }
    if (typeof c4BoundaryInRowParam === "object") {
      const value = Object.values(c4BoundaryInRowParam)[0];
      c4BoundaryInRowValue = parseInt(value);
    } else {
      c4BoundaryInRowValue = parseInt(c4BoundaryInRowParam);
    }
    if (c4ShapeInRowValue >= 1)
      c4ShapeInRow$1 = c4ShapeInRowValue;
    if (c4BoundaryInRowValue >= 1)
      c4BoundaryInRow$1 = c4BoundaryInRowValue;
  };
  const getC4ShapeInRow = function() {
    return c4ShapeInRow$1;
  };
  const getC4BoundaryInRow = function() {
    return c4BoundaryInRow$1;
  };
  const getCurrentBoundaryParse = function() {
    return currentBoundaryParse;
  };
  const getParentBoundaryParse = function() {
    return parentBoundaryParse;
  };
  const getC4ShapeArray = function(parentBoundary) {
    if (parentBoundary === void 0 || parentBoundary === null)
      return c4ShapeArray;
    else
      return c4ShapeArray.filter((personOrSystem) => {
        return personOrSystem.parentBoundary === parentBoundary;
      });
  };
  const getC4Shape = function(alias) {
    return c4ShapeArray.find((personOrSystem) => personOrSystem.alias === alias);
  };
  const getC4ShapeKeys = function(parentBoundary) {
    return Object.keys(getC4ShapeArray(parentBoundary));
  };
  const getBoundarys = function(parentBoundary) {
    if (parentBoundary === void 0 || parentBoundary === null)
      return boundarys;
    else
      return boundarys.filter((boundary) => boundary.parentBoundary === parentBoundary);
  };
  const getRels = function() {
    return rels;
  };
  const getTitle = function() {
    return title;
  };
  const setWrap$1 = function(wrapSetting) {
    wrapEnabled$1 = wrapSetting;
  };
  const autoWrap$1 = function() {
    return wrapEnabled$1;
  };
  const clear$d = function() {
    c4ShapeArray = [];
    boundarys = [
      {
        alias: "global",
        label: { text: "global" },
        type: { text: "global" },
        tags: null,
        link: null,
        parentBoundary: ""
      }
    ];
    parentBoundaryParse = "";
    currentBoundaryParse = "global";
    boundaryParseStack = [""];
    rels = [];
    boundaryParseStack = [""];
    title = "";
    wrapEnabled$1 = false;
    c4ShapeInRow$1 = 4;
    c4BoundaryInRow$1 = 2;
  };
  const LINETYPE$1 = {
    SOLID: 0,
    DOTTED: 1,
    NOTE: 2,
    SOLID_CROSS: 3,
    DOTTED_CROSS: 4,
    SOLID_OPEN: 5,
    DOTTED_OPEN: 6,
    LOOP_START: 10,
    LOOP_END: 11,
    ALT_START: 12,
    ALT_ELSE: 13,
    ALT_END: 14,
    OPT_START: 15,
    OPT_END: 16,
    ACTIVE_START: 17,
    ACTIVE_END: 18,
    PAR_START: 19,
    PAR_AND: 20,
    PAR_END: 21,
    RECT_START: 22,
    RECT_END: 23,
    SOLID_POINT: 24,
    DOTTED_POINT: 25
  };
  const ARROWTYPE$1 = {
    FILLED: 0,
    OPEN: 1
  };
  const PLACEMENT$1 = {
    LEFTOF: 0,
    RIGHTOF: 1,
    OVER: 2
  };
  const setTitle = function(txt) {
    let sanitizedText = sanitizeText$5(txt, getConfig$1());
    title = sanitizedText;
  };
  const c4Db = {
    addPersonOrSystem,
    addPersonOrSystemBoundary,
    addContainer,
    addContainerBoundary,
    addComponent,
    addDeploymentNode,
    popBoundaryParseStack,
    addRel,
    updateElStyle,
    updateRelStyle,
    updateLayoutConfig,
    autoWrap: autoWrap$1,
    setWrap: setWrap$1,
    getC4ShapeArray,
    getC4Shape,
    getC4ShapeKeys,
    getBoundarys,
    getCurrentBoundaryParse,
    getParentBoundaryParse,
    getRels,
    getTitle,
    getC4Type,
    getC4ShapeInRow,
    getC4BoundaryInRow,
    setAccTitle,
    getAccTitle,
    getAccDescription,
    setAccDescription,
    parseDirective: parseDirective$a,
    getConfig: () => getConfig$1().c4,
    clear: clear$d,
    LINETYPE: LINETYPE$1,
    ARROWTYPE: ARROWTYPE$1,
    PLACEMENT: PLACEMENT$1,
    setTitle,
    setC4Type
  };
  const drawRect$2 = function(elem, rectData) {
    const rectElem = elem.append("rect");
    rectElem.attr("x", rectData.x);
    rectElem.attr("y", rectData.y);
    rectElem.attr("fill", rectData.fill);
    rectElem.attr("stroke", rectData.stroke);
    rectElem.attr("width", rectData.width);
    rectElem.attr("height", rectData.height);
    rectElem.attr("rx", rectData.rx);
    rectElem.attr("ry", rectData.ry);
    if (rectData.attrs !== "undefined" && rectData.attrs !== null) {
      for (let attrKey in rectData.attrs)
        rectElem.attr(attrKey, rectData.attrs[attrKey]);
    }
    if (rectData.class !== "undefined") {
      rectElem.attr("class", rectData.class);
    }
    return rectElem;
  };
  const drawImage$1 = function(elem, width2, height2, x2, y2, link2) {
    const imageElem = elem.append("image");
    imageElem.attr("width", width2);
    imageElem.attr("height", height2);
    imageElem.attr("x", x2);
    imageElem.attr("y", y2);
    let sanitizedLink = link2.startsWith("data:image/png;base64") ? link2 : sanitizeUrl_1(link2);
    imageElem.attr("xlink:href", sanitizedLink);
  };
  const drawEmbeddedImage$1 = function(elem, x2, y2, link2) {
    const imageElem = elem.append("use");
    imageElem.attr("x", x2);
    imageElem.attr("y", y2);
    var sanitizedLink = sanitizeUrl_1(link2);
    imageElem.attr("xlink:href", "#" + sanitizedLink);
  };
  const drawText$2 = function(elem, textData) {
    let prevTextHeight = 0, textHeight = 0;
    const lines = textData.text.split(common.lineBreakRegex);
    let textElems = [];
    let dy = 0;
    let yfunc = () => textData.y;
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      switch (textData.valign) {
        case "top":
        case "start":
          yfunc = () => Math.round(textData.y + textData.textMargin);
          break;
        case "middle":
        case "center":
          yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
          break;
        case "bottom":
        case "end":
          yfunc = () => Math.round(
            textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
          );
          break;
      }
    }
    if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
      switch (textData.anchor) {
        case "left":
        case "start":
          textData.x = Math.round(textData.x + textData.textMargin);
          textData.anchor = "start";
          textData.dominantBaseline = "text-after-edge";
          textData.alignmentBaseline = "middle";
          break;
        case "middle":
        case "center":
          textData.x = Math.round(textData.x + textData.width / 2);
          textData.anchor = "middle";
          textData.dominantBaseline = "middle";
          textData.alignmentBaseline = "middle";
          break;
        case "right":
        case "end":
          textData.x = Math.round(textData.x + textData.width - textData.textMargin);
          textData.anchor = "end";
          textData.dominantBaseline = "text-before-edge";
          textData.alignmentBaseline = "middle";
          break;
      }
    }
    for (let i = 0; i < lines.length; i++) {
      let line2 = lines[i];
      if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
        dy = i * textData.fontSize;
      }
      const textElem = elem.append("text");
      textElem.attr("x", textData.x);
      textElem.attr("y", yfunc());
      if (typeof textData.anchor !== "undefined") {
        textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
      }
      if (typeof textData.fontFamily !== "undefined") {
        textElem.style("font-family", textData.fontFamily);
      }
      if (typeof textData.fontSize !== "undefined") {
        textElem.style("font-size", textData.fontSize);
      }
      if (typeof textData.fontWeight !== "undefined") {
        textElem.style("font-weight", textData.fontWeight);
      }
      if (typeof textData.fill !== "undefined") {
        textElem.attr("fill", textData.fill);
      }
      if (typeof textData.class !== "undefined") {
        textElem.attr("class", textData.class);
      }
      if (typeof textData.dy !== "undefined") {
        textElem.attr("dy", textData.dy);
      } else if (dy !== 0) {
        textElem.attr("dy", dy);
      }
      if (textData.tspan) {
        const span = textElem.append("tspan");
        span.attr("x", textData.x);
        if (typeof textData.fill !== "undefined") {
          span.attr("fill", textData.fill);
        }
        span.text(line2);
      } else {
        textElem.text(line2);
      }
      if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
        textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
        prevTextHeight = textHeight;
      }
      textElems.push(textElem);
    }
    return textElems;
  };
  const drawLabel$2 = function(elem, txtObject) {
    function genPoints(x2, y2, width2, height2, cut) {
      return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
    }
    const polygon = elem.append("polygon");
    polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
    polygon.attr("class", "labelBox");
    txtObject.y = txtObject.y + txtObject.height / 2;
    drawText$2(elem, txtObject);
    return polygon;
  };
  const drawRels$1 = (elem, rels2, conf2) => {
    const relsElem = elem.append("g");
    let i = 0;
    for (let rel of rels2) {
      let textColor = rel.textColor ? rel.textColor : "#444444";
      let strokeColor = rel.lineColor ? rel.lineColor : "#444444";
      let offsetX = rel.offsetX ? parseInt(rel.offsetX) : 0;
      let offsetY = rel.offsetY ? parseInt(rel.offsetY) : 0;
      let url = "";
      if (i === 0) {
        let line2 = relsElem.append("line");
        line2.attr("x1", rel.startPoint.x);
        line2.attr("y1", rel.startPoint.y);
        line2.attr("x2", rel.endPoint.x);
        line2.attr("y2", rel.endPoint.y);
        line2.attr("stroke-width", "1");
        line2.attr("stroke", strokeColor);
        line2.style("fill", "none");
        if (rel.type !== "rel_b")
          line2.attr("marker-end", "url(" + url + "#arrowhead)");
        if (rel.type === "birel" || rel.type === "rel_b")
          line2.attr("marker-start", "url(" + url + "#arrowend)");
        i = -1;
      } else {
        let line2 = relsElem.append("path");
        line2.attr("fill", "none").attr("stroke-width", "1").attr("stroke", strokeColor).attr(
          "d",
          "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", rel.startPoint.x).replaceAll("starty", rel.startPoint.y).replaceAll(
            "controlx",
            rel.startPoint.x + (rel.endPoint.x - rel.startPoint.x) / 2 - (rel.endPoint.x - rel.startPoint.x) / 4
          ).replaceAll("controly", rel.startPoint.y + (rel.endPoint.y - rel.startPoint.y) / 2).replaceAll("stopx", rel.endPoint.x).replaceAll("stopy", rel.endPoint.y)
        );
        if (rel.type !== "rel_b")
          line2.attr("marker-end", "url(" + url + "#arrowhead)");
        if (rel.type === "birel" || rel.type === "rel_b")
          line2.attr("marker-start", "url(" + url + "#arrowend)");
      }
      let messageConf = conf2.messageFont();
      _drawTextCandidateFunc$2(conf2)(
        rel.label.text,
        relsElem,
        Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
        Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + offsetY,
        rel.label.width,
        rel.label.height,
        { fill: textColor },
        messageConf
      );
      if (rel.techn && rel.techn.text !== "") {
        messageConf = conf2.messageFont();
        _drawTextCandidateFunc$2(conf2)(
          "[" + rel.techn.text + "]",
          relsElem,
          Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
          Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + conf2.messageFontSize + 5 + offsetY,
          Math.max(rel.label.width, rel.techn.width),
          rel.techn.height,
          { fill: textColor, "font-style": "italic" },
          messageConf
        );
      }
    }
  };
  const drawBoundary$1 = function(elem, boundary, conf2) {
    const boundaryElem = elem.append("g");
    let fillColor = boundary.bgColor ? boundary.bgColor : "none";
    let strokeColor = boundary.borderColor ? boundary.borderColor : "#444444";
    let fontColor = boundary.fontColor ? boundary.fontColor : "black";
    let attrsValue = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
    if (boundary.nodeType)
      attrsValue = { "stroke-width": 1 };
    let rectData = {
      x: boundary.x,
      y: boundary.y,
      fill: fillColor,
      stroke: strokeColor,
      width: boundary.width,
      height: boundary.height,
      rx: 2.5,
      ry: 2.5,
      attrs: attrsValue
    };
    drawRect$2(boundaryElem, rectData);
    let boundaryConf = conf2.boundaryFont();
    boundaryConf.fontWeight = "bold";
    boundaryConf.fontSize = boundaryConf.fontSize + 2;
    boundaryConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      boundary.label.text,
      boundaryElem,
      boundary.x,
      boundary.y + boundary.label.Y,
      boundary.width,
      boundary.height,
      { fill: "#444444" },
      boundaryConf
    );
    if (boundary.type && boundary.type.text !== "") {
      boundaryConf = conf2.boundaryFont();
      boundaryConf.fontColor = fontColor;
      _drawTextCandidateFunc$2(conf2)(
        boundary.type.text,
        boundaryElem,
        boundary.x,
        boundary.y + boundary.type.Y,
        boundary.width,
        boundary.height,
        { fill: "#444444" },
        boundaryConf
      );
    }
    if (boundary.descr && boundary.descr.text !== "") {
      boundaryConf = conf2.boundaryFont();
      boundaryConf.fontSize = boundaryConf.fontSize - 2;
      boundaryConf.fontColor = fontColor;
      _drawTextCandidateFunc$2(conf2)(
        boundary.descr.text,
        boundaryElem,
        boundary.x,
        boundary.y + boundary.descr.Y,
        boundary.width,
        boundary.height,
        { fill: "#444444" },
        boundaryConf
      );
    }
  };
  const drawC4Shape = function(elem, c4Shape, conf2) {
    let fillColor = c4Shape.bgColor ? c4Shape.bgColor : conf2[c4Shape.typeC4Shape.text + "_bg_color"];
    let strokeColor = c4Shape.borderColor ? c4Shape.borderColor : conf2[c4Shape.typeC4Shape.text + "_border_color"];
    let fontColor = c4Shape.fontColor ? c4Shape.fontColor : "#FFFFFF";
    let personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
    switch (c4Shape.typeC4Shape.text) {
      case "person":
        personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
        break;
      case "external_person":
        personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
        break;
    }
    const c4ShapeElem = elem.append("g");
    c4ShapeElem.attr("class", "person-man");
    const rect2 = getNoteRect$2();
    switch (c4Shape.typeC4Shape.text) {
      case "person":
      case "external_person":
      case "system":
      case "external_system":
      case "container":
      case "external_container":
      case "component":
      case "external_component":
        rect2.x = c4Shape.x;
        rect2.y = c4Shape.y;
        rect2.fill = fillColor;
        rect2.width = c4Shape.width;
        rect2.height = c4Shape.height;
        rect2.style = "stroke:" + strokeColor + ";stroke-width:0.5;";
        rect2.rx = 2.5;
        rect2.ry = 2.5;
        drawRect$2(c4ShapeElem, rect2);
        break;
      case "system_db":
      case "external_system_db":
      case "container_db":
      case "external_container_db":
      case "component_db":
      case "external_component_db":
        c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
          "d",
          "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2).replaceAll("height", c4Shape.height)
        );
        c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
          "d",
          "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2)
        );
        break;
      case "system_queue":
      case "external_system_queue":
      case "container_queue":
      case "external_container_queue":
      case "component_queue":
      case "external_component_queue":
        c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
          "d",
          "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("width", c4Shape.width).replaceAll("half", c4Shape.height / 2)
        );
        c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
          "d",
          "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", c4Shape.x + c4Shape.width).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.height / 2)
        );
        break;
    }
    let c4ShapeFontConf = getC4ShapeFont(conf2, c4Shape.typeC4Shape.text);
    c4ShapeElem.append("text").attr("fill", fontColor).attr("font-family", c4ShapeFontConf.fontFamily).attr("font-size", c4ShapeFontConf.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", c4Shape.typeC4Shape.width).attr("x", c4Shape.x + c4Shape.width / 2 - c4Shape.typeC4Shape.width / 2).attr("y", c4Shape.y + c4Shape.typeC4Shape.Y).text("<<" + c4Shape.typeC4Shape.text + ">>");
    switch (c4Shape.typeC4Shape.text) {
      case "person":
      case "external_person":
        drawImage$1(
          c4ShapeElem,
          48,
          48,
          c4Shape.x + c4Shape.width / 2 - 24,
          c4Shape.y + c4Shape.image.Y,
          personImg
        );
        break;
    }
    let textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
    textFontConf.fontWeight = "bold";
    textFontConf.fontSize = textFontConf.fontSize + 2;
    textFontConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.label.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.label.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor },
      textFontConf
    );
    textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
    textFontConf.fontColor = fontColor;
    if (c4Shape.thchn && c4Shape.thchn.text !== "") {
      _drawTextCandidateFunc$2(conf2)(
        c4Shape.thchn.text,
        c4ShapeElem,
        c4Shape.x,
        c4Shape.y + c4Shape.thchn.Y,
        c4Shape.width,
        c4Shape.height,
        { fill: fontColor, "font-style": "italic" },
        textFontConf
      );
    } else if (c4Shape.type && c4Shape.type.text !== "") {
      _drawTextCandidateFunc$2(conf2)(
        c4Shape.type.text,
        c4ShapeElem,
        c4Shape.x,
        c4Shape.y + c4Shape.type.Y,
        c4Shape.width,
        c4Shape.height,
        { fill: fontColor, "font-style": "italic" },
        textFontConf
      );
    }
    if (c4Shape.descr && c4Shape.descr.text !== "") {
      textFontConf = conf2.personFont();
      textFontConf.fontColor = fontColor;
      _drawTextCandidateFunc$2(conf2)(
        c4Shape.descr.text,
        c4ShapeElem,
        c4Shape.x,
        c4Shape.y + c4Shape.descr.Y,
        c4Shape.width,
        c4Shape.height,
        { fill: fontColor },
        textFontConf
      );
    }
    return c4Shape.height;
  };
  const insertDatabaseIcon$1 = function(elem) {
    elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
    );
  };
  const insertComputerIcon$1 = function(elem) {
    elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
    );
  };
  const insertClockIcon$1 = function(elem) {
    elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
    );
  };
  const insertArrowHead$1 = function(elem) {
    elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
  };
  const insertArrowEnd = function(elem) {
    elem.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
  };
  const insertArrowFilledHead$1 = function(elem) {
    elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
  };
  const insertDynamicNumber = function(elem) {
    elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
  };
  const insertArrowCrossHead$1 = function(elem) {
    const defs = elem.append("defs");
    const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
    marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
    marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
  };
  const getTextObj$2 = function() {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      anchor: void 0,
      style: "#666",
      width: void 0,
      height: void 0,
      textMargin: 0,
      rx: 0,
      ry: 0,
      tspan: true,
      valign: void 0
    };
  };
  const getNoteRect$2 = function() {
    return {
      x: 0,
      y: 0,
      fill: "#EDF2AE",
      stroke: "#666",
      width: 100,
      anchor: "start",
      height: 100,
      rx: 0,
      ry: 0
    };
  };
  const getC4ShapeFont = (cnf, typeC4Shape) => {
    return {
      fontFamily: cnf[typeC4Shape + "FontFamily"],
      fontSize: cnf[typeC4Shape + "FontSize"],
      fontWeight: cnf[typeC4Shape + "FontWeight"]
    };
  };
  const _drawTextCandidateFunc$2 = function() {
    function byText(content, g, x2, y2, width2, height2, textAttrs) {
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content);
      _setTextAttrs(text2, textAttrs);
    }
    function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const { fontSize, fontFamily, fontWeight } = conf2;
      const lines = content.split(common.lineBreakRegex);
      for (let i = 0; i < lines.length; i++) {
        const dy = i * fontSize - fontSize * (lines.length - 1) / 2;
        const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily);
        text2.append("tspan").attr("dy", dy).text(lines[i]).attr("alignment-baseline", "mathematical");
        _setTextAttrs(text2, textAttrs);
      }
    }
    function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const s2 = g.append("switch");
      const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
      const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
      text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
      byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
      _setTextAttrs(text2, textAttrs);
    }
    function _setTextAttrs(toText, fromTextAttrsDict) {
      for (const key in fromTextAttrsDict) {
        if (fromTextAttrsDict.hasOwnProperty(key)) {
          toText.attr(key, fromTextAttrsDict[key]);
        }
      }
    }
    return function(conf2) {
      return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
    };
  }();
  const svgDraw$3 = {
    drawRect: drawRect$2,
    drawText: drawText$2,
    drawLabel: drawLabel$2,
    drawBoundary: drawBoundary$1,
    drawC4Shape,
    drawRels: drawRels$1,
    drawImage: drawImage$1,
    drawEmbeddedImage: drawEmbeddedImage$1,
    insertArrowHead: insertArrowHead$1,
    insertArrowEnd,
    insertArrowFilledHead: insertArrowFilledHead$1,
    insertDynamicNumber,
    insertArrowCrossHead: insertArrowCrossHead$1,
    insertDatabaseIcon: insertDatabaseIcon$1,
    insertComputerIcon: insertComputerIcon$1,
    insertClockIcon: insertClockIcon$1,
    getTextObj: getTextObj$2,
    getNoteRect: getNoteRect$2,
    sanitizeUrl: sanitizeUrl_1
  };
  let globalBoundaryMaxX = 0, globalBoundaryMaxY = 0;
  let c4ShapeInRow = 4;
  let c4BoundaryInRow = 2;
  parser$a.yy = c4Db;
  let conf$a = {};
  class Bounds {
    constructor(diagObj) {
      this.name = "";
      this.data = {};
      this.data.startx = void 0;
      this.data.stopx = void 0;
      this.data.starty = void 0;
      this.data.stopy = void 0;
      this.data.widthLimit = void 0;
      this.nextData = {};
      this.nextData.startx = void 0;
      this.nextData.stopx = void 0;
      this.nextData.starty = void 0;
      this.nextData.stopy = void 0;
      this.nextData.cnt = 0;
      setConf$a(diagObj.db.getConfig());
    }
    setData(startx, stopx, starty, stopy) {
      this.nextData.startx = this.data.startx = startx;
      this.nextData.stopx = this.data.stopx = stopx;
      this.nextData.starty = this.data.starty = starty;
      this.nextData.stopy = this.data.stopy = stopy;
    }
    updateVal(obj, key, val, fun) {
      if (typeof obj[key] === "undefined") {
        obj[key] = val;
      } else {
        obj[key] = fun(val, obj[key]);
      }
    }
    insert(c4Shape) {
      this.nextData.cnt = this.nextData.cnt + 1;
      let _startx = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + c4Shape.margin : this.nextData.stopx + c4Shape.margin * 2;
      let _stopx = _startx + c4Shape.width;
      let _starty = this.nextData.starty + c4Shape.margin * 2;
      let _stopy = _starty + c4Shape.height;
      if (_startx >= this.data.widthLimit || _stopx >= this.data.widthLimit || this.nextData.cnt > c4ShapeInRow) {
        _startx = this.nextData.startx + c4Shape.margin + conf$a.nextLinePaddingX;
        _starty = this.nextData.stopy + c4Shape.margin * 2;
        this.nextData.stopx = _stopx = _startx + c4Shape.width;
        this.nextData.starty = this.nextData.stopy;
        this.nextData.stopy = _stopy = _starty + c4Shape.height;
        this.nextData.cnt = 1;
      }
      c4Shape.x = _startx;
      c4Shape.y = _starty;
      this.updateVal(this.data, "startx", _startx, Math.min);
      this.updateVal(this.data, "starty", _starty, Math.min);
      this.updateVal(this.data, "stopx", _stopx, Math.max);
      this.updateVal(this.data, "stopy", _stopy, Math.max);
      this.updateVal(this.nextData, "startx", _startx, Math.min);
      this.updateVal(this.nextData, "starty", _starty, Math.min);
      this.updateVal(this.nextData, "stopx", _stopx, Math.max);
      this.updateVal(this.nextData, "stopy", _stopy, Math.max);
    }
    init(diagObj) {
      this.name = "";
      this.data = {
        startx: void 0,
        stopx: void 0,
        starty: void 0,
        stopy: void 0,
        widthLimit: void 0
      };
      this.nextData = {
        startx: void 0,
        stopx: void 0,
        starty: void 0,
        stopy: void 0,
        cnt: 0
      };
      setConf$a(diagObj.db.getConfig());
    }
    bumpLastMargin(margin) {
      this.data.stopx += margin;
      this.data.stopy += margin;
    }
  }
  const setConf$a = function(cnf) {
    assignWithDepth(conf$a, cnf);
    if (cnf.fontFamily) {
      conf$a.personFontFamily = conf$a.systemFontFamily = conf$a.messageFontFamily = cnf.fontFamily;
    }
    if (cnf.fontSize) {
      conf$a.personFontSize = conf$a.systemFontSize = conf$a.messageFontSize = cnf.fontSize;
    }
    if (cnf.fontWeight) {
      conf$a.personFontWeight = conf$a.systemFontWeight = conf$a.messageFontWeight = cnf.fontWeight;
    }
  };
  const c4ShapeFont = (cnf, typeC4Shape) => {
    return {
      fontFamily: cnf[typeC4Shape + "FontFamily"],
      fontSize: cnf[typeC4Shape + "FontSize"],
      fontWeight: cnf[typeC4Shape + "FontWeight"]
    };
  };
  const boundaryFont = (cnf) => {
    return {
      fontFamily: cnf.boundaryFontFamily,
      fontSize: cnf.boundaryFontSize,
      fontWeight: cnf.boundaryFontWeight
    };
  };
  const messageFont$1 = (cnf) => {
    return {
      fontFamily: cnf.messageFontFamily,
      fontSize: cnf.messageFontSize,
      fontWeight: cnf.messageFontWeight
    };
  };
  function calcC4ShapeTextWH(textType, c4Shape, c4ShapeTextWrap, textConf, textLimitWidth) {
    if (!c4Shape[textType].width) {
      if (c4ShapeTextWrap) {
        c4Shape[textType].text = wrapLabel(c4Shape[textType].text, textLimitWidth, textConf);
        c4Shape[textType].textLines = c4Shape[textType].text.split(common.lineBreakRegex).length;
        c4Shape[textType].width = textLimitWidth;
        c4Shape[textType].height = calculateTextHeight(c4Shape[textType].text, textConf);
      } else {
        let lines = c4Shape[textType].text.split(common.lineBreakRegex);
        c4Shape[textType].textLines = lines.length;
        let lineHeight = 0;
        c4Shape[textType].height = 0;
        c4Shape[textType].width = 0;
        for (let i = 0; i < lines.length; i++) {
          c4Shape[textType].width = Math.max(
            calculateTextWidth(lines[i], textConf),
            c4Shape[textType].width
          );
          lineHeight = calculateTextHeight(lines[i], textConf);
          c4Shape[textType].height = c4Shape[textType].height + lineHeight;
        }
      }
    }
  }
  const drawBoundary = function(diagram, boundary, bounds2) {
    boundary.x = bounds2.data.startx;
    boundary.y = bounds2.data.starty;
    boundary.width = bounds2.data.stopx - bounds2.data.startx;
    boundary.height = bounds2.data.stopy - bounds2.data.starty;
    boundary.label.y = conf$a.c4ShapeMargin - 35;
    let boundaryTextWrap = boundary.wrap && conf$a.wrap;
    let boundaryLabelConf = boundaryFont(conf$a);
    boundaryLabelConf.fontSize = boundaryLabelConf.fontSize + 2;
    boundaryLabelConf.fontWeight = "bold";
    let textLimitWidth = calculateTextWidth(boundary.label.text, boundaryLabelConf);
    calcC4ShapeTextWH("label", boundary, boundaryTextWrap, boundaryLabelConf, textLimitWidth);
    svgDraw$3.drawBoundary(diagram, boundary, conf$a);
  };
  const drawC4ShapeArray = function(currentBounds, diagram, c4ShapeArray2, c4ShapeKeys) {
    let Y3 = 0;
    for (let i = 0; i < c4ShapeKeys.length; i++) {
      Y3 = 0;
      const c4Shape = c4ShapeArray2[c4ShapeKeys[i]];
      let c4ShapeTypeConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      c4ShapeTypeConf.fontSize = c4ShapeTypeConf.fontSize - 2;
      c4Shape.typeC4Shape.width = calculateTextWidth(
        "<<" + c4Shape.typeC4Shape.text + ">>",
        c4ShapeTypeConf
      );
      c4Shape.typeC4Shape.height = c4ShapeTypeConf.fontSize + 2;
      c4Shape.typeC4Shape.Y = conf$a.c4ShapePadding;
      Y3 = c4Shape.typeC4Shape.Y + c4Shape.typeC4Shape.height - 4;
      c4Shape.image = { width: 0, height: 0, Y: 0 };
      switch (c4Shape.typeC4Shape.text) {
        case "person":
        case "external_person":
          c4Shape.image.width = 48;
          c4Shape.image.height = 48;
          c4Shape.image.Y = Y3;
          Y3 = c4Shape.image.Y + c4Shape.image.height;
          break;
      }
      if (c4Shape.sprite) {
        c4Shape.image.width = 48;
        c4Shape.image.height = 48;
        c4Shape.image.Y = Y3;
        Y3 = c4Shape.image.Y + c4Shape.image.height;
      }
      let c4ShapeTextWrap = c4Shape.wrap && conf$a.wrap;
      let textLimitWidth = conf$a.width - conf$a.c4ShapePadding * 2;
      let c4ShapeLabelConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      c4ShapeLabelConf.fontSize = c4ShapeLabelConf.fontSize + 2;
      c4ShapeLabelConf.fontWeight = "bold";
      calcC4ShapeTextWH("label", c4Shape, c4ShapeTextWrap, c4ShapeLabelConf, textLimitWidth);
      c4Shape["label"].Y = Y3 + 8;
      Y3 = c4Shape["label"].Y + c4Shape["label"].height;
      if (c4Shape.type && c4Shape.type.text !== "") {
        c4Shape.type.text = "[" + c4Shape.type.text + "]";
        let c4ShapeTypeConf2 = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
        calcC4ShapeTextWH("type", c4Shape, c4ShapeTextWrap, c4ShapeTypeConf2, textLimitWidth);
        c4Shape["type"].Y = Y3 + 5;
        Y3 = c4Shape["type"].Y + c4Shape["type"].height;
      } else if (c4Shape.techn && c4Shape.techn.text !== "") {
        c4Shape.techn.text = "[" + c4Shape.techn.text + "]";
        let c4ShapeTechnConf = c4ShapeFont(conf$a, c4Shape.techn.text);
        calcC4ShapeTextWH("techn", c4Shape, c4ShapeTextWrap, c4ShapeTechnConf, textLimitWidth);
        c4Shape["techn"].Y = Y3 + 5;
        Y3 = c4Shape["techn"].Y + c4Shape["techn"].height;
      }
      let rectHeight = Y3;
      let rectWidth = c4Shape.label.width;
      if (c4Shape.descr && c4Shape.descr.text !== "") {
        let c4ShapeDescrConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
        calcC4ShapeTextWH("descr", c4Shape, c4ShapeTextWrap, c4ShapeDescrConf, textLimitWidth);
        c4Shape["descr"].Y = Y3 + 20;
        Y3 = c4Shape["descr"].Y + c4Shape["descr"].height;
        rectWidth = Math.max(c4Shape.label.width, c4Shape.descr.width);
        rectHeight = Y3 - c4Shape["descr"].textLines * 5;
      }
      rectWidth = rectWidth + conf$a.c4ShapePadding;
      c4Shape.width = Math.max(c4Shape.width || conf$a.width, rectWidth, conf$a.width);
      c4Shape.height = Math.max(c4Shape.height || conf$a.height, rectHeight, conf$a.height);
      c4Shape.margin = c4Shape.margin || conf$a.c4ShapeMargin;
      currentBounds.insert(c4Shape);
      svgDraw$3.drawC4Shape(diagram, c4Shape, conf$a);
    }
    currentBounds.bumpLastMargin(conf$a.c4ShapeMargin);
  };
  class Point {
    constructor(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
  }
  let getIntersectPoint = function(fromNode, endPoint) {
    let x12 = fromNode.x;
    let y12 = fromNode.y;
    let x2 = endPoint.x;
    let y2 = endPoint.y;
    let fromCenterX = x12 + fromNode.width / 2;
    let fromCenterY = y12 + fromNode.height / 2;
    let dx = Math.abs(x12 - x2);
    let dy = Math.abs(y12 - y2);
    let tanDYX = dy / dx;
    let fromDYX = fromNode.height / fromNode.width;
    let returnPoint = null;
    if (y12 == y2 && x12 < x2) {
      returnPoint = new Point(x12 + fromNode.width, fromCenterY);
    } else if (y12 == y2 && x12 > x2) {
      returnPoint = new Point(x12, fromCenterY);
    } else if (x12 == x2 && y12 < y2) {
      returnPoint = new Point(fromCenterX, y12 + fromNode.height);
    } else if (x12 == x2 && y12 > y2) {
      returnPoint = new Point(fromCenterX, y12);
    }
    if (x12 > x2 && y12 < y2) {
      if (fromDYX >= tanDYX) {
        returnPoint = new Point(x12, fromCenterY + tanDYX * fromNode.width / 2);
      } else {
        returnPoint = new Point(
          fromCenterX - dx / dy * fromNode.height / 2,
          y12 + fromNode.height
        );
      }
    } else if (x12 < x2 && y12 < y2) {
      if (fromDYX >= tanDYX) {
        returnPoint = new Point(x12 + fromNode.width, fromCenterY + tanDYX * fromNode.width / 2);
      } else {
        returnPoint = new Point(
          fromCenterX + dx / dy * fromNode.height / 2,
          y12 + fromNode.height
        );
      }
    } else if (x12 < x2 && y12 > y2) {
      if (fromDYX >= tanDYX) {
        returnPoint = new Point(x12 + fromNode.width, fromCenterY - tanDYX * fromNode.width / 2);
      } else {
        returnPoint = new Point(fromCenterX + fromNode.height / 2 * dx / dy, y12);
      }
    } else if (x12 > x2 && y12 > y2) {
      if (fromDYX >= tanDYX) {
        returnPoint = new Point(x12, fromCenterY - fromNode.width / 2 * tanDYX);
      } else {
        returnPoint = new Point(fromCenterX - fromNode.height / 2 * dx / dy, y12);
      }
    }
    return returnPoint;
  };
  let getIntersectPoints = function(fromNode, endNode) {
    let endIntersectPoint = { x: 0, y: 0 };
    endIntersectPoint.x = endNode.x + endNode.width / 2;
    endIntersectPoint.y = endNode.y + endNode.height / 2;
    let startPoint = getIntersectPoint(fromNode, endIntersectPoint);
    endIntersectPoint.x = fromNode.x + fromNode.width / 2;
    endIntersectPoint.y = fromNode.y + fromNode.height / 2;
    let endPoint = getIntersectPoint(endNode, endIntersectPoint);
    return { startPoint, endPoint };
  };
  const drawRels = function(diagram, rels2, getC4ShapeObj, diagObj) {
    let i = 0;
    for (let rel of rels2) {
      i = i + 1;
      let relTextWrap = rel.wrap && conf$a.wrap;
      let relConf = messageFont$1(conf$a);
      let diagramType = diagObj.db.getC4Type();
      if (diagramType === "C4Dynamic")
        rel.label.text = i + ": " + rel.label.text;
      let textLimitWidth = calculateTextWidth(rel.label.text, relConf);
      calcC4ShapeTextWH("label", rel, relTextWrap, relConf, textLimitWidth);
      if (rel.techn && rel.techn.text !== "") {
        textLimitWidth = calculateTextWidth(rel.techn.text, relConf);
        calcC4ShapeTextWH("techn", rel, relTextWrap, relConf, textLimitWidth);
      }
      if (rel.descr && rel.descr.text !== "") {
        textLimitWidth = calculateTextWidth(rel.descr.text, relConf);
        calcC4ShapeTextWH("descr", rel, relTextWrap, relConf, textLimitWidth);
      }
      let fromNode = getC4ShapeObj(rel.from);
      let endNode = getC4ShapeObj(rel.to);
      let points = getIntersectPoints(fromNode, endNode);
      rel.startPoint = points.startPoint;
      rel.endPoint = points.endPoint;
    }
    svgDraw$3.drawRels(diagram, rels2, conf$a);
  };
  function drawInsideBoundary(diagram, parentBoundaryAlias, parentBounds, currentBoundarys, diagObj) {
    let currentBounds = new Bounds(diagObj);
    currentBounds.data.widthLimit = parentBounds.data.widthLimit / Math.min(c4BoundaryInRow, currentBoundarys.length);
    for (let i = 0; i < currentBoundarys.length; i++) {
      let currentBoundary = currentBoundarys[i];
      let Y3 = 0;
      currentBoundary.image = { width: 0, height: 0, Y: 0 };
      if (currentBoundary.sprite) {
        currentBoundary.image.width = 48;
        currentBoundary.image.height = 48;
        currentBoundary.image.Y = Y3;
        Y3 = currentBoundary.image.Y + currentBoundary.image.height;
      }
      let currentBoundaryTextWrap = currentBoundary.wrap && conf$a.wrap;
      let currentBoundaryLabelConf = boundaryFont(conf$a);
      currentBoundaryLabelConf.fontSize = currentBoundaryLabelConf.fontSize + 2;
      currentBoundaryLabelConf.fontWeight = "bold";
      calcC4ShapeTextWH(
        "label",
        currentBoundary,
        currentBoundaryTextWrap,
        currentBoundaryLabelConf,
        currentBounds.data.widthLimit
      );
      currentBoundary["label"].Y = Y3 + 8;
      Y3 = currentBoundary["label"].Y + currentBoundary["label"].height;
      if (currentBoundary.type && currentBoundary.type.text !== "") {
        currentBoundary.type.text = "[" + currentBoundary.type.text + "]";
        let currentBoundaryTypeConf = boundaryFont(conf$a);
        calcC4ShapeTextWH(
          "type",
          currentBoundary,
          currentBoundaryTextWrap,
          currentBoundaryTypeConf,
          currentBounds.data.widthLimit
        );
        currentBoundary["type"].Y = Y3 + 5;
        Y3 = currentBoundary["type"].Y + currentBoundary["type"].height;
      }
      if (currentBoundary.descr && currentBoundary.descr.text !== "") {
        let currentBoundaryDescrConf = boundaryFont(conf$a);
        currentBoundaryDescrConf.fontSize = currentBoundaryDescrConf.fontSize - 2;
        calcC4ShapeTextWH(
          "descr",
          currentBoundary,
          currentBoundaryTextWrap,
          currentBoundaryDescrConf,
          currentBounds.data.widthLimit
        );
        currentBoundary["descr"].Y = Y3 + 20;
        Y3 = currentBoundary["descr"].Y + currentBoundary["descr"].height;
      }
      if (i == 0 || i % c4BoundaryInRow === 0) {
        let _x = parentBounds.data.startx + conf$a.diagramMarginX;
        let _y = parentBounds.data.stopy + conf$a.diagramMarginY + Y3;
        currentBounds.setData(_x, _x, _y, _y);
      } else {
        let _x = currentBounds.data.stopx !== currentBounds.data.startx ? currentBounds.data.stopx + conf$a.diagramMarginX : currentBounds.data.startx;
        let _y = currentBounds.data.starty;
        currentBounds.setData(_x, _x, _y, _y);
      }
      currentBounds.name = currentBoundary.alias;
      let currentPersonOrSystemArray = diagObj.db.getC4ShapeArray(currentBoundary.alias);
      let currentPersonOrSystemKeys = diagObj.db.getC4ShapeKeys(currentBoundary.alias);
      if (currentPersonOrSystemKeys.length > 0) {
        drawC4ShapeArray(
          currentBounds,
          diagram,
          currentPersonOrSystemArray,
          currentPersonOrSystemKeys
        );
      }
      parentBoundaryAlias = currentBoundary.alias;
      let nextCurrentBoundarys = diagObj.db.getBoundarys(parentBoundaryAlias);
      if (nextCurrentBoundarys.length > 0) {
        drawInsideBoundary(
          diagram,
          parentBoundaryAlias,
          currentBounds,
          nextCurrentBoundarys,
          diagObj
        );
      }
      if (currentBoundary.alias !== "global")
        drawBoundary(diagram, currentBoundary, currentBounds);
      parentBounds.data.stopy = Math.max(
        currentBounds.data.stopy + conf$a.c4ShapeMargin,
        parentBounds.data.stopy
      );
      parentBounds.data.stopx = Math.max(
        currentBounds.data.stopx + conf$a.c4ShapeMargin,
        parentBounds.data.stopx
      );
      globalBoundaryMaxX = Math.max(globalBoundaryMaxX, parentBounds.data.stopx);
      globalBoundaryMaxY = Math.max(globalBoundaryMaxY, parentBounds.data.stopy);
    }
  }
  const draw$e = function(_text, id2, _version, diagObj) {
    conf$a = getConfig$1().c4;
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    let db = diagObj.db;
    diagObj.db.setWrap(conf$a.wrap);
    c4ShapeInRow = db.getC4ShapeInRow();
    c4BoundaryInRow = db.getC4BoundaryInRow();
    log$3.debug(`C:${JSON.stringify(conf$a, null, 2)}`);
    const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select(`[id="${id2}"]`);
    svgDraw$3.insertComputerIcon(diagram);
    svgDraw$3.insertDatabaseIcon(diagram);
    svgDraw$3.insertClockIcon(diagram);
    let screenBounds = new Bounds(diagObj);
    screenBounds.setData(
      conf$a.diagramMarginX,
      conf$a.diagramMarginX,
      conf$a.diagramMarginY,
      conf$a.diagramMarginY
    );
    screenBounds.data.widthLimit = screen.availWidth;
    globalBoundaryMaxX = conf$a.diagramMarginX;
    globalBoundaryMaxY = conf$a.diagramMarginY;
    const title2 = diagObj.db.getTitle();
    let currentBoundarys = diagObj.db.getBoundarys("");
    drawInsideBoundary(diagram, "", screenBounds, currentBoundarys, diagObj);
    svgDraw$3.insertArrowHead(diagram);
    svgDraw$3.insertArrowEnd(diagram);
    svgDraw$3.insertArrowCrossHead(diagram);
    svgDraw$3.insertArrowFilledHead(diagram);
    drawRels(diagram, diagObj.db.getRels(), diagObj.db.getC4Shape, diagObj);
    screenBounds.data.stopx = globalBoundaryMaxX;
    screenBounds.data.stopy = globalBoundaryMaxY;
    const box = screenBounds.data;
    let boxHeight = box.stopy - box.starty;
    let height2 = boxHeight + 2 * conf$a.diagramMarginY;
    let boxWidth = box.stopx - box.startx;
    const width2 = boxWidth + 2 * conf$a.diagramMarginX;
    if (title2) {
      diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 4 * conf$a.diagramMarginX).attr("y", box.starty + conf$a.diagramMarginY);
    }
    configureSvgSize(diagram, height2, width2, conf$a.useMaxWidth);
    const extraVertForTitle = title2 ? 60 : 0;
    diagram.attr(
      "viewBox",
      box.startx - conf$a.diagramMarginX + " -" + (conf$a.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
    );
    addSVGAccessibilityFields(parser$a.yy, diagram, id2);
    log$3.debug(`models:`, box);
  };
  const c4Renderer = {
    drawPersonOrSystemArray: drawC4ShapeArray,
    drawBoundary,
    setConf: setConf$a,
    draw: draw$e
  };
  var parser$9 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 3], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 10], $V5 = [1, 13], $V6 = [1, 12], $V7 = [1, 16, 25], $V8 = [1, 20], $V9 = [1, 31], $Va = [1, 32], $Vb = [1, 33], $Vc = [1, 35], $Vd = [1, 38], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 39], $Vh = [1, 40], $Vi = [1, 41], $Vj = [1, 42], $Vk = [1, 45], $Vl = [1, 46], $Vm = [1, 47], $Vn = [1, 48], $Vo = [16, 25], $Vp = [1, 62], $Vq = [1, 63], $Vr = [1, 64], $Vs = [1, 65], $Vt = [1, 66], $Vu = [1, 67], $Vv = [1, 68], $Vw = [16, 25, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], $Vx = [16, 25, 30, 32, 44, 45, 49, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69, 84, 85, 86, 87], $Vy = [5, 8, 9, 10, 11, 16, 19, 23, 25], $Vz = [53, 84, 85, 86, 87], $VA = [53, 61, 62, 84, 85, 86, 87], $VB = [53, 56, 57, 58, 59, 60, 84, 85, 86, 87], $VC = [16, 25, 32], $VD = [1, 100];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "statments": 5, "direction": 6, "directive": 7, "direction_tb": 8, "direction_bt": 9, "direction_rl": 10, "direction_lr": 11, "graphConfig": 12, "openDirective": 13, "typeDirective": 14, "closeDirective": 15, "NEWLINE": 16, ":": 17, "argDirective": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "CLASS_DIAGRAM": 23, "statements": 24, "EOF": 25, "statement": 26, "className": 27, "alphaNumToken": 28, "classLiteralName": 29, "GENERICTYPE": 30, "relationStatement": 31, "LABEL": 32, "classStatement": 33, "methodStatement": 34, "annotationStatement": 35, "clickStatement": 36, "cssClassStatement": 37, "acc_title": 38, "acc_title_value": 39, "acc_descr": 40, "acc_descr_value": 41, "acc_descr_multiline_value": 42, "CLASS": 43, "STYLE_SEPARATOR": 44, "STRUCT_START": 45, "members": 46, "STRUCT_STOP": 47, "ANNOTATION_START": 48, "ANNOTATION_END": 49, "MEMBER": 50, "SEPARATOR": 51, "relation": 52, "STR": 53, "relationType": 54, "lineType": 55, "AGGREGATION": 56, "EXTENSION": 57, "COMPOSITION": 58, "DEPENDENCY": 59, "LOLLIPOP": 60, "LINE": 61, "DOTTED_LINE": 62, "CALLBACK": 63, "LINK": 64, "LINK_TARGET": 65, "CLICK": 66, "CALLBACK_NAME": 67, "CALLBACK_ARGS": 68, "HREF": 69, "CSSCLASS": 70, "commentToken": 71, "textToken": 72, "graphCodeTokens": 73, "textNoTagsToken": 74, "TAGSTART": 75, "TAGEND": 76, "==": 77, "--": 78, "PCT": 79, "DEFAULT": 80, "SPACE": 81, "MINUS": 82, "keywords": 83, "UNICODE_TEXT": 84, "NUM": 85, "ALPHA": 86, "BQUOTE_STR": 87, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 5: "statments", 8: "direction_tb", 9: "direction_bt", 10: "direction_rl", 11: "direction_lr", 16: "NEWLINE", 17: ":", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 23: "CLASS_DIAGRAM", 25: "EOF", 30: "GENERICTYPE", 32: "LABEL", 38: "acc_title", 39: "acc_title_value", 40: "acc_descr", 41: "acc_descr_value", 42: "acc_descr_multiline_value", 43: "CLASS", 44: "STYLE_SEPARATOR", 45: "STRUCT_START", 47: "STRUCT_STOP", 48: "ANNOTATION_START", 49: "ANNOTATION_END", 50: "MEMBER", 51: "SEPARATOR", 53: "STR", 56: "AGGREGATION", 57: "EXTENSION", 58: "COMPOSITION", 59: "DEPENDENCY", 60: "LOLLIPOP", 61: "LINE", 62: "DOTTED_LINE", 63: "CALLBACK", 64: "LINK", 65: "LINK_TARGET", 66: "CLICK", 67: "CALLBACK_NAME", 68: "CALLBACK_ARGS", 69: "HREF", 70: "CSSCLASS", 73: "graphCodeTokens", 75: "TAGSTART", 76: "TAGEND", 77: "==", 78: "--", 79: "PCT", 80: "DEFAULT", 81: "SPACE", 82: "MINUS", 83: "keywords", 84: "UNICODE_TEXT", 85: "NUM", 86: "ALPHA", 87: "BQUOTE_STR" },
      productions_: [0, [3, 1], [3, 1], [3, 1], [3, 2], [6, 1], [6, 1], [6, 1], [6, 1], [4, 1], [7, 4], [7, 6], [13, 1], [14, 1], [18, 1], [15, 1], [12, 4], [24, 1], [24, 2], [24, 3], [27, 1], [27, 1], [27, 2], [27, 2], [27, 2], [26, 1], [26, 2], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 2], [26, 2], [26, 1], [33, 2], [33, 4], [33, 5], [33, 7], [35, 4], [46, 1], [46, 2], [34, 1], [34, 2], [34, 1], [34, 1], [31, 3], [31, 4], [31, 4], [31, 5], [52, 3], [52, 2], [52, 2], [52, 1], [54, 1], [54, 1], [54, 1], [54, 1], [54, 1], [55, 1], [55, 1], [36, 3], [36, 4], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [37, 3], [71, 1], [71, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [74, 1], [74, 1], [74, 1], [74, 1], [28, 1], [28, 1], [28, 1], [29, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 5:
            yy.setDirection("TB");
            break;
          case 6:
            yy.setDirection("BT");
            break;
          case 7:
            yy.setDirection("RL");
            break;
          case 8:
            yy.setDirection("LR");
            break;
          case 12:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 13:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 14:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 15:
            yy.parseDirective("}%%", "close_directive", "class");
            break;
          case 20:
          case 21:
            this.$ = $$[$0];
            break;
          case 22:
            this.$ = $$[$0 - 1] + $$[$0];
            break;
          case 23:
          case 24:
            this.$ = $$[$0 - 1] + "~" + $$[$0];
            break;
          case 25:
            yy.addRelation($$[$0]);
            break;
          case 26:
            $$[$0 - 1].title = yy.cleanupLabel($$[$0]);
            yy.addRelation($$[$0 - 1]);
            break;
          case 34:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 35:
          case 36:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 37:
            yy.addClass($$[$0]);
            break;
          case 38:
            yy.addClass($$[$0 - 2]);
            yy.setCssClass($$[$0 - 2], $$[$0]);
            break;
          case 39:
            yy.addClass($$[$0 - 3]);
            yy.addMembers($$[$0 - 3], $$[$0 - 1]);
            break;
          case 40:
            yy.addClass($$[$0 - 5]);
            yy.setCssClass($$[$0 - 5], $$[$0 - 3]);
            yy.addMembers($$[$0 - 5], $$[$0 - 1]);
            break;
          case 41:
            yy.addAnnotation($$[$0], $$[$0 - 2]);
            break;
          case 42:
            this.$ = [$$[$0]];
            break;
          case 43:
            $$[$0].push($$[$0 - 1]);
            this.$ = $$[$0];
            break;
          case 44:
            break;
          case 45:
            yy.addMember($$[$0 - 1], yy.cleanupLabel($$[$0]));
            break;
          case 46:
            break;
          case 47:
            break;
          case 48:
            this.$ = { "id1": $$[$0 - 2], "id2": $$[$0], relation: $$[$0 - 1], relationTitle1: "none", relationTitle2: "none" };
            break;
          case 49:
            this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 1], relationTitle1: $$[$0 - 2], relationTitle2: "none" };
            break;
          case 50:
            this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: "none", relationTitle2: $$[$0 - 1] };
            break;
          case 51:
            this.$ = { id1: $$[$0 - 4], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: $$[$0 - 3], relationTitle2: $$[$0 - 1] };
            break;
          case 52:
            this.$ = { type1: $$[$0 - 2], type2: $$[$0], lineType: $$[$0 - 1] };
            break;
          case 53:
            this.$ = { type1: "none", type2: $$[$0], lineType: $$[$0 - 1] };
            break;
          case 54:
            this.$ = { type1: $$[$0 - 1], type2: "none", lineType: $$[$0] };
            break;
          case 55:
            this.$ = { type1: "none", type2: "none", lineType: $$[$0] };
            break;
          case 56:
            this.$ = yy.relationType.AGGREGATION;
            break;
          case 57:
            this.$ = yy.relationType.EXTENSION;
            break;
          case 58:
            this.$ = yy.relationType.COMPOSITION;
            break;
          case 59:
            this.$ = yy.relationType.DEPENDENCY;
            break;
          case 60:
            this.$ = yy.relationType.LOLLIPOP;
            break;
          case 61:
            this.$ = yy.lineType.LINE;
            break;
          case 62:
            this.$ = yy.lineType.DOTTED_LINE;
            break;
          case 63:
          case 69:
            this.$ = $$[$0 - 2];
            yy.setClickEvent($$[$0 - 1], $$[$0]);
            break;
          case 64:
          case 70:
            this.$ = $$[$0 - 3];
            yy.setClickEvent($$[$0 - 2], $$[$0 - 1]);
            yy.setTooltip($$[$0 - 2], $$[$0]);
            break;
          case 65:
          case 73:
            this.$ = $$[$0 - 2];
            yy.setLink($$[$0 - 1], $$[$0]);
            break;
          case 66:
            this.$ = $$[$0 - 3];
            yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break;
          case 67:
          case 75:
            this.$ = $$[$0 - 3];
            yy.setLink($$[$0 - 2], $$[$0 - 1]);
            yy.setTooltip($$[$0 - 2], $$[$0]);
            break;
          case 68:
          case 76:
            this.$ = $$[$0 - 4];
            yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
            yy.setTooltip($$[$0 - 3], $$[$0 - 1]);
            break;
          case 71:
            this.$ = $$[$0 - 3];
            yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break;
          case 72:
            this.$ = $$[$0 - 4];
            yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
            yy.setTooltip($$[$0 - 3], $$[$0]);
            break;
          case 74:
            this.$ = $$[$0 - 3];
            yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break;
          case 77:
            yy.setCssClass($$[$0 - 1], $$[$0]);
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 3: 14, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [2, 9] }, o($V7, [2, 5]), o($V7, [2, 6]), o($V7, [2, 7]), o($V7, [2, 8]), { 14: 15, 20: [1, 16] }, { 16: [1, 17] }, { 20: [2, 12] }, { 1: [2, 4] }, { 15: 18, 17: [1, 19], 22: $V8 }, o([17, 22], [2, 13]), { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 21, 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 16: [1, 49] }, { 18: 50, 21: [1, 51] }, { 16: [2, 15] }, { 25: [1, 52] }, { 16: [1, 53], 25: [2, 17] }, o($Vo, [2, 25], { 32: [1, 54] }), o($Vo, [2, 27]), o($Vo, [2, 28]), o($Vo, [2, 29]), o($Vo, [2, 30]), o($Vo, [2, 31]), o($Vo, [2, 32]), o($Vo, [2, 33]), { 39: [1, 55] }, { 41: [1, 56] }, o($Vo, [2, 36]), o($Vo, [2, 44], { 52: 57, 54: 60, 55: 61, 32: [1, 59], 53: [1, 58], 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }), { 27: 69, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 46]), o($Vo, [2, 47]), { 28: 70, 84: $Vk, 85: $Vl, 86: $Vm }, { 27: 71, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 72, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 73, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 53: [1, 74] }, o($Vw, [2, 20], { 28: 43, 29: 44, 27: 75, 30: [1, 76], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }), o($Vw, [2, 21], { 30: [1, 77] }), o($Vx, [2, 91]), o($Vx, [2, 92]), o($Vx, [2, 93]), o([16, 25, 30, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], [2, 94]), o($Vy, [2, 10]), { 15: 78, 22: $V8 }, { 22: [2, 14] }, { 1: [2, 16] }, { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 79, 25: [2, 18], 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 26]), o($Vo, [2, 34]), o($Vo, [2, 35]), { 27: 80, 28: 43, 29: 44, 53: [1, 81], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 52: 82, 54: 60, 55: 61, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }, o($Vo, [2, 45]), { 55: 83, 61: $Vu, 62: $Vv }, o($Vz, [2, 55], { 54: 84, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($VA, [2, 56]), o($VA, [2, 57]), o($VA, [2, 58]), o($VA, [2, 59]), o($VA, [2, 60]), o($VB, [2, 61]), o($VB, [2, 62]), o($Vo, [2, 37], { 44: [1, 85], 45: [1, 86] }), { 49: [1, 87] }, { 53: [1, 88] }, { 53: [1, 89] }, { 67: [1, 90], 69: [1, 91] }, { 28: 92, 84: $Vk, 85: $Vl, 86: $Vm }, o($Vw, [2, 22]), o($Vw, [2, 23]), o($Vw, [2, 24]), { 16: [1, 93] }, { 25: [2, 19] }, o($VC, [2, 48]), { 27: 94, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 95, 28: 43, 29: 44, 53: [1, 96], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 54], { 54: 97, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($Vz, [2, 53]), { 28: 98, 84: $Vk, 85: $Vl, 86: $Vm }, { 46: 99, 50: $VD }, { 27: 101, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 63], { 53: [1, 102] }), o($Vo, [2, 65], { 53: [1, 104], 65: [1, 103] }), o($Vo, [2, 69], { 53: [1, 105], 68: [1, 106] }), o($Vo, [2, 73], { 53: [1, 108], 65: [1, 107] }), o($Vo, [2, 77]), o($Vy, [2, 11]), o($VC, [2, 50]), o($VC, [2, 49]), { 27: 109, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 52]), o($Vo, [2, 38], { 45: [1, 110] }), { 47: [1, 111] }, { 46: 112, 47: [2, 42], 50: $VD }, o($Vo, [2, 41]), o($Vo, [2, 64]), o($Vo, [2, 66]), o($Vo, [2, 67], { 65: [1, 113] }), o($Vo, [2, 70]), o($Vo, [2, 71], { 53: [1, 114] }), o($Vo, [2, 74]), o($Vo, [2, 75], { 65: [1, 115] }), o($VC, [2, 51]), { 46: 116, 50: $VD }, o($Vo, [2, 39]), { 47: [2, 43] }, o($Vo, [2, 68]), o($Vo, [2, 72]), o($Vo, [2, 76]), { 47: [1, 117] }, o($Vo, [2, 40])],
      defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 6: [2, 9], 13: [2, 12], 14: [2, 4], 20: [2, 15], 51: [2, 14], 52: [2, 16], 79: [2, 19], 112: [2, 43] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 19;
            case 1:
              return 8;
            case 2:
              return 9;
            case 3:
              return 10;
            case 4:
              return 11;
            case 5:
              this.begin("type_directive");
              return 20;
            case 6:
              this.popState();
              this.begin("arg_directive");
              return 17;
            case 7:
              this.popState();
              this.popState();
              return 22;
            case 8:
              return 21;
            case 9:
              break;
            case 10:
              break;
            case 11:
              this.begin("acc_title");
              return 38;
            case 12:
              this.popState();
              return "acc_title_value";
            case 13:
              this.begin("acc_descr");
              return 40;
            case 14:
              this.popState();
              return "acc_descr_value";
            case 15:
              this.begin("acc_descr_multiline");
              break;
            case 16:
              this.popState();
              break;
            case 17:
              return "acc_descr_multiline_value";
            case 18:
              return 16;
            case 19:
              break;
            case 20:
              return 23;
            case 21:
              return 23;
            case 22:
              this.begin("struct");
              return 45;
            case 23:
              return "EDGE_STATE";
            case 24:
              return "EOF_IN_STRUCT";
            case 25:
              return "OPEN_IN_STRUCT";
            case 26:
              this.popState();
              return 47;
            case 27:
              break;
            case 28:
              return "MEMBER";
            case 29:
              return 43;
            case 30:
              return 70;
            case 31:
              return 63;
            case 32:
              return 64;
            case 33:
              return 66;
            case 34:
              return 48;
            case 35:
              return 49;
            case 36:
              this.begin("generic");
              break;
            case 37:
              this.popState();
              break;
            case 38:
              return "GENERICTYPE";
            case 39:
              this.begin("string");
              break;
            case 40:
              this.popState();
              break;
            case 41:
              return "STR";
            case 42:
              this.begin("bqstring");
              break;
            case 43:
              this.popState();
              break;
            case 44:
              return "BQUOTE_STR";
            case 45:
              this.begin("href");
              break;
            case 46:
              this.popState();
              break;
            case 47:
              return 69;
            case 48:
              this.begin("callback_name");
              break;
            case 49:
              this.popState();
              break;
            case 50:
              this.popState();
              this.begin("callback_args");
              break;
            case 51:
              return 67;
            case 52:
              this.popState();
              break;
            case 53:
              return 68;
            case 54:
              return 65;
            case 55:
              return 65;
            case 56:
              return 65;
            case 57:
              return 65;
            case 58:
              return 57;
            case 59:
              return 57;
            case 60:
              return 59;
            case 61:
              return 59;
            case 62:
              return 58;
            case 63:
              return 56;
            case 64:
              return 60;
            case 65:
              return 61;
            case 66:
              return 62;
            case 67:
              return 32;
            case 68:
              return 44;
            case 69:
              return 82;
            case 70:
              return "DOT";
            case 71:
              return "PLUS";
            case 72:
              return 79;
            case 73:
              return "EQUALS";
            case 74:
              return "EQUALS";
            case 75:
              return 86;
            case 76:
              return "PUNCTUATION";
            case 77:
              return 85;
            case 78:
              return 84;
            case 79:
              return 81;
            case 80:
              return 25;
          }
        },
        rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:[{])/, /^(?:\[\*\])/, /^(?:$)/, /^(?:[{])/, /^(?:[}])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:class\b)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:[~])/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[`])/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:$)/],
        conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "callback_args": { "rules": [52, 53], "inclusive": false }, "callback_name": { "rules": [49, 50, 51], "inclusive": false }, "href": { "rules": [46, 47], "inclusive": false }, "struct": { "rules": [23, 24, 25, 26, 27, 28], "inclusive": false }, "generic": { "rules": [37, 38], "inclusive": false }, "bqstring": { "rules": [43, 44], "inclusive": false }, "string": { "rules": [40, 41], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 29, 30, 31, 32, 33, 34, 35, 36, 39, 42, 45, 48, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$9.parser = parser$9;
  const classDetector = (txt, config2) => {
    var _a;
    if (((_a = config2 == null ? void 0 : config2.class) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
      return false;
    return txt.match(/^\s*classDiagram/) !== null;
  };
  const classDetectorV2 = (txt, config2) => {
    var _a;
    if (txt.match(/^\s*classDiagram/) !== null && ((_a = config2 == null ? void 0 : config2.class) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
      return true;
    return txt.match(/^\s*classDiagram-v2/) !== null;
  };
  const MERMAID_DOM_ID_PREFIX$1 = "classid-";
  let relations$1 = [];
  let classes$2 = {};
  let classCounter = 0;
  let funs$2 = [];
  const sanitizeText$2 = (txt) => common.sanitizeText(txt, getConfig$1());
  const parseDirective$9 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const splitClassNameAndType = function(id2) {
    let genericType = "";
    let className = id2;
    if (id2.indexOf("~") > 0) {
      let split = id2.split("~");
      className = split[0];
      genericType = common.sanitizeText(split[1], getConfig$1());
    }
    return { className, type: genericType };
  };
  const addClass$1 = function(id2) {
    let classId = splitClassNameAndType(id2);
    if (typeof classes$2[classId.className] !== "undefined")
      return;
    classes$2[classId.className] = {
      id: classId.className,
      type: classId.type,
      cssClasses: [],
      methods: [],
      members: [],
      annotations: [],
      domId: MERMAID_DOM_ID_PREFIX$1 + classId.className + "-" + classCounter
    };
    classCounter++;
  };
  const lookUpDomId$1 = function(id2) {
    const classKeys = Object.keys(classes$2);
    for (let i = 0; i < classKeys.length; i++) {
      if (classes$2[classKeys[i]].id === id2) {
        return classes$2[classKeys[i]].domId;
      }
    }
  };
  const clear$c = function() {
    relations$1 = [];
    classes$2 = {};
    funs$2 = [];
    funs$2.push(setupToolTips$1);
    clear$g();
  };
  const getClass = function(id2) {
    return classes$2[id2];
  };
  const getClasses$5 = function() {
    return classes$2;
  };
  const getRelations$1 = function() {
    return relations$1;
  };
  const addRelation$1 = function(relation) {
    log$3.debug("Adding relation: " + JSON.stringify(relation));
    addClass$1(relation.id1);
    addClass$1(relation.id2);
    relation.id1 = splitClassNameAndType(relation.id1).className;
    relation.id2 = splitClassNameAndType(relation.id2).className;
    relation.relationTitle1 = common.sanitizeText(
      relation.relationTitle1.trim(),
      getConfig$1()
    );
    relation.relationTitle2 = common.sanitizeText(
      relation.relationTitle2.trim(),
      getConfig$1()
    );
    relations$1.push(relation);
  };
  const addAnnotation = function(className, annotation) {
    const validatedClassName = splitClassNameAndType(className).className;
    classes$2[validatedClassName].annotations.push(annotation);
  };
  const addMember = function(className, member) {
    const validatedClassName = splitClassNameAndType(className).className;
    const theClass = classes$2[validatedClassName];
    if (typeof member === "string") {
      const memberString = member.trim();
      if (memberString.startsWith("<<") && memberString.endsWith(">>")) {
        theClass.annotations.push(sanitizeText$2(memberString.substring(2, memberString.length - 2)));
      } else if (memberString.indexOf(")") > 0) {
        theClass.methods.push(sanitizeText$2(memberString));
      } else if (memberString) {
        theClass.members.push(sanitizeText$2(memberString));
      }
    }
  };
  const addMembers = function(className, members) {
    if (Array.isArray(members)) {
      members.reverse();
      members.forEach((member) => addMember(className, member));
    }
  };
  const cleanupLabel$1 = function(label) {
    if (label.substring(0, 1) === ":") {
      return common.sanitizeText(label.substr(1).trim(), getConfig$1());
    } else {
      return sanitizeText$2(label.trim());
    }
  };
  const setCssClass = function(ids, className) {
    ids.split(",").forEach(function(_id) {
      let id2 = _id;
      if (_id[0].match(/\d/))
        id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
      if (typeof classes$2[id2] !== "undefined") {
        classes$2[id2].cssClasses.push(className);
      }
    });
  };
  const setTooltip$1 = function(ids, tooltip) {
    const config2 = getConfig$1();
    ids.split(",").forEach(function(id2) {
      if (typeof tooltip !== "undefined") {
        classes$2[id2].tooltip = common.sanitizeText(tooltip, config2);
      }
    });
  };
  const getTooltip$1 = function(id2) {
    return classes$2[id2].tooltip;
  };
  const setLink$2 = function(ids, linkStr, target) {
    const config2 = getConfig$1();
    ids.split(",").forEach(function(_id) {
      let id2 = _id;
      if (_id[0].match(/\d/))
        id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
      if (typeof classes$2[id2] !== "undefined") {
        classes$2[id2].link = utils.formatUrl(linkStr, config2);
        if (config2.securityLevel === "sandbox") {
          classes$2[id2].linkTarget = "_top";
        } else if (typeof target === "string") {
          classes$2[id2].linkTarget = sanitizeText$2(target);
        } else {
          classes$2[id2].linkTarget = "_blank";
        }
      }
    });
    setCssClass(ids, "clickable");
  };
  const setClickEvent$2 = function(ids, functionName, functionArgs) {
    ids.split(",").forEach(function(id2) {
      setClickFunc(id2, functionName, functionArgs);
      classes$2[id2].haveCallback = true;
    });
    setCssClass(ids, "clickable");
  };
  const setClickFunc = function(domId, functionName, functionArgs) {
    const config2 = getConfig$1();
    let id2 = domId;
    let elemId = lookUpDomId$1(id2);
    if (config2.securityLevel !== "loose") {
      return;
    }
    if (typeof functionName === "undefined") {
      return;
    }
    if (typeof classes$2[id2] !== "undefined") {
      let argList = [];
      if (typeof functionArgs === "string") {
        argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
        for (let i = 0; i < argList.length; i++) {
          let item = argList[i].trim();
          if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
            item = item.substr(1, item.length - 2);
          }
          argList[i] = item;
        }
      }
      if (argList.length === 0) {
        argList.push(elemId);
      }
      funs$2.push(function() {
        const elem = document.querySelector(`[id="${elemId}"]`);
        if (elem !== null) {
          elem.addEventListener(
            "click",
            function() {
              utils.runFunc(functionName, ...argList);
            },
            false
          );
        }
      });
    }
  };
  const bindFunctions$2 = function(element) {
    funs$2.forEach(function(fun) {
      fun(element);
    });
  };
  const lineType$1 = {
    LINE: 0,
    DOTTED_LINE: 1
  };
  const relationType$1 = {
    AGGREGATION: 0,
    EXTENSION: 1,
    COMPOSITION: 2,
    DEPENDENCY: 3,
    LOLLIPOP: 4
  };
  const setupToolTips$1 = function(element) {
    let tooltipElem = select(".mermaidTooltip");
    if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
      tooltipElem = select("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
    }
    const svg2 = select(element).select("svg");
    const nodes = svg2.selectAll("g.node");
    nodes.on("mouseover", function() {
      const el = select(this);
      const title2 = el.attr("title");
      if (title2 === null) {
        return;
      }
      const rect2 = this.getBoundingClientRect();
      tooltipElem.transition().duration(200).style("opacity", ".9");
      tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
      tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
      el.classed("hover", true);
    }).on("mouseout", function() {
      tooltipElem.transition().duration(500).style("opacity", 0);
      const el = select(this);
      el.classed("hover", false);
    });
  };
  funs$2.push(setupToolTips$1);
  let direction$2 = "TB";
  const getDirection$2 = () => direction$2;
  const setDirection$2 = (dir) => {
    direction$2 = dir;
  };
  const classDb = {
    parseDirective: parseDirective$9,
    setAccTitle,
    getAccTitle,
    getAccDescription,
    setAccDescription,
    getConfig: () => getConfig$1().class,
    addClass: addClass$1,
    bindFunctions: bindFunctions$2,
    clear: clear$c,
    getClass,
    getClasses: getClasses$5,
    addAnnotation,
    getRelations: getRelations$1,
    addRelation: addRelation$1,
    getDirection: getDirection$2,
    setDirection: setDirection$2,
    addMember,
    addMembers,
    cleanupLabel: cleanupLabel$1,
    lineType: lineType$1,
    relationType: relationType$1,
    setClickEvent: setClickEvent$2,
    setCssClass,
    setLink: setLink$2,
    getTooltip: getTooltip$1,
    setTooltip: setTooltip$1,
    lookUpDomId: lookUpDomId$1
  };
  var _stackClear;
  var hasRequired_stackClear;
  function require_stackClear() {
    if (hasRequired_stackClear)
      return _stackClear;
    hasRequired_stackClear = 1;
    var ListCache2 = _ListCache;
    function stackClear() {
      this.__data__ = new ListCache2();
      this.size = 0;
    }
    _stackClear = stackClear;
    return _stackClear;
  }
  var _stackDelete;
  var hasRequired_stackDelete;
  function require_stackDelete() {
    if (hasRequired_stackDelete)
      return _stackDelete;
    hasRequired_stackDelete = 1;
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    _stackDelete = stackDelete;
    return _stackDelete;
  }
  var _stackGet;
  var hasRequired_stackGet;
  function require_stackGet() {
    if (hasRequired_stackGet)
      return _stackGet;
    hasRequired_stackGet = 1;
    function stackGet(key) {
      return this.__data__.get(key);
    }
    _stackGet = stackGet;
    return _stackGet;
  }
  var _stackHas;
  var hasRequired_stackHas;
  function require_stackHas() {
    if (hasRequired_stackHas)
      return _stackHas;
    hasRequired_stackHas = 1;
    function stackHas(key) {
      return this.__data__.has(key);
    }
    _stackHas = stackHas;
    return _stackHas;
  }
  var _stackSet;
  var hasRequired_stackSet;
  function require_stackSet() {
    if (hasRequired_stackSet)
      return _stackSet;
    hasRequired_stackSet = 1;
    var ListCache2 = _ListCache, Map2 = _Map, MapCache2 = _MapCache;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache2) {
        var pairs2 = data.__data__;
        if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
          pairs2.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache2(pairs2);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    _stackSet = stackSet;
    return _stackSet;
  }
  var _Stack;
  var hasRequired_Stack;
  function require_Stack() {
    if (hasRequired_Stack)
      return _Stack;
    hasRequired_Stack = 1;
    var ListCache2 = _ListCache, stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
    function Stack(entries) {
      var data = this.__data__ = new ListCache2(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    _Stack = Stack;
    return _Stack;
  }
  var _arrayEach;
  var hasRequired_arrayEach;
  function require_arrayEach() {
    if (hasRequired_arrayEach)
      return _arrayEach;
    hasRequired_arrayEach = 1;
    function arrayEach(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    _arrayEach = arrayEach;
    return _arrayEach;
  }
  var _defineProperty;
  var hasRequired_defineProperty;
  function require_defineProperty() {
    if (hasRequired_defineProperty)
      return _defineProperty;
    hasRequired_defineProperty = 1;
    var getNative2 = _getNative;
    var defineProperty = function() {
      try {
        var func = getNative2(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    _defineProperty = defineProperty;
    return _defineProperty;
  }
  var _baseAssignValue;
  var hasRequired_baseAssignValue;
  function require_baseAssignValue() {
    if (hasRequired_baseAssignValue)
      return _baseAssignValue;
    hasRequired_baseAssignValue = 1;
    var defineProperty = require_defineProperty();
    function baseAssignValue(object2, key, value) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    _baseAssignValue = baseAssignValue;
    return _baseAssignValue;
  }
  var _assignValue;
  var hasRequired_assignValue;
  function require_assignValue() {
    if (hasRequired_assignValue)
      return _assignValue;
    hasRequired_assignValue = 1;
    var baseAssignValue = require_baseAssignValue(), eq2 = eq_1;
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function assignValue(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    _assignValue = assignValue;
    return _assignValue;
  }
  var _copyObject;
  var hasRequired_copyObject;
  function require_copyObject() {
    if (hasRequired_copyObject)
      return _copyObject;
    hasRequired_copyObject = 1;
    var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
    function copyObject(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length2 = props.length;
      while (++index2 < length2) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object2, key, newValue);
        } else {
          assignValue(object2, key, newValue);
        }
      }
      return object2;
    }
    _copyObject = copyObject;
    return _copyObject;
  }
  var _baseTimes;
  var hasRequired_baseTimes;
  function require_baseTimes() {
    if (hasRequired_baseTimes)
      return _baseTimes;
    hasRequired_baseTimes = 1;
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    _baseTimes = baseTimes;
    return _baseTimes;
  }
  var isObjectLike_1;
  var hasRequiredIsObjectLike;
  function requireIsObjectLike() {
    if (hasRequiredIsObjectLike)
      return isObjectLike_1;
    hasRequiredIsObjectLike = 1;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    isObjectLike_1 = isObjectLike;
    return isObjectLike_1;
  }
  var _baseIsArguments;
  var hasRequired_baseIsArguments;
  function require_baseIsArguments() {
    if (hasRequired_baseIsArguments)
      return _baseIsArguments;
    hasRequired_baseIsArguments = 1;
    var baseGetTag2 = _baseGetTag, isObjectLike = requireIsObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag2(value) == argsTag;
    }
    _baseIsArguments = baseIsArguments;
    return _baseIsArguments;
  }
  var isArguments_1;
  var hasRequiredIsArguments;
  function requireIsArguments() {
    if (hasRequiredIsArguments)
      return isArguments_1;
    hasRequiredIsArguments = 1;
    var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    isArguments_1 = isArguments;
    return isArguments_1;
  }
  var isArray_1;
  var hasRequiredIsArray;
  function requireIsArray() {
    if (hasRequiredIsArray)
      return isArray_1;
    hasRequiredIsArray = 1;
    var isArray = Array.isArray;
    isArray_1 = isArray;
    return isArray_1;
  }
  var isBuffer = { exports: {} };
  var stubFalse_1;
  var hasRequiredStubFalse;
  function requireStubFalse() {
    if (hasRequiredStubFalse)
      return stubFalse_1;
    hasRequiredStubFalse = 1;
    function stubFalse() {
      return false;
    }
    stubFalse_1 = stubFalse;
    return stubFalse_1;
  }
  var hasRequiredIsBuffer;
  function requireIsBuffer() {
    if (hasRequiredIsBuffer)
      return isBuffer.exports;
    hasRequiredIsBuffer = 1;
    (function(module3, exports2) {
      var root2 = _root, stubFalse = requireStubFalse();
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer2 = nativeIsBuffer || stubFalse;
      module3.exports = isBuffer2;
    })(isBuffer, isBuffer.exports);
    return isBuffer.exports;
  }
  var _isIndex;
  var hasRequired_isIndex;
  function require_isIndex() {
    if (hasRequired_isIndex)
      return _isIndex;
    hasRequired_isIndex = 1;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length2) {
      var type2 = typeof value;
      length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
      return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
    }
    _isIndex = isIndex;
    return _isIndex;
  }
  var isLength_1;
  var hasRequiredIsLength;
  function requireIsLength() {
    if (hasRequiredIsLength)
      return isLength_1;
    hasRequiredIsLength = 1;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    isLength_1 = isLength;
    return isLength_1;
  }
  var _baseIsTypedArray;
  var hasRequired_baseIsTypedArray;
  function require_baseIsTypedArray() {
    if (hasRequired_baseIsTypedArray)
      return _baseIsTypedArray;
    hasRequired_baseIsTypedArray = 1;
    var baseGetTag2 = _baseGetTag, isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag2(value)];
    }
    _baseIsTypedArray = baseIsTypedArray;
    return _baseIsTypedArray;
  }
  var _baseUnary;
  var hasRequired_baseUnary;
  function require_baseUnary() {
    if (hasRequired_baseUnary)
      return _baseUnary;
    hasRequired_baseUnary = 1;
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    _baseUnary = baseUnary;
    return _baseUnary;
  }
  var _nodeUtil = { exports: {} };
  var hasRequired_nodeUtil;
  function require_nodeUtil() {
    if (hasRequired_nodeUtil)
      return _nodeUtil.exports;
    hasRequired_nodeUtil = 1;
    (function(module3, exports2) {
      var freeGlobal2 = _freeGlobal;
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal2.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module3.exports = nodeUtil;
    })(_nodeUtil, _nodeUtil.exports);
    return _nodeUtil.exports;
  }
  var isTypedArray_1;
  var hasRequiredIsTypedArray;
  function requireIsTypedArray() {
    if (hasRequiredIsTypedArray)
      return isTypedArray_1;
    hasRequiredIsTypedArray = 1;
    var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    isTypedArray_1 = isTypedArray;
    return isTypedArray_1;
  }
  var _arrayLikeKeys;
  var hasRequired_arrayLikeKeys;
  function require_arrayLikeKeys() {
    if (hasRequired_arrayLikeKeys)
      return _arrayLikeKeys;
    hasRequired_arrayLikeKeys = 1;
    var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
          result.push(key);
        }
      }
      return result;
    }
    _arrayLikeKeys = arrayLikeKeys;
    return _arrayLikeKeys;
  }
  var _isPrototype;
  var hasRequired_isPrototype;
  function require_isPrototype() {
    if (hasRequired_isPrototype)
      return _isPrototype;
    hasRequired_isPrototype = 1;
    var objectProto2 = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
      return value === proto;
    }
    _isPrototype = isPrototype;
    return _isPrototype;
  }
  var _overArg;
  var hasRequired_overArg;
  function require_overArg() {
    if (hasRequired_overArg)
      return _overArg;
    hasRequired_overArg = 1;
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    _overArg = overArg;
    return _overArg;
  }
  var _nativeKeys;
  var hasRequired_nativeKeys;
  function require_nativeKeys() {
    if (hasRequired_nativeKeys)
      return _nativeKeys;
    hasRequired_nativeKeys = 1;
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    _nativeKeys = nativeKeys;
    return _nativeKeys;
  }
  var _baseKeys;
  var hasRequired_baseKeys;
  function require_baseKeys() {
    if (hasRequired_baseKeys)
      return _baseKeys;
    hasRequired_baseKeys = 1;
    var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    _baseKeys = baseKeys;
    return _baseKeys;
  }
  var isArrayLike_1;
  var hasRequiredIsArrayLike;
  function requireIsArrayLike() {
    if (hasRequiredIsArrayLike)
      return isArrayLike_1;
    hasRequiredIsArrayLike = 1;
    var isFunction2 = isFunction_1, isLength = requireIsLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    isArrayLike_1 = isArrayLike;
    return isArrayLike_1;
  }
  var keys_1;
  var hasRequiredKeys;
  function requireKeys() {
    if (hasRequiredKeys)
      return keys_1;
    hasRequiredKeys = 1;
    var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
    function keys(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    keys_1 = keys;
    return keys_1;
  }
  var _baseAssign;
  var hasRequired_baseAssign;
  function require_baseAssign() {
    if (hasRequired_baseAssign)
      return _baseAssign;
    hasRequired_baseAssign = 1;
    var copyObject = require_copyObject(), keys = requireKeys();
    function baseAssign(object2, source) {
      return object2 && copyObject(source, keys(source), object2);
    }
    _baseAssign = baseAssign;
    return _baseAssign;
  }
  var _nativeKeysIn;
  var hasRequired_nativeKeysIn;
  function require_nativeKeysIn() {
    if (hasRequired_nativeKeysIn)
      return _nativeKeysIn;
    hasRequired_nativeKeysIn = 1;
    function nativeKeysIn(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    _nativeKeysIn = nativeKeysIn;
    return _nativeKeysIn;
  }
  var _baseKeysIn;
  var hasRequired_baseKeysIn;
  function require_baseKeysIn() {
    if (hasRequired_baseKeysIn)
      return _baseKeysIn;
    hasRequired_baseKeysIn = 1;
    var isObject2 = isObject_1, isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function baseKeysIn(object2) {
      if (!isObject2(object2)) {
        return nativeKeysIn(object2);
      }
      var isProto = isPrototype(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    _baseKeysIn = baseKeysIn;
    return _baseKeysIn;
  }
  var keysIn_1;
  var hasRequiredKeysIn;
  function requireKeysIn() {
    if (hasRequiredKeysIn)
      return keysIn_1;
    hasRequiredKeysIn = 1;
    var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
    function keysIn(object2) {
      return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
    }
    keysIn_1 = keysIn;
    return keysIn_1;
  }
  var _baseAssignIn;
  var hasRequired_baseAssignIn;
  function require_baseAssignIn() {
    if (hasRequired_baseAssignIn)
      return _baseAssignIn;
    hasRequired_baseAssignIn = 1;
    var copyObject = require_copyObject(), keysIn = requireKeysIn();
    function baseAssignIn(object2, source) {
      return object2 && copyObject(source, keysIn(source), object2);
    }
    _baseAssignIn = baseAssignIn;
    return _baseAssignIn;
  }
  var _cloneBuffer = { exports: {} };
  var hasRequired_cloneBuffer;
  function require_cloneBuffer() {
    if (hasRequired_cloneBuffer)
      return _cloneBuffer.exports;
    hasRequired_cloneBuffer = 1;
    (function(module3, exports2) {
      var root2 = _root;
      var freeExports = exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && true && module3 && !module3.nodeType && module3;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
        buffer2.copy(result);
        return result;
      }
      module3.exports = cloneBuffer;
    })(_cloneBuffer, _cloneBuffer.exports);
    return _cloneBuffer.exports;
  }
  var _copyArray;
  var hasRequired_copyArray;
  function require_copyArray() {
    if (hasRequired_copyArray)
      return _copyArray;
    hasRequired_copyArray = 1;
    function copyArray(source, array2) {
      var index2 = -1, length2 = source.length;
      array2 || (array2 = Array(length2));
      while (++index2 < length2) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    _copyArray = copyArray;
    return _copyArray;
  }
  var _arrayFilter;
  var hasRequired_arrayFilter;
  function require_arrayFilter() {
    if (hasRequired_arrayFilter)
      return _arrayFilter;
    hasRequired_arrayFilter = 1;
    function arrayFilter(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length2) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    _arrayFilter = arrayFilter;
    return _arrayFilter;
  }
  var stubArray_1;
  var hasRequiredStubArray;
  function requireStubArray() {
    if (hasRequiredStubArray)
      return stubArray_1;
    hasRequiredStubArray = 1;
    function stubArray() {
      return [];
    }
    stubArray_1 = stubArray;
    return stubArray_1;
  }
  var _getSymbols;
  var hasRequired_getSymbols;
  function require_getSymbols() {
    if (hasRequired_getSymbols)
      return _getSymbols;
    hasRequired_getSymbols = 1;
    var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
    var objectProto2 = Object.prototype;
    var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    _getSymbols = getSymbols;
    return _getSymbols;
  }
  var _copySymbols;
  var hasRequired_copySymbols;
  function require_copySymbols() {
    if (hasRequired_copySymbols)
      return _copySymbols;
    hasRequired_copySymbols = 1;
    var copyObject = require_copyObject(), getSymbols = require_getSymbols();
    function copySymbols(source, object2) {
      return copyObject(source, getSymbols(source), object2);
    }
    _copySymbols = copySymbols;
    return _copySymbols;
  }
  var _arrayPush;
  var hasRequired_arrayPush;
  function require_arrayPush() {
    if (hasRequired_arrayPush)
      return _arrayPush;
    hasRequired_arrayPush = 1;
    function arrayPush2(array2, values) {
      var index2 = -1, length2 = values.length, offset = array2.length;
      while (++index2 < length2) {
        array2[offset + index2] = values[index2];
      }
      return array2;
    }
    _arrayPush = arrayPush2;
    return _arrayPush;
  }
  var _getPrototype;
  var hasRequired_getPrototype;
  function require_getPrototype() {
    if (hasRequired_getPrototype)
      return _getPrototype;
    hasRequired_getPrototype = 1;
    var overArg = require_overArg();
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    _getPrototype = getPrototype;
    return _getPrototype;
  }
  var _getSymbolsIn;
  var hasRequired_getSymbolsIn;
  function require_getSymbolsIn() {
    if (hasRequired_getSymbolsIn)
      return _getSymbolsIn;
    hasRequired_getSymbolsIn = 1;
    var arrayPush2 = require_arrayPush(), getPrototype = require_getPrototype(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
      var result = [];
      while (object2) {
        arrayPush2(result, getSymbols(object2));
        object2 = getPrototype(object2);
      }
      return result;
    };
    _getSymbolsIn = getSymbolsIn;
    return _getSymbolsIn;
  }
  var _copySymbolsIn;
  var hasRequired_copySymbolsIn;
  function require_copySymbolsIn() {
    if (hasRequired_copySymbolsIn)
      return _copySymbolsIn;
    hasRequired_copySymbolsIn = 1;
    var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
    function copySymbolsIn(source, object2) {
      return copyObject(source, getSymbolsIn(source), object2);
    }
    _copySymbolsIn = copySymbolsIn;
    return _copySymbolsIn;
  }
  var _baseGetAllKeys;
  var hasRequired_baseGetAllKeys;
  function require_baseGetAllKeys() {
    if (hasRequired_baseGetAllKeys)
      return _baseGetAllKeys;
    hasRequired_baseGetAllKeys = 1;
    var arrayPush2 = require_arrayPush(), isArray = requireIsArray();
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray(object2) ? result : arrayPush2(result, symbolsFunc(object2));
    }
    _baseGetAllKeys = baseGetAllKeys;
    return _baseGetAllKeys;
  }
  var _getAllKeys;
  var hasRequired_getAllKeys;
  function require_getAllKeys() {
    if (hasRequired_getAllKeys)
      return _getAllKeys;
    hasRequired_getAllKeys = 1;
    var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    _getAllKeys = getAllKeys;
    return _getAllKeys;
  }
  var _getAllKeysIn;
  var hasRequired_getAllKeysIn;
  function require_getAllKeysIn() {
    if (hasRequired_getAllKeysIn)
      return _getAllKeysIn;
    hasRequired_getAllKeysIn = 1;
    var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn();
    function getAllKeysIn(object2) {
      return baseGetAllKeys(object2, keysIn, getSymbolsIn);
    }
    _getAllKeysIn = getAllKeysIn;
    return _getAllKeysIn;
  }
  var _DataView;
  var hasRequired_DataView;
  function require_DataView() {
    if (hasRequired_DataView)
      return _DataView;
    hasRequired_DataView = 1;
    var getNative2 = _getNative, root2 = _root;
    var DataView2 = getNative2(root2, "DataView");
    _DataView = DataView2;
    return _DataView;
  }
  var _Promise;
  var hasRequired_Promise;
  function require_Promise() {
    if (hasRequired_Promise)
      return _Promise;
    hasRequired_Promise = 1;
    var getNative2 = _getNative, root2 = _root;
    var Promise2 = getNative2(root2, "Promise");
    _Promise = Promise2;
    return _Promise;
  }
  var _Set;
  var hasRequired_Set;
  function require_Set() {
    if (hasRequired_Set)
      return _Set;
    hasRequired_Set = 1;
    var getNative2 = _getNative, root2 = _root;
    var Set4 = getNative2(root2, "Set");
    _Set = Set4;
    return _Set;
  }
  var _WeakMap;
  var hasRequired_WeakMap;
  function require_WeakMap() {
    if (hasRequired_WeakMap)
      return _WeakMap;
    hasRequired_WeakMap = 1;
    var getNative2 = _getNative, root2 = _root;
    var WeakMap = getNative2(root2, "WeakMap");
    _WeakMap = WeakMap;
    return _WeakMap;
  }
  var _getTag;
  var hasRequired_getTag;
  function require_getTag() {
    if (hasRequired_getTag)
      return _getTag;
    hasRequired_getTag = 1;
    var DataView2 = require_DataView(), Map2 = _Map, Promise2 = require_Promise(), Set4 = require_Set(), WeakMap = require_WeakMap(), baseGetTag2 = _baseGetTag, toSource2 = _toSource;
    var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource2(DataView2), mapCtorString = toSource2(Map2), promiseCtorString = toSource2(Promise2), setCtorString = toSource2(Set4), weakMapCtorString = toSource2(WeakMap);
    var getTag = baseGetTag2;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set4 && getTag(new Set4()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag2(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    _getTag = getTag;
    return _getTag;
  }
  var _initCloneArray;
  var hasRequired_initCloneArray;
  function require_initCloneArray() {
    if (hasRequired_initCloneArray)
      return _initCloneArray;
    hasRequired_initCloneArray = 1;
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function initCloneArray(array2) {
      var length2 = array2.length, result = new array2.constructor(length2);
      if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    _initCloneArray = initCloneArray;
    return _initCloneArray;
  }
  var _Uint8Array;
  var hasRequired_Uint8Array;
  function require_Uint8Array() {
    if (hasRequired_Uint8Array)
      return _Uint8Array;
    hasRequired_Uint8Array = 1;
    var root2 = _root;
    var Uint8Array2 = root2.Uint8Array;
    _Uint8Array = Uint8Array2;
    return _Uint8Array;
  }
  var _cloneArrayBuffer;
  var hasRequired_cloneArrayBuffer;
  function require_cloneArrayBuffer() {
    if (hasRequired_cloneArrayBuffer)
      return _cloneArrayBuffer;
    hasRequired_cloneArrayBuffer = 1;
    var Uint8Array2 = require_Uint8Array();
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    _cloneArrayBuffer = cloneArrayBuffer;
    return _cloneArrayBuffer;
  }
  var _cloneDataView;
  var hasRequired_cloneDataView;
  function require_cloneDataView() {
    if (hasRequired_cloneDataView)
      return _cloneDataView;
    hasRequired_cloneDataView = 1;
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneDataView(dataView, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
    }
    _cloneDataView = cloneDataView;
    return _cloneDataView;
  }
  var _cloneRegExp;
  var hasRequired_cloneRegExp;
  function require_cloneRegExp() {
    if (hasRequired_cloneRegExp)
      return _cloneRegExp;
    hasRequired_cloneRegExp = 1;
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    _cloneRegExp = cloneRegExp;
    return _cloneRegExp;
  }
  var _cloneSymbol;
  var hasRequired_cloneSymbol;
  function require_cloneSymbol() {
    if (hasRequired_cloneSymbol)
      return _cloneSymbol;
    hasRequired_cloneSymbol = 1;
    var Symbol2 = _Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    _cloneSymbol = cloneSymbol;
    return _cloneSymbol;
  }
  var _cloneTypedArray;
  var hasRequired_cloneTypedArray;
  function require_cloneTypedArray() {
    if (hasRequired_cloneTypedArray)
      return _cloneTypedArray;
    hasRequired_cloneTypedArray = 1;
    var cloneArrayBuffer = require_cloneArrayBuffer();
    function cloneTypedArray(typedArray, isDeep) {
      var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
    }
    _cloneTypedArray = cloneTypedArray;
    return _cloneTypedArray;
  }
  var _initCloneByTag;
  var hasRequired_initCloneByTag;
  function require_initCloneByTag() {
    if (hasRequired_initCloneByTag)
      return _initCloneByTag;
    hasRequired_initCloneByTag = 1;
    var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
    var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    function initCloneByTag(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object2);
        case boolTag:
        case dateTag:
          return new Ctor(+object2);
        case dataViewTag:
          return cloneDataView(object2, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object2, isDeep);
        case mapTag:
          return new Ctor();
        case numberTag:
        case stringTag:
          return new Ctor(object2);
        case regexpTag:
          return cloneRegExp(object2);
        case setTag:
          return new Ctor();
        case symbolTag:
          return cloneSymbol(object2);
      }
    }
    _initCloneByTag = initCloneByTag;
    return _initCloneByTag;
  }
  var _baseCreate;
  var hasRequired_baseCreate;
  function require_baseCreate() {
    if (hasRequired_baseCreate)
      return _baseCreate;
    hasRequired_baseCreate = 1;
    var isObject2 = isObject_1;
    var objectCreate = Object.create;
    var baseCreate = function() {
      function object2() {
      }
      return function(proto) {
        if (!isObject2(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object2.prototype = proto;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    _baseCreate = baseCreate;
    return _baseCreate;
  }
  var _initCloneObject;
  var hasRequired_initCloneObject;
  function require_initCloneObject() {
    if (hasRequired_initCloneObject)
      return _initCloneObject;
    hasRequired_initCloneObject = 1;
    var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype = require_isPrototype();
    function initCloneObject(object2) {
      return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
    }
    _initCloneObject = initCloneObject;
    return _initCloneObject;
  }
  var _baseIsMap;
  var hasRequired_baseIsMap;
  function require_baseIsMap() {
    if (hasRequired_baseIsMap)
      return _baseIsMap;
    hasRequired_baseIsMap = 1;
    var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
    var mapTag = "[object Map]";
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }
    _baseIsMap = baseIsMap;
    return _baseIsMap;
  }
  var isMap_1;
  var hasRequiredIsMap;
  function requireIsMap() {
    if (hasRequiredIsMap)
      return isMap_1;
    hasRequiredIsMap = 1;
    var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    isMap_1 = isMap;
    return isMap_1;
  }
  var _baseIsSet;
  var hasRequired_baseIsSet;
  function require_baseIsSet() {
    if (hasRequired_baseIsSet)
      return _baseIsSet;
    hasRequired_baseIsSet = 1;
    var getTag = require_getTag(), isObjectLike = requireIsObjectLike();
    var setTag = "[object Set]";
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }
    _baseIsSet = baseIsSet;
    return _baseIsSet;
  }
  var isSet_1;
  var hasRequiredIsSet;
  function requireIsSet() {
    if (hasRequiredIsSet)
      return isSet_1;
    hasRequiredIsSet = 1;
    var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    isSet_1 = isSet;
    return isSet_1;
  }
  var _baseClone;
  var hasRequired_baseClone;
  function require_baseClone() {
    if (hasRequired_baseClone)
      return _baseClone;
    hasRequired_baseClone = 1;
    var Stack = require_Stack(), arrayEach = require_arrayEach(), assignValue = require_assignValue(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isMap = requireIsMap(), isObject2 = isObject_1, isSet = requireIsSet(), keys = requireKeys(), keysIn = requireKeysIn();
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag] = false;
    function baseClone(value, bitmask, customizer, key, object2, stack2) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack2) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
        if (isBuffer2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      stack2 || (stack2 = new Stack());
      var stacked = stack2.get(value);
      if (stacked) {
        return stacked;
      }
      stack2.set(value, result);
      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
      return result;
    }
    _baseClone = baseClone;
    return _baseClone;
  }
  var clone_1;
  var hasRequiredClone;
  function requireClone() {
    if (hasRequiredClone)
      return clone_1;
    hasRequiredClone = 1;
    var baseClone = require_baseClone();
    var CLONE_SYMBOLS_FLAG = 4;
    function clone2(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }
    clone_1 = clone2;
    return clone_1;
  }
  var constant_1;
  var hasRequiredConstant;
  function requireConstant() {
    if (hasRequiredConstant)
      return constant_1;
    hasRequiredConstant = 1;
    function constant2(value) {
      return function() {
        return value;
      };
    }
    constant_1 = constant2;
    return constant_1;
  }
  var each = { exports: {} };
  var _createBaseFor;
  var hasRequired_createBaseFor;
  function require_createBaseFor() {
    if (hasRequired_createBaseFor)
      return _createBaseFor;
    hasRequired_createBaseFor = 1;
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
        while (length2--) {
          var key = props[fromRight ? length2 : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    _createBaseFor = createBaseFor;
    return _createBaseFor;
  }
  var _baseFor;
  var hasRequired_baseFor;
  function require_baseFor() {
    if (hasRequired_baseFor)
      return _baseFor;
    hasRequired_baseFor = 1;
    var createBaseFor = require_createBaseFor();
    var baseFor = createBaseFor();
    _baseFor = baseFor;
    return _baseFor;
  }
  var _baseForOwn;
  var hasRequired_baseForOwn;
  function require_baseForOwn() {
    if (hasRequired_baseForOwn)
      return _baseForOwn;
    hasRequired_baseForOwn = 1;
    var baseFor = require_baseFor(), keys = requireKeys();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys);
    }
    _baseForOwn = baseForOwn;
    return _baseForOwn;
  }
  var _createBaseEach;
  var hasRequired_createBaseEach;
  function require_createBaseEach() {
    if (hasRequired_createBaseEach)
      return _createBaseEach;
    hasRequired_createBaseEach = 1;
    var isArrayLike = requireIsArrayLike();
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    _createBaseEach = createBaseEach;
    return _createBaseEach;
  }
  var _baseEach;
  var hasRequired_baseEach;
  function require_baseEach() {
    if (hasRequired_baseEach)
      return _baseEach;
    hasRequired_baseEach = 1;
    var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
    var baseEach = createBaseEach(baseForOwn);
    _baseEach = baseEach;
    return _baseEach;
  }
  var identity_1;
  var hasRequiredIdentity;
  function requireIdentity() {
    if (hasRequiredIdentity)
      return identity_1;
    hasRequiredIdentity = 1;
    function identity2(value) {
      return value;
    }
    identity_1 = identity2;
    return identity_1;
  }
  var _castFunction;
  var hasRequired_castFunction;
  function require_castFunction() {
    if (hasRequired_castFunction)
      return _castFunction;
    hasRequired_castFunction = 1;
    var identity2 = requireIdentity();
    function castFunction(value) {
      return typeof value == "function" ? value : identity2;
    }
    _castFunction = castFunction;
    return _castFunction;
  }
  var forEach_1;
  var hasRequiredForEach;
  function requireForEach() {
    if (hasRequiredForEach)
      return forEach_1;
    hasRequiredForEach = 1;
    var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray = requireIsArray();
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    forEach_1 = forEach;
    return forEach_1;
  }
  var hasRequiredEach;
  function requireEach() {
    if (hasRequiredEach)
      return each.exports;
    hasRequiredEach = 1;
    (function(module3) {
      module3.exports = requireForEach();
    })(each);
    return each.exports;
  }
  var _baseFilter;
  var hasRequired_baseFilter;
  function require_baseFilter() {
    if (hasRequired_baseFilter)
      return _baseFilter;
    hasRequired_baseFilter = 1;
    var baseEach = require_baseEach();
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index2, collection2) {
        if (predicate(value, index2, collection2)) {
          result.push(value);
        }
      });
      return result;
    }
    _baseFilter = baseFilter;
    return _baseFilter;
  }
  var _setCacheAdd;
  var hasRequired_setCacheAdd;
  function require_setCacheAdd() {
    if (hasRequired_setCacheAdd)
      return _setCacheAdd;
    hasRequired_setCacheAdd = 1;
    var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED2);
      return this;
    }
    _setCacheAdd = setCacheAdd;
    return _setCacheAdd;
  }
  var _setCacheHas;
  var hasRequired_setCacheHas;
  function require_setCacheHas() {
    if (hasRequired_setCacheHas)
      return _setCacheHas;
    hasRequired_setCacheHas = 1;
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    _setCacheHas = setCacheHas;
    return _setCacheHas;
  }
  var _SetCache;
  var hasRequired_SetCache;
  function require_SetCache() {
    if (hasRequired_SetCache)
      return _SetCache;
    hasRequired_SetCache = 1;
    var MapCache2 = _MapCache, setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
    function SetCache(values) {
      var index2 = -1, length2 = values == null ? 0 : values.length;
      this.__data__ = new MapCache2();
      while (++index2 < length2) {
        this.add(values[index2]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    _SetCache = SetCache;
    return _SetCache;
  }
  var _arraySome;
  var hasRequired_arraySome;
  function require_arraySome() {
    if (hasRequired_arraySome)
      return _arraySome;
    hasRequired_arraySome = 1;
    function arraySome(array2, predicate) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    _arraySome = arraySome;
    return _arraySome;
  }
  var _cacheHas;
  var hasRequired_cacheHas;
  function require_cacheHas() {
    if (hasRequired_cacheHas)
      return _cacheHas;
    hasRequired_cacheHas = 1;
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    _cacheHas = cacheHas;
    return _cacheHas;
  }
  var _equalArrays;
  var hasRequired_equalArrays;
  function require_equalArrays() {
    if (hasRequired_equalArrays)
      return _equalArrays;
    hasRequired_equalArrays = 1;
    var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack2.get(array2);
      var othStacked = stack2.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    _equalArrays = equalArrays;
    return _equalArrays;
  }
  var _mapToArray;
  var hasRequired_mapToArray;
  function require_mapToArray() {
    if (hasRequired_mapToArray)
      return _mapToArray;
    hasRequired_mapToArray = 1;
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    _mapToArray = mapToArray;
    return _mapToArray;
  }
  var _setToArray;
  var hasRequired_setToArray;
  function require_setToArray() {
    if (hasRequired_setToArray)
      return _setToArray;
    hasRequired_setToArray = 1;
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    _setToArray = setToArray;
    return _setToArray;
  }
  var _equalByTag;
  var hasRequired_equalByTag;
  function require_equalByTag() {
    if (hasRequired_equalByTag)
      return _equalByTag;
    hasRequired_equalByTag = 1;
    var Symbol2 = _Symbol, Uint8Array2 = require_Uint8Array(), eq2 = eq_1, equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq2(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack2.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
          stack2["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    _equalByTag = equalByTag;
    return _equalByTag;
  }
  var _equalObjects;
  var hasRequired_equalObjects;
  function require_equalObjects() {
    if (hasRequired_equalObjects)
      return _equalObjects;
    hasRequired_equalObjects = 1;
    var getAllKeys = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG = 1;
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack2.get(object2);
      var othStacked = stack2.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack2.set(object2, other);
      stack2.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object2);
      stack2["delete"](other);
      return result;
    }
    _equalObjects = equalObjects;
    return _equalObjects;
  }
  var _baseIsEqualDeep;
  var hasRequired_baseIsEqualDeep;
  function require_baseIsEqualDeep() {
    if (hasRequired_baseIsEqualDeep)
      return _baseIsEqualDeep;
    hasRequired_baseIsEqualDeep = 1;
    var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray = requireIsTypedArray();
    var COMPARE_PARTIAL_FLAG = 1;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
      var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer2(object2)) {
        if (!isBuffer2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
    }
    _baseIsEqualDeep = baseIsEqualDeep;
    return _baseIsEqualDeep;
  }
  var _baseIsEqual;
  var hasRequired_baseIsEqual;
  function require_baseIsEqual() {
    if (hasRequired_baseIsEqual)
      return _baseIsEqual;
    hasRequired_baseIsEqual = 1;
    var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
    function baseIsEqual(value, other, bitmask, customizer, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
    }
    _baseIsEqual = baseIsEqual;
    return _baseIsEqual;
  }
  var _baseIsMatch;
  var hasRequired_baseIsMatch;
  function require_baseIsMatch() {
    if (hasRequired_baseIsMatch)
      return _baseIsMatch;
    hasRequired_baseIsMatch = 1;
    var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseIsMatch(object2, source, matchData, customizer) {
      var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length2;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length2) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    _baseIsMatch = baseIsMatch;
    return _baseIsMatch;
  }
  var _isStrictComparable;
  var hasRequired_isStrictComparable;
  function require_isStrictComparable() {
    if (hasRequired_isStrictComparable)
      return _isStrictComparable;
    hasRequired_isStrictComparable = 1;
    var isObject2 = isObject_1;
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    _isStrictComparable = isStrictComparable;
    return _isStrictComparable;
  }
  var _getMatchData;
  var hasRequired_getMatchData;
  function require_getMatchData() {
    if (hasRequired_getMatchData)
      return _getMatchData;
    hasRequired_getMatchData = 1;
    var isStrictComparable = require_isStrictComparable(), keys = requireKeys();
    function getMatchData(object2) {
      var result = keys(object2), length2 = result.length;
      while (length2--) {
        var key = result[length2], value = object2[key];
        result[length2] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    _getMatchData = getMatchData;
    return _getMatchData;
  }
  var _matchesStrictComparable;
  var hasRequired_matchesStrictComparable;
  function require_matchesStrictComparable() {
    if (hasRequired_matchesStrictComparable)
      return _matchesStrictComparable;
    hasRequired_matchesStrictComparable = 1;
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    _matchesStrictComparable = matchesStrictComparable;
    return _matchesStrictComparable;
  }
  var _baseMatches;
  var hasRequired_baseMatches;
  function require_baseMatches() {
    if (hasRequired_baseMatches)
      return _baseMatches;
    hasRequired_baseMatches = 1;
    var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    _baseMatches = baseMatches;
    return _baseMatches;
  }
  var isSymbol_1;
  var hasRequiredIsSymbol;
  function requireIsSymbol() {
    if (hasRequiredIsSymbol)
      return isSymbol_1;
    hasRequiredIsSymbol = 1;
    var baseGetTag2 = _baseGetTag, isObjectLike = requireIsObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && baseGetTag2(value) == symbolTag;
    }
    isSymbol_1 = isSymbol;
    return isSymbol_1;
  }
  var _isKey;
  var hasRequired_isKey;
  function require_isKey() {
    if (hasRequired_isKey)
      return _isKey;
    hasRequired_isKey = 1;
    var isArray = requireIsArray(), isSymbol = requireIsSymbol();
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value, object2) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    _isKey = isKey;
    return _isKey;
  }
  var _memoizeCapped;
  var hasRequired_memoizeCapped;
  function require_memoizeCapped() {
    if (hasRequired_memoizeCapped)
      return _memoizeCapped;
    hasRequired_memoizeCapped = 1;
    var memoize2 = memoize_1;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize2(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    _memoizeCapped = memoizeCapped;
    return _memoizeCapped;
  }
  var _stringToPath;
  var hasRequired_stringToPath;
  function require_stringToPath() {
    if (hasRequired_stringToPath)
      return _stringToPath;
    hasRequired_stringToPath = 1;
    var memoizeCapped = require_memoizeCapped();
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match, number3, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
      });
      return result;
    });
    _stringToPath = stringToPath;
    return _stringToPath;
  }
  var _arrayMap;
  var hasRequired_arrayMap;
  function require_arrayMap() {
    if (hasRequired_arrayMap)
      return _arrayMap;
    hasRequired_arrayMap = 1;
    function arrayMap(array2, iteratee) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
      while (++index2 < length2) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    _arrayMap = arrayMap;
    return _arrayMap;
  }
  var _baseToString;
  var hasRequired_baseToString;
  function require_baseToString() {
    if (hasRequired_baseToString)
      return _baseToString;
    hasRequired_baseToString = 1;
    var Symbol2 = _Symbol, arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    _baseToString = baseToString;
    return _baseToString;
  }
  var toString_1;
  var hasRequiredToString;
  function requireToString() {
    if (hasRequiredToString)
      return toString_1;
    hasRequiredToString = 1;
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    toString_1 = toString;
    return toString_1;
  }
  var _castPath;
  var hasRequired_castPath;
  function require_castPath() {
    if (hasRequired_castPath)
      return _castPath;
    hasRequired_castPath = 1;
    var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();
    function castPath(value, object2) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object2) ? [value] : stringToPath(toString(value));
    }
    _castPath = castPath;
    return _castPath;
  }
  var _toKey;
  var hasRequired_toKey;
  function require_toKey() {
    if (hasRequired_toKey)
      return _toKey;
    hasRequired_toKey = 1;
    var isSymbol = requireIsSymbol();
    var INFINITY = 1 / 0;
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    _toKey = toKey;
    return _toKey;
  }
  var _baseGet;
  var hasRequired_baseGet;
  function require_baseGet() {
    if (hasRequired_baseGet)
      return _baseGet;
    hasRequired_baseGet = 1;
    var castPath = require_castPath(), toKey = require_toKey();
    function baseGet(object2, path2) {
      path2 = castPath(path2, object2);
      var index2 = 0, length2 = path2.length;
      while (object2 != null && index2 < length2) {
        object2 = object2[toKey(path2[index2++])];
      }
      return index2 && index2 == length2 ? object2 : void 0;
    }
    _baseGet = baseGet;
    return _baseGet;
  }
  var get_1;
  var hasRequiredGet;
  function requireGet() {
    if (hasRequiredGet)
      return get_1;
    hasRequiredGet = 1;
    var baseGet = require_baseGet();
    function get2(object2, path2, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path2);
      return result === void 0 ? defaultValue : result;
    }
    get_1 = get2;
    return get_1;
  }
  var _baseHasIn;
  var hasRequired_baseHasIn;
  function require_baseHasIn() {
    if (hasRequired_baseHasIn)
      return _baseHasIn;
    hasRequired_baseHasIn = 1;
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    _baseHasIn = baseHasIn;
    return _baseHasIn;
  }
  var _hasPath;
  var hasRequired_hasPath;
  function require_hasPath() {
    if (hasRequired_hasPath)
      return _hasPath;
    hasRequired_hasPath = 1;
    var castPath = require_castPath(), isArguments = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
    function hasPath(object2, path2, hasFunc) {
      path2 = castPath(path2, object2);
      var index2 = -1, length2 = path2.length, result = false;
      while (++index2 < length2) {
        var key = toKey(path2[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length2) {
        return result;
      }
      length2 = object2 == null ? 0 : object2.length;
      return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
    }
    _hasPath = hasPath;
    return _hasPath;
  }
  var hasIn_1;
  var hasRequiredHasIn;
  function requireHasIn() {
    if (hasRequiredHasIn)
      return hasIn_1;
    hasRequiredHasIn = 1;
    var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
    function hasIn(object2, path2) {
      return object2 != null && hasPath(object2, path2, baseHasIn);
    }
    hasIn_1 = hasIn;
    return hasIn_1;
  }
  var _baseMatchesProperty;
  var hasRequired_baseMatchesProperty;
  function require_baseMatchesProperty() {
    if (hasRequired_baseMatchesProperty)
      return _baseMatchesProperty;
    hasRequired_baseMatchesProperty = 1;
    var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object2) {
        var objValue = get2(object2, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    _baseMatchesProperty = baseMatchesProperty;
    return _baseMatchesProperty;
  }
  var _baseProperty;
  var hasRequired_baseProperty;
  function require_baseProperty() {
    if (hasRequired_baseProperty)
      return _baseProperty;
    hasRequired_baseProperty = 1;
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    _baseProperty = baseProperty;
    return _baseProperty;
  }
  var _basePropertyDeep;
  var hasRequired_basePropertyDeep;
  function require_basePropertyDeep() {
    if (hasRequired_basePropertyDeep)
      return _basePropertyDeep;
    hasRequired_basePropertyDeep = 1;
    var baseGet = require_baseGet();
    function basePropertyDeep(path2) {
      return function(object2) {
        return baseGet(object2, path2);
      };
    }
    _basePropertyDeep = basePropertyDeep;
    return _basePropertyDeep;
  }
  var property_1;
  var hasRequiredProperty;
  function requireProperty() {
    if (hasRequiredProperty)
      return property_1;
    hasRequiredProperty = 1;
    var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    property_1 = property;
    return property_1;
  }
  var _baseIteratee;
  var hasRequired_baseIteratee;
  function require_baseIteratee() {
    if (hasRequired_baseIteratee)
      return _baseIteratee;
    hasRequired_baseIteratee = 1;
    var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity(), isArray = requireIsArray(), property = requireProperty();
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity2;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    _baseIteratee = baseIteratee;
    return _baseIteratee;
  }
  var filter_1;
  var hasRequiredFilter;
  function requireFilter() {
    if (hasRequiredFilter)
      return filter_1;
    hasRequiredFilter = 1;
    var arrayFilter = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray = requireIsArray();
    function filter2(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, baseIteratee(predicate, 3));
    }
    filter_1 = filter2;
    return filter_1;
  }
  var _baseHas;
  var hasRequired_baseHas;
  function require_baseHas() {
    if (hasRequired_baseHas)
      return _baseHas;
    hasRequired_baseHas = 1;
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty2.call(object2, key);
    }
    _baseHas = baseHas;
    return _baseHas;
  }
  var has_1;
  var hasRequiredHas;
  function requireHas() {
    if (hasRequiredHas)
      return has_1;
    hasRequiredHas = 1;
    var baseHas = require_baseHas(), hasPath = require_hasPath();
    function has(object2, path2) {
      return object2 != null && hasPath(object2, path2, baseHas);
    }
    has_1 = has;
    return has_1;
  }
  var isEmpty_1;
  var hasRequiredIsEmpty;
  function requireIsEmpty() {
    if (hasRequiredIsEmpty)
      return isEmpty_1;
    hasRequiredIsEmpty = 1;
    var baseKeys = require_baseKeys(), getTag = require_getTag(), isArguments = requireIsArguments(), isArray = requireIsArray(), isArrayLike = requireIsArrayLike(), isBuffer2 = requireIsBuffer(), isPrototype = require_isPrototype(), isTypedArray = requireIsTypedArray();
    var mapTag = "[object Map]", setTag = "[object Set]";
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty2.call(value, key)) {
          return false;
        }
      }
      return true;
    }
    isEmpty_1 = isEmpty;
    return isEmpty_1;
  }
  var isUndefined_1;
  var hasRequiredIsUndefined;
  function requireIsUndefined() {
    if (hasRequiredIsUndefined)
      return isUndefined_1;
    hasRequiredIsUndefined = 1;
    function isUndefined(value) {
      return value === void 0;
    }
    isUndefined_1 = isUndefined;
    return isUndefined_1;
  }
  var _baseMap;
  var hasRequired_baseMap;
  function require_baseMap() {
    if (hasRequired_baseMap)
      return _baseMap;
    hasRequired_baseMap = 1;
    var baseEach = require_baseEach(), isArrayLike = requireIsArrayLike();
    function baseMap(collection, iteratee) {
      var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    _baseMap = baseMap;
    return _baseMap;
  }
  var map_1;
  var hasRequiredMap;
  function requireMap() {
    if (hasRequiredMap)
      return map_1;
    hasRequiredMap = 1;
    var arrayMap = require_arrayMap(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray = requireIsArray();
    function map2(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee, 3));
    }
    map_1 = map2;
    return map_1;
  }
  var _arrayReduce;
  var hasRequired_arrayReduce;
  function require_arrayReduce() {
    if (hasRequired_arrayReduce)
      return _arrayReduce;
    hasRequired_arrayReduce = 1;
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      if (initAccum && length2) {
        accumulator = array2[++index2];
      }
      while (++index2 < length2) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    _arrayReduce = arrayReduce;
    return _arrayReduce;
  }
  var _baseReduce;
  var hasRequired_baseReduce;
  function require_baseReduce() {
    if (hasRequired_baseReduce)
      return _baseReduce;
    hasRequired_baseReduce = 1;
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    _baseReduce = baseReduce;
    return _baseReduce;
  }
  var reduce_1;
  var hasRequiredReduce;
  function requireReduce() {
    if (hasRequiredReduce)
      return reduce_1;
    hasRequiredReduce = 1;
    var arrayReduce = require_arrayReduce(), baseEach = require_baseEach(), baseIteratee = require_baseIteratee(), baseReduce = require_baseReduce(), isArray = requireIsArray();
    function reduce2(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
      return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }
    reduce_1 = reduce2;
    return reduce_1;
  }
  var isString_1;
  var hasRequiredIsString;
  function requireIsString() {
    if (hasRequiredIsString)
      return isString_1;
    hasRequiredIsString = 1;
    var baseGetTag2 = _baseGetTag, isArray = requireIsArray(), isObjectLike = requireIsObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag2(value) == stringTag;
    }
    isString_1 = isString;
    return isString_1;
  }
  var _asciiSize;
  var hasRequired_asciiSize;
  function require_asciiSize() {
    if (hasRequired_asciiSize)
      return _asciiSize;
    hasRequired_asciiSize = 1;
    var baseProperty = require_baseProperty();
    var asciiSize = baseProperty("length");
    _asciiSize = asciiSize;
    return _asciiSize;
  }
  var _hasUnicode;
  var hasRequired_hasUnicode;
  function require_hasUnicode() {
    if (hasRequired_hasUnicode)
      return _hasUnicode;
    hasRequired_hasUnicode = 1;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    _hasUnicode = hasUnicode;
    return _hasUnicode;
  }
  var _unicodeSize;
  var hasRequired_unicodeSize;
  function require_unicodeSize() {
    if (hasRequired_unicodeSize)
      return _unicodeSize;
    hasRequired_unicodeSize = 1;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    _unicodeSize = unicodeSize;
    return _unicodeSize;
  }
  var _stringSize;
  var hasRequired_stringSize;
  function require_stringSize() {
    if (hasRequired_stringSize)
      return _stringSize;
    hasRequired_stringSize = 1;
    var asciiSize = require_asciiSize(), hasUnicode = require_hasUnicode(), unicodeSize = require_unicodeSize();
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    _stringSize = stringSize;
    return _stringSize;
  }
  var size_1;
  var hasRequiredSize;
  function requireSize() {
    if (hasRequiredSize)
      return size_1;
    hasRequiredSize = 1;
    var baseKeys = require_baseKeys(), getTag = require_getTag(), isArrayLike = requireIsArrayLike(), isString = requireIsString(), stringSize = require_stringSize();
    var mapTag = "[object Map]", setTag = "[object Set]";
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }
    size_1 = size;
    return size_1;
  }
  var transform_1;
  var hasRequiredTransform;
  function requireTransform() {
    if (hasRequiredTransform)
      return transform_1;
    hasRequiredTransform = 1;
    var arrayEach = require_arrayEach(), baseCreate = require_baseCreate(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee(), getPrototype = require_getPrototype(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isFunction2 = isFunction_1, isObject2 = isObject_1, isTypedArray = requireIsTypedArray();
    function transform2(object2, iteratee, accumulator) {
      var isArr = isArray(object2), isArrLike = isArr || isBuffer2(object2) || isTypedArray(object2);
      iteratee = baseIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object2 && object2.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor() : [];
        } else if (isObject2(object2)) {
          accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object2)) : {};
        } else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
        return iteratee(accumulator, value, index2, object3);
      });
      return accumulator;
    }
    transform_1 = transform2;
    return transform_1;
  }
  var _isFlattenable;
  var hasRequired_isFlattenable;
  function require_isFlattenable() {
    if (hasRequired_isFlattenable)
      return _isFlattenable;
    hasRequired_isFlattenable = 1;
    var Symbol2 = _Symbol, isArguments = requireIsArguments(), isArray = requireIsArray();
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    _isFlattenable = isFlattenable;
    return _isFlattenable;
  }
  var _baseFlatten;
  var hasRequired_baseFlatten;
  function require_baseFlatten() {
    if (hasRequired_baseFlatten)
      return _baseFlatten;
    hasRequired_baseFlatten = 1;
    var arrayPush2 = require_arrayPush(), isFlattenable = require_isFlattenable();
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index2 = -1, length2 = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index2 < length2) {
        var value = array2[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush2(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    _baseFlatten = baseFlatten;
    return _baseFlatten;
  }
  var _apply;
  var hasRequired_apply;
  function require_apply() {
    if (hasRequired_apply)
      return _apply;
    hasRequired_apply = 1;
    function apply2(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    _apply = apply2;
    return _apply;
  }
  var _overRest;
  var hasRequired_overRest;
  function require_overRest() {
    if (hasRequired_overRest)
      return _overRest;
    hasRequired_overRest = 1;
    var apply2 = require_apply();
    var nativeMax = Math.max;
    function overRest(func, start2, transform2) {
      start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
      return function() {
        var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
        while (++index2 < length2) {
          array2[index2] = args[start2 + index2];
        }
        index2 = -1;
        var otherArgs = Array(start2 + 1);
        while (++index2 < start2) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start2] = transform2(array2);
        return apply2(func, this, otherArgs);
      };
    }
    _overRest = overRest;
    return _overRest;
  }
  var _baseSetToString;
  var hasRequired_baseSetToString;
  function require_baseSetToString() {
    if (hasRequired_baseSetToString)
      return _baseSetToString;
    hasRequired_baseSetToString = 1;
    var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
    var baseSetToString = !defineProperty ? identity2 : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant2(string),
        "writable": true
      });
    };
    _baseSetToString = baseSetToString;
    return _baseSetToString;
  }
  var _shortOut;
  var hasRequired_shortOut;
  function require_shortOut() {
    if (hasRequired_shortOut)
      return _shortOut;
    hasRequired_shortOut = 1;
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count2 = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count2 >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count2 = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    _shortOut = shortOut;
    return _shortOut;
  }
  var _setToString;
  var hasRequired_setToString;
  function require_setToString() {
    if (hasRequired_setToString)
      return _setToString;
    hasRequired_setToString = 1;
    var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
    var setToString = shortOut(baseSetToString);
    _setToString = setToString;
    return _setToString;
  }
  var _baseRest;
  var hasRequired_baseRest;
  function require_baseRest() {
    if (hasRequired_baseRest)
      return _baseRest;
    hasRequired_baseRest = 1;
    var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
    function baseRest(func, start2) {
      return setToString(overRest(func, start2, identity2), func + "");
    }
    _baseRest = baseRest;
    return _baseRest;
  }
  var _baseFindIndex;
  var hasRequired_baseFindIndex;
  function require_baseFindIndex() {
    if (hasRequired_baseFindIndex)
      return _baseFindIndex;
    hasRequired_baseFindIndex = 1;
    function baseFindIndex(array2, predicate, fromIndex, fromRight) {
      var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (predicate(array2[index2], index2, array2)) {
          return index2;
        }
      }
      return -1;
    }
    _baseFindIndex = baseFindIndex;
    return _baseFindIndex;
  }
  var _baseIsNaN;
  var hasRequired_baseIsNaN;
  function require_baseIsNaN() {
    if (hasRequired_baseIsNaN)
      return _baseIsNaN;
    hasRequired_baseIsNaN = 1;
    function baseIsNaN(value) {
      return value !== value;
    }
    _baseIsNaN = baseIsNaN;
    return _baseIsNaN;
  }
  var _strictIndexOf;
  var hasRequired_strictIndexOf;
  function require_strictIndexOf() {
    if (hasRequired_strictIndexOf)
      return _strictIndexOf;
    hasRequired_strictIndexOf = 1;
    function strictIndexOf(array2, value, fromIndex) {
      var index2 = fromIndex - 1, length2 = array2.length;
      while (++index2 < length2) {
        if (array2[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    _strictIndexOf = strictIndexOf;
    return _strictIndexOf;
  }
  var _baseIndexOf;
  var hasRequired_baseIndexOf;
  function require_baseIndexOf() {
    if (hasRequired_baseIndexOf)
      return _baseIndexOf;
    hasRequired_baseIndexOf = 1;
    var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array2, value, fromIndex) {
      return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    _baseIndexOf = baseIndexOf;
    return _baseIndexOf;
  }
  var _arrayIncludes;
  var hasRequired_arrayIncludes;
  function require_arrayIncludes() {
    if (hasRequired_arrayIncludes)
      return _arrayIncludes;
    hasRequired_arrayIncludes = 1;
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array2, value) {
      var length2 = array2 == null ? 0 : array2.length;
      return !!length2 && baseIndexOf(array2, value, 0) > -1;
    }
    _arrayIncludes = arrayIncludes;
    return _arrayIncludes;
  }
  var _arrayIncludesWith;
  var hasRequired_arrayIncludesWith;
  function require_arrayIncludesWith() {
    if (hasRequired_arrayIncludesWith)
      return _arrayIncludesWith;
    hasRequired_arrayIncludesWith = 1;
    function arrayIncludesWith(array2, value, comparator) {
      var index2 = -1, length2 = array2 == null ? 0 : array2.length;
      while (++index2 < length2) {
        if (comparator(value, array2[index2])) {
          return true;
        }
      }
      return false;
    }
    _arrayIncludesWith = arrayIncludesWith;
    return _arrayIncludesWith;
  }
  var noop_1;
  var hasRequiredNoop;
  function requireNoop() {
    if (hasRequiredNoop)
      return noop_1;
    hasRequiredNoop = 1;
    function noop2() {
    }
    noop_1 = noop2;
    return noop_1;
  }
  var _createSet;
  var hasRequired_createSet;
  function require_createSet() {
    if (hasRequired_createSet)
      return _createSet;
    hasRequired_createSet = 1;
    var Set4 = require_Set(), noop2 = requireNoop(), setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set4 && 1 / setToArray(new Set4([, -0]))[1] == INFINITY) ? noop2 : function(values) {
      return new Set4(values);
    };
    _createSet = createSet;
    return _createSet;
  }
  var _baseUniq;
  var hasRequired_baseUniq;
  function require_baseUniq() {
    if (hasRequired_baseUniq)
      return _baseUniq;
    hasRequired_baseUniq = 1;
    var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array2, iteratee, comparator) {
      var index2 = -1, includes2 = arrayIncludes, length2 = array2.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes2 = arrayIncludesWith;
      } else if (length2 >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee ? null : createSet(array2);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes2 = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index2 < length2) {
          var value = array2[index2], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes2(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    _baseUniq = baseUniq;
    return _baseUniq;
  }
  var isArrayLikeObject_1;
  var hasRequiredIsArrayLikeObject;
  function requireIsArrayLikeObject() {
    if (hasRequiredIsArrayLikeObject)
      return isArrayLikeObject_1;
    hasRequiredIsArrayLikeObject = 1;
    var isArrayLike = requireIsArrayLike(), isObjectLike = requireIsObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    isArrayLikeObject_1 = isArrayLikeObject;
    return isArrayLikeObject_1;
  }
  var union_1;
  var hasRequiredUnion;
  function requireUnion() {
    if (hasRequiredUnion)
      return union_1;
    hasRequiredUnion = 1;
    var baseFlatten = require_baseFlatten(), baseRest = require_baseRest(), baseUniq = require_baseUniq(), isArrayLikeObject = requireIsArrayLikeObject();
    var union2 = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    union_1 = union2;
    return union_1;
  }
  var _baseValues;
  var hasRequired_baseValues;
  function require_baseValues() {
    if (hasRequired_baseValues)
      return _baseValues;
    hasRequired_baseValues = 1;
    var arrayMap = require_arrayMap();
    function baseValues(object2, props) {
      return arrayMap(props, function(key) {
        return object2[key];
      });
    }
    _baseValues = baseValues;
    return _baseValues;
  }
  var values_1;
  var hasRequiredValues;
  function requireValues() {
    if (hasRequiredValues)
      return values_1;
    hasRequiredValues = 1;
    var baseValues = require_baseValues(), keys = requireKeys();
    function values(object2) {
      return object2 == null ? [] : baseValues(object2, keys(object2));
    }
    values_1 = values;
    return values_1;
  }
  var lodash$1;
  if (typeof commonjsRequire === "function") {
    try {
      lodash$1 = {
        clone: requireClone(),
        constant: requireConstant(),
        each: requireEach(),
        filter: requireFilter(),
        has: requireHas(),
        isArray: requireIsArray(),
        isEmpty: requireIsEmpty(),
        isFunction: isFunction_1,
        isUndefined: requireIsUndefined(),
        keys: requireKeys(),
        map: requireMap(),
        reduce: requireReduce(),
        size: requireSize(),
        transform: requireTransform(),
        union: requireUnion(),
        values: requireValues()
      };
    } catch (e) {
    }
  }
  if (!lodash$1) {
    lodash$1 = window._;
  }
  var lodash_1$2 = lodash$1;
  var _$d = lodash_1$2;
  var graph = Graph$2;
  var DEFAULT_EDGE_NAME = "\0";
  var GRAPH_NODE = "\0";
  var EDGE_KEY_DELIM = "";
  function Graph$2(opts) {
    this._isDirected = _$d.has(opts, "directed") ? opts.directed : true;
    this._isMultigraph = _$d.has(opts, "multigraph") ? opts.multigraph : false;
    this._isCompound = _$d.has(opts, "compound") ? opts.compound : false;
    this._label = void 0;
    this._defaultNodeLabelFn = _$d.constant(void 0);
    this._defaultEdgeLabelFn = _$d.constant(void 0);
    this._nodes = {};
    if (this._isCompound) {
      this._parent = {};
      this._children = {};
      this._children[GRAPH_NODE] = {};
    }
    this._in = {};
    this._preds = {};
    this._out = {};
    this._sucs = {};
    this._edgeObjs = {};
    this._edgeLabels = {};
  }
  Graph$2.prototype._nodeCount = 0;
  Graph$2.prototype._edgeCount = 0;
  Graph$2.prototype.isDirected = function() {
    return this._isDirected;
  };
  Graph$2.prototype.isMultigraph = function() {
    return this._isMultigraph;
  };
  Graph$2.prototype.isCompound = function() {
    return this._isCompound;
  };
  Graph$2.prototype.setGraph = function(label) {
    this._label = label;
    return this;
  };
  Graph$2.prototype.graph = function() {
    return this._label;
  };
  Graph$2.prototype.setDefaultNodeLabel = function(newDefault) {
    if (!_$d.isFunction(newDefault)) {
      newDefault = _$d.constant(newDefault);
    }
    this._defaultNodeLabelFn = newDefault;
    return this;
  };
  Graph$2.prototype.nodeCount = function() {
    return this._nodeCount;
  };
  Graph$2.prototype.nodes = function() {
    return _$d.keys(this._nodes);
  };
  Graph$2.prototype.sources = function() {
    var self2 = this;
    return _$d.filter(this.nodes(), function(v) {
      return _$d.isEmpty(self2._in[v]);
    });
  };
  Graph$2.prototype.sinks = function() {
    var self2 = this;
    return _$d.filter(this.nodes(), function(v) {
      return _$d.isEmpty(self2._out[v]);
    });
  };
  Graph$2.prototype.setNodes = function(vs, value) {
    var args = arguments;
    var self2 = this;
    _$d.each(vs, function(v) {
      if (args.length > 1) {
        self2.setNode(v, value);
      } else {
        self2.setNode(v);
      }
    });
    return this;
  };
  Graph$2.prototype.setNode = function(v, value) {
    if (_$d.has(this._nodes, v)) {
      if (arguments.length > 1) {
        this._nodes[v] = value;
      }
      return this;
    }
    this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
    if (this._isCompound) {
      this._parent[v] = GRAPH_NODE;
      this._children[v] = {};
      this._children[GRAPH_NODE][v] = true;
    }
    this._in[v] = {};
    this._preds[v] = {};
    this._out[v] = {};
    this._sucs[v] = {};
    ++this._nodeCount;
    return this;
  };
  Graph$2.prototype.node = function(v) {
    return this._nodes[v];
  };
  Graph$2.prototype.hasNode = function(v) {
    return _$d.has(this._nodes, v);
  };
  Graph$2.prototype.removeNode = function(v) {
    var self2 = this;
    if (_$d.has(this._nodes, v)) {
      var removeEdge = function(e) {
        self2.removeEdge(self2._edgeObjs[e]);
      };
      delete this._nodes[v];
      if (this._isCompound) {
        this._removeFromParentsChildList(v);
        delete this._parent[v];
        _$d.each(this.children(v), function(child) {
          self2.setParent(child);
        });
        delete this._children[v];
      }
      _$d.each(_$d.keys(this._in[v]), removeEdge);
      delete this._in[v];
      delete this._preds[v];
      _$d.each(_$d.keys(this._out[v]), removeEdge);
      delete this._out[v];
      delete this._sucs[v];
      --this._nodeCount;
    }
    return this;
  };
  Graph$2.prototype.setParent = function(v, parent) {
    if (!this._isCompound) {
      throw new Error("Cannot set parent in a non-compound graph");
    }
    if (_$d.isUndefined(parent)) {
      parent = GRAPH_NODE;
    } else {
      parent += "";
      for (var ancestor = parent; !_$d.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
        if (ancestor === v) {
          throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
        }
      }
      this.setNode(parent);
    }
    this.setNode(v);
    this._removeFromParentsChildList(v);
    this._parent[v] = parent;
    this._children[parent][v] = true;
    return this;
  };
  Graph$2.prototype._removeFromParentsChildList = function(v) {
    delete this._children[this._parent[v]][v];
  };
  Graph$2.prototype.parent = function(v) {
    if (this._isCompound) {
      var parent = this._parent[v];
      if (parent !== GRAPH_NODE) {
        return parent;
      }
    }
  };
  Graph$2.prototype.children = function(v) {
    if (_$d.isUndefined(v)) {
      v = GRAPH_NODE;
    }
    if (this._isCompound) {
      var children2 = this._children[v];
      if (children2) {
        return _$d.keys(children2);
      }
    } else if (v === GRAPH_NODE) {
      return this.nodes();
    } else if (this.hasNode(v)) {
      return [];
    }
  };
  Graph$2.prototype.predecessors = function(v) {
    var predsV = this._preds[v];
    if (predsV) {
      return _$d.keys(predsV);
    }
  };
  Graph$2.prototype.successors = function(v) {
    var sucsV = this._sucs[v];
    if (sucsV) {
      return _$d.keys(sucsV);
    }
  };
  Graph$2.prototype.neighbors = function(v) {
    var preds = this.predecessors(v);
    if (preds) {
      return _$d.union(preds, this.successors(v));
    }
  };
  Graph$2.prototype.isLeaf = function(v) {
    var neighbors;
    if (this.isDirected()) {
      neighbors = this.successors(v);
    } else {
      neighbors = this.neighbors(v);
    }
    return neighbors.length === 0;
  };
  Graph$2.prototype.filterNodes = function(filter2) {
    var copy2 = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    copy2.setGraph(this.graph());
    var self2 = this;
    _$d.each(this._nodes, function(value, v) {
      if (filter2(v)) {
        copy2.setNode(v, value);
      }
    });
    _$d.each(this._edgeObjs, function(e) {
      if (copy2.hasNode(e.v) && copy2.hasNode(e.w)) {
        copy2.setEdge(e, self2.edge(e));
      }
    });
    var parents2 = {};
    function findParent(v) {
      var parent = self2.parent(v);
      if (parent === void 0 || copy2.hasNode(parent)) {
        parents2[v] = parent;
        return parent;
      } else if (parent in parents2) {
        return parents2[parent];
      } else {
        return findParent(parent);
      }
    }
    if (this._isCompound) {
      _$d.each(copy2.nodes(), function(v) {
        copy2.setParent(v, findParent(v));
      });
    }
    return copy2;
  };
  Graph$2.prototype.setDefaultEdgeLabel = function(newDefault) {
    if (!_$d.isFunction(newDefault)) {
      newDefault = _$d.constant(newDefault);
    }
    this._defaultEdgeLabelFn = newDefault;
    return this;
  };
  Graph$2.prototype.edgeCount = function() {
    return this._edgeCount;
  };
  Graph$2.prototype.edges = function() {
    return _$d.values(this._edgeObjs);
  };
  Graph$2.prototype.setPath = function(vs, value) {
    var self2 = this;
    var args = arguments;
    _$d.reduce(vs, function(v, w2) {
      if (args.length > 1) {
        self2.setEdge(v, w2, value);
      } else {
        self2.setEdge(v, w2);
      }
      return w2;
    });
    return this;
  };
  Graph$2.prototype.setEdge = function() {
    var v, w2, name2, value;
    var valueSpecified = false;
    var arg0 = arguments[0];
    if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
      v = arg0.v;
      w2 = arg0.w;
      name2 = arg0.name;
      if (arguments.length === 2) {
        value = arguments[1];
        valueSpecified = true;
      }
    } else {
      v = arg0;
      w2 = arguments[1];
      name2 = arguments[3];
      if (arguments.length > 2) {
        value = arguments[2];
        valueSpecified = true;
      }
    }
    v = "" + v;
    w2 = "" + w2;
    if (!_$d.isUndefined(name2)) {
      name2 = "" + name2;
    }
    var e = edgeArgsToId(this._isDirected, v, w2, name2);
    if (_$d.has(this._edgeLabels, e)) {
      if (valueSpecified) {
        this._edgeLabels[e] = value;
      }
      return this;
    }
    if (!_$d.isUndefined(name2) && !this._isMultigraph) {
      throw new Error("Cannot set a named edge when isMultigraph = false");
    }
    this.setNode(v);
    this.setNode(w2);
    this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w2, name2);
    var edgeObj = edgeArgsToObj(this._isDirected, v, w2, name2);
    v = edgeObj.v;
    w2 = edgeObj.w;
    Object.freeze(edgeObj);
    this._edgeObjs[e] = edgeObj;
    incrementOrInitEntry(this._preds[w2], v);
    incrementOrInitEntry(this._sucs[v], w2);
    this._in[w2][e] = edgeObj;
    this._out[v][e] = edgeObj;
    this._edgeCount++;
    return this;
  };
  Graph$2.prototype.edge = function(v, w2, name2) {
    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
    return this._edgeLabels[e];
  };
  Graph$2.prototype.hasEdge = function(v, w2, name2) {
    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
    return _$d.has(this._edgeLabels, e);
  };
  Graph$2.prototype.removeEdge = function(v, w2, name2) {
    var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
    var edge = this._edgeObjs[e];
    if (edge) {
      v = edge.v;
      w2 = edge.w;
      delete this._edgeLabels[e];
      delete this._edgeObjs[e];
      decrementOrRemoveEntry(this._preds[w2], v);
      decrementOrRemoveEntry(this._sucs[v], w2);
      delete this._in[w2][e];
      delete this._out[v][e];
      this._edgeCount--;
    }
    return this;
  };
  Graph$2.prototype.inEdges = function(v, u2) {
    var inV = this._in[v];
    if (inV) {
      var edges2 = _$d.values(inV);
      if (!u2) {
        return edges2;
      }
      return _$d.filter(edges2, function(edge) {
        return edge.v === u2;
      });
    }
  };
  Graph$2.prototype.outEdges = function(v, w2) {
    var outV = this._out[v];
    if (outV) {
      var edges2 = _$d.values(outV);
      if (!w2) {
        return edges2;
      }
      return _$d.filter(edges2, function(edge) {
        return edge.w === w2;
      });
    }
  };
  Graph$2.prototype.nodeEdges = function(v, w2) {
    var inEdges = this.inEdges(v, w2);
    if (inEdges) {
      return inEdges.concat(this.outEdges(v, w2));
    }
  };
  function incrementOrInitEntry(map2, k2) {
    if (map2[k2]) {
      map2[k2]++;
    } else {
      map2[k2] = 1;
    }
  }
  function decrementOrRemoveEntry(map2, k2) {
    if (!--map2[k2]) {
      delete map2[k2];
    }
  }
  function edgeArgsToId(isDirected, v_, w_, name2) {
    var v = "" + v_;
    var w2 = "" + w_;
    if (!isDirected && v > w2) {
      var tmp = v;
      v = w2;
      w2 = tmp;
    }
    return v + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (_$d.isUndefined(name2) ? DEFAULT_EDGE_NAME : name2);
  }
  function edgeArgsToObj(isDirected, v_, w_, name2) {
    var v = "" + v_;
    var w2 = "" + w_;
    if (!isDirected && v > w2) {
      var tmp = v;
      v = w2;
      w2 = tmp;
    }
    var edgeObj = { v, w: w2 };
    if (name2) {
      edgeObj.name = name2;
    }
    return edgeObj;
  }
  function edgeObjToId(isDirected, edgeObj) {
    return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
  }
  var version$3 = "2.1.8";
  var lib$1 = {
    Graph: graph,
    version: version$3
  };
  var _$c = lodash_1$2;
  var Graph$1 = graph;
  var json = {
    write,
    read
  };
  function write(g) {
    var json2 = {
      options: {
        directed: g.isDirected(),
        multigraph: g.isMultigraph(),
        compound: g.isCompound()
      },
      nodes: writeNodes(g),
      edges: writeEdges(g)
    };
    if (!_$c.isUndefined(g.graph())) {
      json2.value = _$c.clone(g.graph());
    }
    return json2;
  }
  function writeNodes(g) {
    return _$c.map(g.nodes(), function(v) {
      var nodeValue = g.node(v);
      var parent = g.parent(v);
      var node2 = { v };
      if (!_$c.isUndefined(nodeValue)) {
        node2.value = nodeValue;
      }
      if (!_$c.isUndefined(parent)) {
        node2.parent = parent;
      }
      return node2;
    });
  }
  function writeEdges(g) {
    return _$c.map(g.edges(), function(e) {
      var edgeValue = g.edge(e);
      var edge = { v: e.v, w: e.w };
      if (!_$c.isUndefined(e.name)) {
        edge.name = e.name;
      }
      if (!_$c.isUndefined(edgeValue)) {
        edge.value = edgeValue;
      }
      return edge;
    });
  }
  function read(json2) {
    var g = new Graph$1(json2.options).setGraph(json2.value);
    _$c.each(json2.nodes, function(entry) {
      g.setNode(entry.v, entry.value);
      if (entry.parent) {
        g.setParent(entry.v, entry.parent);
      }
    });
    _$c.each(json2.edges, function(entry) {
      g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
    });
    return g;
  }
  var _$b = lodash_1$2;
  var components_1 = components;
  function components(g) {
    var visited = {};
    var cmpts = [];
    var cmpt;
    function dfs2(v) {
      if (_$b.has(visited, v))
        return;
      visited[v] = true;
      cmpt.push(v);
      _$b.each(g.successors(v), dfs2);
      _$b.each(g.predecessors(v), dfs2);
    }
    _$b.each(g.nodes(), function(v) {
      cmpt = [];
      dfs2(v);
      if (cmpt.length) {
        cmpts.push(cmpt);
      }
    });
    return cmpts;
  }
  var _$a = lodash_1$2;
  var priorityQueue = PriorityQueue$2;
  function PriorityQueue$2() {
    this._arr = [];
    this._keyIndices = {};
  }
  PriorityQueue$2.prototype.size = function() {
    return this._arr.length;
  };
  PriorityQueue$2.prototype.keys = function() {
    return this._arr.map(function(x2) {
      return x2.key;
    });
  };
  PriorityQueue$2.prototype.has = function(key) {
    return _$a.has(this._keyIndices, key);
  };
  PriorityQueue$2.prototype.priority = function(key) {
    var index2 = this._keyIndices[key];
    if (index2 !== void 0) {
      return this._arr[index2].priority;
    }
  };
  PriorityQueue$2.prototype.min = function() {
    if (this.size() === 0) {
      throw new Error("Queue underflow");
    }
    return this._arr[0].key;
  };
  PriorityQueue$2.prototype.add = function(key, priority) {
    var keyIndices = this._keyIndices;
    key = String(key);
    if (!_$a.has(keyIndices, key)) {
      var arr = this._arr;
      var index2 = arr.length;
      keyIndices[key] = index2;
      arr.push({ key, priority });
      this._decrease(index2);
      return true;
    }
    return false;
  };
  PriorityQueue$2.prototype.removeMin = function() {
    this._swap(0, this._arr.length - 1);
    var min2 = this._arr.pop();
    delete this._keyIndices[min2.key];
    this._heapify(0);
    return min2.key;
  };
  PriorityQueue$2.prototype.decrease = function(key, priority) {
    var index2 = this._keyIndices[key];
    if (priority > this._arr[index2].priority) {
      throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
    }
    this._arr[index2].priority = priority;
    this._decrease(index2);
  };
  PriorityQueue$2.prototype._heapify = function(i) {
    var arr = this._arr;
    var l = 2 * i;
    var r = l + 1;
    var largest = i;
    if (l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if (r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if (largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  };
  PriorityQueue$2.prototype._decrease = function(index2) {
    var arr = this._arr;
    var priority = arr[index2].priority;
    var parent;
    while (index2 !== 0) {
      parent = index2 >> 1;
      if (arr[parent].priority < priority) {
        break;
      }
      this._swap(index2, parent);
      index2 = parent;
    }
  };
  PriorityQueue$2.prototype._swap = function(i, j) {
    var arr = this._arr;
    var keyIndices = this._keyIndices;
    var origArrI = arr[i];
    var origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices[origArrJ.key] = i;
    keyIndices[origArrI.key] = j;
  };
  var _$9 = lodash_1$2;
  var PriorityQueue$1 = priorityQueue;
  var dijkstra_1 = dijkstra$1;
  var DEFAULT_WEIGHT_FUNC$1 = _$9.constant(1);
  function dijkstra$1(g, source, weightFn, edgeFn) {
    return runDijkstra(
      g,
      String(source),
      weightFn || DEFAULT_WEIGHT_FUNC$1,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runDijkstra(g, source, weightFn, edgeFn) {
    var results = {};
    var pq = new PriorityQueue$1();
    var v, vEntry;
    var updateNeighbors = function(edge) {
      var w2 = edge.v !== v ? edge.v : edge.w;
      var wEntry = results[w2];
      var weight = weightFn(edge);
      var distance2 = vEntry.distance + weight;
      if (weight < 0) {
        throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
      }
      if (distance2 < wEntry.distance) {
        wEntry.distance = distance2;
        wEntry.predecessor = v;
        pq.decrease(w2, distance2);
      }
    };
    g.nodes().forEach(function(v2) {
      var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
      results[v2] = { distance: distance2 };
      pq.add(v2, distance2);
    });
    while (pq.size() > 0) {
      v = pq.removeMin();
      vEntry = results[v];
      if (vEntry.distance === Number.POSITIVE_INFINITY) {
        break;
      }
      edgeFn(v).forEach(updateNeighbors);
    }
    return results;
  }
  var dijkstra = dijkstra_1;
  var _$8 = lodash_1$2;
  var dijkstraAll_1 = dijkstraAll;
  function dijkstraAll(g, weightFunc, edgeFunc) {
    return _$8.transform(g.nodes(), function(acc, v) {
      acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
    }, {});
  }
  var _$7 = lodash_1$2;
  var tarjan_1 = tarjan$1;
  function tarjan$1(g) {
    var index2 = 0;
    var stack2 = [];
    var visited = {};
    var results = [];
    function dfs2(v) {
      var entry = visited[v] = {
        onStack: true,
        lowlink: index2,
        index: index2++
      };
      stack2.push(v);
      g.successors(v).forEach(function(w3) {
        if (!_$7.has(visited, w3)) {
          dfs2(w3);
          entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink);
        } else if (visited[w3].onStack) {
          entry.lowlink = Math.min(entry.lowlink, visited[w3].index);
        }
      });
      if (entry.lowlink === entry.index) {
        var cmpt = [];
        var w2;
        do {
          w2 = stack2.pop();
          visited[w2].onStack = false;
          cmpt.push(w2);
        } while (v !== w2);
        results.push(cmpt);
      }
    }
    g.nodes().forEach(function(v) {
      if (!_$7.has(visited, v)) {
        dfs2(v);
      }
    });
    return results;
  }
  var _$6 = lodash_1$2;
  var tarjan = tarjan_1;
  var findCycles_1 = findCycles;
  function findCycles(g) {
    return _$6.filter(tarjan(g), function(cmpt) {
      return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
    });
  }
  var _$5 = lodash_1$2;
  var floydWarshall_1 = floydWarshall;
  var DEFAULT_WEIGHT_FUNC = _$5.constant(1);
  function floydWarshall(g, weightFn, edgeFn) {
    return runFloydWarshall(
      g,
      weightFn || DEFAULT_WEIGHT_FUNC,
      edgeFn || function(v) {
        return g.outEdges(v);
      }
    );
  }
  function runFloydWarshall(g, weightFn, edgeFn) {
    var results = {};
    var nodes = g.nodes();
    nodes.forEach(function(v) {
      results[v] = {};
      results[v][v] = { distance: 0 };
      nodes.forEach(function(w2) {
        if (v !== w2) {
          results[v][w2] = { distance: Number.POSITIVE_INFINITY };
        }
      });
      edgeFn(v).forEach(function(edge) {
        var w2 = edge.v === v ? edge.w : edge.v;
        var d = weightFn(edge);
        results[v][w2] = { distance: d, predecessor: v };
      });
    });
    nodes.forEach(function(k2) {
      var rowK = results[k2];
      nodes.forEach(function(i) {
        var rowI = results[i];
        nodes.forEach(function(j) {
          var ik = rowI[k2];
          var kj = rowK[j];
          var ij = rowI[j];
          var altDistance = ik.distance + kj.distance;
          if (altDistance < ij.distance) {
            ij.distance = altDistance;
            ij.predecessor = kj.predecessor;
          }
        });
      });
    });
    return results;
  }
  var _$4 = lodash_1$2;
  var topsort_1 = topsort$1;
  topsort$1.CycleException = CycleException;
  function topsort$1(g) {
    var visited = {};
    var stack2 = {};
    var results = [];
    function visit(node2) {
      if (_$4.has(stack2, node2)) {
        throw new CycleException();
      }
      if (!_$4.has(visited, node2)) {
        stack2[node2] = true;
        visited[node2] = true;
        _$4.each(g.predecessors(node2), visit);
        delete stack2[node2];
        results.push(node2);
      }
    }
    _$4.each(g.sinks(), visit);
    if (_$4.size(visited) !== g.nodeCount()) {
      throw new CycleException();
    }
    return results;
  }
  function CycleException() {
  }
  CycleException.prototype = new Error();
  var topsort = topsort_1;
  var isAcyclic_1 = isAcyclic;
  function isAcyclic(g) {
    try {
      topsort(g);
    } catch (e) {
      if (e instanceof topsort.CycleException) {
        return false;
      }
      throw e;
    }
    return true;
  }
  var _$3 = lodash_1$2;
  var dfs_1 = dfs$2;
  function dfs$2(g, vs, order) {
    if (!_$3.isArray(vs)) {
      vs = [vs];
    }
    var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
    var acc = [];
    var visited = {};
    _$3.each(vs, function(v) {
      if (!g.hasNode(v)) {
        throw new Error("Graph does not have node: " + v);
      }
      doDfs(g, v, order === "post", visited, navigation, acc);
    });
    return acc;
  }
  function doDfs(g, v, postorder2, visited, navigation, acc) {
    if (!_$3.has(visited, v)) {
      visited[v] = true;
      if (!postorder2) {
        acc.push(v);
      }
      _$3.each(navigation(v), function(w2) {
        doDfs(g, w2, postorder2, visited, navigation, acc);
      });
      if (postorder2) {
        acc.push(v);
      }
    }
  }
  var dfs$1 = dfs_1;
  var postorder_1 = postorder;
  function postorder(g, vs) {
    return dfs$1(g, vs, "post");
  }
  var dfs = dfs_1;
  var preorder_1 = preorder;
  function preorder(g, vs) {
    return dfs(g, vs, "pre");
  }
  var _$2 = lodash_1$2;
  var Graph = graph;
  var PriorityQueue = priorityQueue;
  var prim_1 = prim;
  function prim(g, weightFunc) {
    var result = new Graph();
    var parents2 = {};
    var pq = new PriorityQueue();
    var v;
    function updateNeighbors(edge) {
      var w2 = edge.v === v ? edge.w : edge.v;
      var pri = pq.priority(w2);
      if (pri !== void 0) {
        var edgeWeight = weightFunc(edge);
        if (edgeWeight < pri) {
          parents2[w2] = v;
          pq.decrease(w2, edgeWeight);
        }
      }
    }
    if (g.nodeCount() === 0) {
      return result;
    }
    _$2.each(g.nodes(), function(v2) {
      pq.add(v2, Number.POSITIVE_INFINITY);
      result.setNode(v2);
    });
    pq.decrease(g.nodes()[0], 0);
    var init2 = false;
    while (pq.size() > 0) {
      v = pq.removeMin();
      if (_$2.has(parents2, v)) {
        result.setEdge(v, parents2[v]);
      } else if (init2) {
        throw new Error("Input graph is not connected: " + g);
      } else {
        init2 = true;
      }
      g.nodeEdges(v).forEach(updateNeighbors);
    }
    return result;
  }
  var alg = {
    components: components_1,
    dijkstra: dijkstra_1,
    dijkstraAll: dijkstraAll_1,
    findCycles: findCycles_1,
    floydWarshall: floydWarshall_1,
    isAcyclic: isAcyclic_1,
    postorder: postorder_1,
    preorder: preorder_1,
    prim: prim_1,
    tarjan: tarjan_1,
    topsort: topsort_1
  };
  var lib = lib$1;
  var graphlib$1 = {
    Graph: lib.Graph,
    json,
    alg,
    version: lib.version
  };
  var graphlib_1$1;
  var hasRequiredGraphlib;
  function requireGraphlib() {
    if (hasRequiredGraphlib)
      return graphlib_1$1;
    hasRequiredGraphlib = 1;
    var graphlib2;
    if (typeof commonjsRequire === "function") {
      try {
        graphlib2 = graphlib$1;
      } catch (e) {
      }
    }
    if (!graphlib2) {
      graphlib2 = window.graphlib;
    }
    graphlib_1$1 = graphlib2;
    return graphlib_1$1;
  }
  var cloneDeep_1;
  var hasRequiredCloneDeep;
  function requireCloneDeep() {
    if (hasRequiredCloneDeep)
      return cloneDeep_1;
    hasRequiredCloneDeep = 1;
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    cloneDeep_1 = cloneDeep;
    return cloneDeep_1;
  }
  var _isIterateeCall;
  var hasRequired_isIterateeCall;
  function require_isIterateeCall() {
    if (hasRequired_isIterateeCall)
      return _isIterateeCall;
    hasRequired_isIterateeCall = 1;
    var eq2 = eq_1, isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject2 = isObject_1;
    function isIterateeCall(value, index2, object2) {
      if (!isObject2(object2)) {
        return false;
      }
      var type2 = typeof index2;
      if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
        return eq2(object2[index2], value);
      }
      return false;
    }
    _isIterateeCall = isIterateeCall;
    return _isIterateeCall;
  }
  var defaults_1;
  var hasRequiredDefaults;
  function requireDefaults() {
    if (hasRequiredDefaults)
      return defaults_1;
    hasRequiredDefaults = 1;
    var baseRest = require_baseRest(), eq2 = eq_1, isIterateeCall = require_isIterateeCall(), keysIn = requireKeysIn();
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var defaults = baseRest(function(object2, sources) {
      object2 = Object(object2);
      var index2 = -1;
      var length2 = sources.length;
      var guard = length2 > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length2 = 1;
      }
      while (++index2 < length2) {
        var source = sources[index2];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object2[key];
          if (value === void 0 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
            object2[key] = source[key];
          }
        }
      }
      return object2;
    });
    defaults_1 = defaults;
    return defaults_1;
  }
  var _createFind;
  var hasRequired_createFind;
  function require_createFind() {
    if (hasRequired_createFind)
      return _createFind;
    hasRequired_createFind = 1;
    var baseIteratee = require_baseIteratee(), isArrayLike = requireIsArrayLike(), keys = requireKeys();
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = baseIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) {
            return iteratee(iterable[key], key, iterable);
          };
        }
        var index2 = findIndexFunc(collection, predicate, fromIndex);
        return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
      };
    }
    _createFind = createFind;
    return _createFind;
  }
  var _trimmedEndIndex;
  var hasRequired_trimmedEndIndex;
  function require_trimmedEndIndex() {
    if (hasRequired_trimmedEndIndex)
      return _trimmedEndIndex;
    hasRequired_trimmedEndIndex = 1;
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    _trimmedEndIndex = trimmedEndIndex;
    return _trimmedEndIndex;
  }
  var _baseTrim;
  var hasRequired_baseTrim;
  function require_baseTrim() {
    if (hasRequired_baseTrim)
      return _baseTrim;
    hasRequired_baseTrim = 1;
    var trimmedEndIndex = require_trimmedEndIndex();
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    _baseTrim = baseTrim;
    return _baseTrim;
  }
  var toNumber_1;
  var hasRequiredToNumber;
  function requireToNumber() {
    if (hasRequiredToNumber)
      return toNumber_1;
    hasRequiredToNumber = 1;
    var baseTrim = require_baseTrim(), isObject2 = isObject_1, isSymbol = requireIsSymbol();
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    toNumber_1 = toNumber;
    return toNumber_1;
  }
  var toFinite_1;
  var hasRequiredToFinite;
  function requireToFinite() {
    if (hasRequiredToFinite)
      return toFinite_1;
    hasRequiredToFinite = 1;
    var toNumber = requireToNumber();
    var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign2 = value < 0 ? -1 : 1;
        return sign2 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    toFinite_1 = toFinite;
    return toFinite_1;
  }
  var toInteger_1;
  var hasRequiredToInteger;
  function requireToInteger() {
    if (hasRequiredToInteger)
      return toInteger_1;
    hasRequiredToInteger = 1;
    var toFinite = requireToFinite();
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    toInteger_1 = toInteger;
    return toInteger_1;
  }
  var findIndex_1;
  var hasRequiredFindIndex;
  function requireFindIndex() {
    if (hasRequiredFindIndex)
      return findIndex_1;
    hasRequiredFindIndex = 1;
    var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
    var nativeMax = Math.max;
    function findIndex(array2, predicate, fromIndex) {
      var length2 = array2 == null ? 0 : array2.length;
      if (!length2) {
        return -1;
      }
      var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index2 < 0) {
        index2 = nativeMax(length2 + index2, 0);
      }
      return baseFindIndex(array2, baseIteratee(predicate, 3), index2);
    }
    findIndex_1 = findIndex;
    return findIndex_1;
  }
  var find_1;
  var hasRequiredFind;
  function requireFind() {
    if (hasRequiredFind)
      return find_1;
    hasRequiredFind = 1;
    var createFind = require_createFind(), findIndex = requireFindIndex();
    var find2 = createFind(findIndex);
    find_1 = find2;
    return find_1;
  }
  var flatten_1;
  var hasRequiredFlatten;
  function requireFlatten() {
    if (hasRequiredFlatten)
      return flatten_1;
    hasRequiredFlatten = 1;
    var baseFlatten = require_baseFlatten();
    function flatten2(array2) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? baseFlatten(array2, 1) : [];
    }
    flatten_1 = flatten2;
    return flatten_1;
  }
  var forIn_1;
  var hasRequiredForIn;
  function requireForIn() {
    if (hasRequiredForIn)
      return forIn_1;
    hasRequiredForIn = 1;
    var baseFor = require_baseFor(), castFunction = require_castFunction(), keysIn = requireKeysIn();
    function forIn(object2, iteratee) {
      return object2 == null ? object2 : baseFor(object2, castFunction(iteratee), keysIn);
    }
    forIn_1 = forIn;
    return forIn_1;
  }
  var last_1;
  var hasRequiredLast;
  function requireLast() {
    if (hasRequiredLast)
      return last_1;
    hasRequiredLast = 1;
    function last(array2) {
      var length2 = array2 == null ? 0 : array2.length;
      return length2 ? array2[length2 - 1] : void 0;
    }
    last_1 = last;
    return last_1;
  }
  var mapValues_1;
  var hasRequiredMapValues;
  function requireMapValues() {
    if (hasRequiredMapValues)
      return mapValues_1;
    hasRequiredMapValues = 1;
    var baseAssignValue = require_baseAssignValue(), baseForOwn = require_baseForOwn(), baseIteratee = require_baseIteratee();
    function mapValues(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee(iteratee, 3);
      baseForOwn(object2, function(value, key, object3) {
        baseAssignValue(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    mapValues_1 = mapValues;
    return mapValues_1;
  }
  var _baseExtremum;
  var hasRequired_baseExtremum;
  function require_baseExtremum() {
    if (hasRequired_baseExtremum)
      return _baseExtremum;
    hasRequired_baseExtremum = 1;
    var isSymbol = requireIsSymbol();
    function baseExtremum(array2, iteratee, comparator) {
      var index2 = -1, length2 = array2.length;
      while (++index2 < length2) {
        var value = array2[index2], current = iteratee(value);
        if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
          var computed = current, result = value;
        }
      }
      return result;
    }
    _baseExtremum = baseExtremum;
    return _baseExtremum;
  }
  var _baseGt;
  var hasRequired_baseGt;
  function require_baseGt() {
    if (hasRequired_baseGt)
      return _baseGt;
    hasRequired_baseGt = 1;
    function baseGt(value, other) {
      return value > other;
    }
    _baseGt = baseGt;
    return _baseGt;
  }
  var max_1;
  var hasRequiredMax;
  function requireMax() {
    if (hasRequiredMax)
      return max_1;
    hasRequiredMax = 1;
    var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity2 = requireIdentity();
    function max2(array2) {
      return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : void 0;
    }
    max_1 = max2;
    return max_1;
  }
  var _assignMergeValue;
  var hasRequired_assignMergeValue;
  function require_assignMergeValue() {
    if (hasRequired_assignMergeValue)
      return _assignMergeValue;
    hasRequired_assignMergeValue = 1;
    var baseAssignValue = require_baseAssignValue(), eq2 = eq_1;
    function assignMergeValue(object2, key, value) {
      if (value !== void 0 && !eq2(object2[key], value) || value === void 0 && !(key in object2)) {
        baseAssignValue(object2, key, value);
      }
    }
    _assignMergeValue = assignMergeValue;
    return _assignMergeValue;
  }
  var isPlainObject_1;
  var hasRequiredIsPlainObject;
  function requireIsPlainObject() {
    if (hasRequiredIsPlainObject)
      return isPlainObject_1;
    hasRequiredIsPlainObject = 1;
    var baseGetTag2 = _baseGetTag, getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
    var objectTag = "[object Object]";
    var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
    var funcToString2 = funcProto2.toString;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var objectCtorString = funcToString2.call(Object);
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag2(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
    }
    isPlainObject_1 = isPlainObject;
    return isPlainObject_1;
  }
  var _safeGet;
  var hasRequired_safeGet;
  function require_safeGet() {
    if (hasRequired_safeGet)
      return _safeGet;
    hasRequired_safeGet = 1;
    function safeGet(object2, key) {
      if (key === "constructor" && typeof object2[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object2[key];
    }
    _safeGet = safeGet;
    return _safeGet;
  }
  var toPlainObject_1;
  var hasRequiredToPlainObject;
  function requireToPlainObject() {
    if (hasRequiredToPlainObject)
      return toPlainObject_1;
    hasRequiredToPlainObject = 1;
    var copyObject = require_copyObject(), keysIn = requireKeysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    toPlainObject_1 = toPlainObject;
    return toPlainObject_1;
  }
  var _baseMergeDeep;
  var hasRequired_baseMergeDeep;
  function require_baseMergeDeep() {
    if (hasRequired_baseMergeDeep)
      return _baseMergeDeep;
    hasRequired_baseMergeDeep = 1;
    var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments = requireIsArguments(), isArray = requireIsArray(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer(), isFunction2 = isFunction_1, isObject2 = isObject_1, isPlainObject = requireIsPlainObject(), isTypedArray = requireIsTypedArray(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
    function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
      var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
      if (stacked) {
        assignMergeValue(object2, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject2(objValue) || isFunction2(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack2.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
        stack2["delete"](srcValue);
      }
      assignMergeValue(object2, key, newValue);
    }
    _baseMergeDeep = baseMergeDeep;
    return _baseMergeDeep;
  }
  var _baseMerge;
  var hasRequired_baseMerge;
  function require_baseMerge() {
    if (hasRequired_baseMerge)
      return _baseMerge;
    hasRequired_baseMerge = 1;
    var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor(), baseMergeDeep = require_baseMergeDeep(), isObject2 = isObject_1, keysIn = requireKeysIn(), safeGet = require_safeGet();
    function baseMerge(object2, source, srcIndex, customizer, stack2) {
      if (object2 === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack2 || (stack2 = new Stack());
        if (isObject2(srcValue)) {
          baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
        } else {
          var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object2, key, newValue);
        }
      }, keysIn);
    }
    _baseMerge = baseMerge;
    return _baseMerge;
  }
  var _createAssigner;
  var hasRequired_createAssigner;
  function require_createAssigner() {
    if (hasRequired_createAssigner)
      return _createAssigner;
    hasRequired_createAssigner = 1;
    var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object2, sources) {
        var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length2 < 3 ? void 0 : customizer;
          length2 = 1;
        }
        object2 = Object(object2);
        while (++index2 < length2) {
          var source = sources[index2];
          if (source) {
            assigner(object2, source, index2, customizer);
          }
        }
        return object2;
      });
    }
    _createAssigner = createAssigner;
    return _createAssigner;
  }
  var merge_1;
  var hasRequiredMerge;
  function requireMerge() {
    if (hasRequiredMerge)
      return merge_1;
    hasRequiredMerge = 1;
    var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
    var merge2 = createAssigner(function(object2, source, srcIndex) {
      baseMerge(object2, source, srcIndex);
    });
    merge_1 = merge2;
    return merge_1;
  }
  var _baseLt;
  var hasRequired_baseLt;
  function require_baseLt() {
    if (hasRequired_baseLt)
      return _baseLt;
    hasRequired_baseLt = 1;
    function baseLt(value, other) {
      return value < other;
    }
    _baseLt = baseLt;
    return _baseLt;
  }
  var min_1;
  var hasRequiredMin;
  function requireMin() {
    if (hasRequiredMin)
      return min_1;
    hasRequiredMin = 1;
    var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity2 = requireIdentity();
    function min2(array2) {
      return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : void 0;
    }
    min_1 = min2;
    return min_1;
  }
  var minBy_1;
  var hasRequiredMinBy;
  function requireMinBy() {
    if (hasRequiredMinBy)
      return minBy_1;
    hasRequiredMinBy = 1;
    var baseExtremum = require_baseExtremum(), baseIteratee = require_baseIteratee(), baseLt = require_baseLt();
    function minBy(array2, iteratee) {
      return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee, 2), baseLt) : void 0;
    }
    minBy_1 = minBy;
    return minBy_1;
  }
  var now_1;
  var hasRequiredNow;
  function requireNow() {
    if (hasRequiredNow)
      return now_1;
    hasRequiredNow = 1;
    var root2 = _root;
    var now2 = function() {
      return root2.Date.now();
    };
    now_1 = now2;
    return now_1;
  }
  var _baseSet;
  var hasRequired_baseSet;
  function require_baseSet() {
    if (hasRequired_baseSet)
      return _baseSet;
    hasRequired_baseSet = 1;
    var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject2 = isObject_1, toKey = require_toKey();
    function baseSet(object2, path2, value, customizer) {
      if (!isObject2(object2)) {
        return object2;
      }
      path2 = castPath(path2, object2);
      var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
      while (nested != null && ++index2 < length2) {
        var key = toKey(path2[index2]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object2;
        }
        if (index2 != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object2;
    }
    _baseSet = baseSet;
    return _baseSet;
  }
  var _basePickBy;
  var hasRequired_basePickBy;
  function require_basePickBy() {
    if (hasRequired_basePickBy)
      return _basePickBy;
    hasRequired_basePickBy = 1;
    var baseGet = require_baseGet(), baseSet = require_baseSet(), castPath = require_castPath();
    function basePickBy(object2, paths, predicate) {
      var index2 = -1, length2 = paths.length, result = {};
      while (++index2 < length2) {
        var path2 = paths[index2], value = baseGet(object2, path2);
        if (predicate(value, path2)) {
          baseSet(result, castPath(path2, object2), value);
        }
      }
      return result;
    }
    _basePickBy = basePickBy;
    return _basePickBy;
  }
  var _basePick;
  var hasRequired_basePick;
  function require_basePick() {
    if (hasRequired_basePick)
      return _basePick;
    hasRequired_basePick = 1;
    var basePickBy = require_basePickBy(), hasIn = requireHasIn();
    function basePick(object2, paths) {
      return basePickBy(object2, paths, function(value, path2) {
        return hasIn(object2, path2);
      });
    }
    _basePick = basePick;
    return _basePick;
  }
  var _flatRest;
  var hasRequired_flatRest;
  function require_flatRest() {
    if (hasRequired_flatRest)
      return _flatRest;
    hasRequired_flatRest = 1;
    var flatten2 = requireFlatten(), overRest = require_overRest(), setToString = require_setToString();
    function flatRest(func) {
      return setToString(overRest(func, void 0, flatten2), func + "");
    }
    _flatRest = flatRest;
    return _flatRest;
  }
  var pick_1;
  var hasRequiredPick;
  function requirePick() {
    if (hasRequiredPick)
      return pick_1;
    hasRequiredPick = 1;
    var basePick = require_basePick(), flatRest = require_flatRest();
    var pick = flatRest(function(object2, paths) {
      return object2 == null ? {} : basePick(object2, paths);
    });
    pick_1 = pick;
    return pick_1;
  }
  var _baseRange;
  var hasRequired_baseRange;
  function require_baseRange() {
    if (hasRequired_baseRange)
      return _baseRange;
    hasRequired_baseRange = 1;
    var nativeCeil = Math.ceil, nativeMax = Math.max;
    function baseRange(start2, end2, step, fromRight) {
      var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step || 1)), 0), result = Array(length2);
      while (length2--) {
        result[fromRight ? length2 : ++index2] = start2;
        start2 += step;
      }
      return result;
    }
    _baseRange = baseRange;
    return _baseRange;
  }
  var _createRange;
  var hasRequired_createRange;
  function require_createRange() {
    if (hasRequired_createRange)
      return _createRange;
    hasRequired_createRange = 1;
    var baseRange = require_baseRange(), isIterateeCall = require_isIterateeCall(), toFinite = requireToFinite();
    function createRange(fromRight) {
      return function(start2, end2, step) {
        if (step && typeof step != "number" && isIterateeCall(start2, end2, step)) {
          end2 = step = void 0;
        }
        start2 = toFinite(start2);
        if (end2 === void 0) {
          end2 = start2;
          start2 = 0;
        } else {
          end2 = toFinite(end2);
        }
        step = step === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step);
        return baseRange(start2, end2, step, fromRight);
      };
    }
    _createRange = createRange;
    return _createRange;
  }
  var range_1;
  var hasRequiredRange;
  function requireRange() {
    if (hasRequiredRange)
      return range_1;
    hasRequiredRange = 1;
    var createRange = require_createRange();
    var range2 = createRange();
    range_1 = range2;
    return range_1;
  }
  var _baseSortBy;
  var hasRequired_baseSortBy;
  function require_baseSortBy() {
    if (hasRequired_baseSortBy)
      return _baseSortBy;
    hasRequired_baseSortBy = 1;
    function baseSortBy(array2, comparer) {
      var length2 = array2.length;
      array2.sort(comparer);
      while (length2--) {
        array2[length2] = array2[length2].value;
      }
      return array2;
    }
    _baseSortBy = baseSortBy;
    return _baseSortBy;
  }
  var _compareAscending;
  var hasRequired_compareAscending;
  function require_compareAscending() {
    if (hasRequired_compareAscending)
      return _compareAscending;
    hasRequired_compareAscending = 1;
    var isSymbol = requireIsSymbol();
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    _compareAscending = compareAscending;
    return _compareAscending;
  }
  var _compareMultiple;
  var hasRequired_compareMultiple;
  function require_compareMultiple() {
    if (hasRequired_compareMultiple)
      return _compareMultiple;
    hasRequired_compareMultiple = 1;
    var compareAscending = require_compareAscending();
    function compareMultiple(object2, other, orders) {
      var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
      while (++index2 < length2) {
        var result = compareAscending(objCriteria[index2], othCriteria[index2]);
        if (result) {
          if (index2 >= ordersLength) {
            return result;
          }
          var order = orders[index2];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object2.index - other.index;
    }
    _compareMultiple = compareMultiple;
    return _compareMultiple;
  }
  var _baseOrderBy;
  var hasRequired_baseOrderBy;
  function require_baseOrderBy() {
    if (hasRequired_baseOrderBy)
      return _baseOrderBy;
    hasRequired_baseOrderBy = 1;
    var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity(), isArray = requireIsArray();
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            };
          }
          return iteratee;
        });
      } else {
        iteratees = [identity2];
      }
      var index2 = -1;
      iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index2, "value": value };
      });
      return baseSortBy(result, function(object2, other) {
        return compareMultiple(object2, other, orders);
      });
    }
    _baseOrderBy = baseOrderBy;
    return _baseOrderBy;
  }
  var sortBy_1;
  var hasRequiredSortBy;
  function requireSortBy() {
    if (hasRequiredSortBy)
      return sortBy_1;
    hasRequiredSortBy = 1;
    var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length2 = iteratees.length;
      if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    sortBy_1 = sortBy;
    return sortBy_1;
  }
  var uniqueId_1;
  var hasRequiredUniqueId;
  function requireUniqueId() {
    if (hasRequiredUniqueId)
      return uniqueId_1;
    hasRequiredUniqueId = 1;
    var toString = requireToString();
    var idCounter = 0;
    function uniqueId(prefix) {
      var id2 = ++idCounter;
      return toString(prefix) + id2;
    }
    uniqueId_1 = uniqueId;
    return uniqueId_1;
  }
  var _baseZipObject;
  var hasRequired_baseZipObject;
  function require_baseZipObject() {
    if (hasRequired_baseZipObject)
      return _baseZipObject;
    hasRequired_baseZipObject = 1;
    function baseZipObject(props, values, assignFunc) {
      var index2 = -1, length2 = props.length, valsLength = values.length, result = {};
      while (++index2 < length2) {
        var value = index2 < valsLength ? values[index2] : void 0;
        assignFunc(result, props[index2], value);
      }
      return result;
    }
    _baseZipObject = baseZipObject;
    return _baseZipObject;
  }
  var zipObject_1;
  var hasRequiredZipObject;
  function requireZipObject() {
    if (hasRequiredZipObject)
      return zipObject_1;
    hasRequiredZipObject = 1;
    var assignValue = require_assignValue(), baseZipObject = require_baseZipObject();
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }
    zipObject_1 = zipObject;
    return zipObject_1;
  }
  var lodash_1$1;
  var hasRequiredLodash;
  function requireLodash() {
    if (hasRequiredLodash)
      return lodash_1$1;
    hasRequiredLodash = 1;
    var lodash2;
    if (typeof commonjsRequire === "function") {
      try {
        lodash2 = {
          cloneDeep: requireCloneDeep(),
          constant: requireConstant(),
          defaults: requireDefaults(),
          each: requireEach(),
          filter: requireFilter(),
          find: requireFind(),
          flatten: requireFlatten(),
          forEach: requireForEach(),
          forIn: requireForIn(),
          has: requireHas(),
          isUndefined: requireIsUndefined(),
          last: requireLast(),
          map: requireMap(),
          mapValues: requireMapValues(),
          max: requireMax(),
          merge: requireMerge(),
          min: requireMin(),
          minBy: requireMinBy(),
          now: requireNow(),
          pick: requirePick(),
          range: requireRange(),
          reduce: requireReduce(),
          sortBy: requireSortBy(),
          uniqueId: requireUniqueId(),
          values: requireValues(),
          zipObject: requireZipObject()
        };
      } catch (e) {
      }
    }
    if (!lodash2) {
      lodash2 = window._;
    }
    lodash_1$1 = lodash2;
    return lodash_1$1;
  }
  var list;
  var hasRequiredList;
  function requireList() {
    if (hasRequiredList)
      return list;
    hasRequiredList = 1;
    list = List;
    function List() {
      var sentinel = {};
      sentinel._next = sentinel._prev = sentinel;
      this._sentinel = sentinel;
    }
    List.prototype.dequeue = function() {
      var sentinel = this._sentinel;
      var entry = sentinel._prev;
      if (entry !== sentinel) {
        unlink(entry);
        return entry;
      }
    };
    List.prototype.enqueue = function(entry) {
      var sentinel = this._sentinel;
      if (entry._prev && entry._next) {
        unlink(entry);
      }
      entry._next = sentinel._next;
      sentinel._next._prev = entry;
      sentinel._next = entry;
      entry._prev = sentinel;
    };
    List.prototype.toString = function() {
      var strs = [];
      var sentinel = this._sentinel;
      var curr = sentinel._prev;
      while (curr !== sentinel) {
        strs.push(JSON.stringify(curr, filterOutLinks));
        curr = curr._prev;
      }
      return "[" + strs.join(", ") + "]";
    };
    function unlink(entry) {
      entry._prev._next = entry._next;
      entry._next._prev = entry._prev;
      delete entry._next;
      delete entry._prev;
    }
    function filterOutLinks(k2, v) {
      if (k2 !== "_next" && k2 !== "_prev") {
        return v;
      }
    }
    return list;
  }
  var greedyFas;
  var hasRequiredGreedyFas;
  function requireGreedyFas() {
    if (hasRequiredGreedyFas)
      return greedyFas;
    hasRequiredGreedyFas = 1;
    var _2 = requireLodash();
    var Graph2 = requireGraphlib().Graph;
    var List = requireList();
    greedyFas = greedyFAS;
    var DEFAULT_WEIGHT_FN = _2.constant(1);
    function greedyFAS(g, weightFn) {
      if (g.nodeCount() <= 1) {
        return [];
      }
      var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
      var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
      return _2.flatten(_2.map(results, function(e) {
        return g.outEdges(e.v, e.w);
      }), true);
    }
    function doGreedyFAS(g, buckets, zeroIdx) {
      var results = [];
      var sources = buckets[buckets.length - 1];
      var sinks = buckets[0];
      var entry;
      while (g.nodeCount()) {
        while (entry = sinks.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        while (entry = sources.dequeue()) {
          removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.nodeCount()) {
          for (var i = buckets.length - 2; i > 0; --i) {
            entry = buckets[i].dequeue();
            if (entry) {
              results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
              break;
            }
          }
        }
      }
      return results;
    }
    function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
      var results = collectPredecessors ? [] : void 0;
      _2.forEach(g.inEdges(entry.v), function(edge) {
        var weight = g.edge(edge);
        var uEntry = g.node(edge.v);
        if (collectPredecessors) {
          results.push({ v: edge.v, w: edge.w });
        }
        uEntry.out -= weight;
        assignBucket(buckets, zeroIdx, uEntry);
      });
      _2.forEach(g.outEdges(entry.v), function(edge) {
        var weight = g.edge(edge);
        var w2 = edge.w;
        var wEntry = g.node(w2);
        wEntry["in"] -= weight;
        assignBucket(buckets, zeroIdx, wEntry);
      });
      g.removeNode(entry.v);
      return results;
    }
    function buildState(g, weightFn) {
      var fasGraph = new Graph2();
      var maxIn = 0;
      var maxOut = 0;
      _2.forEach(g.nodes(), function(v) {
        fasGraph.setNode(v, { v, "in": 0, out: 0 });
      });
      _2.forEach(g.edges(), function(e) {
        var prevWeight = fasGraph.edge(e.v, e.w) || 0;
        var weight = weightFn(e);
        var edgeWeight = prevWeight + weight;
        fasGraph.setEdge(e.v, e.w, edgeWeight);
        maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
        maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
      });
      var buckets = _2.range(maxOut + maxIn + 3).map(function() {
        return new List();
      });
      var zeroIdx = maxIn + 1;
      _2.forEach(fasGraph.nodes(), function(v) {
        assignBucket(buckets, zeroIdx, fasGraph.node(v));
      });
      return { graph: fasGraph, buckets, zeroIdx };
    }
    function assignBucket(buckets, zeroIdx, entry) {
      if (!entry.out) {
        buckets[0].enqueue(entry);
      } else if (!entry["in"]) {
        buckets[buckets.length - 1].enqueue(entry);
      } else {
        buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
      }
    }
    return greedyFas;
  }
  var acyclic;
  var hasRequiredAcyclic;
  function requireAcyclic() {
    if (hasRequiredAcyclic)
      return acyclic;
    hasRequiredAcyclic = 1;
    var _2 = requireLodash();
    var greedyFAS = requireGreedyFas();
    acyclic = {
      run,
      undo
    };
    function run(g) {
      var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
      _2.forEach(fas, function(e) {
        var label = g.edge(e);
        g.removeEdge(e);
        label.forwardName = e.name;
        label.reversed = true;
        g.setEdge(e.w, e.v, label, _2.uniqueId("rev"));
      });
      function weightFn(g2) {
        return function(e) {
          return g2.edge(e).weight;
        };
      }
    }
    function dfsFAS(g) {
      var fas = [];
      var stack2 = {};
      var visited = {};
      function dfs2(v) {
        if (_2.has(visited, v)) {
          return;
        }
        visited[v] = true;
        stack2[v] = true;
        _2.forEach(g.outEdges(v), function(e) {
          if (_2.has(stack2, e.w)) {
            fas.push(e);
          } else {
            dfs2(e.w);
          }
        });
        delete stack2[v];
      }
      _2.forEach(g.nodes(), dfs2);
      return fas;
    }
    function undo(g) {
      _2.forEach(g.edges(), function(e) {
        var label = g.edge(e);
        if (label.reversed) {
          g.removeEdge(e);
          var forwardName = label.forwardName;
          delete label.reversed;
          delete label.forwardName;
          g.setEdge(e.w, e.v, label, forwardName);
        }
      });
    }
    return acyclic;
  }
  var util$3;
  var hasRequiredUtil$1;
  function requireUtil$1() {
    if (hasRequiredUtil$1)
      return util$3;
    hasRequiredUtil$1 = 1;
    var _2 = requireLodash();
    var Graph2 = requireGraphlib().Graph;
    util$3 = {
      addDummyNode,
      simplify,
      asNonCompoundGraph,
      successorWeights,
      predecessorWeights,
      intersectRect: intersectRect2,
      buildLayerMatrix,
      normalizeRanks,
      removeEmptyRanks,
      addBorderNode,
      maxRank,
      partition: partition2,
      time: time2,
      notime
    };
    function addDummyNode(g, type2, attrs, name2) {
      var v;
      do {
        v = _2.uniqueId(name2);
      } while (g.hasNode(v));
      attrs.dummy = type2;
      g.setNode(v, attrs);
      return v;
    }
    function simplify(g) {
      var simplified = new Graph2().setGraph(g.graph());
      _2.forEach(g.nodes(), function(v) {
        simplified.setNode(v, g.node(v));
      });
      _2.forEach(g.edges(), function(e) {
        var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
        var label = g.edge(e);
        simplified.setEdge(e.v, e.w, {
          weight: simpleLabel.weight + label.weight,
          minlen: Math.max(simpleLabel.minlen, label.minlen)
        });
      });
      return simplified;
    }
    function asNonCompoundGraph(g) {
      var simplified = new Graph2({ multigraph: g.isMultigraph() }).setGraph(g.graph());
      _2.forEach(g.nodes(), function(v) {
        if (!g.children(v).length) {
          simplified.setNode(v, g.node(v));
        }
      });
      _2.forEach(g.edges(), function(e) {
        simplified.setEdge(e, g.edge(e));
      });
      return simplified;
    }
    function successorWeights(g) {
      var weightMap = _2.map(g.nodes(), function(v) {
        var sucs = {};
        _2.forEach(g.outEdges(v), function(e) {
          sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
        });
        return sucs;
      });
      return _2.zipObject(g.nodes(), weightMap);
    }
    function predecessorWeights(g) {
      var weightMap = _2.map(g.nodes(), function(v) {
        var preds = {};
        _2.forEach(g.inEdges(v), function(e) {
          preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
        });
        return preds;
      });
      return _2.zipObject(g.nodes(), weightMap);
    }
    function intersectRect2(rect2, point2) {
      var x2 = rect2.x;
      var y2 = rect2.y;
      var dx = point2.x - x2;
      var dy = point2.y - y2;
      var w2 = rect2.width / 2;
      var h = rect2.height / 2;
      if (!dx && !dy) {
        throw new Error("Not possible to find intersection inside of the rectangle");
      }
      var sx, sy;
      if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
        if (dy < 0) {
          h = -h;
        }
        sx = h * dx / dy;
        sy = h;
      } else {
        if (dx < 0) {
          w2 = -w2;
        }
        sx = w2;
        sy = w2 * dy / dx;
      }
      return { x: x2 + sx, y: y2 + sy };
    }
    function buildLayerMatrix(g) {
      var layering = _2.map(_2.range(maxRank(g) + 1), function() {
        return [];
      });
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        var rank2 = node2.rank;
        if (!_2.isUndefined(rank2)) {
          layering[rank2][node2.order] = v;
        }
      });
      return layering;
    }
    function normalizeRanks(g) {
      var min2 = _2.min(_2.map(g.nodes(), function(v) {
        return g.node(v).rank;
      }));
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        if (_2.has(node2, "rank")) {
          node2.rank -= min2;
        }
      });
    }
    function removeEmptyRanks(g) {
      var offset = _2.min(_2.map(g.nodes(), function(v) {
        return g.node(v).rank;
      }));
      var layers = [];
      _2.forEach(g.nodes(), function(v) {
        var rank2 = g.node(v).rank - offset;
        if (!layers[rank2]) {
          layers[rank2] = [];
        }
        layers[rank2].push(v);
      });
      var delta = 0;
      var nodeRankFactor = g.graph().nodeRankFactor;
      _2.forEach(layers, function(vs, i) {
        if (_2.isUndefined(vs) && i % nodeRankFactor !== 0) {
          --delta;
        } else if (delta) {
          _2.forEach(vs, function(v) {
            g.node(v).rank += delta;
          });
        }
      });
    }
    function addBorderNode(g, prefix, rank2, order) {
      var node2 = {
        width: 0,
        height: 0
      };
      if (arguments.length >= 4) {
        node2.rank = rank2;
        node2.order = order;
      }
      return addDummyNode(g, "border", node2, prefix);
    }
    function maxRank(g) {
      return _2.max(_2.map(g.nodes(), function(v) {
        var rank2 = g.node(v).rank;
        if (!_2.isUndefined(rank2)) {
          return rank2;
        }
      }));
    }
    function partition2(collection, fn) {
      var result = { lhs: [], rhs: [] };
      _2.forEach(collection, function(value) {
        if (fn(value)) {
          result.lhs.push(value);
        } else {
          result.rhs.push(value);
        }
      });
      return result;
    }
    function time2(name2, fn) {
      var start2 = _2.now();
      try {
        return fn();
      } finally {
        console.log(name2 + " time: " + (_2.now() - start2) + "ms");
      }
    }
    function notime(name2, fn) {
      return fn();
    }
    return util$3;
  }
  var normalize;
  var hasRequiredNormalize;
  function requireNormalize() {
    if (hasRequiredNormalize)
      return normalize;
    hasRequiredNormalize = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    normalize = {
      run,
      undo
    };
    function run(g) {
      g.graph().dummyChains = [];
      _2.forEach(g.edges(), function(edge) {
        normalizeEdge(g, edge);
      });
    }
    function normalizeEdge(g, e) {
      var v = e.v;
      var vRank = g.node(v).rank;
      var w2 = e.w;
      var wRank = g.node(w2).rank;
      var name2 = e.name;
      var edgeLabel = g.edge(e);
      var labelRank = edgeLabel.labelRank;
      if (wRank === vRank + 1)
        return;
      g.removeEdge(e);
      var dummy, attrs, i;
      for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        edgeLabel.points = [];
        attrs = {
          width: 0,
          height: 0,
          edgeLabel,
          edgeObj: e,
          rank: vRank
        };
        dummy = util2.addDummyNode(g, "edge", attrs, "_d");
        if (vRank === labelRank) {
          attrs.width = edgeLabel.width;
          attrs.height = edgeLabel.height;
          attrs.dummy = "edge-label";
          attrs.labelpos = edgeLabel.labelpos;
        }
        g.setEdge(v, dummy, { weight: edgeLabel.weight }, name2);
        if (i === 0) {
          g.graph().dummyChains.push(dummy);
        }
        v = dummy;
      }
      g.setEdge(v, w2, { weight: edgeLabel.weight }, name2);
    }
    function undo(g) {
      _2.forEach(g.graph().dummyChains, function(v) {
        var node2 = g.node(v);
        var origLabel = node2.edgeLabel;
        var w2;
        g.setEdge(node2.edgeObj, origLabel);
        while (node2.dummy) {
          w2 = g.successors(v)[0];
          g.removeNode(v);
          origLabel.points.push({ x: node2.x, y: node2.y });
          if (node2.dummy === "edge-label") {
            origLabel.x = node2.x;
            origLabel.y = node2.y;
            origLabel.width = node2.width;
            origLabel.height = node2.height;
          }
          v = w2;
          node2 = g.node(v);
        }
      });
    }
    return normalize;
  }
  var util$2;
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil)
      return util$2;
    hasRequiredUtil = 1;
    var _2 = requireLodash();
    util$2 = {
      longestPath,
      slack
    };
    function longestPath(g) {
      var visited = {};
      function dfs2(v) {
        var label = g.node(v);
        if (_2.has(visited, v)) {
          return label.rank;
        }
        visited[v] = true;
        var rank2 = _2.min(_2.map(g.outEdges(v), function(e) {
          return dfs2(e.w) - g.edge(e).minlen;
        }));
        if (rank2 === Number.POSITIVE_INFINITY || rank2 === void 0 || rank2 === null) {
          rank2 = 0;
        }
        return label.rank = rank2;
      }
      _2.forEach(g.sources(), dfs2);
    }
    function slack(g, e) {
      return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
    }
    return util$2;
  }
  var feasibleTree_1;
  var hasRequiredFeasibleTree;
  function requireFeasibleTree() {
    if (hasRequiredFeasibleTree)
      return feasibleTree_1;
    hasRequiredFeasibleTree = 1;
    var _2 = requireLodash();
    var Graph2 = requireGraphlib().Graph;
    var slack = requireUtil().slack;
    feasibleTree_1 = feasibleTree;
    function feasibleTree(g) {
      var t = new Graph2({ directed: false });
      var start2 = g.nodes()[0];
      var size = g.nodeCount();
      t.setNode(start2, {});
      var edge, delta;
      while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
        shiftRanks(t, g, delta);
      }
      return t;
    }
    function tightTree(t, g) {
      function dfs2(v) {
        _2.forEach(g.nodeEdges(v), function(e) {
          var edgeV = e.v, w2 = v === edgeV ? e.w : edgeV;
          if (!t.hasNode(w2) && !slack(g, e)) {
            t.setNode(w2, {});
            t.setEdge(v, w2, {});
            dfs2(w2);
          }
        });
      }
      _2.forEach(t.nodes(), dfs2);
      return t.nodeCount();
    }
    function findMinSlackEdge(t, g) {
      return _2.minBy(g.edges(), function(e) {
        if (t.hasNode(e.v) !== t.hasNode(e.w)) {
          return slack(g, e);
        }
      });
    }
    function shiftRanks(t, g, delta) {
      _2.forEach(t.nodes(), function(v) {
        g.node(v).rank += delta;
      });
    }
    return feasibleTree_1;
  }
  var networkSimplex_1;
  var hasRequiredNetworkSimplex;
  function requireNetworkSimplex() {
    if (hasRequiredNetworkSimplex)
      return networkSimplex_1;
    hasRequiredNetworkSimplex = 1;
    var _2 = requireLodash();
    var feasibleTree = requireFeasibleTree();
    var slack = requireUtil().slack;
    var initRank = requireUtil().longestPath;
    var preorder2 = requireGraphlib().alg.preorder;
    var postorder2 = requireGraphlib().alg.postorder;
    var simplify = requireUtil$1().simplify;
    networkSimplex_1 = networkSimplex;
    networkSimplex.initLowLimValues = initLowLimValues;
    networkSimplex.initCutValues = initCutValues;
    networkSimplex.calcCutValue = calcCutValue;
    networkSimplex.leaveEdge = leaveEdge;
    networkSimplex.enterEdge = enterEdge;
    networkSimplex.exchangeEdges = exchangeEdges;
    function networkSimplex(g) {
      g = simplify(g);
      initRank(g);
      var t = feasibleTree(g);
      initLowLimValues(t);
      initCutValues(t, g);
      var e, f;
      while (e = leaveEdge(t)) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
      }
    }
    function initCutValues(t, g) {
      var vs = postorder2(t, t.nodes());
      vs = vs.slice(0, vs.length - 1);
      _2.forEach(vs, function(v) {
        assignCutValue(t, g, v);
      });
    }
    function assignCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
    }
    function calcCutValue(t, g, child) {
      var childLab = t.node(child);
      var parent = childLab.parent;
      var childIsTail = true;
      var graphEdge = g.edge(child, parent);
      var cutValue = 0;
      if (!graphEdge) {
        childIsTail = false;
        graphEdge = g.edge(parent, child);
      }
      cutValue = graphEdge.weight;
      _2.forEach(g.nodeEdges(child), function(e) {
        var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
        if (other !== parent) {
          var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
          cutValue += pointsToHead ? otherWeight : -otherWeight;
          if (isTreeEdge(t, child, other)) {
            var otherCutValue = t.edge(child, other).cutvalue;
            cutValue += pointsToHead ? -otherCutValue : otherCutValue;
          }
        }
      });
      return cutValue;
    }
    function initLowLimValues(tree2, root2) {
      if (arguments.length < 2) {
        root2 = tree2.nodes()[0];
      }
      dfsAssignLowLim(tree2, {}, 1, root2);
    }
    function dfsAssignLowLim(tree2, visited, nextLim, v, parent) {
      var low = nextLim;
      var label = tree2.node(v);
      visited[v] = true;
      _2.forEach(tree2.neighbors(v), function(w2) {
        if (!_2.has(visited, w2)) {
          nextLim = dfsAssignLowLim(tree2, visited, nextLim, w2, v);
        }
      });
      label.low = low;
      label.lim = nextLim++;
      if (parent) {
        label.parent = parent;
      } else {
        delete label.parent;
      }
      return nextLim;
    }
    function leaveEdge(tree2) {
      return _2.find(tree2.edges(), function(e) {
        return tree2.edge(e).cutvalue < 0;
      });
    }
    function enterEdge(t, g, edge) {
      var v = edge.v;
      var w2 = edge.w;
      if (!g.hasEdge(v, w2)) {
        v = edge.w;
        w2 = edge.v;
      }
      var vLabel = t.node(v);
      var wLabel = t.node(w2);
      var tailLabel = vLabel;
      var flip = false;
      if (vLabel.lim > wLabel.lim) {
        tailLabel = wLabel;
        flip = true;
      }
      var candidates = _2.filter(g.edges(), function(edge2) {
        return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
      });
      return _2.minBy(candidates, function(edge2) {
        return slack(g, edge2);
      });
    }
    function exchangeEdges(t, g, e, f) {
      var v = e.v;
      var w2 = e.w;
      t.removeEdge(v, w2);
      t.setEdge(f.v, f.w, {});
      initLowLimValues(t);
      initCutValues(t, g);
      updateRanks(t, g);
    }
    function updateRanks(t, g) {
      var root2 = _2.find(t.nodes(), function(v) {
        return !g.node(v).parent;
      });
      var vs = preorder2(t, root2);
      vs = vs.slice(1);
      _2.forEach(vs, function(v) {
        var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
        if (!edge) {
          edge = g.edge(parent, v);
          flipped = true;
        }
        g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
      });
    }
    function isTreeEdge(tree2, u2, v) {
      return tree2.hasEdge(u2, v);
    }
    function isDescendant(tree2, vLabel, rootLabel) {
      return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
    }
    return networkSimplex_1;
  }
  var rank_1;
  var hasRequiredRank;
  function requireRank() {
    if (hasRequiredRank)
      return rank_1;
    hasRequiredRank = 1;
    var rankUtil = requireUtil();
    var longestPath = rankUtil.longestPath;
    var feasibleTree = requireFeasibleTree();
    var networkSimplex = requireNetworkSimplex();
    rank_1 = rank2;
    function rank2(g) {
      switch (g.graph().ranker) {
        case "network-simplex":
          networkSimplexRanker(g);
          break;
        case "tight-tree":
          tightTreeRanker(g);
          break;
        case "longest-path":
          longestPathRanker(g);
          break;
        default:
          networkSimplexRanker(g);
      }
    }
    var longestPathRanker = longestPath;
    function tightTreeRanker(g) {
      longestPath(g);
      feasibleTree(g);
    }
    function networkSimplexRanker(g) {
      networkSimplex(g);
    }
    return rank_1;
  }
  var parentDummyChains_1;
  var hasRequiredParentDummyChains;
  function requireParentDummyChains() {
    if (hasRequiredParentDummyChains)
      return parentDummyChains_1;
    hasRequiredParentDummyChains = 1;
    var _2 = requireLodash();
    parentDummyChains_1 = parentDummyChains;
    function parentDummyChains(g) {
      var postorderNums = postorder2(g);
      _2.forEach(g.graph().dummyChains, function(v) {
        var node2 = g.node(v);
        var edgeObj = node2.edgeObj;
        var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
        var path2 = pathData.path;
        var lca = pathData.lca;
        var pathIdx = 0;
        var pathV = path2[pathIdx];
        var ascending2 = true;
        while (v !== edgeObj.w) {
          node2 = g.node(v);
          if (ascending2) {
            while ((pathV = path2[pathIdx]) !== lca && g.node(pathV).maxRank < node2.rank) {
              pathIdx++;
            }
            if (pathV === lca) {
              ascending2 = false;
            }
          }
          if (!ascending2) {
            while (pathIdx < path2.length - 1 && g.node(pathV = path2[pathIdx + 1]).minRank <= node2.rank) {
              pathIdx++;
            }
            pathV = path2[pathIdx];
          }
          g.setParent(v, pathV);
          v = g.successors(v)[0];
        }
      });
    }
    function findPath(g, postorderNums, v, w2) {
      var vPath = [];
      var wPath = [];
      var low = Math.min(postorderNums[v].low, postorderNums[w2].low);
      var lim = Math.max(postorderNums[v].lim, postorderNums[w2].lim);
      var parent;
      var lca;
      parent = v;
      do {
        parent = g.parent(parent);
        vPath.push(parent);
      } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
      lca = parent;
      parent = w2;
      while ((parent = g.parent(parent)) !== lca) {
        wPath.push(parent);
      }
      return { path: vPath.concat(wPath.reverse()), lca };
    }
    function postorder2(g) {
      var result = {};
      var lim = 0;
      function dfs2(v) {
        var low = lim;
        _2.forEach(g.children(v), dfs2);
        result[v] = { low, lim: lim++ };
      }
      _2.forEach(g.children(), dfs2);
      return result;
    }
    return parentDummyChains_1;
  }
  var nestingGraph;
  var hasRequiredNestingGraph;
  function requireNestingGraph() {
    if (hasRequiredNestingGraph)
      return nestingGraph;
    hasRequiredNestingGraph = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    nestingGraph = {
      run,
      cleanup
    };
    function run(g) {
      var root2 = util2.addDummyNode(g, "root", {}, "_root");
      var depths = treeDepths(g);
      var height2 = _2.max(_2.values(depths)) - 1;
      var nodeSep = 2 * height2 + 1;
      g.graph().nestingRoot = root2;
      _2.forEach(g.edges(), function(e) {
        g.edge(e).minlen *= nodeSep;
      });
      var weight = sumWeights(g) + 1;
      _2.forEach(g.children(), function(child) {
        dfs2(g, root2, nodeSep, weight, height2, depths, child);
      });
      g.graph().nodeRankFactor = nodeSep;
    }
    function dfs2(g, root2, nodeSep, weight, height2, depths, v) {
      var children2 = g.children(v);
      if (!children2.length) {
        if (v !== root2) {
          g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
        }
        return;
      }
      var top2 = util2.addBorderNode(g, "_bt");
      var bottom2 = util2.addBorderNode(g, "_bb");
      var label = g.node(v);
      g.setParent(top2, v);
      label.borderTop = top2;
      g.setParent(bottom2, v);
      label.borderBottom = bottom2;
      _2.forEach(children2, function(child) {
        dfs2(g, root2, nodeSep, weight, height2, depths, child);
        var childNode = g.node(child);
        var childTop = childNode.borderTop ? childNode.borderTop : child;
        var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
        var thisWeight = childNode.borderTop ? weight : 2 * weight;
        var minlen = childTop !== childBottom ? 1 : height2 - depths[v] + 1;
        g.setEdge(top2, childTop, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
        g.setEdge(childBottom, bottom2, {
          weight: thisWeight,
          minlen,
          nestingEdge: true
        });
      });
      if (!g.parent(v)) {
        g.setEdge(root2, top2, { weight: 0, minlen: height2 + depths[v] });
      }
    }
    function treeDepths(g) {
      var depths = {};
      function dfs3(v, depth) {
        var children2 = g.children(v);
        if (children2 && children2.length) {
          _2.forEach(children2, function(child) {
            dfs3(child, depth + 1);
          });
        }
        depths[v] = depth;
      }
      _2.forEach(g.children(), function(v) {
        dfs3(v, 1);
      });
      return depths;
    }
    function sumWeights(g) {
      return _2.reduce(g.edges(), function(acc, e) {
        return acc + g.edge(e).weight;
      }, 0);
    }
    function cleanup(g) {
      var graphLabel = g.graph();
      g.removeNode(graphLabel.nestingRoot);
      delete graphLabel.nestingRoot;
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        if (edge.nestingEdge) {
          g.removeEdge(e);
        }
      });
    }
    return nestingGraph;
  }
  var addBorderSegments_1;
  var hasRequiredAddBorderSegments;
  function requireAddBorderSegments() {
    if (hasRequiredAddBorderSegments)
      return addBorderSegments_1;
    hasRequiredAddBorderSegments = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    addBorderSegments_1 = addBorderSegments;
    function addBorderSegments(g) {
      function dfs2(v) {
        var children2 = g.children(v);
        var node2 = g.node(v);
        if (children2.length) {
          _2.forEach(children2, dfs2);
        }
        if (_2.has(node2, "minRank")) {
          node2.borderLeft = [];
          node2.borderRight = [];
          for (var rank2 = node2.minRank, maxRank = node2.maxRank + 1; rank2 < maxRank; ++rank2) {
            addBorderNode(g, "borderLeft", "_bl", v, node2, rank2);
            addBorderNode(g, "borderRight", "_br", v, node2, rank2);
          }
        }
      }
      _2.forEach(g.children(), dfs2);
    }
    function addBorderNode(g, prop, prefix, sg, sgNode, rank2) {
      var label = { width: 0, height: 0, rank: rank2, borderType: prop };
      var prev2 = sgNode[prop][rank2 - 1];
      var curr = util2.addDummyNode(g, "border", label, prefix);
      sgNode[prop][rank2] = curr;
      g.setParent(curr, sg);
      if (prev2) {
        g.setEdge(prev2, curr, { weight: 1 });
      }
    }
    return addBorderSegments_1;
  }
  var coordinateSystem;
  var hasRequiredCoordinateSystem;
  function requireCoordinateSystem() {
    if (hasRequiredCoordinateSystem)
      return coordinateSystem;
    hasRequiredCoordinateSystem = 1;
    var _2 = requireLodash();
    coordinateSystem = {
      adjust: adjust2,
      undo
    };
    function adjust2(g) {
      var rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "lr" || rankDir === "rl") {
        swapWidthHeight(g);
      }
    }
    function undo(g) {
      var rankDir = g.graph().rankdir.toLowerCase();
      if (rankDir === "bt" || rankDir === "rl") {
        reverseY(g);
      }
      if (rankDir === "lr" || rankDir === "rl") {
        swapXY(g);
        swapWidthHeight(g);
      }
    }
    function swapWidthHeight(g) {
      _2.forEach(g.nodes(), function(v) {
        swapWidthHeightOne(g.node(v));
      });
      _2.forEach(g.edges(), function(e) {
        swapWidthHeightOne(g.edge(e));
      });
    }
    function swapWidthHeightOne(attrs) {
      var w2 = attrs.width;
      attrs.width = attrs.height;
      attrs.height = w2;
    }
    function reverseY(g) {
      _2.forEach(g.nodes(), function(v) {
        reverseYOne(g.node(v));
      });
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        _2.forEach(edge.points, reverseYOne);
        if (_2.has(edge, "y")) {
          reverseYOne(edge);
        }
      });
    }
    function reverseYOne(attrs) {
      attrs.y = -attrs.y;
    }
    function swapXY(g) {
      _2.forEach(g.nodes(), function(v) {
        swapXYOne(g.node(v));
      });
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        _2.forEach(edge.points, swapXYOne);
        if (_2.has(edge, "x")) {
          swapXYOne(edge);
        }
      });
    }
    function swapXYOne(attrs) {
      var x2 = attrs.x;
      attrs.x = attrs.y;
      attrs.y = x2;
    }
    return coordinateSystem;
  }
  var initOrder_1;
  var hasRequiredInitOrder;
  function requireInitOrder() {
    if (hasRequiredInitOrder)
      return initOrder_1;
    hasRequiredInitOrder = 1;
    var _2 = requireLodash();
    initOrder_1 = initOrder;
    function initOrder(g) {
      var visited = {};
      var simpleNodes = _2.filter(g.nodes(), function(v) {
        return !g.children(v).length;
      });
      var maxRank = _2.max(_2.map(simpleNodes, function(v) {
        return g.node(v).rank;
      }));
      var layers = _2.map(_2.range(maxRank + 1), function() {
        return [];
      });
      function dfs2(v) {
        if (_2.has(visited, v))
          return;
        visited[v] = true;
        var node2 = g.node(v);
        layers[node2.rank].push(v);
        _2.forEach(g.successors(v), dfs2);
      }
      var orderedVs = _2.sortBy(simpleNodes, function(v) {
        return g.node(v).rank;
      });
      _2.forEach(orderedVs, dfs2);
      return layers;
    }
    return initOrder_1;
  }
  var crossCount_1;
  var hasRequiredCrossCount;
  function requireCrossCount() {
    if (hasRequiredCrossCount)
      return crossCount_1;
    hasRequiredCrossCount = 1;
    var _2 = requireLodash();
    crossCount_1 = crossCount;
    function crossCount(g, layering) {
      var cc = 0;
      for (var i = 1; i < layering.length; ++i) {
        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
      }
      return cc;
    }
    function twoLayerCrossCount(g, northLayer, southLayer) {
      var southPos = _2.zipObject(
        southLayer,
        _2.map(southLayer, function(v, i) {
          return i;
        })
      );
      var southEntries = _2.flatten(_2.map(northLayer, function(v) {
        return _2.sortBy(_2.map(g.outEdges(v), function(e) {
          return { pos: southPos[e.w], weight: g.edge(e).weight };
        }), "pos");
      }), true);
      var firstIndex = 1;
      while (firstIndex < southLayer.length)
        firstIndex <<= 1;
      var treeSize = 2 * firstIndex - 1;
      firstIndex -= 1;
      var tree2 = _2.map(new Array(treeSize), function() {
        return 0;
      });
      var cc = 0;
      _2.forEach(southEntries.forEach(function(entry) {
        var index2 = entry.pos + firstIndex;
        tree2[index2] += entry.weight;
        var weightSum = 0;
        while (index2 > 0) {
          if (index2 % 2) {
            weightSum += tree2[index2 + 1];
          }
          index2 = index2 - 1 >> 1;
          tree2[index2] += entry.weight;
        }
        cc += entry.weight * weightSum;
      }));
      return cc;
    }
    return crossCount_1;
  }
  var barycenter_1;
  var hasRequiredBarycenter;
  function requireBarycenter() {
    if (hasRequiredBarycenter)
      return barycenter_1;
    hasRequiredBarycenter = 1;
    var _2 = requireLodash();
    barycenter_1 = barycenter;
    function barycenter(g, movable) {
      return _2.map(movable, function(v) {
        var inV = g.inEdges(v);
        if (!inV.length) {
          return { v };
        } else {
          var result = _2.reduce(inV, function(acc, e) {
            var edge = g.edge(e), nodeU = g.node(e.v);
            return {
              sum: acc.sum + edge.weight * nodeU.order,
              weight: acc.weight + edge.weight
            };
          }, { sum: 0, weight: 0 });
          return {
            v,
            barycenter: result.sum / result.weight,
            weight: result.weight
          };
        }
      });
    }
    return barycenter_1;
  }
  var resolveConflicts_1;
  var hasRequiredResolveConflicts;
  function requireResolveConflicts() {
    if (hasRequiredResolveConflicts)
      return resolveConflicts_1;
    hasRequiredResolveConflicts = 1;
    var _2 = requireLodash();
    resolveConflicts_1 = resolveConflicts;
    function resolveConflicts(entries, cg) {
      var mappedEntries = {};
      _2.forEach(entries, function(entry, i) {
        var tmp = mappedEntries[entry.v] = {
          indegree: 0,
          "in": [],
          out: [],
          vs: [entry.v],
          i
        };
        if (!_2.isUndefined(entry.barycenter)) {
          tmp.barycenter = entry.barycenter;
          tmp.weight = entry.weight;
        }
      });
      _2.forEach(cg.edges(), function(e) {
        var entryV = mappedEntries[e.v];
        var entryW = mappedEntries[e.w];
        if (!_2.isUndefined(entryV) && !_2.isUndefined(entryW)) {
          entryW.indegree++;
          entryV.out.push(mappedEntries[e.w]);
        }
      });
      var sourceSet = _2.filter(mappedEntries, function(entry) {
        return !entry.indegree;
      });
      return doResolveConflicts(sourceSet);
    }
    function doResolveConflicts(sourceSet) {
      var entries = [];
      function handleIn(vEntry) {
        return function(uEntry) {
          if (uEntry.merged) {
            return;
          }
          if (_2.isUndefined(uEntry.barycenter) || _2.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
            mergeEntries(vEntry, uEntry);
          }
        };
      }
      function handleOut(vEntry) {
        return function(wEntry) {
          wEntry["in"].push(vEntry);
          if (--wEntry.indegree === 0) {
            sourceSet.push(wEntry);
          }
        };
      }
      while (sourceSet.length) {
        var entry = sourceSet.pop();
        entries.push(entry);
        _2.forEach(entry["in"].reverse(), handleIn(entry));
        _2.forEach(entry.out, handleOut(entry));
      }
      return _2.map(
        _2.filter(entries, function(entry2) {
          return !entry2.merged;
        }),
        function(entry2) {
          return _2.pick(entry2, ["vs", "i", "barycenter", "weight"]);
        }
      );
    }
    function mergeEntries(target, source) {
      var sum2 = 0;
      var weight = 0;
      if (target.weight) {
        sum2 += target.barycenter * target.weight;
        weight += target.weight;
      }
      if (source.weight) {
        sum2 += source.barycenter * source.weight;
        weight += source.weight;
      }
      target.vs = source.vs.concat(target.vs);
      target.barycenter = sum2 / weight;
      target.weight = weight;
      target.i = Math.min(source.i, target.i);
      source.merged = true;
    }
    return resolveConflicts_1;
  }
  var sort_1;
  var hasRequiredSort;
  function requireSort() {
    if (hasRequiredSort)
      return sort_1;
    hasRequiredSort = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    sort_1 = sort2;
    function sort2(entries, biasRight) {
      var parts = util2.partition(entries, function(entry) {
        return _2.has(entry, "barycenter");
      });
      var sortable = parts.lhs, unsortable = _2.sortBy(parts.rhs, function(entry) {
        return -entry.i;
      }), vs = [], sum2 = 0, weight = 0, vsIndex = 0;
      sortable.sort(compareWithBias(!!biasRight));
      vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      _2.forEach(sortable, function(entry) {
        vsIndex += entry.vs.length;
        vs.push(entry.vs);
        sum2 += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
      });
      var result = { vs: _2.flatten(vs, true) };
      if (weight) {
        result.barycenter = sum2 / weight;
        result.weight = weight;
      }
      return result;
    }
    function consumeUnsortable(vs, unsortable, index2) {
      var last;
      while (unsortable.length && (last = _2.last(unsortable)).i <= index2) {
        unsortable.pop();
        vs.push(last.vs);
        index2++;
      }
      return index2;
    }
    function compareWithBias(bias) {
      return function(entryV, entryW) {
        if (entryV.barycenter < entryW.barycenter) {
          return -1;
        } else if (entryV.barycenter > entryW.barycenter) {
          return 1;
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
      };
    }
    return sort_1;
  }
  var sortSubgraph_1;
  var hasRequiredSortSubgraph;
  function requireSortSubgraph() {
    if (hasRequiredSortSubgraph)
      return sortSubgraph_1;
    hasRequiredSortSubgraph = 1;
    var _2 = requireLodash();
    var barycenter = requireBarycenter();
    var resolveConflicts = requireResolveConflicts();
    var sort2 = requireSort();
    sortSubgraph_1 = sortSubgraph;
    function sortSubgraph(g, v, cg, biasRight) {
      var movable = g.children(v);
      var node2 = g.node(v);
      var bl = node2 ? node2.borderLeft : void 0;
      var br = node2 ? node2.borderRight : void 0;
      var subgraphs = {};
      if (bl) {
        movable = _2.filter(movable, function(w2) {
          return w2 !== bl && w2 !== br;
        });
      }
      var barycenters = barycenter(g, movable);
      _2.forEach(barycenters, function(entry) {
        if (g.children(entry.v).length) {
          var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
          subgraphs[entry.v] = subgraphResult;
          if (_2.has(subgraphResult, "barycenter")) {
            mergeBarycenters(entry, subgraphResult);
          }
        }
      });
      var entries = resolveConflicts(barycenters, cg);
      expandSubgraphs(entries, subgraphs);
      var result = sort2(entries, biasRight);
      if (bl) {
        result.vs = _2.flatten([bl, result.vs, br], true);
        if (g.predecessors(bl).length) {
          var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
          if (!_2.has(result, "barycenter")) {
            result.barycenter = 0;
            result.weight = 0;
          }
          result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
          result.weight += 2;
        }
      }
      return result;
    }
    function expandSubgraphs(entries, subgraphs) {
      _2.forEach(entries, function(entry) {
        entry.vs = _2.flatten(entry.vs.map(function(v) {
          if (subgraphs[v]) {
            return subgraphs[v].vs;
          }
          return v;
        }), true);
      });
    }
    function mergeBarycenters(target, other) {
      if (!_2.isUndefined(target.barycenter)) {
        target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
        target.weight += other.weight;
      } else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
      }
    }
    return sortSubgraph_1;
  }
  var buildLayerGraph_1;
  var hasRequiredBuildLayerGraph;
  function requireBuildLayerGraph() {
    if (hasRequiredBuildLayerGraph)
      return buildLayerGraph_1;
    hasRequiredBuildLayerGraph = 1;
    var _2 = requireLodash();
    var Graph2 = requireGraphlib().Graph;
    buildLayerGraph_1 = buildLayerGraph;
    function buildLayerGraph(g, rank2, relationship) {
      var root2 = createRootNode(g), result = new Graph2({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v) {
        return g.node(v);
      });
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v), parent = g.parent(v);
        if (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) {
          result.setNode(v);
          result.setParent(v, parent || root2);
          _2.forEach(g[relationship](v), function(e) {
            var u2 = e.v === v ? e.w : e.v, edge = result.edge(u2, v), weight = !_2.isUndefined(edge) ? edge.weight : 0;
            result.setEdge(u2, v, { weight: g.edge(e).weight + weight });
          });
          if (_2.has(node2, "minRank")) {
            result.setNode(v, {
              borderLeft: node2.borderLeft[rank2],
              borderRight: node2.borderRight[rank2]
            });
          }
        }
      });
      return result;
    }
    function createRootNode(g) {
      var v;
      while (g.hasNode(v = _2.uniqueId("_root")))
        ;
      return v;
    }
    return buildLayerGraph_1;
  }
  var addSubgraphConstraints_1;
  var hasRequiredAddSubgraphConstraints;
  function requireAddSubgraphConstraints() {
    if (hasRequiredAddSubgraphConstraints)
      return addSubgraphConstraints_1;
    hasRequiredAddSubgraphConstraints = 1;
    var _2 = requireLodash();
    addSubgraphConstraints_1 = addSubgraphConstraints;
    function addSubgraphConstraints(g, cg, vs) {
      var prev2 = {}, rootPrev;
      _2.forEach(vs, function(v) {
        var child = g.parent(v), parent, prevChild;
        while (child) {
          parent = g.parent(child);
          if (parent) {
            prevChild = prev2[parent];
            prev2[parent] = child;
          } else {
            prevChild = rootPrev;
            rootPrev = child;
          }
          if (prevChild && prevChild !== child) {
            cg.setEdge(prevChild, child);
            return;
          }
          child = parent;
        }
      });
    }
    return addSubgraphConstraints_1;
  }
  var order_1;
  var hasRequiredOrder;
  function requireOrder() {
    if (hasRequiredOrder)
      return order_1;
    hasRequiredOrder = 1;
    var _2 = requireLodash();
    var initOrder = requireInitOrder();
    var crossCount = requireCrossCount();
    var sortSubgraph = requireSortSubgraph();
    var buildLayerGraph = requireBuildLayerGraph();
    var addSubgraphConstraints = requireAddSubgraphConstraints();
    var Graph2 = requireGraphlib().Graph;
    var util2 = requireUtil$1();
    order_1 = order;
    function order(g) {
      var maxRank = util2.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _2.range(1, maxRank + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, _2.range(maxRank - 1, -1, -1), "outEdges");
      var layering = initOrder(g);
      assignOrder(g, layering);
      var bestCC = Number.POSITIVE_INFINITY, best;
      for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
        layering = util2.buildLayerMatrix(g);
        var cc = crossCount(g, layering);
        if (cc < bestCC) {
          lastBest = 0;
          best = _2.cloneDeep(layering);
          bestCC = cc;
        }
      }
      assignOrder(g, best);
    }
    function buildLayerGraphs(g, ranks, relationship) {
      return _2.map(ranks, function(rank2) {
        return buildLayerGraph(g, rank2, relationship);
      });
    }
    function sweepLayerGraphs(layerGraphs, biasRight) {
      var cg = new Graph2();
      _2.forEach(layerGraphs, function(lg) {
        var root2 = lg.graph().root;
        var sorted = sortSubgraph(lg, root2, cg, biasRight);
        _2.forEach(sorted.vs, function(v, i) {
          lg.node(v).order = i;
        });
        addSubgraphConstraints(lg, cg, sorted.vs);
      });
    }
    function assignOrder(g, layering) {
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v, i) {
          g.node(v).order = i;
        });
      });
    }
    return order_1;
  }
  var bk;
  var hasRequiredBk;
  function requireBk() {
    if (hasRequiredBk)
      return bk;
    hasRequiredBk = 1;
    var _2 = requireLodash();
    var Graph2 = requireGraphlib().Graph;
    var util2 = requireUtil$1();
    bk = {
      positionX,
      findType1Conflicts,
      findType2Conflicts,
      addConflict,
      hasConflict,
      verticalAlignment,
      horizontalCompaction,
      alignCoordinates,
      findSmallestWidthAlignment,
      balance
    };
    function findType1Conflicts(g, layering) {
      var conflicts = {};
      function visitLayer(prevLayer, layer) {
        var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _2.last(layer);
        _2.forEach(layer, function(v, i) {
          var w2 = findOtherInnerSegmentNode(g, v), k1 = w2 ? g.node(w2).order : prevLayerLength;
          if (w2 || v === lastNode) {
            _2.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
              _2.forEach(g.predecessors(scanNode), function(u2) {
                var uLabel = g.node(u2), uPos = uLabel.order;
                if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
                  addConflict(conflicts, u2, scanNode);
                }
              });
            });
            scanPos = i + 1;
            k0 = k1;
          }
        });
        return layer;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findType2Conflicts(g, layering) {
      var conflicts = {};
      function scan2(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var v;
        _2.forEach(_2.range(southPos, southEnd), function(i) {
          v = south[i];
          if (g.node(v).dummy) {
            _2.forEach(g.predecessors(v), function(u2) {
              var uNode = g.node(u2);
              if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
                addConflict(conflicts, u2, v);
              }
            });
          }
        });
      }
      function visitLayer(north, south) {
        var prevNorthPos = -1, nextNorthPos, southPos = 0;
        _2.forEach(south, function(v, southLookahead) {
          if (g.node(v).dummy === "border") {
            var predecessors = g.predecessors(v);
            if (predecessors.length) {
              nextNorthPos = g.node(predecessors[0]).order;
              scan2(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
              southPos = southLookahead;
              prevNorthPos = nextNorthPos;
            }
          }
          scan2(south, southPos, south.length, nextNorthPos, north.length);
        });
        return south;
      }
      _2.reduce(layering, visitLayer);
      return conflicts;
    }
    function findOtherInnerSegmentNode(g, v) {
      if (g.node(v).dummy) {
        return _2.find(g.predecessors(v), function(u2) {
          return g.node(u2).dummy;
        });
      }
    }
    function addConflict(conflicts, v, w2) {
      if (v > w2) {
        var tmp = v;
        v = w2;
        w2 = tmp;
      }
      var conflictsV = conflicts[v];
      if (!conflictsV) {
        conflicts[v] = conflictsV = {};
      }
      conflictsV[w2] = true;
    }
    function hasConflict(conflicts, v, w2) {
      if (v > w2) {
        var tmp = v;
        v = w2;
        w2 = tmp;
      }
      return _2.has(conflicts[v], w2);
    }
    function verticalAlignment(g, layering, conflicts, neighborFn) {
      var root2 = {}, align = {}, pos = {};
      _2.forEach(layering, function(layer) {
        _2.forEach(layer, function(v, order) {
          root2[v] = v;
          align[v] = v;
          pos[v] = order;
        });
      });
      _2.forEach(layering, function(layer) {
        var prevIdx = -1;
        _2.forEach(layer, function(v) {
          var ws = neighborFn(v);
          if (ws.length) {
            ws = _2.sortBy(ws, function(w3) {
              return pos[w3];
            });
            var mp = (ws.length - 1) / 2;
            for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
              var w2 = ws[i];
              if (align[v] === v && prevIdx < pos[w2] && !hasConflict(conflicts, v, w2)) {
                align[w2] = v;
                align[v] = root2[v] = root2[w2];
                prevIdx = pos[w2];
              }
            }
          }
        });
      });
      return { root: root2, align };
    }
    function horizontalCompaction(g, layering, root2, align, reverseSep) {
      var xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
      function iterate(setXsFunc, nextNodesFunc) {
        var stack2 = blockG.nodes();
        var elem = stack2.pop();
        var visited = {};
        while (elem) {
          if (visited[elem]) {
            setXsFunc(elem);
          } else {
            visited[elem] = true;
            stack2.push(elem);
            stack2 = stack2.concat(nextNodesFunc(elem));
          }
          elem = stack2.pop();
        }
      }
      function pass1(elem) {
        xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
          return Math.max(acc, xs[e.v] + blockG.edge(e));
        }, 0);
      }
      function pass2(elem) {
        var min2 = blockG.outEdges(elem).reduce(function(acc, e) {
          return Math.min(acc, xs[e.w] - blockG.edge(e));
        }, Number.POSITIVE_INFINITY);
        var node2 = g.node(elem);
        if (min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType) {
          xs[elem] = Math.max(xs[elem], min2);
        }
      }
      iterate(pass1, blockG.predecessors.bind(blockG));
      iterate(pass2, blockG.successors.bind(blockG));
      _2.forEach(align, function(v) {
        xs[v] = xs[root2[v]];
      });
      return xs;
    }
    function buildBlockGraph(g, layering, root2, reverseSep) {
      var blockGraph = new Graph2(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
      _2.forEach(layering, function(layer) {
        var u2;
        _2.forEach(layer, function(v) {
          var vRoot = root2[v];
          blockGraph.setNode(vRoot);
          if (u2) {
            var uRoot = root2[u2], prevMax = blockGraph.edge(uRoot, vRoot);
            blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u2), prevMax || 0));
          }
          u2 = v;
        });
      });
      return blockGraph;
    }
    function findSmallestWidthAlignment(g, xss) {
      return _2.minBy(_2.values(xss), function(xs) {
        var max2 = Number.NEGATIVE_INFINITY;
        var min2 = Number.POSITIVE_INFINITY;
        _2.forIn(xs, function(x2, v) {
          var halfWidth = width2(g, v) / 2;
          max2 = Math.max(x2 + halfWidth, max2);
          min2 = Math.min(x2 - halfWidth, min2);
        });
        return max2 - min2;
      });
    }
    function alignCoordinates(xss, alignTo) {
      var alignToVals = _2.values(alignTo), alignToMin = _2.min(alignToVals), alignToMax = _2.max(alignToVals);
      _2.forEach(["u", "d"], function(vert) {
        _2.forEach(["l", "r"], function(horiz) {
          var alignment = vert + horiz, xs = xss[alignment], delta;
          if (xs === alignTo)
            return;
          var xsVals = _2.values(xs);
          delta = horiz === "l" ? alignToMin - _2.min(xsVals) : alignToMax - _2.max(xsVals);
          if (delta) {
            xss[alignment] = _2.mapValues(xs, function(x2) {
              return x2 + delta;
            });
          }
        });
      });
    }
    function balance(xss, align) {
      return _2.mapValues(xss.ul, function(ignore, v) {
        if (align) {
          return xss[align.toLowerCase()][v];
        } else {
          var xs = _2.sortBy(_2.map(xss, v));
          return (xs[1] + xs[2]) / 2;
        }
      });
    }
    function positionX(g) {
      var layering = util2.buildLayerMatrix(g);
      var conflicts = _2.merge(
        findType1Conflicts(g, layering),
        findType2Conflicts(g, layering)
      );
      var xss = {};
      var adjustedLayering;
      _2.forEach(["u", "d"], function(vert) {
        adjustedLayering = vert === "u" ? layering : _2.values(layering).reverse();
        _2.forEach(["l", "r"], function(horiz) {
          if (horiz === "r") {
            adjustedLayering = _2.map(adjustedLayering, function(inner) {
              return _2.values(inner).reverse();
            });
          }
          var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
          var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
          var xs = horizontalCompaction(
            g,
            adjustedLayering,
            align.root,
            align.align,
            horiz === "r"
          );
          if (horiz === "r") {
            xs = _2.mapValues(xs, function(x2) {
              return -x2;
            });
          }
          xss[vert + horiz] = xs;
        });
      });
      var smallestWidth = findSmallestWidthAlignment(g, xss);
      alignCoordinates(xss, smallestWidth);
      return balance(xss, g.graph().align);
    }
    function sep(nodeSep, edgeSep, reverseSep) {
      return function(g, v, w2) {
        var vLabel = g.node(v);
        var wLabel = g.node(w2);
        var sum2 = 0;
        var delta;
        sum2 += vLabel.width / 2;
        if (_2.has(vLabel, "labelpos")) {
          switch (vLabel.labelpos.toLowerCase()) {
            case "l":
              delta = -vLabel.width / 2;
              break;
            case "r":
              delta = vLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum2 += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum2 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
        sum2 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
        sum2 += wLabel.width / 2;
        if (_2.has(wLabel, "labelpos")) {
          switch (wLabel.labelpos.toLowerCase()) {
            case "l":
              delta = wLabel.width / 2;
              break;
            case "r":
              delta = -wLabel.width / 2;
              break;
          }
        }
        if (delta) {
          sum2 += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum2;
      };
    }
    function width2(g, v) {
      return g.node(v).width;
    }
    return bk;
  }
  var position_1;
  var hasRequiredPosition;
  function requirePosition() {
    if (hasRequiredPosition)
      return position_1;
    hasRequiredPosition = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    var positionX = requireBk().positionX;
    position_1 = position2;
    function position2(g) {
      g = util2.asNonCompoundGraph(g);
      positionY(g);
      _2.forEach(positionX(g), function(x2, v) {
        g.node(v).x = x2;
      });
    }
    function positionY(g) {
      var layering = util2.buildLayerMatrix(g);
      var rankSep = g.graph().ranksep;
      var prevY = 0;
      _2.forEach(layering, function(layer) {
        var maxHeight = _2.max(_2.map(layer, function(v) {
          return g.node(v).height;
        }));
        _2.forEach(layer, function(v) {
          g.node(v).y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + rankSep;
      });
    }
    return position_1;
  }
  var layout_1;
  var hasRequiredLayout;
  function requireLayout() {
    if (hasRequiredLayout)
      return layout_1;
    hasRequiredLayout = 1;
    var _2 = requireLodash();
    var acyclic2 = requireAcyclic();
    var normalize2 = requireNormalize();
    var rank2 = requireRank();
    var normalizeRanks = requireUtil$1().normalizeRanks;
    var parentDummyChains = requireParentDummyChains();
    var removeEmptyRanks = requireUtil$1().removeEmptyRanks;
    var nestingGraph2 = requireNestingGraph();
    var addBorderSegments = requireAddBorderSegments();
    var coordinateSystem2 = requireCoordinateSystem();
    var order = requireOrder();
    var position2 = requirePosition();
    var util2 = requireUtil$1();
    var Graph2 = requireGraphlib().Graph;
    layout_1 = layout2;
    function layout2(g, opts) {
      var time2 = opts && opts.debugTiming ? util2.time : util2.notime;
      time2("layout", function() {
        var layoutGraph = time2("  buildLayoutGraph", function() {
          return buildLayoutGraph(g);
        });
        time2("  runLayout", function() {
          runLayout(layoutGraph, time2);
        });
        time2("  updateInputGraph", function() {
          updateInputGraph(g, layoutGraph);
        });
      });
    }
    function runLayout(g, time2) {
      time2("    makeSpaceForEdgeLabels", function() {
        makeSpaceForEdgeLabels(g);
      });
      time2("    removeSelfEdges", function() {
        removeSelfEdges(g);
      });
      time2("    acyclic", function() {
        acyclic2.run(g);
      });
      time2("    nestingGraph.run", function() {
        nestingGraph2.run(g);
      });
      time2("    rank", function() {
        rank2(util2.asNonCompoundGraph(g));
      });
      time2("    injectEdgeLabelProxies", function() {
        injectEdgeLabelProxies(g);
      });
      time2("    removeEmptyRanks", function() {
        removeEmptyRanks(g);
      });
      time2("    nestingGraph.cleanup", function() {
        nestingGraph2.cleanup(g);
      });
      time2("    normalizeRanks", function() {
        normalizeRanks(g);
      });
      time2("    assignRankMinMax", function() {
        assignRankMinMax(g);
      });
      time2("    removeEdgeLabelProxies", function() {
        removeEdgeLabelProxies(g);
      });
      time2("    normalize.run", function() {
        normalize2.run(g);
      });
      time2("    parentDummyChains", function() {
        parentDummyChains(g);
      });
      time2("    addBorderSegments", function() {
        addBorderSegments(g);
      });
      time2("    order", function() {
        order(g);
      });
      time2("    insertSelfEdges", function() {
        insertSelfEdges(g);
      });
      time2("    adjustCoordinateSystem", function() {
        coordinateSystem2.adjust(g);
      });
      time2("    position", function() {
        position2(g);
      });
      time2("    positionSelfEdges", function() {
        positionSelfEdges(g);
      });
      time2("    removeBorderNodes", function() {
        removeBorderNodes(g);
      });
      time2("    normalize.undo", function() {
        normalize2.undo(g);
      });
      time2("    fixupEdgeLabelCoords", function() {
        fixupEdgeLabelCoords(g);
      });
      time2("    undoCoordinateSystem", function() {
        coordinateSystem2.undo(g);
      });
      time2("    translateGraph", function() {
        translateGraph(g);
      });
      time2("    assignNodeIntersects", function() {
        assignNodeIntersects(g);
      });
      time2("    reversePoints", function() {
        reversePointsForReversedEdges(g);
      });
      time2("    acyclic.undo", function() {
        acyclic2.undo(g);
      });
    }
    function updateInputGraph(inputGraph, layoutGraph) {
      _2.forEach(inputGraph.nodes(), function(v) {
        var inputLabel = inputGraph.node(v);
        var layoutLabel = layoutGraph.node(v);
        if (inputLabel) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
          if (layoutGraph.children(v).length) {
            inputLabel.width = layoutLabel.width;
            inputLabel.height = layoutLabel.height;
          }
        }
      });
      _2.forEach(inputGraph.edges(), function(e) {
        var inputLabel = inputGraph.edge(e);
        var layoutLabel = layoutGraph.edge(e);
        inputLabel.points = layoutLabel.points;
        if (_2.has(layoutLabel, "x")) {
          inputLabel.x = layoutLabel.x;
          inputLabel.y = layoutLabel.y;
        }
      });
      inputGraph.graph().width = layoutGraph.graph().width;
      inputGraph.graph().height = layoutGraph.graph().height;
    }
    var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
    var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
    var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
    var nodeNumAttrs = ["width", "height"];
    var nodeDefaults = { width: 0, height: 0 };
    var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
    var edgeDefaults = {
      minlen: 1,
      weight: 1,
      width: 0,
      height: 0,
      labeloffset: 10,
      labelpos: "r"
    };
    var edgeAttrs = ["labelpos"];
    function buildLayoutGraph(inputGraph) {
      var g = new Graph2({ multigraph: true, compound: true });
      var graph2 = canonicalize(inputGraph.graph());
      g.setGraph(_2.merge(
        {},
        graphDefaults,
        selectNumberAttrs(graph2, graphNumAttrs),
        _2.pick(graph2, graphAttrs)
      ));
      _2.forEach(inputGraph.nodes(), function(v) {
        var node2 = canonicalize(inputGraph.node(v));
        g.setNode(v, _2.defaults(selectNumberAttrs(node2, nodeNumAttrs), nodeDefaults));
        g.setParent(v, inputGraph.parent(v));
      });
      _2.forEach(inputGraph.edges(), function(e) {
        var edge = canonicalize(inputGraph.edge(e));
        g.setEdge(e, _2.merge(
          {},
          edgeDefaults,
          selectNumberAttrs(edge, edgeNumAttrs),
          _2.pick(edge, edgeAttrs)
        ));
      });
      return g;
    }
    function makeSpaceForEdgeLabels(g) {
      var graph2 = g.graph();
      graph2.ranksep /= 2;
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        edge.minlen *= 2;
        if (edge.labelpos.toLowerCase() !== "c") {
          if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
            edge.width += edge.labeloffset;
          } else {
            edge.height += edge.labeloffset;
          }
        }
      });
    }
    function injectEdgeLabelProxies(g) {
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        if (edge.width && edge.height) {
          var v = g.node(e.v);
          var w2 = g.node(e.w);
          var label = { rank: (w2.rank - v.rank) / 2 + v.rank, e };
          util2.addDummyNode(g, "edge-proxy", label, "_ep");
        }
      });
    }
    function assignRankMinMax(g) {
      var maxRank = 0;
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        if (node2.borderTop) {
          node2.minRank = g.node(node2.borderTop).rank;
          node2.maxRank = g.node(node2.borderBottom).rank;
          maxRank = _2.max(maxRank, node2.maxRank);
        }
      });
      g.graph().maxRank = maxRank;
    }
    function removeEdgeLabelProxies(g) {
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        if (node2.dummy === "edge-proxy") {
          g.edge(node2.e).labelRank = node2.rank;
          g.removeNode(v);
        }
      });
    }
    function translateGraph(g) {
      var minX = Number.POSITIVE_INFINITY;
      var maxX = 0;
      var minY = Number.POSITIVE_INFINITY;
      var maxY2 = 0;
      var graphLabel = g.graph();
      var marginX = graphLabel.marginx || 0;
      var marginY = graphLabel.marginy || 0;
      function getExtremes(attrs) {
        var x2 = attrs.x;
        var y2 = attrs.y;
        var w2 = attrs.width;
        var h = attrs.height;
        minX = Math.min(minX, x2 - w2 / 2);
        maxX = Math.max(maxX, x2 + w2 / 2);
        minY = Math.min(minY, y2 - h / 2);
        maxY2 = Math.max(maxY2, y2 + h / 2);
      }
      _2.forEach(g.nodes(), function(v) {
        getExtremes(g.node(v));
      });
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        if (_2.has(edge, "x")) {
          getExtremes(edge);
        }
      });
      minX -= marginX;
      minY -= marginY;
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        node2.x -= minX;
        node2.y -= minY;
      });
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        _2.forEach(edge.points, function(p) {
          p.x -= minX;
          p.y -= minY;
        });
        if (_2.has(edge, "x")) {
          edge.x -= minX;
        }
        if (_2.has(edge, "y")) {
          edge.y -= minY;
        }
      });
      graphLabel.width = maxX - minX + marginX;
      graphLabel.height = maxY2 - minY + marginY;
    }
    function assignNodeIntersects(g) {
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        var nodeV = g.node(e.v);
        var nodeW = g.node(e.w);
        var p1, p2;
        if (!edge.points) {
          edge.points = [];
          p1 = nodeW;
          p2 = nodeV;
        } else {
          p1 = edge.points[0];
          p2 = edge.points[edge.points.length - 1];
        }
        edge.points.unshift(util2.intersectRect(nodeV, p1));
        edge.points.push(util2.intersectRect(nodeW, p2));
      });
    }
    function fixupEdgeLabelCoords(g) {
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        if (_2.has(edge, "x")) {
          if (edge.labelpos === "l" || edge.labelpos === "r") {
            edge.width -= edge.labeloffset;
          }
          switch (edge.labelpos) {
            case "l":
              edge.x -= edge.width / 2 + edge.labeloffset;
              break;
            case "r":
              edge.x += edge.width / 2 + edge.labeloffset;
              break;
          }
        }
      });
    }
    function reversePointsForReversedEdges(g) {
      _2.forEach(g.edges(), function(e) {
        var edge = g.edge(e);
        if (edge.reversed) {
          edge.points.reverse();
        }
      });
    }
    function removeBorderNodes(g) {
      _2.forEach(g.nodes(), function(v) {
        if (g.children(v).length) {
          var node2 = g.node(v);
          var t = g.node(node2.borderTop);
          var b = g.node(node2.borderBottom);
          var l = g.node(_2.last(node2.borderLeft));
          var r = g.node(_2.last(node2.borderRight));
          node2.width = Math.abs(r.x - l.x);
          node2.height = Math.abs(b.y - t.y);
          node2.x = l.x + node2.width / 2;
          node2.y = t.y + node2.height / 2;
        }
      });
      _2.forEach(g.nodes(), function(v) {
        if (g.node(v).dummy === "border") {
          g.removeNode(v);
        }
      });
    }
    function removeSelfEdges(g) {
      _2.forEach(g.edges(), function(e) {
        if (e.v === e.w) {
          var node2 = g.node(e.v);
          if (!node2.selfEdges) {
            node2.selfEdges = [];
          }
          node2.selfEdges.push({ e, label: g.edge(e) });
          g.removeEdge(e);
        }
      });
    }
    function insertSelfEdges(g) {
      var layers = util2.buildLayerMatrix(g);
      _2.forEach(layers, function(layer) {
        var orderShift = 0;
        _2.forEach(layer, function(v, i) {
          var node2 = g.node(v);
          node2.order = i + orderShift;
          _2.forEach(node2.selfEdges, function(selfEdge) {
            util2.addDummyNode(g, "selfedge", {
              width: selfEdge.label.width,
              height: selfEdge.label.height,
              rank: node2.rank,
              order: i + ++orderShift,
              e: selfEdge.e,
              label: selfEdge.label
            }, "_se");
          });
          delete node2.selfEdges;
        });
      });
    }
    function positionSelfEdges(g) {
      _2.forEach(g.nodes(), function(v) {
        var node2 = g.node(v);
        if (node2.dummy === "selfedge") {
          var selfNode = g.node(node2.e.v);
          var x2 = selfNode.x + selfNode.width / 2;
          var y2 = selfNode.y;
          var dx = node2.x - x2;
          var dy = selfNode.height / 2;
          g.setEdge(node2.e, node2.label);
          g.removeNode(v);
          node2.label.points = [
            { x: x2 + 2 * dx / 3, y: y2 - dy },
            { x: x2 + 5 * dx / 6, y: y2 - dy },
            { x: x2 + dx, y: y2 },
            { x: x2 + 5 * dx / 6, y: y2 + dy },
            { x: x2 + 2 * dx / 3, y: y2 + dy }
          ];
          node2.label.x = node2.x;
          node2.label.y = node2.y;
        }
      });
    }
    function selectNumberAttrs(obj, attrs) {
      return _2.mapValues(_2.pick(obj, attrs), Number);
    }
    function canonicalize(attrs) {
      var newAttrs = {};
      _2.forEach(attrs, function(v, k2) {
        newAttrs[k2.toLowerCase()] = v;
      });
      return newAttrs;
    }
    return layout_1;
  }
  var debug;
  var hasRequiredDebug;
  function requireDebug() {
    if (hasRequiredDebug)
      return debug;
    hasRequiredDebug = 1;
    var _2 = requireLodash();
    var util2 = requireUtil$1();
    var Graph2 = requireGraphlib().Graph;
    debug = {
      debugOrdering
    };
    function debugOrdering(g) {
      var layerMatrix = util2.buildLayerMatrix(g);
      var h = new Graph2({ compound: true, multigraph: true }).setGraph({});
      _2.forEach(g.nodes(), function(v) {
        h.setNode(v, { label: v });
        h.setParent(v, "layer" + g.node(v).rank);
      });
      _2.forEach(g.edges(), function(e) {
        h.setEdge(e.v, e.w, {}, e.name);
      });
      _2.forEach(layerMatrix, function(layer, i) {
        var layerV = "layer" + i;
        h.setNode(layerV, { rank: "same" });
        _2.reduce(layer, function(u2, v) {
          h.setEdge(u2, v, { style: "invis" });
          return v;
        });
      });
      return h;
    }
    return debug;
  }
  var version$2;
  var hasRequiredVersion;
  function requireVersion() {
    if (hasRequiredVersion)
      return version$2;
    hasRequiredVersion = 1;
    version$2 = "0.8.5";
    return version$2;
  }
  var dagre$1;
  var hasRequiredDagre;
  function requireDagre() {
    if (hasRequiredDagre)
      return dagre$1;
    hasRequiredDagre = 1;
    dagre$1 = {
      graphlib: requireGraphlib(),
      layout: requireLayout(),
      debug: requireDebug(),
      util: {
        time: requireUtil$1().time,
        notime: requireUtil$1().notime
      },
      version: requireVersion()
    };
    return dagre$1;
  }
  var dagreExports = requireDagre();
  let edgeCount$1 = 0;
  const drawEdge$1 = function(elem, path2, relation, conf2, diagObj) {
    const getRelationType = function(type2) {
      switch (type2) {
        case diagObj.db.relationType.AGGREGATION:
          return "aggregation";
        case diagObj.db.EXTENSION:
          return "extension";
        case diagObj.db.COMPOSITION:
          return "composition";
        case diagObj.db.DEPENDENCY:
          return "dependency";
        case diagObj.db.LOLLIPOP:
          return "lollipop";
      }
    };
    path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
    const lineData = path2.points;
    const lineFunction = line$1().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    }).curve(curveBasis);
    const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount$1).attr("class", "relation");
    let url = "";
    if (conf2.arrowMarkerAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replace(/\(/g, "\\(");
      url = url.replace(/\)/g, "\\)");
    }
    if (relation.relation.lineType == 1) {
      svgPath.attr("class", "relation dashed-line");
    }
    if (relation.relation.type1 !== "none") {
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + getRelationType(relation.relation.type1) + "Start)"
      );
    }
    if (relation.relation.type2 !== "none") {
      svgPath.attr(
        "marker-end",
        "url(" + url + "#" + getRelationType(relation.relation.type2) + "End)"
      );
    }
    let x2, y2;
    const l = path2.points.length;
    let labelPosition = utils.calcLabelPosition(path2.points);
    x2 = labelPosition.x;
    y2 = labelPosition.y;
    let p1_card_x, p1_card_y;
    let p2_card_x, p2_card_y;
    if (l % 2 !== 0 && l > 1) {
      let cardinality_1_point = utils.calcCardinalityPosition(
        relation.relation.type1 !== "none",
        path2.points,
        path2.points[0]
      );
      let cardinality_2_point = utils.calcCardinalityPosition(
        relation.relation.type2 !== "none",
        path2.points,
        path2.points[l - 1]
      );
      log$3.debug("cardinality_1_point " + JSON.stringify(cardinality_1_point));
      log$3.debug("cardinality_2_point " + JSON.stringify(cardinality_2_point));
      p1_card_x = cardinality_1_point.x;
      p1_card_y = cardinality_1_point.y;
      p2_card_x = cardinality_2_point.x;
      p2_card_y = cardinality_2_point.y;
    }
    if (typeof relation.title !== "undefined") {
      const g = elem.append("g").attr("class", "classLabel");
      const label = g.append("text").attr("class", "label").attr("x", x2).attr("y", y2).attr("fill", "red").attr("text-anchor", "middle").text(relation.title);
      window.label = label;
      const bounds2 = label.node().getBBox();
      g.insert("rect", ":first-child").attr("class", "box").attr("x", bounds2.x - conf2.padding / 2).attr("y", bounds2.y - conf2.padding / 2).attr("width", bounds2.width + conf2.padding).attr("height", bounds2.height + conf2.padding);
    }
    log$3.info("Rendering relation " + JSON.stringify(relation));
    if (typeof relation.relationTitle1 !== "undefined" && relation.relationTitle1 !== "none") {
      const g = elem.append("g").attr("class", "cardinality");
      g.append("text").attr("class", "type1").attr("x", p1_card_x).attr("y", p1_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle1);
    }
    if (typeof relation.relationTitle2 !== "undefined" && relation.relationTitle2 !== "none") {
      const g = elem.append("g").attr("class", "cardinality");
      g.append("text").attr("class", "type2").attr("x", p2_card_x).attr("y", p2_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle2);
    }
    edgeCount$1++;
  };
  const drawClass = function(elem, classDef, conf2, diagObj) {
    log$3.debug("Rendering class ", classDef, conf2);
    const id2 = classDef.id;
    const classInfo = {
      id: id2,
      label: classDef.id,
      width: 0,
      height: 0
    };
    const g = elem.append("g").attr("id", diagObj.db.lookUpDomId(id2)).attr("class", "classGroup");
    let title2;
    if (classDef.link) {
      title2 = g.append("svg:a").attr("xlink:href", classDef.link).attr("target", classDef.linkTarget).append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
    } else {
      title2 = g.append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
    }
    let isFirst = true;
    classDef.annotations.forEach(function(member) {
      const titleText2 = title2.append("tspan").text("\xAB" + member + "\xBB");
      if (!isFirst)
        titleText2.attr("dy", conf2.textHeight);
      isFirst = false;
    });
    let classTitleString = classDef.id;
    if (classDef.type !== void 0 && classDef.type !== "") {
      classTitleString += "<" + classDef.type + ">";
    }
    const classTitle = title2.append("tspan").text(classTitleString).attr("class", "title");
    if (!isFirst)
      classTitle.attr("dy", conf2.textHeight);
    const titleHeight = title2.node().getBBox().height;
    const membersLine = g.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin / 2).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin / 2);
    const members = g.append("text").attr("x", conf2.padding).attr("y", titleHeight + conf2.dividerMargin + conf2.textHeight).attr("fill", "white").attr("class", "classText");
    isFirst = true;
    classDef.members.forEach(function(member) {
      addTspan(members, member, isFirst, conf2);
      isFirst = false;
    });
    const membersBox = members.node().getBBox();
    const methodsLine = g.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height);
    const methods = g.append("text").attr("x", conf2.padding).attr("y", titleHeight + 2 * conf2.dividerMargin + membersBox.height + conf2.textHeight).attr("fill", "white").attr("class", "classText");
    isFirst = true;
    classDef.methods.forEach(function(method) {
      addTspan(methods, method, isFirst, conf2);
      isFirst = false;
    });
    const classBox = g.node().getBBox();
    var cssClassStr = " ";
    if (classDef.cssClasses.length > 0) {
      cssClassStr = cssClassStr + classDef.cssClasses.join(" ");
    }
    const rect2 = g.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", classBox.width + 2 * conf2.padding).attr("height", classBox.height + conf2.padding + 0.5 * conf2.dividerMargin).attr("class", cssClassStr);
    const rectWidth = rect2.node().getBBox().width;
    title2.node().childNodes.forEach(function(x2) {
      x2.setAttribute("x", (rectWidth - x2.getBBox().width) / 2);
    });
    if (classDef.tooltip) {
      title2.insert("title").text(classDef.tooltip);
    }
    membersLine.attr("x2", rectWidth);
    methodsLine.attr("x2", rectWidth);
    classInfo.width = rectWidth;
    classInfo.height = classBox.height + conf2.padding + 0.5 * conf2.dividerMargin;
    return classInfo;
  };
  const parseMember = function(text2) {
    const fieldRegEx = /^(\+|-|~|#)?(\w+)(~\w+~|\[\])?\s+(\w+) *(\*|\$)?$/;
    const methodRegEx = /^([+|\-|~|#])?(\w+) *\( *(.*)\) *(\*|\$)? *(\w*[~|[\]]*\s*\w*~?)$/;
    let fieldMatch = text2.match(fieldRegEx);
    let methodMatch = text2.match(methodRegEx);
    if (fieldMatch && !methodMatch) {
      return buildFieldDisplay(fieldMatch);
    } else if (methodMatch) {
      return buildMethodDisplay(methodMatch);
    } else {
      return buildLegacyDisplay(text2);
    }
  };
  const buildFieldDisplay = function(parsedText) {
    let cssStyle = "";
    let displayText = "";
    try {
      let visibility = parsedText[1] ? parsedText[1].trim() : "";
      let fieldType = parsedText[2] ? parsedText[2].trim() : "";
      let genericType = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
      let fieldName = parsedText[4] ? parsedText[4].trim() : "";
      let classifier = parsedText[5] ? parsedText[5].trim() : "";
      displayText = visibility + fieldType + genericType + " " + fieldName;
      cssStyle = parseClassifier(classifier);
    } catch (err) {
      displayText = parsedText;
    }
    return {
      displayText,
      cssStyle
    };
  };
  const buildMethodDisplay = function(parsedText) {
    let cssStyle = "";
    let displayText = "";
    try {
      let visibility = parsedText[1] ? parsedText[1].trim() : "";
      let methodName = parsedText[2] ? parsedText[2].trim() : "";
      let parameters = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
      let classifier = parsedText[4] ? parsedText[4].trim() : "";
      let returnType = parsedText[5] ? " : " + parseGenericTypes(parsedText[5]).trim() : "";
      displayText = visibility + methodName + "(" + parameters + ")" + returnType;
      cssStyle = parseClassifier(classifier);
    } catch (err) {
      displayText = parsedText;
    }
    return {
      displayText,
      cssStyle
    };
  };
  const buildLegacyDisplay = function(text2) {
    let displayText = "";
    let cssStyle = "";
    let returnType = "";
    let methodStart = text2.indexOf("(");
    let methodEnd = text2.indexOf(")");
    if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text2.length) {
      let visibility = "";
      let methodName = "";
      let firstChar = text2.substring(0, 1);
      if (firstChar.match(/\w/)) {
        methodName = text2.substring(0, methodStart).trim();
      } else {
        if (firstChar.match(/\+|-|~|#/)) {
          visibility = firstChar;
        }
        methodName = text2.substring(1, methodStart).trim();
      }
      const parameters = text2.substring(methodStart + 1, methodEnd);
      text2.substring(methodEnd + 1, 1);
      cssStyle = parseClassifier(text2.substring(methodEnd + 1, methodEnd + 2));
      displayText = visibility + methodName + "(" + parseGenericTypes(parameters.trim()) + ")";
      if (methodEnd < text2.length) {
        returnType = text2.substring(methodEnd + 2).trim();
        if (returnType !== "") {
          returnType = " : " + parseGenericTypes(returnType);
          displayText += returnType;
        }
      }
    } else {
      displayText = parseGenericTypes(text2);
    }
    return {
      displayText,
      cssStyle
    };
  };
  const addTspan = function(textEl, txt, isFirst, conf2) {
    let member = parseMember(txt);
    const tSpan = textEl.append("tspan").attr("x", conf2.padding).text(member.displayText);
    if (member.cssStyle !== "") {
      tSpan.attr("style", member.cssStyle);
    }
    if (!isFirst) {
      tSpan.attr("dy", conf2.textHeight);
    }
  };
  const parseClassifier = function(classifier) {
    switch (classifier) {
      case "*":
        return "font-style:italic;";
      case "$":
        return "text-decoration:underline;";
      default:
        return "";
    }
  };
  const svgDraw$2 = {
    drawClass,
    drawEdge: drawEdge$1,
    parseMember
  };
  let idCache = {};
  const padding = 20;
  const getGraphId = function(label) {
    const foundEntry = Object.entries(idCache).find((entry) => entry[1].label === label);
    if (foundEntry) {
      return foundEntry[0];
    }
  };
  const insertMarkers$3 = function(elem) {
    elem.append("defs").append("marker").attr("id", "extensionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
    elem.append("defs").append("marker").attr("id", "extensionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
    elem.append("defs").append("marker").attr("id", "compositionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", "compositionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", "aggregationStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", "aggregationEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", "dependencyStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
  };
  const draw$d = function(text2, id2, _version, diagObj) {
    const conf2 = getConfig$1().class;
    idCache = {};
    log$3.info("Rendering diagram " + text2);
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const diagram = root2.select(`[id='${id2}']`);
    insertMarkers$3(diagram);
    const g = new graphlib$1.Graph({
      multigraph: true
    });
    g.setGraph({
      isMultiGraph: true
    });
    g.setDefaultEdgeLabel(function() {
      return {};
    });
    const classes2 = diagObj.db.getClasses();
    const keys = Object.keys(classes2);
    for (let i = 0; i < keys.length; i++) {
      const classDef = classes2[keys[i]];
      const node2 = svgDraw$2.drawClass(diagram, classDef, conf2, diagObj);
      idCache[node2.id] = node2;
      g.setNode(node2.id, node2);
      log$3.info("Org height: " + node2.height);
    }
    const relations2 = diagObj.db.getRelations();
    relations2.forEach(function(relation) {
      log$3.info(
        "tjoho" + getGraphId(relation.id1) + getGraphId(relation.id2) + JSON.stringify(relation)
      );
      g.setEdge(
        getGraphId(relation.id1),
        getGraphId(relation.id2),
        {
          relation
        },
        relation.title || "DEFAULT"
      );
    });
    dagreExports.layout(g);
    g.nodes().forEach(function(v) {
      if (typeof v !== "undefined" && typeof g.node(v) !== "undefined") {
        log$3.debug("Node " + v + ": " + JSON.stringify(g.node(v)));
        root2.select("#" + diagObj.db.lookUpDomId(v)).attr(
          "transform",
          "translate(" + (g.node(v).x - g.node(v).width / 2) + "," + (g.node(v).y - g.node(v).height / 2) + " )"
        );
      }
    });
    g.edges().forEach(function(e) {
      if (typeof e !== "undefined" && typeof g.edge(e) !== "undefined") {
        log$3.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(g.edge(e)));
        svgDraw$2.drawEdge(diagram, g.edge(e), g.edge(e).relation, conf2, diagObj);
      }
    });
    const svgBounds = diagram.node().getBBox();
    const width2 = svgBounds.width + padding * 2;
    const height2 = svgBounds.height + padding * 2;
    configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
    const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${width2} ${height2}`;
    log$3.debug(`viewBox ${vBox}`);
    diagram.attr("viewBox", vBox);
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
  };
  const classRenderer = {
    draw: draw$d
  };
  const insertMarkers$2 = (elem, markerArray, type2, id2) => {
    markerArray.forEach((markerName) => {
      markers$1[markerName](elem, type2, id2);
    });
  };
  const extension = (elem, type2, id2) => {
    log$3.trace("Making markers for ", id2);
    elem.append("defs").append("marker").attr("id", type2 + "-extensionStart").attr("class", "marker extension " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
    elem.append("defs").append("marker").attr("id", type2 + "-extensionEnd").attr("class", "marker extension " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
  };
  const composition = (elem, type2) => {
    elem.append("defs").append("marker").attr("id", type2 + "-compositionStart").attr("class", "marker composition " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", type2 + "-compositionEnd").attr("class", "marker composition " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  };
  const aggregation = (elem, type2) => {
    elem.append("defs").append("marker").attr("id", type2 + "-aggregationStart").attr("class", "marker aggregation " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", type2 + "-aggregationEnd").attr("class", "marker aggregation " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  };
  const dependency = (elem, type2) => {
    elem.append("defs").append("marker").attr("id", type2 + "-dependencyStart").attr("class", "marker dependency " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
    elem.append("defs").append("marker").attr("id", type2 + "-dependencyEnd").attr("class", "marker dependency " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
  };
  const lollipop = (elem, type2) => {
    elem.append("defs").append("marker").attr("id", type2 + "-lollipopStart").attr("class", "marker lollipop " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);
  };
  const point = (elem, type2) => {
    elem.append("marker").attr("id", type2 + "-pointEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", type2 + "-pointStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const circle$1 = (elem, type2) => {
    elem.append("marker").attr("id", type2 + "-circleEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", type2 + "-circleStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const cross = (elem, type2) => {
    elem.append("marker").attr("id", type2 + "-crossEnd").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
    elem.append("marker").attr("id", type2 + "-crossStart").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
  };
  const barb = (elem, type2) => {
    elem.append("defs").append("marker").attr("id", type2 + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
  };
  const markers$1 = {
    extension,
    composition,
    aggregation,
    dependency,
    lollipop,
    point,
    circle: circle$1,
    cross,
    barb
  };
  function applyStyle$1(dom, styleFn) {
    if (styleFn) {
      dom.attr("style", styleFn);
    }
  }
  function addHtmlLabel$1(node2) {
    const fo = select(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));
    const div = fo.append("xhtml:div");
    const label = node2.label;
    const labelClass = node2.isNode ? "nodeLabel" : "edgeLabel";
    div.html(
      '<span class="' + labelClass + '" ' + (node2.labelStyle ? 'style="' + node2.labelStyle + '"' : "") + ">" + label + "</span>"
    );
    applyStyle$1(div, node2.labelStyle);
    div.style("display", "inline-block");
    div.style("white-space", "nowrap");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    return fo.node();
  }
  const createLabel = (_vertexText, style, isTitle, isNode) => {
    let vertexText = _vertexText || "";
    if (typeof vertexText === "object")
      vertexText = vertexText[0];
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      vertexText = vertexText.replace(/\\n|\n/g, "<br />");
      log$3.info("vertexText" + vertexText);
      const node2 = {
        isNode,
        label: decodeEntities(vertexText).replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        ),
        labelStyle: style.replace("fill:", "color:")
      };
      let vertexNode = addHtmlLabel$1(node2);
      return vertexNode;
    } else {
      const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("style", style.replace("color:", "fill:"));
      let rows = [];
      if (typeof vertexText === "string") {
        rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
      } else if (Array.isArray(vertexText)) {
        rows = vertexText;
      } else {
        rows = [];
      }
      for (let j = 0; j < rows.length; j++) {
        const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        tspan.setAttribute("dy", "1em");
        tspan.setAttribute("x", "0");
        if (isTitle) {
          tspan.setAttribute("class", "title-row");
        } else {
          tspan.setAttribute("class", "row");
        }
        tspan.textContent = rows[j].trim();
        svgLabel.appendChild(tspan);
      }
      return svgLabel;
    }
  };
  const labelHelper = (parent, node2, _classes, isNode) => {
    let classes2;
    if (!_classes) {
      classes2 = "node default";
    } else {
      classes2 = _classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
    const label = shapeSvg.insert("g").attr("class", "label").attr("style", node2.labelStyle);
    let labelText;
    if (typeof node2.labelText === "undefined") {
      labelText = "";
    } else {
      labelText = typeof node2.labelText === "string" ? node2.labelText : node2.labelText[0];
    }
    const text2 = label.node().appendChild(
      createLabel(
        sanitizeText$5(decodeEntities(labelText), getConfig$1()),
        node2.labelStyle,
        false,
        isNode
      )
    );
    let bbox = text2.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = text2.children[0];
      const dv = select(text2);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    const halfPadding = node2.padding / 2;
    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
    return { shapeSvg, bbox, halfPadding, label };
  };
  const updateNodeBounds = (node2, element) => {
    const bbox = element.node().getBBox();
    node2.width = bbox.width;
    node2.height = bbox.height;
  };
  function insertPolygonShape$1(parent, w2, h, points) {
    return parent.insert("polygon", ":first-child").attr(
      "points",
      points.map(function(d) {
        return d.x + "," + d.y;
      }).join(" ")
    ).attr("class", "label-container").attr("transform", "translate(" + -w2 / 2 + "," + h / 2 + ")");
  }
  let clusterDb = {};
  let decendants = {};
  let parents = {};
  const clear$b = () => {
    decendants = {};
    parents = {};
    clusterDb = {};
  };
  const isDecendant = (id2, ancenstorId) => {
    log$3.trace(
      "In isDecendant",
      ancenstorId,
      " ",
      id2,
      " = ",
      decendants[ancenstorId].indexOf(id2) >= 0
    );
    if (decendants[ancenstorId].indexOf(id2) >= 0)
      return true;
    return false;
  };
  const edgeInCluster = (edge, clusterId) => {
    log$3.info("Decendants of ", clusterId, " is ", decendants[clusterId]);
    log$3.info("Edge is ", edge);
    if (edge.v === clusterId)
      return false;
    if (edge.w === clusterId)
      return false;
    if (!decendants[clusterId]) {
      log$3.debug("Tilt, ", clusterId, ",not in decendants");
      return false;
    }
    if (decendants[clusterId].indexOf(edge.v) >= 0)
      return true;
    if (isDecendant(edge.v, clusterId))
      return true;
    if (isDecendant(edge.w, clusterId))
      return true;
    if (decendants[clusterId].indexOf(edge.w) >= 0)
      return true;
    return false;
  };
  const copy = (clusterId, graph2, newGraph, rootId) => {
    log$3.warn(
      "Copying children of ",
      clusterId,
      "root",
      rootId,
      "data",
      graph2.node(clusterId),
      rootId
    );
    const nodes = graph2.children(clusterId) || [];
    if (clusterId !== rootId) {
      nodes.push(clusterId);
    }
    log$3.warn("Copying (nodes) clusterId", clusterId, "nodes", nodes);
    nodes.forEach((node2) => {
      if (graph2.children(node2).length > 0) {
        copy(node2, graph2, newGraph, rootId);
      } else {
        const data = graph2.node(node2);
        log$3.info("cp ", node2, " to ", rootId, " with parent ", clusterId);
        newGraph.setNode(node2, data);
        if (rootId !== graph2.parent(node2)) {
          log$3.warn("Setting parent", node2, graph2.parent(node2));
          newGraph.setParent(node2, graph2.parent(node2));
        }
        if (clusterId !== rootId && node2 !== clusterId) {
          log$3.debug("Setting parent", node2, clusterId);
          newGraph.setParent(node2, clusterId);
        } else {
          log$3.info("In copy ", clusterId, "root", rootId, "data", graph2.node(clusterId), rootId);
          log$3.debug(
            "Not Setting parent for node=",
            node2,
            "cluster!==rootId",
            clusterId !== rootId,
            "node!==clusterId",
            node2 !== clusterId
          );
        }
        const edges2 = graph2.edges(node2);
        log$3.debug("Copying Edges", edges2);
        edges2.forEach((edge) => {
          log$3.info("Edge", edge);
          const data2 = graph2.edge(edge.v, edge.w, edge.name);
          log$3.info("Edge data", data2, rootId);
          try {
            if (edgeInCluster(edge, rootId)) {
              log$3.info("Copying as ", edge.v, edge.w, data2, edge.name);
              newGraph.setEdge(edge.v, edge.w, data2, edge.name);
              log$3.info("newGraph edges ", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
            } else {
              log$3.info(
                "Skipping copy of edge ",
                edge.v,
                "-->",
                edge.w,
                " rootId: ",
                rootId,
                " clusterId:",
                clusterId
              );
            }
          } catch (e) {
            log$3.error(e);
          }
        });
      }
      log$3.debug("Removing node", node2);
      graph2.removeNode(node2);
    });
  };
  const extractDecendants = (id2, graph2) => {
    const children2 = graph2.children(id2);
    let res = [].concat(children2);
    for (let i = 0; i < children2.length; i++) {
      parents[children2[i]] = id2;
      res = res.concat(extractDecendants(children2[i], graph2));
    }
    return res;
  };
  const findNonClusterChild = (id2, graph2) => {
    log$3.trace("Searching", id2);
    const children2 = graph2.children(id2);
    log$3.trace("Searching children of id ", id2, children2);
    if (children2.length < 1) {
      log$3.trace("This is a valid node", id2);
      return id2;
    }
    for (let i = 0; i < children2.length; i++) {
      const _id = findNonClusterChild(children2[i], graph2);
      if (_id) {
        log$3.trace("Found replacement for", id2, " => ", _id);
        return _id;
      }
    }
  };
  const getAnchorId = (id2) => {
    if (!clusterDb[id2]) {
      return id2;
    }
    if (!clusterDb[id2].externalConnections) {
      return id2;
    }
    if (clusterDb[id2]) {
      return clusterDb[id2].id;
    }
    return id2;
  };
  const adjustClustersAndEdges = (graph2, depth) => {
    if (!graph2 || depth > 10) {
      log$3.debug("Opting out, no graph ");
      return;
    } else {
      log$3.debug("Opting in, graph ");
    }
    graph2.nodes().forEach(function(id2) {
      const children2 = graph2.children(id2);
      if (children2.length > 0) {
        log$3.warn(
          "Cluster identified",
          id2,
          " Replacement id in edges: ",
          findNonClusterChild(id2, graph2)
        );
        decendants[id2] = extractDecendants(id2, graph2);
        clusterDb[id2] = { id: findNonClusterChild(id2, graph2), clusterData: graph2.node(id2) };
      }
    });
    graph2.nodes().forEach(function(id2) {
      const children2 = graph2.children(id2);
      const edges2 = graph2.edges();
      if (children2.length > 0) {
        log$3.debug("Cluster identified", id2, decendants);
        edges2.forEach((edge) => {
          if (edge.v !== id2 && edge.w !== id2) {
            const d1 = isDecendant(edge.v, id2);
            const d2 = isDecendant(edge.w, id2);
            if (d1 ^ d2) {
              log$3.warn("Edge: ", edge, " leaves cluster ", id2);
              log$3.warn("Decendants of XXX ", id2, ": ", decendants[id2]);
              clusterDb[id2].externalConnections = true;
            }
          }
        });
      } else {
        log$3.debug("Not a cluster ", id2, decendants);
      }
    });
    graph2.edges().forEach(function(e) {
      const edge = graph2.edge(e);
      log$3.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
      log$3.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
      let v = e.v;
      let w2 = e.w;
      log$3.warn(
        "Fix XXX",
        clusterDb,
        "ids:",
        e.v,
        e.w,
        "Translateing: ",
        clusterDb[e.v],
        " --- ",
        clusterDb[e.w]
      );
      if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {
        log$3.warn("Fixing and trixing link to self - removing XXX", e.v, e.w, e.name);
        log$3.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
        v = getAnchorId(e.v);
        w2 = getAnchorId(e.w);
        graph2.removeEdge(e.v, e.w, e.name);
        const specialId = e.w + "---" + e.v;
        graph2.setNode(specialId, {
          domId: specialId,
          id: specialId,
          labelStyle: "",
          labelText: edge.label,
          padding: 0,
          shape: "labelRect",
          style: ""
        });
        const edge1 = JSON.parse(JSON.stringify(edge));
        const edge2 = JSON.parse(JSON.stringify(edge));
        edge1.label = "";
        edge1.arrowTypeEnd = "none";
        edge2.label = "";
        edge1.fromCluster = e.v;
        edge2.toCluster = e.v;
        graph2.setEdge(v, specialId, edge1, e.name + "-cyclic-special");
        graph2.setEdge(specialId, w2, edge2, e.name + "-cyclic-special");
      } else if (clusterDb[e.v] || clusterDb[e.w]) {
        log$3.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
        v = getAnchorId(e.v);
        w2 = getAnchorId(e.w);
        graph2.removeEdge(e.v, e.w, e.name);
        if (v !== e.v)
          edge.fromCluster = e.v;
        if (w2 !== e.w)
          edge.toCluster = e.w;
        log$3.warn("Fix Replacing with XXX", v, w2, e.name);
        graph2.setEdge(v, w2, edge, e.name);
      }
    });
    log$3.warn("Adjusted Graph", graphlib$1.json.write(graph2));
    extractor(graph2, 0);
    log$3.trace(clusterDb);
  };
  const extractor = (graph2, depth) => {
    log$3.warn("extractor - ", depth, graphlib$1.json.write(graph2), graph2.children("D"));
    if (depth > 10) {
      log$3.error("Bailing out");
      return;
    }
    let nodes = graph2.nodes();
    let hasChildren = false;
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      const children2 = graph2.children(node2);
      hasChildren = hasChildren || children2.length > 0;
    }
    if (!hasChildren) {
      log$3.debug("Done, no node has children", graph2.nodes());
      return;
    }
    log$3.debug("Nodes = ", nodes, depth);
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      log$3.debug(
        "Extracting node",
        node2,
        clusterDb,
        clusterDb[node2] && !clusterDb[node2].externalConnections,
        !graph2.parent(node2),
        graph2.node(node2),
        graph2.children("D"),
        " Depth ",
        depth
      );
      if (!clusterDb[node2]) {
        log$3.debug("Not a cluster", node2, depth);
      } else if (!clusterDb[node2].externalConnections && graph2.children(node2) && graph2.children(node2).length > 0) {
        log$3.warn(
          "Cluster without external connections, without a parent and with children",
          node2,
          depth
        );
        const graphSettings = graph2.graph();
        let dir = graphSettings.rankdir === "TB" ? "LR" : "TB";
        if (clusterDb[node2]) {
          if (clusterDb[node2].clusterData && clusterDb[node2].clusterData.dir) {
            dir = clusterDb[node2].clusterData.dir;
            log$3.warn("Fixing dir", clusterDb[node2].clusterData.dir, dir);
          }
        }
        const clusterGraph = new graphlib$1.Graph({
          multigraph: true,
          compound: true
        }).setGraph({
          rankdir: dir,
          nodesep: 50,
          ranksep: 50,
          marginx: 8,
          marginy: 8
        }).setDefaultEdgeLabel(function() {
          return {};
        });
        log$3.warn("Old graph before copy", graphlib$1.json.write(graph2));
        copy(node2, graph2, clusterGraph, node2);
        graph2.setNode(node2, {
          clusterNode: true,
          id: node2,
          clusterData: clusterDb[node2].clusterData,
          labelText: clusterDb[node2].labelText,
          graph: clusterGraph
        });
        log$3.warn("New graph after copy node: (", node2, ")", graphlib$1.json.write(clusterGraph));
        log$3.debug("Old graph after copy", graphlib$1.json.write(graph2));
      } else {
        log$3.warn(
          "Cluster ** ",
          node2,
          " **not meeting the criteria !externalConnections:",
          !clusterDb[node2].externalConnections,
          " no parent: ",
          !graph2.parent(node2),
          " children ",
          graph2.children(node2) && graph2.children(node2).length > 0,
          graph2.children("D"),
          depth
        );
        log$3.debug(clusterDb);
      }
    }
    nodes = graph2.nodes();
    log$3.warn("New list of nodes", nodes);
    for (let i = 0; i < nodes.length; i++) {
      const node2 = nodes[i];
      const data = graph2.node(node2);
      log$3.warn(" Now next level", node2, data);
      if (data.clusterNode) {
        extractor(data.graph, depth + 1);
      }
    }
  };
  const sorter = (graph2, nodes) => {
    if (nodes.length === 0)
      return [];
    let result = Object.assign(nodes);
    nodes.forEach((node2) => {
      const children2 = graph2.children(node2);
      const sorted = sorter(graph2, children2);
      result = result.concat(sorted);
    });
    return result;
  };
  const sortNodesByHierarchy = (graph2) => sorter(graph2, graph2.children());
  function intersectNode$1(node2, point2) {
    return node2.intersect(point2);
  }
  function intersectEllipse$2(node2, rx, ry, point2) {
    var cx = node2.x;
    var cy = node2.y;
    var px = cx - point2.x;
    var py = cy - point2.y;
    var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
    var dx = Math.abs(rx * ry * px / det);
    if (point2.x < cx) {
      dx = -dx;
    }
    var dy = Math.abs(rx * ry * py / det);
    if (point2.y < cy) {
      dy = -dy;
    }
    return { x: cx + dx, y: cy + dy };
  }
  function intersectCircle$1(node2, rx, point2) {
    return intersectEllipse$2(node2, rx, rx, point2);
  }
  function intersectLine$2(p1, p2, q1, q2) {
    var a1, a2, b12, b22, c1, c2;
    var r1, r2, r3, r4;
    var denom, offset, num;
    var x2, y2;
    a1 = p2.y - p1.y;
    b12 = p1.x - p2.x;
    c1 = p2.x * p1.y - p1.x * p2.y;
    r3 = a1 * q1.x + b12 * q1.y + c1;
    r4 = a1 * q2.x + b12 * q2.y + c1;
    if (r3 !== 0 && r4 !== 0 && sameSign$1(r3, r4)) {
      return;
    }
    a2 = q2.y - q1.y;
    b22 = q1.x - q2.x;
    c2 = q2.x * q1.y - q1.x * q2.y;
    r1 = a2 * p1.x + b22 * p1.y + c2;
    r2 = a2 * p2.x + b22 * p2.y + c2;
    if (r1 !== 0 && r2 !== 0 && sameSign$1(r1, r2)) {
      return;
    }
    denom = a1 * b22 - a2 * b12;
    if (denom === 0) {
      return;
    }
    offset = Math.abs(denom / 2);
    num = b12 * c2 - b22 * c1;
    x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    num = a2 * c1 - a1 * c2;
    y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    return { x: x2, y: y2 };
  }
  function sameSign$1(r1, r2) {
    return r1 * r2 > 0;
  }
  function intersectPolygon$1(node2, polyPoints, point2) {
    var x12 = node2.x;
    var y12 = node2.y;
    var intersections = [];
    var minX = Number.POSITIVE_INFINITY;
    var minY = Number.POSITIVE_INFINITY;
    if (typeof polyPoints.forEach === "function") {
      polyPoints.forEach(function(entry) {
        minX = Math.min(minX, entry.x);
        minY = Math.min(minY, entry.y);
      });
    } else {
      minX = Math.min(minX, polyPoints.x);
      minY = Math.min(minY, polyPoints.y);
    }
    var left2 = x12 - node2.width / 2 - minX;
    var top2 = y12 - node2.height / 2 - minY;
    for (var i = 0; i < polyPoints.length; i++) {
      var p1 = polyPoints[i];
      var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
      var intersect2 = intersectLine$2(
        node2,
        point2,
        { x: left2 + p1.x, y: top2 + p1.y },
        { x: left2 + p2.x, y: top2 + p2.y }
      );
      if (intersect2) {
        intersections.push(intersect2);
      }
    }
    if (!intersections.length) {
      return node2;
    }
    if (intersections.length > 1) {
      intersections.sort(function(p, q) {
        var pdx = p.x - point2.x;
        var pdy = p.y - point2.y;
        var distp = Math.sqrt(pdx * pdx + pdy * pdy);
        var qdx = q.x - point2.x;
        var qdy = q.y - point2.y;
        var distq = Math.sqrt(qdx * qdx + qdy * qdy);
        return distp < distq ? -1 : distp === distq ? 0 : 1;
      });
    }
    return intersections[0];
  }
  const intersectRect$1 = (node2, point2) => {
    var x2 = node2.x;
    var y2 = node2.y;
    var dx = point2.x - x2;
    var dy = point2.y - y2;
    var w2 = node2.width / 2;
    var h = node2.height / 2;
    var sx, sy;
    if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
      if (dy < 0) {
        h = -h;
      }
      sx = dy === 0 ? 0 : h * dx / dy;
      sy = h;
    } else {
      if (dx < 0) {
        w2 = -w2;
      }
      sx = w2;
      sy = dx === 0 ? 0 : w2 * dy / dx;
    }
    return { x: x2 + sx, y: y2 + sy };
  };
  const intersect$1 = {
    node: intersectNode$1,
    circle: intersectCircle$1,
    ellipse: intersectEllipse$2,
    polygon: intersectPolygon$1,
    rect: intersectRect$1
  };
  const note = (parent, node2) => {
    const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
    log$3.info("Classes = ", node2.classes);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const question$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const s2 = w2 + h;
    const points = [
      { x: s2 / 2, y: 0 },
      { x: s2, y: -s2 / 2 },
      { x: s2 / 2, y: -s2 },
      { x: 0, y: -s2 / 2 }
    ];
    log$3.info("Question main (Circle)");
    const questionElem = insertPolygonShape$1(shapeSvg, s2, s2, points);
    questionElem.attr("style", node2.style);
    updateNodeBounds(node2, questionElem);
    node2.intersect = function(point2) {
      log$3.warn("Intersect called");
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const choice = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
    const s2 = 28;
    const points = [
      { x: 0, y: s2 / 2 },
      { x: s2 / 2, y: 0 },
      { x: 0, y: -s2 / 2 },
      { x: -s2 / 2, y: 0 }
    ];
    const choice2 = shapeSvg.insert("polygon", ":first-child").attr(
      "points",
      points.map(function(d) {
        return d.x + "," + d.y;
      }).join(" ")
    );
    choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);
    node2.width = 28;
    node2.height = 28;
    node2.intersect = function(point2) {
      return intersect$1.circle(node2, 14, point2);
    };
    return shapeSvg;
  };
  const hexagon$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const f = 4;
    const h = bbox.height + node2.padding;
    const m2 = h / f;
    const w2 = bbox.width + 2 * m2 + node2.padding;
    const points = [
      { x: m2, y: 0 },
      { x: w2 - m2, y: 0 },
      { x: w2, y: -h / 2 },
      { x: w2 - m2, y: -h },
      { x: m2, y: -h },
      { x: 0, y: -h / 2 }
    ];
    const hex2 = insertPolygonShape$1(shapeSvg, w2, h, points);
    hex2.attr("style", node2.style);
    updateNodeBounds(node2, hex2);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const rect_left_inv_arrow$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: -h / 2, y: 0 },
      { x: w2, y: 0 },
      { x: w2, y: -h },
      { x: -h / 2, y: -h },
      { x: 0, y: -h / 2 }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    node2.width = w2 + h;
    node2.height = h;
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const lean_right$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: -2 * h / 6, y: 0 },
      { x: w2 - h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: -h },
      { x: h / 6, y: -h }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const lean_left$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: 2 * h / 6, y: 0 },
      { x: w2 + h / 6, y: 0 },
      { x: w2 - 2 * h / 6, y: -h },
      { x: -h / 6, y: -h }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const trapezoid$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: -2 * h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: 0 },
      { x: w2 - h / 6, y: -h },
      { x: h / 6, y: -h }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const inv_trapezoid$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: h / 6, y: 0 },
      { x: w2 - h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: -h },
      { x: -2 * h / 6, y: -h }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const rect_right_inv_arrow$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: 0, y: 0 },
      { x: w2 + h / 2, y: 0 },
      { x: w2, y: -h / 2 },
      { x: w2 + h / 2, y: -h },
      { x: 0, y: -h }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const cylinder$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const rx = w2 / 2;
    const ry = rx / (2.5 + w2 / 50);
    const h = bbox.height + ry + node2.padding;
    const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h;
    const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node2.style).attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h / 2 + ry) + ")");
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      const pos = intersect$1.rect(node2, point2);
      const x2 = pos.x - node2.x;
      if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
        let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
        if (y2 != 0)
          y2 = Math.sqrt(y2);
        y2 = ry - y2;
        if (point2.y - node2.y > 0)
          y2 = -y2;
        pos.y += y2;
      }
      return pos;
    };
    return shapeSvg;
  };
  const rect$1 = (parent, node2) => {
    const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
    log$3.trace("Classes = ", node2.classes);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const totalWidth = bbox.width + node2.padding;
    const totalHeight = bbox.height + node2.padding;
    rect2.attr("class", "basic label-container").attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", totalWidth).attr("height", totalHeight);
    if (node2.props) {
      const propKeys = new Set(Object.keys(node2.props));
      if (node2.props.borders) {
        applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
        propKeys.delete("borders");
      }
      propKeys.forEach((propKey) => {
        log$3.warn(`Unknown node property ${propKey}`);
      });
    }
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const labelRect = (parent, node2) => {
    const { shapeSvg } = labelHelper(parent, node2, "label", true);
    log$3.trace("Classes = ", node2.classes);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const totalWidth = 0;
    const totalHeight = 0;
    rect2.attr("width", totalWidth).attr("height", totalHeight);
    shapeSvg.attr("class", "label edgeLabel");
    if (node2.props) {
      const propKeys = new Set(Object.keys(node2.props));
      if (node2.props.borders) {
        applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
        propKeys.delete("borders");
      }
      propKeys.forEach((propKey) => {
        log$3.warn(`Unknown node property ${propKey}`);
      });
    }
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  function applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {
    const strokeDashArray = [];
    const addBorder = (length2) => {
      strokeDashArray.push(length2);
      strokeDashArray.push(0);
    };
    const skipBorder = (length2) => {
      strokeDashArray.push(0);
      strokeDashArray.push(length2);
    };
    if (borders.includes("t")) {
      log$3.debug("add top border");
      addBorder(totalWidth);
    } else {
      skipBorder(totalWidth);
    }
    if (borders.includes("r")) {
      log$3.debug("add right border");
      addBorder(totalHeight);
    } else {
      skipBorder(totalHeight);
    }
    if (borders.includes("b")) {
      log$3.debug("add bottom border");
      addBorder(totalWidth);
    } else {
      skipBorder(totalWidth);
    }
    if (borders.includes("l")) {
      log$3.debug("add left border");
      addBorder(totalHeight);
    } else {
      skipBorder(totalHeight);
    }
    rect2.attr("stroke-dasharray", strokeDashArray.join(" "));
  }
  const rectWithTitle = (parent, node2) => {
    let classes2;
    if (!node2.classes) {
      classes2 = "node default";
    } else {
      classes2 = "node " + node2.classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const innerLine = shapeSvg.insert("line");
    const label = shapeSvg.insert("g").attr("class", "label");
    const text2 = node2.labelText.flat ? node2.labelText.flat() : node2.labelText;
    let title2 = "";
    if (typeof text2 === "object") {
      title2 = text2[0];
    } else {
      title2 = text2;
    }
    log$3.info("Label text abc79", title2, text2, typeof text2 === "object");
    const text3 = label.node().appendChild(createLabel(title2, node2.labelStyle, true, true));
    let bbox = { width: 0, height: 0 };
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = text3.children[0];
      const dv = select(text3);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    log$3.info("Text 2", text2);
    const textRows = text2.slice(1, text2.length);
    let titleBox = text3.getBBox();
    const descr = label.node().appendChild(
      createLabel(textRows.join ? textRows.join("<br/>") : textRows, node2.labelStyle, true, true)
    );
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = descr.children[0];
      const dv = select(descr);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    const halfPadding = node2.padding / 2;
    select(descr).attr(
      "transform",
      "translate( " + (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"
    );
    select(text3).attr(
      "transform",
      "translate( " + (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", " + 0 + ")"
    );
    bbox = label.node().getBBox();
    label.attr(
      "transform",
      "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"
    );
    rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
    innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const stadium$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const h = bbox.height + node2.padding;
    const w2 = bbox.width + h / 4 + node2.padding;
    const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node2.style).attr("rx", h / 2).attr("ry", h / 2).attr("x", -w2 / 2).attr("y", -h / 2).attr("width", w2).attr("height", h);
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const circle = (parent, node2) => {
    const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
    log$3.info("Circle main");
    updateNodeBounds(node2, circle2);
    node2.intersect = function(point2) {
      log$3.info("Circle intersect", node2, bbox.width / 2 + halfPadding, point2);
      return intersect$1.circle(node2, bbox.width / 2 + halfPadding, point2);
    };
    return shapeSvg;
  };
  const doublecircle = (parent, node2) => {
    const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
    const gap = 5;
    const circleGroup = shapeSvg.insert("g", ":first-child");
    const outerCircle = circleGroup.insert("circle");
    const innerCircle = circleGroup.insert("circle");
    outerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node2.padding + gap * 2).attr("height", bbox.height + node2.padding + gap * 2);
    innerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
    log$3.info("DoubleCircle main");
    updateNodeBounds(node2, outerCircle);
    node2.intersect = function(point2) {
      log$3.info("DoubleCircle intersect", node2, bbox.width / 2 + halfPadding + gap, point2);
      return intersect$1.circle(node2, bbox.width / 2 + halfPadding + gap, point2);
    };
    return shapeSvg;
  };
  const subroutine$1 = (parent, node2) => {
    const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
    const w2 = bbox.width + node2.padding;
    const h = bbox.height + node2.padding;
    const points = [
      { x: 0, y: 0 },
      { x: w2, y: 0 },
      { x: w2, y: -h },
      { x: 0, y: -h },
      { x: 0, y: 0 },
      { x: -8, y: 0 },
      { x: w2 + 8, y: 0 },
      { x: w2 + 8, y: -h },
      { x: -8, y: -h },
      { x: -8, y: 0 }
    ];
    const el = insertPolygonShape$1(shapeSvg, w2, h, points);
    el.attr("style", node2.style);
    updateNodeBounds(node2, el);
    node2.intersect = function(point2) {
      return intersect$1.polygon(node2, points, point2);
    };
    return shapeSvg;
  };
  const start = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    updateNodeBounds(node2, circle2);
    node2.intersect = function(point2) {
      return intersect$1.circle(node2, 7, point2);
    };
    return shapeSvg;
  };
  const forkJoin = (parent, node2, dir) => {
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
    let width2 = 70;
    let height2 = 10;
    if (dir === "LR") {
      width2 = 10;
      height2 = 70;
    }
    const shape = shapeSvg.append("rect").attr("x", -1 * width2 / 2).attr("y", -1 * height2 / 2).attr("width", width2).attr("height", height2).attr("class", "fork-join");
    updateNodeBounds(node2, shape);
    node2.height = node2.height + node2.padding / 2;
    node2.width = node2.width + node2.padding / 2;
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const end = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
    const innerCircle = shapeSvg.insert("circle", ":first-child");
    const circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
    innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);
    updateNodeBounds(node2, circle2);
    node2.intersect = function(point2) {
      return intersect$1.circle(node2, 7, point2);
    };
    return shapeSvg;
  };
  const class_box = (parent, node2) => {
    const halfPadding = node2.padding / 2;
    const rowPadding = 4;
    const lineHeight = 8;
    let classes2;
    if (!node2.classes) {
      classes2 = "node default";
    } else {
      classes2 = "node " + node2.classes;
    }
    const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const topLine = shapeSvg.insert("line");
    const bottomLine = shapeSvg.insert("line");
    let maxWidth = 0;
    let maxHeight = rowPadding;
    const labelContainer = shapeSvg.insert("g").attr("class", "label");
    let verticalPos = 0;
    const hasInterface = node2.classData.annotations && node2.classData.annotations[0];
    const interfaceLabelText = node2.classData.annotations[0] ? "\xAB" + node2.classData.annotations[0] + "\xBB" : "";
    const interfaceLabel = labelContainer.node().appendChild(createLabel(interfaceLabelText, node2.labelStyle, true, true));
    let interfaceBBox = interfaceLabel.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = interfaceLabel.children[0];
      const dv = select(interfaceLabel);
      interfaceBBox = div.getBoundingClientRect();
      dv.attr("width", interfaceBBox.width);
      dv.attr("height", interfaceBBox.height);
    }
    if (node2.classData.annotations[0]) {
      maxHeight += interfaceBBox.height + rowPadding;
      maxWidth += interfaceBBox.width;
    }
    let classTitleString = node2.classData.id;
    if (node2.classData.type !== void 0 && node2.classData.type !== "") {
      if (getConfig$1().flowchart.htmlLabels) {
        classTitleString += "&lt;" + node2.classData.type + "&gt;";
      } else {
        classTitleString += "<" + node2.classData.type + ">";
      }
    }
    const classTitleLabel = labelContainer.node().appendChild(createLabel(classTitleString, node2.labelStyle, true, true));
    select(classTitleLabel).attr("class", "classTitle");
    let classTitleBBox = classTitleLabel.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = classTitleLabel.children[0];
      const dv = select(classTitleLabel);
      classTitleBBox = div.getBoundingClientRect();
      dv.attr("width", classTitleBBox.width);
      dv.attr("height", classTitleBBox.height);
    }
    maxHeight += classTitleBBox.height + rowPadding;
    if (classTitleBBox.width > maxWidth) {
      maxWidth = classTitleBBox.width;
    }
    const classAttributes = [];
    node2.classData.members.forEach((str) => {
      const parsedInfo = parseMember(str);
      let parsedText = parsedInfo.displayText;
      if (getConfig$1().flowchart.htmlLabels) {
        parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      const lbl = labelContainer.node().appendChild(
        createLabel(
          parsedText,
          parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
          true,
          true
        )
      );
      let bbox = lbl.getBBox();
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        const div = lbl.children[0];
        const dv = select(lbl);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
      }
      if (bbox.width > maxWidth) {
        maxWidth = bbox.width;
      }
      maxHeight += bbox.height + rowPadding;
      classAttributes.push(lbl);
    });
    maxHeight += lineHeight;
    const classMethods = [];
    node2.classData.methods.forEach((str) => {
      const parsedInfo = parseMember(str);
      let displayText = parsedInfo.displayText;
      if (getConfig$1().flowchart.htmlLabels) {
        displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      }
      const lbl = labelContainer.node().appendChild(
        createLabel(
          displayText,
          parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
          true,
          true
        )
      );
      let bbox = lbl.getBBox();
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        const div = lbl.children[0];
        const dv = select(lbl);
        bbox = div.getBoundingClientRect();
        dv.attr("width", bbox.width);
        dv.attr("height", bbox.height);
      }
      if (bbox.width > maxWidth) {
        maxWidth = bbox.width;
      }
      maxHeight += bbox.height + rowPadding;
      classMethods.push(lbl);
    });
    maxHeight += lineHeight;
    if (hasInterface) {
      let diffX2 = (maxWidth - interfaceBBox.width) / 2;
      select(interfaceLabel).attr(
        "transform",
        "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")"
      );
      verticalPos = interfaceBBox.height + rowPadding;
    }
    let diffX = (maxWidth - classTitleBBox.width) / 2;
    select(classTitleLabel).attr(
      "transform",
      "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
    );
    verticalPos += classTitleBBox.height + rowPadding;
    topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
    verticalPos += lineHeight;
    classAttributes.forEach((lbl) => {
      select(lbl).attr(
        "transform",
        "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")"
      );
      verticalPos += classTitleBBox.height + rowPadding;
    });
    verticalPos += lineHeight;
    bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
    verticalPos += lineHeight;
    classMethods.forEach((lbl) => {
      select(lbl).attr(
        "transform",
        "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
      );
      verticalPos += classTitleBBox.height + rowPadding;
    });
    rect2.attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node2.padding).attr("height", maxHeight + node2.padding);
    updateNodeBounds(node2, rect2);
    node2.intersect = function(point2) {
      return intersect$1.rect(node2, point2);
    };
    return shapeSvg;
  };
  const shapes$2 = {
    question: question$1,
    rect: rect$1,
    labelRect,
    rectWithTitle,
    choice,
    circle,
    doublecircle,
    stadium: stadium$1,
    hexagon: hexagon$1,
    rect_left_inv_arrow: rect_left_inv_arrow$1,
    lean_right: lean_right$1,
    lean_left: lean_left$1,
    trapezoid: trapezoid$1,
    inv_trapezoid: inv_trapezoid$1,
    rect_right_inv_arrow: rect_right_inv_arrow$1,
    cylinder: cylinder$1,
    start,
    end,
    note,
    subroutine: subroutine$1,
    fork: forkJoin,
    join: forkJoin,
    class_box
  };
  let nodeElems = {};
  const insertNode = (elem, node2, dir) => {
    let newEl;
    let el;
    if (node2.link) {
      let target;
      if (getConfig$1().securityLevel === "sandbox") {
        target = "_top";
      } else if (node2.linkTarget) {
        target = node2.linkTarget || "_blank";
      }
      newEl = elem.insert("svg:a").attr("xlink:href", node2.link).attr("target", target);
      el = shapes$2[node2.shape](newEl, node2, dir);
    } else {
      el = shapes$2[node2.shape](elem, node2, dir);
      newEl = el;
    }
    if (node2.tooltip) {
      el.attr("title", node2.tooltip);
    }
    if (node2.class) {
      el.attr("class", "node default " + node2.class);
    }
    nodeElems[node2.id] = newEl;
    if (node2.haveCallback) {
      nodeElems[node2.id].attr("class", nodeElems[node2.id].attr("class") + " clickable");
    }
  };
  const setNodeElem = (elem, node2) => {
    nodeElems[node2.id] = elem;
  };
  const clear$a = () => {
    nodeElems = {};
  };
  const positionNode = (node2) => {
    const el = nodeElems[node2.id];
    log$3.trace(
      "Transforming node",
      node2.diff,
      node2,
      "translate(" + (node2.x - node2.width / 2 - 5) + ", " + node2.width / 2 + ")"
    );
    const padding2 = 8;
    const diff = node2.diff || 0;
    if (node2.clusterNode) {
      el.attr(
        "transform",
        "translate(" + (node2.x + diff - node2.width / 2) + ", " + (node2.y - node2.height / 2 - padding2) + ")"
      );
    } else {
      el.attr("transform", "translate(" + node2.x + ", " + node2.y + ")");
    }
    return diff;
  };
  const rect = (parent, node2) => {
    log$3.trace("Creating subgraph rect for ", node2.id, node2);
    const shapeSvg = parent.insert("g").attr("class", "cluster" + (node2.class ? " " + node2.class : "")).attr("id", node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const label = shapeSvg.insert("g").attr("class", "cluster-label");
    const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
    let bbox = text2.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = text2.children[0];
      const dv = select(text2);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    const padding2 = 0 * node2.padding;
    const halfPadding = padding2 / 2;
    const width2 = node2.width <= bbox.width + padding2 ? bbox.width + padding2 : node2.width;
    if (node2.width <= bbox.width + padding2) {
      node2.diff = (bbox.width - node2.width) / 2 - node2.padding / 2;
    } else {
      node2.diff = -node2.padding / 2;
    }
    log$3.trace("Data ", node2, JSON.stringify(node2));
    rect2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - width2 / 2).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2).attr("height", node2.height + padding2);
    label.attr(
      "transform",
      "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 + node2.padding / 3) + ")"
    );
    const rectBox = rect2.node().getBBox();
    node2.width = rectBox.width;
    node2.height = rectBox.height;
    node2.intersect = function(point2) {
      return intersectRect$1(node2, point2);
    };
    return shapeSvg;
  };
  const noteGroup = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const padding2 = 0 * node2.padding;
    const halfPadding = padding2 / 2;
    rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", node2.width + padding2).attr("height", node2.height + padding2).attr("fill", "none");
    const rectBox = rect2.node().getBBox();
    node2.width = rectBox.width;
    node2.height = rectBox.height;
    node2.intersect = function(point2) {
      return intersectRect$1(node2, point2);
    };
    return shapeSvg;
  };
  const roundedWithTitle = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const label = shapeSvg.insert("g").attr("class", "cluster-label");
    const innerRect = shapeSvg.append("rect");
    const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
    let bbox = text2.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = text2.children[0];
      const dv = select(text2);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    bbox = text2.getBBox();
    const padding2 = 0 * node2.padding;
    const halfPadding = padding2 / 2;
    const width2 = node2.width <= bbox.width + node2.padding ? bbox.width + node2.padding : node2.width;
    if (node2.width <= bbox.width + node2.padding) {
      node2.diff = (bbox.width + node2.padding * 0 - node2.width) / 2;
    } else {
      node2.diff = -node2.padding / 2;
    }
    rect2.attr("class", "outer").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2 + padding2).attr("height", node2.height + padding2);
    innerRect.attr("class", "inner").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding + bbox.height - 1).attr("width", width2 + padding2).attr("height", node2.height + padding2 - bbox.height - 3);
    label.attr(
      "transform",
      "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 - node2.padding / 3 + (evaluate(getConfig$1().flowchart.htmlLabels) ? 5 : 3)) + ")"
    );
    const rectBox = rect2.node().getBBox();
    node2.height = rectBox.height;
    node2.intersect = function(point2) {
      return intersectRect$1(node2, point2);
    };
    return shapeSvg;
  };
  const divider = (parent, node2) => {
    const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
    const rect2 = shapeSvg.insert("rect", ":first-child");
    const padding2 = 0 * node2.padding;
    const halfPadding = padding2 / 2;
    rect2.attr("class", "divider").attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2).attr("width", node2.width + padding2).attr("height", node2.height + padding2);
    const rectBox = rect2.node().getBBox();
    node2.width = rectBox.width;
    node2.height = rectBox.height;
    node2.diff = -node2.padding / 2;
    node2.intersect = function(point2) {
      return intersectRect$1(node2, point2);
    };
    return shapeSvg;
  };
  const shapes$1 = { rect, roundedWithTitle, noteGroup, divider };
  let clusterElems = {};
  const insertCluster = (elem, node2) => {
    log$3.trace("Inserting cluster");
    const shape = node2.shape || "rect";
    clusterElems[node2.id] = shapes$1[shape](elem, node2);
  };
  const clear$9 = () => {
    clusterElems = {};
  };
  let edgeLabels = {};
  let terminalLabels = {};
  const clear$8 = () => {
    edgeLabels = {};
    terminalLabels = {};
  };
  const insertEdgeLabel = (elem, edge) => {
    const labelElement = createLabel(edge.label, edge.labelStyle);
    const edgeLabel = elem.insert("g").attr("class", "edgeLabel");
    const label = edgeLabel.insert("g").attr("class", "label");
    label.node().appendChild(labelElement);
    let bbox = labelElement.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = labelElement.children[0];
      const dv = select(labelElement);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
    edgeLabels[edge.id] = edgeLabel;
    edge.width = bbox.width;
    edge.height = bbox.height;
    let fo;
    if (edge.startLabelLeft) {
      const startLabelElement = createLabel(edge.startLabelLeft, edge.labelStyle);
      const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
      const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");
      fo = inner.node().appendChild(startLabelElement);
      const slBox = startLabelElement.getBBox();
      inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
      if (!terminalLabels[edge.id]) {
        terminalLabels[edge.id] = {};
      }
      terminalLabels[edge.id].startLeft = startEdgeLabelLeft;
      setTerminalWidth(fo, edge.startLabelLeft);
    }
    if (edge.startLabelRight) {
      const startLabelElement = createLabel(edge.startLabelRight, edge.labelStyle);
      const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
      const inner = startEdgeLabelRight.insert("g").attr("class", "inner");
      fo = startEdgeLabelRight.node().appendChild(startLabelElement);
      inner.node().appendChild(startLabelElement);
      const slBox = startLabelElement.getBBox();
      inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
      if (!terminalLabels[edge.id]) {
        terminalLabels[edge.id] = {};
      }
      terminalLabels[edge.id].startRight = startEdgeLabelRight;
      setTerminalWidth(fo, edge.startLabelRight);
    }
    if (edge.endLabelLeft) {
      const endLabelElement = createLabel(edge.endLabelLeft, edge.labelStyle);
      const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
      const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");
      fo = inner.node().appendChild(endLabelElement);
      const slBox = endLabelElement.getBBox();
      inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
      endEdgeLabelLeft.node().appendChild(endLabelElement);
      if (!terminalLabels[edge.id]) {
        terminalLabels[edge.id] = {};
      }
      terminalLabels[edge.id].endLeft = endEdgeLabelLeft;
      setTerminalWidth(fo, edge.endLabelLeft);
    }
    if (edge.endLabelRight) {
      const endLabelElement = createLabel(edge.endLabelRight, edge.labelStyle);
      const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
      const inner = endEdgeLabelRight.insert("g").attr("class", "inner");
      fo = inner.node().appendChild(endLabelElement);
      const slBox = endLabelElement.getBBox();
      inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
      endEdgeLabelRight.node().appendChild(endLabelElement);
      if (!terminalLabels[edge.id]) {
        terminalLabels[edge.id] = {};
      }
      terminalLabels[edge.id].endRight = endEdgeLabelRight;
      setTerminalWidth(fo, edge.endLabelRight);
    }
  };
  function setTerminalWidth(fo, value) {
    if (getConfig$1().flowchart.htmlLabels && fo) {
      fo.style.width = value.length * 9 + "px";
      fo.style.height = "12px";
    }
  }
  const positionEdgeLabel = (edge, paths) => {
    log$3.info("Moving label abc78 ", edge.id, edge.label, edgeLabels[edge.id]);
    let path2 = paths.updatedPath ? paths.updatedPath : paths.originalPath;
    if (edge.label) {
      const el = edgeLabels[edge.id];
      let x2 = edge.x;
      let y2 = edge.y;
      if (path2) {
        const pos = utils.calcLabelPosition(path2);
        log$3.info("Moving label from (", x2, ",", y2, ") to (", pos.x, ",", pos.y, ") abc78");
      }
      el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
    }
    if (edge.startLabelLeft) {
      const el = terminalLabels[edge.id].startLeft;
      let x2 = edge.x;
      let y2 = edge.y;
      if (path2) {
        const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path2);
        x2 = pos.x;
        y2 = pos.y;
      }
      el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
    }
    if (edge.startLabelRight) {
      const el = terminalLabels[edge.id].startRight;
      let x2 = edge.x;
      let y2 = edge.y;
      if (path2) {
        const pos = utils.calcTerminalLabelPosition(
          edge.arrowTypeStart ? 10 : 0,
          "start_right",
          path2
        );
        x2 = pos.x;
        y2 = pos.y;
      }
      el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
    }
    if (edge.endLabelLeft) {
      const el = terminalLabels[edge.id].endLeft;
      let x2 = edge.x;
      let y2 = edge.y;
      if (path2) {
        const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path2);
        x2 = pos.x;
        y2 = pos.y;
      }
      el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
    }
    if (edge.endLabelRight) {
      const el = terminalLabels[edge.id].endRight;
      let x2 = edge.x;
      let y2 = edge.y;
      if (path2) {
        const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path2);
        x2 = pos.x;
        y2 = pos.y;
      }
      el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
    }
  };
  const outsideNode = (node2, point2) => {
    const x2 = node2.x;
    const y2 = node2.y;
    const dx = Math.abs(point2.x - x2);
    const dy = Math.abs(point2.y - y2);
    const w2 = node2.width / 2;
    const h = node2.height / 2;
    if (dx >= w2 || dy >= h) {
      return true;
    }
    return false;
  };
  const intersection = (node2, outsidePoint, insidePoint) => {
    log$3.warn(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(outsidePoint)}
  insidePoint : ${JSON.stringify(insidePoint)}
  node        : x:${node2.x} y:${node2.y} w:${node2.width} h:${node2.height}`);
    const x2 = node2.x;
    const y2 = node2.y;
    const dx = Math.abs(x2 - insidePoint.x);
    const w2 = node2.width / 2;
    let r = insidePoint.x < outsidePoint.x ? w2 - dx : w2 + dx;
    const h = node2.height / 2;
    const Q = Math.abs(outsidePoint.y - insidePoint.y);
    const R = Math.abs(outsidePoint.x - insidePoint.x);
    if (Math.abs(y2 - outsidePoint.y) * w2 > Math.abs(x2 - outsidePoint.x) * h) {
      let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y2 : y2 - h - outsidePoint.y;
      r = R * q / Q;
      const res = {
        x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
        y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
      };
      if (r === 0) {
        res.x = outsidePoint.x;
        res.y = outsidePoint.y;
      }
      if (R === 0) {
        res.x = outsidePoint.x;
      }
      if (Q === 0) {
        res.y = outsidePoint.y;
      }
      log$3.warn(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);
      return res;
    } else {
      if (insidePoint.x < outsidePoint.x) {
        r = outsidePoint.x - w2 - x2;
      } else {
        r = x2 - w2 - outsidePoint.x;
      }
      let q = Q * r / R;
      let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;
      let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;
      log$3.warn(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });
      if (r === 0) {
        _x = outsidePoint.x;
        _y = outsidePoint.y;
      }
      if (R === 0) {
        _x = outsidePoint.x;
      }
      if (Q === 0) {
        _y = outsidePoint.y;
      }
      return { x: _x, y: _y };
    }
  };
  const cutPathAtIntersect = (_points, boundryNode) => {
    log$3.warn("abc88 cutPathAtIntersect", _points, boundryNode);
    let points = [];
    let lastPointOutside = _points[0];
    let isInside = false;
    _points.forEach((point2) => {
      log$3.info("abc88 checking point", point2, boundryNode);
      if (!outsideNode(boundryNode, point2) && !isInside) {
        const inter = intersection(boundryNode, lastPointOutside, point2);
        log$3.warn("abc88 inside", point2, lastPointOutside, inter);
        log$3.warn("abc88 intersection", inter);
        let pointPresent = false;
        points.forEach((p) => {
          pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
        });
        if (!points.find((e) => e.x === inter.x && e.y === inter.y)) {
          points.push(inter);
        } else {
          log$3.warn("abc88 no intersect", inter, points);
        }
        isInside = true;
      } else {
        log$3.warn("abc88 outside", point2, lastPointOutside);
        lastPointOutside = point2;
        if (!isInside)
          points.push(point2);
      }
    });
    log$3.warn("abc88 returning points", points);
    return points;
  };
  const insertEdge = function(elem, e, edge, clusterDb2, diagramType, graph2) {
    let points = edge.points;
    let pointsHasChanged = false;
    const tail = graph2.node(e.v);
    var head2 = graph2.node(e.w);
    log$3.info("abc88 InsertEdge: ", edge);
    if (head2.intersect && tail.intersect) {
      points = points.slice(1, edge.points.length - 1);
      points.unshift(tail.intersect(points[0]));
      log$3.info(
        "Last point",
        points[points.length - 1],
        head2,
        head2.intersect(points[points.length - 1])
      );
      points.push(head2.intersect(points[points.length - 1]));
    }
    if (edge.toCluster) {
      log$3.info("to cluster abc88", clusterDb2[edge.toCluster]);
      points = cutPathAtIntersect(edge.points, clusterDb2[edge.toCluster].node);
      pointsHasChanged = true;
    }
    if (edge.fromCluster) {
      log$3.info("from cluster abc88", clusterDb2[edge.fromCluster]);
      points = cutPathAtIntersect(points.reverse(), clusterDb2[edge.fromCluster].node).reverse();
      pointsHasChanged = true;
    }
    const lineData = points.filter((p) => !Number.isNaN(p.y));
    let curve;
    if (diagramType === "graph" || diagramType === "flowchart") {
      curve = edge.curve || curveBasis;
    } else {
      curve = curveBasis;
    }
    const lineFunction = line$1().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    }).curve(curve);
    let strokeClasses;
    switch (edge.thickness) {
      case "normal":
        strokeClasses = "edge-thickness-normal";
        break;
      case "thick":
        strokeClasses = "edge-thickness-thick";
        break;
      case "invisible":
        strokeClasses = "edge-thickness-thick";
        break;
      default:
        strokeClasses = "";
    }
    switch (edge.pattern) {
      case "solid":
        strokeClasses += " edge-pattern-solid";
        break;
      case "dotted":
        strokeClasses += " edge-pattern-dotted";
        break;
      case "dashed":
        strokeClasses += " edge-pattern-dashed";
        break;
    }
    const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);
    let url = "";
    if (getConfig$1().flowchart.arrowMarkerAbsolute || getConfig$1().state.arrowMarkerAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replace(/\(/g, "\\(");
      url = url.replace(/\)/g, "\\)");
    }
    log$3.info("arrowTypeStart", edge.arrowTypeStart);
    log$3.info("arrowTypeEnd", edge.arrowTypeEnd);
    switch (edge.arrowTypeStart) {
      case "arrow_cross":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-crossStart)");
        break;
      case "arrow_point":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-pointStart)");
        break;
      case "arrow_barb":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-barbStart)");
        break;
      case "arrow_circle":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-circleStart)");
        break;
      case "aggregation":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-aggregationStart)");
        break;
      case "extension":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-extensionStart)");
        break;
      case "composition":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-compositionStart)");
        break;
      case "dependency":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-dependencyStart)");
        break;
      case "lollipop":
        svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-lollipopStart)");
        break;
    }
    switch (edge.arrowTypeEnd) {
      case "arrow_cross":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-crossEnd)");
        break;
      case "arrow_point":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-pointEnd)");
        break;
      case "arrow_barb":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-barbEnd)");
        break;
      case "arrow_circle":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-circleEnd)");
        break;
      case "aggregation":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-aggregationEnd)");
        break;
      case "extension":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-extensionEnd)");
        break;
      case "composition":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-compositionEnd)");
        break;
      case "dependency":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-dependencyEnd)");
        break;
      case "lollipop":
        svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-lollipopEnd)");
        break;
    }
    let paths = {};
    if (pointsHasChanged) {
      paths.updatedPath = points;
    }
    paths.originalPath = edge.points;
    return paths;
  };
  const recursiveRender = (_elem, graph2, diagramtype, parentCluster) => {
    log$3.info("Graph in recursive render: XXX", graphlib$1.json.write(graph2), parentCluster);
    const dir = graph2.graph().rankdir;
    log$3.trace("Dir in recursive render - dir:", dir);
    const elem = _elem.insert("g").attr("class", "root");
    if (!graph2.nodes()) {
      log$3.info("No nodes found for", graph2);
    } else {
      log$3.info("Recursive render XXX", graph2.nodes());
    }
    if (graph2.edges().length > 0) {
      log$3.trace("Recursive edges", graph2.edge(graph2.edges()[0]));
    }
    const clusters = elem.insert("g").attr("class", "clusters");
    const edgePaths = elem.insert("g").attr("class", "edgePaths");
    const edgeLabels2 = elem.insert("g").attr("class", "edgeLabels");
    const nodes = elem.insert("g").attr("class", "nodes");
    graph2.nodes().forEach(function(v) {
      const node2 = graph2.node(v);
      if (typeof parentCluster !== "undefined") {
        const data = JSON.parse(JSON.stringify(parentCluster.clusterData));
        log$3.info("Setting data for cluster XXX (", v, ") ", data, parentCluster);
        graph2.setNode(parentCluster.id, data);
        if (!graph2.parent(v)) {
          log$3.trace("Setting parent", v, parentCluster.id);
          graph2.setParent(v, parentCluster.id, data);
        }
      }
      log$3.info("(Insert) Node XXX" + v + ": " + JSON.stringify(graph2.node(v)));
      if (node2 && node2.clusterNode) {
        log$3.info("Cluster identified", v, node2.width, graph2.node(v));
        const o = recursiveRender(nodes, node2.graph, diagramtype, graph2.node(v));
        const newEl = o.elem;
        updateNodeBounds(node2, newEl);
        node2.diff = o.diff || 0;
        log$3.info("Node bounds (abc123)", v, node2, node2.width, node2.x, node2.y);
        setNodeElem(newEl, node2);
        log$3.warn("Recursive render complete ", newEl, node2);
      } else {
        if (graph2.children(v).length > 0) {
          log$3.info("Cluster - the non recursive path XXX", v, node2.id, node2, graph2);
          log$3.info(findNonClusterChild(node2.id, graph2));
          clusterDb[node2.id] = { id: findNonClusterChild(node2.id, graph2), node: node2 };
        } else {
          log$3.info("Node - the non recursive path", v, node2.id, node2);
          insertNode(nodes, graph2.node(v), dir);
        }
      }
    });
    graph2.edges().forEach(function(e) {
      const edge = graph2.edge(e.v, e.w, e.name);
      log$3.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
      log$3.info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(graph2.edge(e)));
      log$3.info("Fix", clusterDb, "ids:", e.v, e.w, "Translateing: ", clusterDb[e.v], clusterDb[e.w]);
      insertEdgeLabel(edgeLabels2, edge);
    });
    graph2.edges().forEach(function(e) {
      log$3.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    });
    log$3.info("#############################################");
    log$3.info("###                Layout                 ###");
    log$3.info("#############################################");
    log$3.info(graph2);
    dagreExports.layout(graph2);
    log$3.info("Graph after layout:", graphlib$1.json.write(graph2));
    let diff = 0;
    sortNodesByHierarchy(graph2).forEach(function(v) {
      const node2 = graph2.node(v);
      log$3.info("Position " + v + ": " + JSON.stringify(graph2.node(v)));
      log$3.info(
        "Position " + v + ": (" + node2.x,
        "," + node2.y,
        ") width: ",
        node2.width,
        " height: ",
        node2.height
      );
      if (node2 && node2.clusterNode) {
        positionNode(node2);
      } else {
        if (graph2.children(v).length > 0) {
          insertCluster(clusters, node2);
          clusterDb[node2.id].node = node2;
        } else {
          positionNode(node2);
        }
      }
    });
    graph2.edges().forEach(function(e) {
      const edge = graph2.edge(e);
      log$3.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(edge), edge);
      const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph2);
      positionEdgeLabel(edge, paths);
    });
    graph2.nodes().forEach(function(v) {
      const n = graph2.node(v);
      log$3.info(v, n.type, n.diff);
      if (n.type === "group") {
        diff = n.diff;
      }
    });
    return { elem, diff };
  };
  const render$2 = (elem, graph2, markers2, diagramtype, id2) => {
    insertMarkers$2(elem, markers2, diagramtype, id2);
    clear$a();
    clear$8();
    clear$9();
    clear$b();
    log$3.warn("Graph at first:", graphlib$1.json.write(graph2));
    adjustClustersAndEdges(graph2);
    log$3.warn("Graph after:", graphlib$1.json.write(graph2));
    recursiveRender(elem, graph2, diagramtype);
  };
  const sanitizeText$1 = (txt) => common.sanitizeText(txt, getConfig$1());
  const addClasses = function(classes2, g, _id, diagObj) {
    const keys = Object.keys(classes2);
    log$3.info("keys:", keys);
    log$3.info(classes2);
    keys.forEach(function(id2) {
      const vertex = classes2[id2];
      let cssClassStr = "";
      if (vertex.cssClasses.length > 0) {
        cssClassStr = cssClassStr + " " + vertex.cssClasses.join(" ");
      }
      const styles = { labelStyle: "" };
      let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
      let radious = 0;
      let _shape = "";
      switch (vertex.type) {
        case "class":
          _shape = "class_box";
          break;
        default:
          _shape = "class_box";
      }
      g.setNode(vertex.id, {
        labelStyle: styles.labelStyle,
        shape: _shape,
        labelText: sanitizeText$1(vertexText),
        classData: vertex,
        rx: radious,
        ry: radious,
        class: cssClassStr,
        style: styles.style,
        id: vertex.id,
        domId: vertex.domId,
        tooltip: diagObj.db.getTooltip(vertex.id) || "",
        haveCallback: vertex.haveCallback,
        link: vertex.link,
        width: vertex.type === "group" ? 500 : void 0,
        type: vertex.type,
        padding: getConfig$1().flowchart.padding
      });
      log$3.info("setNode", {
        labelStyle: styles.labelStyle,
        shape: _shape,
        labelText: vertexText,
        rx: radious,
        ry: radious,
        class: cssClassStr,
        style: styles.style,
        id: vertex.id,
        width: vertex.type === "group" ? 500 : void 0,
        type: vertex.type,
        padding: getConfig$1().flowchart.padding
      });
    });
  };
  const addRelations = function(relations2, g) {
    const conf2 = getConfig$1().flowchart;
    let cnt2 = 0;
    relations2.forEach(function(edge) {
      cnt2++;
      const edgeData = {};
      edgeData.classes = "relation";
      edgeData.pattern = edge.relation.lineType == 1 ? "dashed" : "solid";
      edgeData.id = "id" + cnt2;
      if (edge.type === "arrow_open") {
        edgeData.arrowhead = "none";
      } else {
        edgeData.arrowhead = "normal";
      }
      log$3.info(edgeData, edge);
      edgeData.startLabelRight = edge.relationTitle1 === "none" ? "" : edge.relationTitle1;
      edgeData.endLabelLeft = edge.relationTitle2 === "none" ? "" : edge.relationTitle2;
      edgeData.arrowTypeStart = getArrowMarker(edge.relation.type1);
      edgeData.arrowTypeEnd = getArrowMarker(edge.relation.type2);
      let style = "";
      let labelStyle = "";
      if (typeof edge.style !== "undefined") {
        const styles = getStylesFromArray(edge.style);
        style = styles.style;
        labelStyle = styles.labelStyle;
      } else {
        style = "fill:none";
      }
      edgeData.style = style;
      edgeData.labelStyle = labelStyle;
      if (typeof edge.interpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);
      } else if (typeof relations2.defaultInterpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(relations2.defaultInterpolate, curveLinear);
      } else {
        edgeData.curve = interpolateToCurve(conf2.curve, curveLinear);
      }
      edge.text = edge.title;
      if (typeof edge.text === "undefined") {
        if (typeof edge.style !== "undefined") {
          edgeData.arrowheadStyle = "fill: #333";
        }
      } else {
        edgeData.arrowheadStyle = "fill: #333";
        edgeData.labelpos = "c";
        if (getConfig$1().flowchart.htmlLabels) {
          edgeData.labelType = "html";
          edgeData.label = '<span class="edgeLabel">' + edge.text + "</span>";
        } else {
          edgeData.labelType = "text";
          edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
          if (typeof edge.style === "undefined") {
            edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
          }
          edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
        }
      }
      g.setEdge(edge.id1, edge.id2, edgeData, cnt2);
    });
  };
  const setConf$9 = function(cnf) {
    const keys = Object.keys(cnf);
    keys.forEach(function(key) {
      cnf[key];
    });
  };
  const draw$c = function(text2, id2, _version, diagObj) {
    log$3.info("Drawing class - ", id2);
    const conf2 = getConfig$1().flowchart;
    const securityLevel = getConfig$1().securityLevel;
    log$3.info("config:", conf2);
    const nodeSpacing = conf2.nodeSpacing || 50;
    const rankSpacing = conf2.rankSpacing || 50;
    const g = new graphlib$1.Graph({
      multigraph: true,
      compound: true
    }).setGraph({
      rankdir: diagObj.db.getDirection(),
      nodesep: nodeSpacing,
      ranksep: rankSpacing,
      marginx: 8,
      marginy: 8
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    const classes2 = diagObj.db.getClasses();
    const relations2 = diagObj.db.getRelations();
    log$3.info(relations2);
    addClasses(classes2, g, id2, diagObj);
    addRelations(relations2, g);
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const svg2 = root2.select(`[id="${id2}"]`);
    const element = root2.select("#" + id2 + " g");
    render$2(
      element,
      g,
      ["aggregation", "extension", "composition", "dependency", "lollipop"],
      "classDiagram",
      id2
    );
    setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
    if (!conf2.htmlLabels) {
      const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
      const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
      for (let k2 = 0; k2 < labels.length; k2++) {
        const label = labels[k2];
        const dim = label.getBBox();
        const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect2.setAttribute("rx", 0);
        rect2.setAttribute("ry", 0);
        rect2.setAttribute("width", dim.width);
        rect2.setAttribute("height", dim.height);
        label.insertBefore(rect2, label.firstChild);
      }
    }
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
  };
  function getArrowMarker(type2) {
    let marker;
    switch (type2) {
      case 0:
        marker = "aggregation";
        break;
      case 1:
        marker = "extension";
        break;
      case 2:
        marker = "composition";
        break;
      case 3:
        marker = "dependency";
        break;
      case 4:
        marker = "lollipop";
        break;
      default:
        marker = "none";
    }
    return marker;
  }
  const classRendererV2 = {
    setConf: setConf$9,
    draw: draw$c
  };
  var parser$8 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $V3 = [1, 17], $V4 = [1, 18], $V5 = [1, 19], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 25], $Va = [1, 30], $Vb = [1, 31], $Vc = [1, 32], $Vd = [1, 33], $Ve = [6, 9, 11, 15, 20, 23, 25, 27, 29, 30, 31, 42, 43, 44, 45, 49], $Vf = [1, 45], $Vg = [30, 31, 46, 47], $Vh = [4, 6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $Vi = [42, 43, 44, 45], $Vj = [22, 37], $Vk = [1, 64];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "ER_DIAGRAM": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "entityName": 17, "relSpec": 18, "role": 19, "BLOCK_START": 20, "attributes": 21, "BLOCK_STOP": 22, "title": 23, "title_value": 24, "acc_title": 25, "acc_title_value": 26, "acc_descr": 27, "acc_descr_value": 28, "acc_descr_multiline_value": 29, "ALPHANUM": 30, "ENTITY_NAME": 31, "attribute": 32, "attributeType": 33, "attributeName": 34, "attributeKeyType": 35, "attributeComment": 36, "ATTRIBUTE_WORD": 37, "ATTRIBUTE_KEY": 38, "COMMENT": 39, "cardinality": 40, "relType": 41, "ZERO_OR_ONE": 42, "ZERO_OR_MORE": 43, "ONE_OR_MORE": 44, "ONLY_ONE": 45, "NON_IDENTIFYING": 46, "IDENTIFYING": 47, "WORD": 48, "open_directive": 49, "type_directive": 50, "arg_directive": 51, "close_directive": 52, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 20: "BLOCK_START", 22: "BLOCK_STOP", 23: "title", 24: "title_value", 25: "acc_title", 26: "acc_title_value", 27: "acc_descr", 28: "acc_descr_value", 29: "acc_descr_multiline_value", 30: "ALPHANUM", 31: "ENTITY_NAME", 37: "ATTRIBUTE_WORD", 38: "ATTRIBUTE_KEY", 39: "COMMENT", 42: "ZERO_OR_ONE", 43: "ZERO_OR_MORE", 44: "ONE_OR_MORE", 45: "ONLY_ONE", 46: "NON_IDENTIFYING", 47: "IDENTIFYING", 48: "WORD", 49: "open_directive", 50: "type_directive", 51: "arg_directive", 52: "close_directive" },
      productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 5], [10, 4], [10, 3], [10, 1], [10, 2], [10, 2], [10, 2], [10, 1], [17, 1], [17, 1], [21, 1], [21, 2], [32, 2], [32, 3], [32, 3], [32, 4], [33, 1], [34, 1], [35, 1], [36, 1], [18, 3], [40, 1], [40, 1], [40, 1], [40, 1], [41, 1], [41, 1], [19, 1], [19, 1], [19, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            break;
          case 3:
            this.$ = [];
            break;
          case 4:
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
            break;
          case 5:
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
          case 8:
            this.$ = [];
            break;
          case 12:
            yy.addEntity($$[$0 - 4]);
            yy.addEntity($$[$0 - 2]);
            yy.addRelationship($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 3]);
            break;
          case 13:
            yy.addEntity($$[$0 - 3]);
            yy.addAttributes($$[$0 - 3], $$[$0 - 1]);
            break;
          case 14:
            yy.addEntity($$[$0 - 2]);
            break;
          case 15:
            yy.addEntity($$[$0]);
            break;
          case 16:
          case 17:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 18:
          case 19:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 20:
          case 41:
            this.$ = $$[$0];
            break;
          case 21:
          case 39:
          case 40:
            this.$ = $$[$0].replace(/"/g, "");
            break;
          case 22:
            this.$ = [$$[$0]];
            break;
          case 23:
            $$[$0].push($$[$0 - 1]);
            this.$ = $$[$0];
            break;
          case 24:
            this.$ = { attributeType: $$[$0 - 1], attributeName: $$[$0] };
            break;
          case 25:
            this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeKeyType: $$[$0] };
            break;
          case 26:
            this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeComment: $$[$0] };
            break;
          case 27:
            this.$ = { attributeType: $$[$0 - 3], attributeName: $$[$0 - 2], attributeKeyType: $$[$0 - 1], attributeComment: $$[$0] };
            break;
          case 28:
          case 29:
          case 30:
            this.$ = $$[$0];
            break;
          case 31:
            this.$ = $$[$0].replace(/"/g, "");
            break;
          case 32:
            this.$ = { cardA: $$[$0], relType: $$[$0 - 1], cardB: $$[$0 - 2] };
            break;
          case 33:
            this.$ = yy.Cardinality.ZERO_OR_ONE;
            break;
          case 34:
            this.$ = yy.Cardinality.ZERO_OR_MORE;
            break;
          case 35:
            this.$ = yy.Cardinality.ONE_OR_MORE;
            break;
          case 36:
            this.$ = yy.Cardinality.ONLY_ONE;
            break;
          case 37:
            this.$ = yy.Identification.NON_IDENTIFYING;
            break;
          case 38:
            this.$ = yy.Identification.IDENTIFYING;
            break;
          case 42:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 43:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 44:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 45:
            yy.parseDirective("}%%", "close_directive", "er");
            break;
        }
      },
      table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 13: 8, 50: [1, 9] }, { 50: [2, 42] }, { 6: [1, 10], 7: 15, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, { 1: [2, 2] }, { 14: 23, 15: [1, 24], 52: $V9 }, o([15, 52], [2, 43]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 15, 10: 26, 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), o($V2, [2, 15], { 18: 27, 40: 29, 20: [1, 28], 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }), { 24: [1, 34] }, { 26: [1, 35] }, { 28: [1, 36] }, o($V2, [2, 19]), o($Ve, [2, 20]), o($Ve, [2, 21]), { 11: [1, 37] }, { 16: 38, 51: [1, 39] }, { 11: [2, 45] }, o($V2, [2, 5]), { 17: 40, 30: $V7, 31: $V8 }, { 21: 41, 22: [1, 42], 32: 43, 33: 44, 37: $Vf }, { 41: 46, 46: [1, 47], 47: [1, 48] }, o($Vg, [2, 33]), o($Vg, [2, 34]), o($Vg, [2, 35]), o($Vg, [2, 36]), o($V2, [2, 16]), o($V2, [2, 17]), o($V2, [2, 18]), o($Vh, [2, 9]), { 14: 49, 52: $V9 }, { 52: [2, 44] }, { 15: [1, 50] }, { 22: [1, 51] }, o($V2, [2, 14]), { 21: 52, 22: [2, 22], 32: 43, 33: 44, 37: $Vf }, { 34: 53, 37: [1, 54] }, { 37: [2, 28] }, { 40: 55, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }, o($Vi, [2, 37]), o($Vi, [2, 38]), { 11: [1, 56] }, { 19: 57, 30: [1, 60], 31: [1, 59], 48: [1, 58] }, o($V2, [2, 13]), { 22: [2, 23] }, o($Vj, [2, 24], { 35: 61, 36: 62, 38: [1, 63], 39: $Vk }), o([22, 37, 38, 39], [2, 29]), o([30, 31], [2, 32]), o($Vh, [2, 10]), o($V2, [2, 12]), o($V2, [2, 39]), o($V2, [2, 40]), o($V2, [2, 41]), o($Vj, [2, 25], { 36: 65, 39: $Vk }), o($Vj, [2, 26]), o([22, 37, 39], [2, 30]), o($Vj, [2, 31]), o($Vj, [2, 27])],
      defaultActions: { 5: [2, 42], 7: [2, 2], 25: [2, 45], 39: [2, 44], 45: [2, 28], 52: [2, 23] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("acc_title");
              return 25;
            case 1:
              this.popState();
              return "acc_title_value";
            case 2:
              this.begin("acc_descr");
              return 27;
            case 3:
              this.popState();
              return "acc_descr_value";
            case 4:
              this.begin("acc_descr_multiline");
              break;
            case 5:
              this.popState();
              break;
            case 6:
              return "acc_descr_multiline_value";
            case 7:
              this.begin("open_directive");
              return 49;
            case 8:
              this.begin("type_directive");
              return 50;
            case 9:
              this.popState();
              this.begin("arg_directive");
              return 15;
            case 10:
              this.popState();
              this.popState();
              return 52;
            case 11:
              return 51;
            case 12:
              break;
            case 13:
              break;
            case 14:
              return 11;
            case 15:
              break;
            case 16:
              return 9;
            case 17:
              return 31;
            case 18:
              return 48;
            case 19:
              return 4;
            case 20:
              this.begin("block");
              return 20;
            case 21:
              break;
            case 22:
              return 38;
            case 23:
              return 37;
            case 24:
              return 37;
            case 25:
              return 39;
            case 26:
              break;
            case 27:
              this.popState();
              return 22;
            case 28:
              return yy_.yytext[0];
            case 29:
              return 42;
            case 30:
              return 43;
            case 31:
              return 44;
            case 32:
              return 45;
            case 33:
              return 42;
            case 34:
              return 43;
            case 35:
              return 44;
            case 36:
              return 46;
            case 37:
              return 47;
            case 38:
              return 46;
            case 39:
              return 46;
            case 40:
              return 30;
            case 41:
              return yy_.yytext[0];
            case 42:
              return 6;
          }
        },
        rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK))\b)/i, /^(?:(.*?)[~](.*?)*[~])/i, /^(?:[A-Za-z][A-Za-z0-9\-_\[\]]*)/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\|o\b)/i, /^(?:\}o\b)/i, /^(?:\}\|)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:[A-Za-z][A-Za-z0-9\-_]*)/i, /^(?:.)/i, /^(?:$)/i],
        conditions: { "acc_descr_multiline": { "rules": [5, 6], "inclusive": false }, "acc_descr": { "rules": [3], "inclusive": false }, "acc_title": { "rules": [1], "inclusive": false }, "open_directive": { "rules": [8], "inclusive": false }, "type_directive": { "rules": [9, 10], "inclusive": false }, "arg_directive": { "rules": [10, 11], "inclusive": false }, "block": { "rules": [21, 22, 23, 24, 25, 26, 27, 28], "inclusive": false }, "INITIAL": { "rules": [0, 2, 4, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$8.parser = parser$8;
  const erDetector = (txt) => {
    return txt.match(/^\s*erDiagram/) !== null;
  };
  let entities = {};
  let relationships = [];
  const Cardinality = {
    ZERO_OR_ONE: "ZERO_OR_ONE",
    ZERO_OR_MORE: "ZERO_OR_MORE",
    ONE_OR_MORE: "ONE_OR_MORE",
    ONLY_ONE: "ONLY_ONE"
  };
  const Identification = {
    NON_IDENTIFYING: "NON_IDENTIFYING",
    IDENTIFYING: "IDENTIFYING"
  };
  const parseDirective$8 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const addEntity = function(name2) {
    if (typeof entities[name2] === "undefined") {
      entities[name2] = { attributes: [] };
      log$3.info("Added new entity :", name2);
    }
    return entities[name2];
  };
  const getEntities = () => entities;
  const addAttributes = function(entityName, attribs) {
    let entity = addEntity(entityName);
    let i;
    for (i = attribs.length - 1; i >= 0; i--) {
      entity.attributes.push(attribs[i]);
      log$3.debug("Added attribute ", attribs[i].attributeName);
    }
  };
  const addRelationship$1 = function(entA, rolA, entB, rSpec) {
    let rel = {
      entityA: entA,
      roleA: rolA,
      entityB: entB,
      relSpec: rSpec
    };
    relationships.push(rel);
    log$3.debug("Added new relationship :", rel);
  };
  const getRelationships$1 = () => relationships;
  const clear$7 = function() {
    entities = {};
    relationships = [];
    clear$g();
  };
  const erDb = {
    Cardinality,
    Identification,
    parseDirective: parseDirective$8,
    getConfig: () => getConfig$1().er,
    addEntity,
    addAttributes,
    getEntities,
    addRelationship: addRelationship$1,
    getRelationships: getRelationships$1,
    clear: clear$7,
    setAccTitle,
    getAccTitle,
    setAccDescription,
    getAccDescription
  };
  const ERMarkers = {
    ONLY_ONE_START: "ONLY_ONE_START",
    ONLY_ONE_END: "ONLY_ONE_END",
    ZERO_OR_ONE_START: "ZERO_OR_ONE_START",
    ZERO_OR_ONE_END: "ZERO_OR_ONE_END",
    ONE_OR_MORE_START: "ONE_OR_MORE_START",
    ONE_OR_MORE_END: "ONE_OR_MORE_END",
    ZERO_OR_MORE_START: "ZERO_OR_MORE_START",
    ZERO_OR_MORE_END: "ZERO_OR_MORE_END"
  };
  const insertMarkers$1 = function(elem, conf2) {
    let marker;
    elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18 M15,0 L15,18");
    elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_END).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,0 L3,18 M9,0 L9,18");
    marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6);
    marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18");
    marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_END).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
    marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6);
    marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,0 L21,18");
    elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27");
    elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_END).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
    marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6);
    marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
    marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_END).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
    marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6);
    marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
    return;
  };
  const erMarkers = {
    ERMarkers,
    insertMarkers: insertMarkers$1
  };
  let getRandomValues;
  const rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  const native = {
    randomUUID
  };
  function v4(options2, buf, offset) {
    if (native.randomUUID && !buf && !options2) {
      return native.randomUUID();
    }
    options2 = options2 || {};
    const rnds = options2.random || (options2.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  const BAD_ID_CHARS_REGEXP = /[^A-Za-z0-9]([\W])*/g;
  let conf$9 = {};
  let entityNameIds = /* @__PURE__ */ new Map();
  const setConf$8 = function(cnf) {
    const keys = Object.keys(cnf);
    for (let i = 0; i < keys.length; i++) {
      conf$9[keys[i]] = cnf[keys[i]];
    }
  };
  const drawAttributes = (groupNode, entityTextNode, attributes) => {
    const heightPadding = conf$9.entityPadding / 3;
    const widthPadding = conf$9.entityPadding / 3;
    const attrFontSize = conf$9.fontSize * 0.85;
    const labelBBox = entityTextNode.node().getBBox();
    const attributeNodes = [];
    let hasKeyType = false;
    let hasComment = false;
    let maxTypeWidth = 0;
    let maxNameWidth = 0;
    let maxKeyWidth = 0;
    let maxCommentWidth = 0;
    let cumulativeHeight = labelBBox.height + heightPadding * 2;
    let attrNum = 1;
    attributes.forEach((item) => {
      if (item.attributeKeyType !== void 0) {
        hasKeyType = true;
      }
      if (item.attributeComment !== void 0) {
        hasComment = true;
      }
    });
    attributes.forEach((item) => {
      const attrPrefix = `${entityTextNode.node().id}-attr-${attrNum}`;
      let nodeHeight = 0;
      const attributeType = parseGenericTypes(item.attributeType);
      const typeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-type`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(attributeType);
      const nameNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-name`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(item.attributeName);
      const attributeNode = {};
      attributeNode.tn = typeNode;
      attributeNode.nn = nameNode;
      const typeBBox = typeNode.node().getBBox();
      const nameBBox = nameNode.node().getBBox();
      maxTypeWidth = Math.max(maxTypeWidth, typeBBox.width);
      maxNameWidth = Math.max(maxNameWidth, nameBBox.width);
      nodeHeight = Math.max(typeBBox.height, nameBBox.height);
      if (hasKeyType) {
        const keyTypeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-key`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
          "style",
          "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
        ).text(item.attributeKeyType || "");
        attributeNode.kn = keyTypeNode;
        const keyTypeBBox = keyTypeNode.node().getBBox();
        maxKeyWidth = Math.max(maxKeyWidth, keyTypeBBox.width);
        nodeHeight = Math.max(nodeHeight, keyTypeBBox.height);
      }
      if (hasComment) {
        const commentNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-comment`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
          "style",
          "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
        ).text(item.attributeComment || "");
        attributeNode.cn = commentNode;
        const commentNodeBBox = commentNode.node().getBBox();
        maxCommentWidth = Math.max(maxCommentWidth, commentNodeBBox.width);
        nodeHeight = Math.max(nodeHeight, commentNodeBBox.height);
      }
      attributeNode.height = nodeHeight;
      attributeNodes.push(attributeNode);
      cumulativeHeight += nodeHeight + heightPadding * 2;
      attrNum += 1;
    });
    let widthPaddingFactor = 4;
    if (hasKeyType) {
      widthPaddingFactor += 2;
    }
    if (hasComment) {
      widthPaddingFactor += 2;
    }
    const maxWidth = maxTypeWidth + maxNameWidth + maxKeyWidth + maxCommentWidth;
    const bBox = {
      width: Math.max(
        conf$9.minEntityWidth,
        Math.max(
          labelBBox.width + conf$9.entityPadding * 2,
          maxWidth + widthPadding * widthPaddingFactor
        )
      ),
      height: attributes.length > 0 ? cumulativeHeight : Math.max(conf$9.minEntityHeight, labelBBox.height + conf$9.entityPadding * 2)
    };
    if (attributes.length > 0) {
      const spareColumnWidth = Math.max(
        0,
        (bBox.width - maxWidth - widthPadding * widthPaddingFactor) / (widthPaddingFactor / 2)
      );
      entityTextNode.attr(
        "transform",
        "translate(" + bBox.width / 2 + "," + (heightPadding + labelBBox.height / 2) + ")"
      );
      let heightOffset = labelBBox.height + heightPadding * 2;
      let attribStyle = "attributeBoxOdd";
      attributeNodes.forEach((attributeNode) => {
        const alignY = heightOffset + heightPadding + attributeNode.height / 2;
        attributeNode.tn.attr("transform", "translate(" + widthPadding + "," + alignY + ")");
        const typeRect = groupNode.insert("rect", "#" + attributeNode.tn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", heightOffset).attr("width", maxTypeWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
        const nameXOffset = parseFloat(typeRect.attr("x")) + parseFloat(typeRect.attr("width"));
        attributeNode.nn.attr(
          "transform",
          "translate(" + (nameXOffset + widthPadding) + "," + alignY + ")"
        );
        const nameRect = groupNode.insert("rect", "#" + attributeNode.nn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", nameXOffset).attr("y", heightOffset).attr("width", maxNameWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
        let keyTypeAndCommentXOffset = parseFloat(nameRect.attr("x")) + parseFloat(nameRect.attr("width"));
        if (hasKeyType) {
          attributeNode.kn.attr(
            "transform",
            "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
          );
          const keyTypeRect = groupNode.insert("rect", "#" + attributeNode.kn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxKeyWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
          keyTypeAndCommentXOffset = parseFloat(keyTypeRect.attr("x")) + parseFloat(keyTypeRect.attr("width"));
        }
        if (hasComment) {
          attributeNode.cn.attr(
            "transform",
            "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
          );
          groupNode.insert("rect", "#" + attributeNode.cn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxCommentWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
        }
        heightOffset += attributeNode.height + heightPadding * 2;
        attribStyle = attribStyle === "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
      });
    } else {
      bBox.height = Math.max(conf$9.minEntityHeight, cumulativeHeight);
      entityTextNode.attr("transform", "translate(" + bBox.width / 2 + "," + bBox.height / 2 + ")");
    }
    return bBox;
  };
  const drawEntities = function(svgNode2, entities2, graph2) {
    const keys = Object.keys(entities2);
    let firstOne;
    keys.forEach(function(entityName) {
      const entityId = generateId(entityName, "entity");
      entityNameIds.set(entityName, entityId);
      const groupNode = svgNode2.append("g").attr("id", entityId);
      firstOne = firstOne === void 0 ? entityId : firstOne;
      const textId = "text-" + entityId;
      const textNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", textId).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
      ).text(entityName);
      const { width: entityWidth, height: entityHeight } = drawAttributes(
        groupNode,
        textNode,
        entities2[entityName].attributes
      );
      const rectNode = groupNode.insert("rect", "#" + textId).attr("class", "er entityBox").attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", 0).attr("width", entityWidth).attr("height", entityHeight);
      const rectBBox = rectNode.node().getBBox();
      graph2.setNode(entityId, {
        width: rectBBox.width,
        height: rectBBox.height,
        shape: "rect",
        id: entityId
      });
    });
    return firstOne;
  };
  const adjustEntities$1 = function(svgNode2, graph2) {
    graph2.nodes().forEach(function(v) {
      if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
        svgNode2.select("#" + v).attr(
          "transform",
          "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
        );
      }
    });
  };
  const getEdgeName = function(rel) {
    return (rel.entityA + rel.roleA + rel.entityB).replace(/\s/g, "");
  };
  const addRelationships$1 = function(relationships2, g) {
    relationships2.forEach(function(r) {
      g.setEdge(
        entityNameIds.get(r.entityA),
        entityNameIds.get(r.entityB),
        { relationship: r },
        getEdgeName(r)
      );
    });
    return relationships2;
  };
  let relCnt$1 = 0;
  const drawRelationshipFromLayout$1 = function(svg2, rel, g, insert, diagObj) {
    relCnt$1++;
    const edge = g.edge(
      entityNameIds.get(rel.entityA),
      entityNameIds.get(rel.entityB),
      getEdgeName(rel)
    );
    const lineFunction = line$1().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    }).curve(curveBasis);
    const svgPath = svg2.insert("path", "#" + insert).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("stroke", conf$9.stroke).attr("fill", "none");
    if (rel.relSpec.relType === diagObj.db.Identification.NON_IDENTIFYING) {
      svgPath.attr("stroke-dasharray", "8,8");
    }
    let url = "";
    if (conf$9.arrowMarkerAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replace(/\(/g, "\\(");
      url = url.replace(/\)/g, "\\)");
    }
    switch (rel.relSpec.cardA) {
      case diagObj.db.Cardinality.ZERO_OR_ONE:
        svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_END + ")");
        break;
      case diagObj.db.Cardinality.ZERO_OR_MORE:
        svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_END + ")");
        break;
      case diagObj.db.Cardinality.ONE_OR_MORE:
        svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_END + ")");
        break;
      case diagObj.db.Cardinality.ONLY_ONE:
        svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_END + ")");
        break;
    }
    switch (rel.relSpec.cardB) {
      case diagObj.db.Cardinality.ZERO_OR_ONE:
        svgPath.attr(
          "marker-start",
          "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_START + ")"
        );
        break;
      case diagObj.db.Cardinality.ZERO_OR_MORE:
        svgPath.attr(
          "marker-start",
          "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_START + ")"
        );
        break;
      case diagObj.db.Cardinality.ONE_OR_MORE:
        svgPath.attr(
          "marker-start",
          "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_START + ")"
        );
        break;
      case diagObj.db.Cardinality.ONLY_ONE:
        svgPath.attr("marker-start", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_START + ")");
        break;
    }
    const len = svgPath.node().getTotalLength();
    const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
    const labelId = "rel" + relCnt$1;
    const labelNode = svg2.append("text").attr("class", "er relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
    ).text(rel.roleA);
    const labelBBox = labelNode.node().getBBox();
    svg2.insert("rect", "#" + labelId).attr("class", "er relationshipLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
  };
  const draw$b = function(text2, id2, _version, diagObj) {
    conf$9 = getConfig$1().er;
    log$3.info("Drawing ER diagram");
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const svg2 = root2.select(`[id='${id2}']`);
    erMarkers.insertMarkers(svg2, conf$9);
    let g;
    g = new graphlib$1.Graph({
      multigraph: true,
      directed: true,
      compound: false
    }).setGraph({
      rankdir: conf$9.layoutDirection,
      marginx: 20,
      marginy: 20,
      nodesep: 100,
      edgesep: 100,
      ranksep: 100
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    const firstEntity = drawEntities(svg2, diagObj.db.getEntities(), g);
    const relationships2 = addRelationships$1(diagObj.db.getRelationships(), g);
    dagreExports.layout(g);
    adjustEntities$1(svg2, g);
    relationships2.forEach(function(rel) {
      drawRelationshipFromLayout$1(svg2, rel, g, firstEntity, diagObj);
    });
    const padding2 = conf$9.diagramPadding;
    const svgBounds = svg2.node().getBBox();
    const width2 = svgBounds.width + padding2 * 2;
    const height2 = svgBounds.height + padding2 * 2;
    configureSvgSize(svg2, height2, width2, conf$9.useMaxWidth);
    svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
  };
  function generateId(str = "", prefix = "") {
    const simplifiedStr = str.replace(BAD_ID_CHARS_REGEXP, "");
    return `${strWithHyphen(prefix)}${strWithHyphen(simplifiedStr)}${v4()}`;
  }
  function strWithHyphen(str = "") {
    return str.length > 0 ? `${str}-` : "";
  }
  const erRenderer = {
    setConf: setConf$8,
    draw: draw$b
  };
  var parser$7 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 9], $V1 = [1, 7], $V2 = [1, 6], $V3 = [1, 8], $V4 = [1, 20, 21, 22, 23, 38, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V5 = [2, 10], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 23], $Va = [1, 30], $Vb = [1, 32], $Vc = [1, 33], $Vd = [1, 34], $Ve = [1, 62], $Vf = [1, 48], $Vg = [1, 52], $Vh = [1, 36], $Vi = [1, 37], $Vj = [1, 38], $Vk = [1, 39], $Vl = [1, 40], $Vm = [1, 56], $Vn = [1, 63], $Vo = [1, 51], $Vp = [1, 53], $Vq = [1, 55], $Vr = [1, 59], $Vs = [1, 60], $Vt = [1, 41], $Vu = [1, 42], $Vv = [1, 43], $Vw = [1, 44], $Vx = [1, 61], $Vy = [1, 50], $Vz = [1, 54], $VA = [1, 57], $VB = [1, 58], $VC = [1, 49], $VD = [1, 66], $VE = [1, 71], $VF = [1, 20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $VG = [1, 75], $VH = [1, 74], $VI = [1, 76], $VJ = [20, 21, 23, 81, 82], $VK = [1, 99], $VL = [1, 104], $VM = [1, 107], $VN = [1, 108], $VO = [1, 101], $VP = [1, 106], $VQ = [1, 109], $VR = [1, 102], $VS = [1, 114], $VT = [1, 113], $VU = [1, 103], $VV = [1, 105], $VW = [1, 110], $VX = [1, 111], $VY = [1, 112], $VZ = [1, 115], $V_ = [20, 21, 22, 23, 81, 82], $V$ = [20, 21, 22, 23, 53, 81, 82], $V01 = [20, 21, 22, 23, 40, 52, 53, 55, 57, 59, 61, 63, 65, 66, 67, 69, 71, 73, 74, 76, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V11 = [20, 21, 23], $V21 = [20, 21, 23, 52, 66, 67, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V31 = [1, 12, 20, 21, 22, 23, 24, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V41 = [52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V51 = [1, 149], $V61 = [1, 157], $V71 = [1, 158], $V81 = [1, 159], $V91 = [1, 160], $Va1 = [1, 144], $Vb1 = [1, 145], $Vc1 = [1, 141], $Vd1 = [1, 152], $Ve1 = [1, 153], $Vf1 = [1, 154], $Vg1 = [1, 155], $Vh1 = [1, 156], $Vi1 = [1, 161], $Vj1 = [1, 162], $Vk1 = [1, 147], $Vl1 = [1, 150], $Vm1 = [1, 146], $Vn1 = [1, 143], $Vo1 = [20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $Vp1 = [1, 165], $Vq1 = [20, 21, 22, 23, 26, 52, 66, 67, 91, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $Vr1 = [20, 21, 22, 23, 24, 26, 38, 40, 41, 42, 52, 56, 58, 60, 62, 64, 66, 67, 68, 70, 72, 73, 75, 77, 81, 82, 86, 87, 88, 89, 90, 91, 92, 95, 105, 106, 109, 111, 112, 113, 114, 122, 123, 124, 125, 126, 127], $Vs1 = [12, 21, 22, 24], $Vt1 = [22, 106], $Vu1 = [1, 250], $Vv1 = [1, 245], $Vw1 = [1, 246], $Vx1 = [1, 254], $Vy1 = [1, 251], $Vz1 = [1, 248], $VA1 = [1, 247], $VB1 = [1, 249], $VC1 = [1, 252], $VD1 = [1, 253], $VE1 = [1, 255], $VF1 = [1, 273], $VG1 = [20, 21, 23, 106], $VH1 = [20, 21, 22, 23, 66, 67, 86, 102, 105, 106, 109, 110, 111, 112, 113];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "directive": 5, "openDirective": 6, "typeDirective": 7, "closeDirective": 8, "separator": 9, ":": 10, "argDirective": 11, "open_directive": 12, "type_directive": 13, "arg_directive": 14, "close_directive": 15, "graphConfig": 16, "document": 17, "line": 18, "statement": 19, "SEMI": 20, "NEWLINE": 21, "SPACE": 22, "EOF": 23, "GRAPH": 24, "NODIR": 25, "DIR": 26, "FirstStmtSeperator": 27, "ending": 28, "endToken": 29, "spaceList": 30, "spaceListNewline": 31, "verticeStatement": 32, "styleStatement": 33, "linkStyleStatement": 34, "classDefStatement": 35, "classStatement": 36, "clickStatement": 37, "subgraph": 38, "text": 39, "SQS": 40, "SQE": 41, "end": 42, "direction": 43, "acc_title": 44, "acc_title_value": 45, "acc_descr": 46, "acc_descr_value": 47, "acc_descr_multiline_value": 48, "link": 49, "node": 50, "vertex": 51, "AMP": 52, "STYLE_SEPARATOR": 53, "idString": 54, "DOUBLECIRCLESTART": 55, "DOUBLECIRCLEEND": 56, "PS": 57, "PE": 58, "(-": 59, "-)": 60, "STADIUMSTART": 61, "STADIUMEND": 62, "SUBROUTINESTART": 63, "SUBROUTINEEND": 64, "VERTEX_WITH_PROPS_START": 65, "ALPHA": 66, "COLON": 67, "PIPE": 68, "CYLINDERSTART": 69, "CYLINDEREND": 70, "DIAMOND_START": 71, "DIAMOND_STOP": 72, "TAGEND": 73, "TRAPSTART": 74, "TRAPEND": 75, "INVTRAPSTART": 76, "INVTRAPEND": 77, "linkStatement": 78, "arrowText": 79, "TESTSTR": 80, "START_LINK": 81, "LINK": 82, "textToken": 83, "STR": 84, "keywords": 85, "STYLE": 86, "LINKSTYLE": 87, "CLASSDEF": 88, "CLASS": 89, "CLICK": 90, "DOWN": 91, "UP": 92, "textNoTags": 93, "textNoTagsToken": 94, "DEFAULT": 95, "stylesOpt": 96, "alphaNum": 97, "CALLBACKNAME": 98, "CALLBACKARGS": 99, "HREF": 100, "LINK_TARGET": 101, "HEX": 102, "numList": 103, "INTERPOLATE": 104, "NUM": 105, "COMMA": 106, "style": 107, "styleComponent": 108, "MINUS": 109, "UNIT": 110, "BRKT": 111, "DOT": 112, "PCT": 113, "TAGSTART": 114, "alphaNumToken": 115, "idStringToken": 116, "alphaNumStatement": 117, "direction_tb": 118, "direction_bt": 119, "direction_rl": 120, "direction_lr": 121, "PUNCTUATION": 122, "UNICODE_TEXT": 123, "PLUS": 124, "EQUALS": 125, "MULT": 126, "UNDERSCORE": 127, "graphCodeTokens": 128, "ARROW_CROSS": 129, "ARROW_POINT": 130, "ARROW_CIRCLE": 131, "ARROW_OPEN": 132, "QUOTE": 133, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 10: ":", 12: "open_directive", 13: "type_directive", 14: "arg_directive", 15: "close_directive", 20: "SEMI", 21: "NEWLINE", 22: "SPACE", 23: "EOF", 24: "GRAPH", 25: "NODIR", 26: "DIR", 38: "subgraph", 40: "SQS", 41: "SQE", 42: "end", 44: "acc_title", 45: "acc_title_value", 46: "acc_descr", 47: "acc_descr_value", 48: "acc_descr_multiline_value", 52: "AMP", 53: "STYLE_SEPARATOR", 55: "DOUBLECIRCLESTART", 56: "DOUBLECIRCLEEND", 57: "PS", 58: "PE", 59: "(-", 60: "-)", 61: "STADIUMSTART", 62: "STADIUMEND", 63: "SUBROUTINESTART", 64: "SUBROUTINEEND", 65: "VERTEX_WITH_PROPS_START", 66: "ALPHA", 67: "COLON", 68: "PIPE", 69: "CYLINDERSTART", 70: "CYLINDEREND", 71: "DIAMOND_START", 72: "DIAMOND_STOP", 73: "TAGEND", 74: "TRAPSTART", 75: "TRAPEND", 76: "INVTRAPSTART", 77: "INVTRAPEND", 80: "TESTSTR", 81: "START_LINK", 82: "LINK", 84: "STR", 86: "STYLE", 87: "LINKSTYLE", 88: "CLASSDEF", 89: "CLASS", 90: "CLICK", 91: "DOWN", 92: "UP", 95: "DEFAULT", 98: "CALLBACKNAME", 99: "CALLBACKARGS", 100: "HREF", 101: "LINK_TARGET", 102: "HEX", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "MINUS", 110: "UNIT", 111: "BRKT", 112: "DOT", 113: "PCT", 114: "TAGSTART", 118: "direction_tb", 119: "direction_bt", 120: "direction_rl", 121: "direction_lr", 122: "PUNCTUATION", 123: "UNICODE_TEXT", 124: "PLUS", 125: "EQUALS", 126: "MULT", 127: "UNDERSCORE", 129: "ARROW_CROSS", 130: "ARROW_POINT", 131: "ARROW_CIRCLE", 132: "ARROW_OPEN", 133: "QUOTE" },
      productions_: [0, [3, 1], [3, 2], [5, 4], [5, 6], [6, 1], [7, 1], [11, 1], [8, 1], [4, 2], [17, 0], [17, 2], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [16, 2], [16, 2], [16, 2], [16, 3], [28, 2], [28, 1], [29, 1], [29, 1], [29, 1], [27, 1], [27, 1], [27, 2], [31, 2], [31, 2], [31, 1], [31, 1], [30, 2], [30, 1], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 9], [19, 6], [19, 4], [19, 1], [19, 2], [19, 2], [19, 1], [9, 1], [9, 1], [9, 1], [32, 3], [32, 4], [32, 2], [32, 1], [50, 1], [50, 5], [50, 3], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 8], [51, 4], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 4], [51, 4], [51, 1], [49, 2], [49, 3], [49, 3], [49, 1], [49, 3], [78, 1], [79, 3], [39, 1], [39, 2], [39, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [93, 1], [93, 2], [35, 5], [35, 5], [36, 5], [37, 2], [37, 4], [37, 3], [37, 5], [37, 2], [37, 4], [37, 4], [37, 6], [37, 2], [37, 4], [37, 2], [37, 4], [37, 4], [37, 6], [33, 5], [33, 5], [34, 5], [34, 5], [34, 9], [34, 9], [34, 7], [34, 7], [103, 1], [103, 3], [96, 1], [96, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [94, 1], [94, 1], [94, 1], [94, 1], [54, 1], [54, 2], [97, 1], [97, 2], [117, 1], [117, 1], [117, 1], [117, 1], [43, 1], [43, 1], [43, 1], [43, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 5:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 6:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 7:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 8:
            yy.parseDirective("}%%", "close_directive", "flowchart");
            break;
          case 10:
            this.$ = [];
            break;
          case 11:
            if (!Array.isArray($$[$0]) || $$[$0].length > 0) {
              $$[$0 - 1].push($$[$0]);
            }
            this.$ = $$[$0 - 1];
            break;
          case 12:
          case 82:
          case 84:
          case 96:
          case 152:
          case 154:
          case 155:
            this.$ = $$[$0];
            break;
          case 19:
            yy.setDirection("TB");
            this.$ = "TB";
            break;
          case 20:
            yy.setDirection($$[$0 - 1]);
            this.$ = $$[$0 - 1];
            break;
          case 35:
            this.$ = $$[$0 - 1].nodes;
            break;
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
            this.$ = [];
            break;
          case 41:
            this.$ = yy.addSubGraph($$[$0 - 6], $$[$0 - 1], $$[$0 - 4]);
            break;
          case 42:
            this.$ = yy.addSubGraph($$[$0 - 3], $$[$0 - 1], $$[$0 - 3]);
            break;
          case 43:
            this.$ = yy.addSubGraph(void 0, $$[$0 - 1], void 0);
            break;
          case 45:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 46:
          case 47:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 51:
            yy.addLink($$[$0 - 2].stmt, $$[$0], $$[$0 - 1]);
            this.$ = { stmt: $$[$0], nodes: $$[$0].concat($$[$0 - 2].nodes) };
            break;
          case 52:
            yy.addLink($$[$0 - 3].stmt, $$[$0 - 1], $$[$0 - 2]);
            this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1].concat($$[$0 - 3].nodes) };
            break;
          case 53:
            this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1] };
            break;
          case 54:
            this.$ = { stmt: $$[$0], nodes: $$[$0] };
            break;
          case 55:
            this.$ = [$$[$0]];
            break;
          case 56:
            this.$ = $$[$0 - 4].concat($$[$0]);
            break;
          case 57:
            this.$ = [$$[$0 - 2]];
            yy.setClass($$[$0 - 2], $$[$0]);
            break;
          case 58:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "square");
            break;
          case 59:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "doublecircle");
            break;
          case 60:
            this.$ = $$[$0 - 5];
            yy.addVertex($$[$0 - 5], $$[$0 - 2], "circle");
            break;
          case 61:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "ellipse");
            break;
          case 62:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "stadium");
            break;
          case 63:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "subroutine");
            break;
          case 64:
            this.$ = $$[$0 - 7];
            yy.addVertex($$[$0 - 7], $$[$0 - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[$$[$0 - 5], $$[$0 - 3]]]));
            break;
          case 65:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "cylinder");
            break;
          case 66:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "round");
            break;
          case 67:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "diamond");
            break;
          case 68:
            this.$ = $$[$0 - 5];
            yy.addVertex($$[$0 - 5], $$[$0 - 2], "hexagon");
            break;
          case 69:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "odd");
            break;
          case 70:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "trapezoid");
            break;
          case 71:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "inv_trapezoid");
            break;
          case 72:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_right");
            break;
          case 73:
            this.$ = $$[$0 - 3];
            yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_left");
            break;
          case 74:
            this.$ = $$[$0];
            yy.addVertex($$[$0]);
            break;
          case 75:
            $$[$0 - 1].text = $$[$0];
            this.$ = $$[$0 - 1];
            break;
          case 76:
          case 77:
            $$[$0 - 2].text = $$[$0 - 1];
            this.$ = $$[$0 - 2];
            break;
          case 78:
            this.$ = $$[$0];
            break;
          case 79:
            var inf = yy.destructLink($$[$0], $$[$0 - 2]);
            this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length, "text": $$[$0 - 1] };
            break;
          case 80:
            var inf = yy.destructLink($$[$0]);
            this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length };
            break;
          case 81:
            this.$ = $$[$0 - 1];
            break;
          case 83:
          case 97:
          case 153:
            this.$ = $$[$0 - 1] + "" + $$[$0];
            break;
          case 98:
          case 99:
            this.$ = $$[$0 - 4];
            yy.addClass($$[$0 - 2], $$[$0]);
            break;
          case 100:
            this.$ = $$[$0 - 4];
            yy.setClass($$[$0 - 2], $$[$0]);
            break;
          case 101:
          case 109:
            this.$ = $$[$0 - 1];
            yy.setClickEvent($$[$0 - 1], $$[$0]);
            break;
          case 102:
          case 110:
            this.$ = $$[$0 - 3];
            yy.setClickEvent($$[$0 - 3], $$[$0 - 2]);
            yy.setTooltip($$[$0 - 3], $$[$0]);
            break;
          case 103:
            this.$ = $$[$0 - 2];
            yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break;
          case 104:
            this.$ = $$[$0 - 4];
            yy.setClickEvent($$[$0 - 4], $$[$0 - 3], $$[$0 - 2]);
            yy.setTooltip($$[$0 - 4], $$[$0]);
            break;
          case 105:
          case 111:
            this.$ = $$[$0 - 1];
            yy.setLink($$[$0 - 1], $$[$0]);
            break;
          case 106:
          case 112:
            this.$ = $$[$0 - 3];
            yy.setLink($$[$0 - 3], $$[$0 - 2]);
            yy.setTooltip($$[$0 - 3], $$[$0]);
            break;
          case 107:
          case 113:
            this.$ = $$[$0 - 3];
            yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
            break;
          case 108:
          case 114:
            this.$ = $$[$0 - 5];
            yy.setLink($$[$0 - 5], $$[$0 - 4], $$[$0]);
            yy.setTooltip($$[$0 - 5], $$[$0 - 2]);
            break;
          case 115:
            this.$ = $$[$0 - 4];
            yy.addVertex($$[$0 - 2], void 0, void 0, $$[$0]);
            break;
          case 116:
          case 118:
            this.$ = $$[$0 - 4];
            yy.updateLink($$[$0 - 2], $$[$0]);
            break;
          case 117:
            this.$ = $$[$0 - 4];
            yy.updateLink([$$[$0 - 2]], $$[$0]);
            break;
          case 119:
            this.$ = $$[$0 - 8];
            yy.updateLinkInterpolate([$$[$0 - 6]], $$[$0 - 2]);
            yy.updateLink([$$[$0 - 6]], $$[$0]);
            break;
          case 120:
            this.$ = $$[$0 - 8];
            yy.updateLinkInterpolate($$[$0 - 6], $$[$0 - 2]);
            yy.updateLink($$[$0 - 6], $$[$0]);
            break;
          case 121:
            this.$ = $$[$0 - 6];
            yy.updateLinkInterpolate([$$[$0 - 4]], $$[$0]);
            break;
          case 122:
            this.$ = $$[$0 - 6];
            yy.updateLinkInterpolate($$[$0 - 4], $$[$0]);
            break;
          case 123:
          case 125:
            this.$ = [$$[$0]];
            break;
          case 124:
          case 126:
            $$[$0 - 2].push($$[$0]);
            this.$ = $$[$0 - 2];
            break;
          case 128:
            this.$ = $$[$0 - 1] + $$[$0];
            break;
          case 150:
            this.$ = $$[$0];
            break;
          case 151:
            this.$ = $$[$0 - 1] + "" + $$[$0];
            break;
          case 156:
            this.$ = "v";
            break;
          case 157:
            this.$ = "-";
            break;
          case 158:
            this.$ = { stmt: "dir", value: "TB" };
            break;
          case 159:
            this.$ = { stmt: "dir", value: "BT" };
            break;
          case 160:
            this.$ = { stmt: "dir", value: "RL" };
            break;
          case 161:
            this.$ = { stmt: "dir", value: "LR" };
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, { 1: [3] }, { 1: [2, 1] }, { 3: 10, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, o($V4, $V5, { 17: 11 }), { 7: 12, 13: [1, 13] }, { 16: 14, 21: $V1, 22: $V2, 24: $V3 }, { 16: 15, 21: $V1, 22: $V2, 24: $V3 }, { 25: [1, 16], 26: [1, 17] }, { 13: [2, 5] }, { 1: [2, 2] }, { 1: [2, 9], 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 8: 64, 10: [1, 65], 15: $VD }, o([10, 15], [2, 6]), o($V4, [2, 17]), o($V4, [2, 18]), o($V4, [2, 19]), { 20: [1, 68], 21: [1, 69], 22: $VE, 27: 67, 30: 70 }, o($VF, [2, 11]), o($VF, [2, 12]), o($VF, [2, 13]), o($VF, [2, 14]), o($VF, [2, 15]), o($VF, [2, 16]), { 9: 72, 20: $VG, 21: $VH, 23: $VI, 49: 73, 78: 77, 81: [1, 78], 82: [1, 79] }, { 9: 80, 20: $VG, 21: $VH, 23: $VI }, { 9: 81, 20: $VG, 21: $VH, 23: $VI }, { 9: 82, 20: $VG, 21: $VH, 23: $VI }, { 9: 83, 20: $VG, 21: $VH, 23: $VI }, { 9: 84, 20: $VG, 21: $VH, 23: $VI }, { 9: 86, 20: $VG, 21: $VH, 22: [1, 85], 23: $VI }, o($VF, [2, 44]), { 45: [1, 87] }, { 47: [1, 88] }, o($VF, [2, 47]), o($VJ, [2, 54], { 30: 89, 22: $VE }), { 22: [1, 90] }, { 22: [1, 91] }, { 22: [1, 92] }, { 22: [1, 93] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 84: [1, 97], 91: $VO, 97: 96, 98: [1, 94], 100: [1, 95], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($VF, [2, 158]), o($VF, [2, 159]), o($VF, [2, 160]), o($VF, [2, 161]), o($V_, [2, 55], { 53: [1, 116] }), o($V$, [2, 74], { 116: 129, 40: [1, 117], 52: $Ve, 55: [1, 118], 57: [1, 119], 59: [1, 120], 61: [1, 121], 63: [1, 122], 65: [1, 123], 66: $Vf, 67: $Vg, 69: [1, 124], 71: [1, 125], 73: [1, 126], 74: [1, 127], 76: [1, 128], 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), o($V01, [2, 150]), o($V01, [2, 175]), o($V01, [2, 176]), o($V01, [2, 177]), o($V01, [2, 178]), o($V01, [2, 179]), o($V01, [2, 180]), o($V01, [2, 181]), o($V01, [2, 182]), o($V01, [2, 183]), o($V01, [2, 184]), o($V01, [2, 185]), o($V01, [2, 186]), o($V01, [2, 187]), o($V01, [2, 188]), o($V01, [2, 189]), o($V01, [2, 190]), { 9: 130, 20: $VG, 21: $VH, 23: $VI }, { 11: 131, 14: [1, 132] }, o($V11, [2, 8]), o($V4, [2, 20]), o($V4, [2, 26]), o($V4, [2, 27]), { 21: [1, 133] }, o($V21, [2, 34], { 30: 134, 22: $VE }), o($VF, [2, 35]), { 50: 135, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V31, [2, 48]), o($V31, [2, 49]), o($V31, [2, 50]), o($V41, [2, 78], { 79: 136, 68: [1, 138], 80: [1, 137] }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 139, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o([52, 66, 67, 68, 80, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 80]), o($VF, [2, 36]), o($VF, [2, 37]), o($VF, [2, 38]), o($VF, [2, 39]), o($VF, [2, 40]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 163, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 164 }), o($VF, [2, 45]), o($VF, [2, 46]), o($VJ, [2, 53], { 52: $Vp1 }), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 166, 102: [1, 167], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 95: [1, 168], 103: 169, 105: [1, 170] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 95: [1, 171], 97: 172, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 173, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 101], { 22: [1, 174], 99: [1, 175] }), o($V11, [2, 105], { 22: [1, 176] }), o($V11, [2, 109], { 115: 100, 117: 178, 22: [1, 177], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 111], { 22: [1, 179] }), o($Vq1, [2, 152]), o($Vq1, [2, 154]), o($Vq1, [2, 155]), o($Vq1, [2, 156]), o($Vq1, [2, 157]), o($Vr1, [2, 162]), o($Vr1, [2, 163]), o($Vr1, [2, 164]), o($Vr1, [2, 165]), o($Vr1, [2, 166]), o($Vr1, [2, 167]), o($Vr1, [2, 168]), o($Vr1, [2, 169]), o($Vr1, [2, 170]), o($Vr1, [2, 171]), o($Vr1, [2, 172]), o($Vr1, [2, 173]), o($Vr1, [2, 174]), { 52: $Ve, 54: 180, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 181, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 182, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 184, 42: $V91, 52: $VL, 57: [1, 183], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 185, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 186, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 187, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 66: [1, 188] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 189, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 190, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 71: [1, 191], 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 192, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 193, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 194, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V01, [2, 151]), o($Vs1, [2, 3]), { 8: 195, 15: $VD }, { 15: [2, 7] }, o($V4, [2, 28]), o($V21, [2, 33]), o($VJ, [2, 51], { 30: 196, 22: $VE }), o($V41, [2, 75], { 22: [1, 197] }), { 22: [1, 198] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 199, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 82: [1, 200], 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vr1, [2, 82]), o($Vr1, [2, 84]), o($Vr1, [2, 140]), o($Vr1, [2, 141]), o($Vr1, [2, 142]), o($Vr1, [2, 143]), o($Vr1, [2, 144]), o($Vr1, [2, 145]), o($Vr1, [2, 146]), o($Vr1, [2, 147]), o($Vr1, [2, 148]), o($Vr1, [2, 149]), o($Vr1, [2, 85]), o($Vr1, [2, 86]), o($Vr1, [2, 87]), o($Vr1, [2, 88]), o($Vr1, [2, 89]), o($Vr1, [2, 90]), o($Vr1, [2, 91]), o($Vr1, [2, 92]), o($Vr1, [2, 93]), o($Vr1, [2, 94]), o($Vr1, [2, 95]), { 9: 203, 20: $VG, 21: $VH, 22: $V51, 23: $VI, 24: $V61, 26: $V71, 38: $V81, 40: [1, 202], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 204], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $VE, 30: 205 }, { 22: [1, 206], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 207] }, { 22: [1, 208] }, { 22: [1, 209], 106: [1, 210] }, o($Vt1, [2, 123]), { 22: [1, 211] }, { 22: [1, 212], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 213], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 84: [1, 214] }, o($V11, [2, 103], { 22: [1, 215] }), { 84: [1, 216], 101: [1, 217] }, { 84: [1, 218] }, o($Vq1, [2, 153]), { 84: [1, 219], 101: [1, 220] }, o($V_, [2, 57], { 116: 129, 52: $Ve, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 221], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 56: [1, 222], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 223, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 224], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 60: [1, 225], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 62: [1, 226], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 64: [1, 227], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 67: [1, 228] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 70: [1, 229], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 230], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 231, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 232], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 233], 77: [1, 234], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 236], 77: [1, 235], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 9: 237, 20: $VG, 21: $VH, 23: $VI }, o($VJ, [2, 52], { 52: $Vp1 }), o($V41, [2, 77]), o($V41, [2, 76]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 68: [1, 238], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V41, [2, 79]), o($Vr1, [2, 83]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 239, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 240 }), o($VF, [2, 43]), { 51: 241, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 242, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 256, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 257, 102: $Vy1, 104: [1, 258], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 259, 102: $Vy1, 104: [1, 260], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 105: [1, 261] }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 262, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 263, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 264, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 102]), { 84: [1, 265] }, o($V11, [2, 106], { 22: [1, 266] }), o($V11, [2, 107]), o($V11, [2, 110]), o($V11, [2, 112], { 22: [1, 267] }), o($V11, [2, 113]), o($V$, [2, 58]), o($V$, [2, 59]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 268], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 66]), o($V$, [2, 61]), o($V$, [2, 62]), o($V$, [2, 63]), { 66: [1, 269] }, o($V$, [2, 65]), o($V$, [2, 67]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 270], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 69]), o($V$, [2, 70]), o($V$, [2, 72]), o($V$, [2, 71]), o($V$, [2, 73]), o($Vs1, [2, 4]), o([22, 52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 81]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 271], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 272], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V_, [2, 56]), o($V11, [2, 115], { 106: $VF1 }), o($VG1, [2, 125], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($VH1, [2, 127]), o($VH1, [2, 129]), o($VH1, [2, 130]), o($VH1, [2, 131]), o($VH1, [2, 132]), o($VH1, [2, 133]), o($VH1, [2, 134]), o($VH1, [2, 135]), o($VH1, [2, 136]), o($VH1, [2, 137]), o($VH1, [2, 138]), o($VH1, [2, 139]), o($V11, [2, 116], { 106: $VF1 }), o($V11, [2, 117], { 106: $VF1 }), { 22: [1, 275] }, o($V11, [2, 118], { 106: $VF1 }), { 22: [1, 276] }, o($Vt1, [2, 124]), o($V11, [2, 98], { 106: $VF1 }), o($V11, [2, 99], { 106: $VF1 }), o($V11, [2, 100], { 115: 100, 117: 178, 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 104]), { 101: [1, 277] }, { 101: [1, 278] }, { 58: [1, 279] }, { 68: [1, 280] }, { 72: [1, 281] }, { 9: 282, 20: $VG, 21: $VH, 23: $VI }, o($VF, [2, 42]), { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 107: 283, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($VH1, [2, 128]), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 284, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 285, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 108]), o($V11, [2, 114]), o($V$, [2, 60]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 286, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 68]), o($Vo1, $V5, { 17: 287 }), o($VG1, [2, 126], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($V11, [2, 121], { 115: 100, 117: 178, 22: [1, 288], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 122], { 115: 100, 117: 178, 22: [1, 289], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 290], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 291], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 292, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 293, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($V$, [2, 64]), o($VF, [2, 41]), o($V11, [2, 119], { 106: $VF1 }), o($V11, [2, 120], { 106: $VF1 })],
      defaultActions: { 2: [2, 1], 9: [2, 5], 10: [2, 2], 132: [2, 7] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 12;
            case 1:
              this.begin("type_directive");
              return 13;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 10;
            case 3:
              this.popState();
              this.popState();
              return 15;
            case 4:
              return 14;
            case 5:
              break;
            case 6:
              break;
            case 7:
              this.begin("acc_title");
              return 44;
            case 8:
              this.popState();
              return "acc_title_value";
            case 9:
              this.begin("acc_descr");
              return 46;
            case 10:
              this.popState();
              return "acc_descr_value";
            case 11:
              this.begin("acc_descr_multiline");
              break;
            case 12:
              this.popState();
              break;
            case 13:
              return "acc_descr_multiline_value";
            case 14:
              this.begin("string");
              break;
            case 15:
              this.popState();
              break;
            case 16:
              return "STR";
            case 17:
              return 86;
            case 18:
              return 95;
            case 19:
              return 87;
            case 20:
              return 104;
            case 21:
              return 88;
            case 22:
              return 89;
            case 23:
              this.begin("href");
              break;
            case 24:
              this.popState();
              break;
            case 25:
              return 100;
            case 26:
              this.begin("callbackname");
              break;
            case 27:
              this.popState();
              break;
            case 28:
              this.popState();
              this.begin("callbackargs");
              break;
            case 29:
              return 98;
            case 30:
              this.popState();
              break;
            case 31:
              return 99;
            case 32:
              this.begin("click");
              break;
            case 33:
              this.popState();
              break;
            case 34:
              return 90;
            case 35:
              if (yy.lex.firstGraph()) {
                this.begin("dir");
              }
              return 24;
            case 36:
              if (yy.lex.firstGraph()) {
                this.begin("dir");
              }
              return 24;
            case 37:
              return 38;
            case 38:
              return 42;
            case 39:
              return 101;
            case 40:
              return 101;
            case 41:
              return 101;
            case 42:
              return 101;
            case 43:
              this.popState();
              return 25;
            case 44:
              this.popState();
              return 26;
            case 45:
              this.popState();
              return 26;
            case 46:
              this.popState();
              return 26;
            case 47:
              this.popState();
              return 26;
            case 48:
              this.popState();
              return 26;
            case 49:
              this.popState();
              return 26;
            case 50:
              this.popState();
              return 26;
            case 51:
              this.popState();
              return 26;
            case 52:
              this.popState();
              return 26;
            case 53:
              this.popState();
              return 26;
            case 54:
              return 118;
            case 55:
              return 119;
            case 56:
              return 120;
            case 57:
              return 121;
            case 58:
              return 105;
            case 59:
              return 111;
            case 60:
              return 53;
            case 61:
              return 67;
            case 62:
              return 52;
            case 63:
              return 20;
            case 64:
              return 106;
            case 65:
              return 126;
            case 66:
              return 82;
            case 67:
              return 82;
            case 68:
              return 82;
            case 69:
              return 82;
            case 70:
              return 81;
            case 71:
              return 81;
            case 72:
              return 81;
            case 73:
              return 59;
            case 74:
              return 60;
            case 75:
              return 61;
            case 76:
              return 62;
            case 77:
              return 63;
            case 78:
              return 64;
            case 79:
              return 65;
            case 80:
              return 69;
            case 81:
              return 70;
            case 82:
              return 55;
            case 83:
              return 56;
            case 84:
              return 109;
            case 85:
              return 112;
            case 86:
              return 127;
            case 87:
              return 124;
            case 88:
              return 113;
            case 89:
              return 125;
            case 90:
              return 125;
            case 91:
              return 114;
            case 92:
              return 73;
            case 93:
              return 92;
            case 94:
              return "SEP";
            case 95:
              return 91;
            case 96:
              return 66;
            case 97:
              return 75;
            case 98:
              return 74;
            case 99:
              return 77;
            case 100:
              return 76;
            case 101:
              return 122;
            case 102:
              return 123;
            case 103:
              return 68;
            case 104:
              return 57;
            case 105:
              return 58;
            case 106:
              return 40;
            case 107:
              return 41;
            case 108:
              return 71;
            case 109:
              return 72;
            case 110:
              return 133;
            case 111:
              return 21;
            case 112:
              return 22;
            case 113:
              return 23;
          }
        },
        rules: [/^(?:%%\{)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)[^\n]*)/, /^(?:[^\}]%%[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\[)/, /^(?:\]\))/, /^(?:\[\[)/, /^(?:\]\])/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\])/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:-)/, /^(?:\.)/, /^(?:[\_])/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:[A-Za-z]+)/, /^(?:\\\])/, /^(?:\[\/)/, /^(?:\/\])/, /^(?:\[\\)/, /^(?:[!"#$%&'*+,-.`?\\_/])/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
        conditions: { "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [30, 31], "inclusive": false }, "callbackname": { "rules": [27, 28, 29], "inclusive": false }, "href": { "rules": [24, 25], "inclusive": false }, "click": { "rules": [33, 34], "inclusive": false }, "vertex": { "rules": [], "inclusive": false }, "dir": { "rules": [43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53], "inclusive": false }, "acc_descr_multiline": { "rules": [12, 13], "inclusive": false }, "acc_descr": { "rules": [10], "inclusive": false }, "acc_title": { "rules": [8], "inclusive": false }, "string": { "rules": [15, 16], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 9, 11, 14, 17, 18, 19, 20, 21, 22, 23, 26, 32, 35, 36, 37, 38, 39, 40, 41, 42, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$7.parser = parser$7;
  const flowDetector = (txt, config2) => {
    var _a;
    if (((_a = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
      return false;
    return txt.match(/^\s*graph/) !== null;
  };
  const flowDetectorV2 = (txt, config2) => {
    var _a;
    if (((_a = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper" && txt.match(/^\s*graph/) !== null)
      return true;
    return txt.match(/^\s*flowchart/) !== null;
  };
  const MERMAID_DOM_ID_PREFIX = "flowchart-";
  let vertexCounter = 0;
  let config = getConfig$1();
  let vertices = {};
  let edges = [];
  let classes$1 = [];
  let subGraphs = [];
  let subGraphLookup = {};
  let tooltips = {};
  let subCount = 0;
  let firstGraphFlag = true;
  let direction$1;
  let version$1;
  let funs$1 = [];
  const sanitizeText = (txt) => common.sanitizeText(txt, config);
  const parseDirective$7 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const lookUpDomId = function(id2) {
    const veritceKeys = Object.keys(vertices);
    for (let i = 0; i < veritceKeys.length; i++) {
      if (vertices[veritceKeys[i]].id === id2) {
        return vertices[veritceKeys[i]].domId;
      }
    }
    return id2;
  };
  const addVertex = function(_id, text2, type2, style, classes2, dir, props = {}) {
    let txt;
    let id2 = _id;
    if (typeof id2 === "undefined") {
      return;
    }
    if (id2.trim().length === 0) {
      return;
    }
    if (typeof vertices[id2] === "undefined") {
      vertices[id2] = {
        id: id2,
        domId: MERMAID_DOM_ID_PREFIX + id2 + "-" + vertexCounter,
        styles: [],
        classes: []
      };
    }
    vertexCounter++;
    if (typeof text2 !== "undefined") {
      config = getConfig$1();
      txt = sanitizeText(text2.trim());
      if (txt[0] === '"' && txt[txt.length - 1] === '"') {
        txt = txt.substring(1, txt.length - 1);
      }
      vertices[id2].text = txt;
    } else {
      if (typeof vertices[id2].text === "undefined") {
        vertices[id2].text = _id;
      }
    }
    if (typeof type2 !== "undefined") {
      vertices[id2].type = type2;
    }
    if (typeof style !== "undefined") {
      if (style !== null) {
        style.forEach(function(s2) {
          vertices[id2].styles.push(s2);
        });
      }
    }
    if (typeof classes2 !== "undefined") {
      if (classes2 !== null) {
        classes2.forEach(function(s2) {
          vertices[id2].classes.push(s2);
        });
      }
    }
    if (typeof dir !== "undefined") {
      vertices[id2].dir = dir;
    }
    vertices[id2].props = props;
  };
  const addSingleLink = function(_start, _end, type2, linktext) {
    let start2 = _start;
    let end2 = _end;
    const edge = { start: start2, end: end2, type: void 0, text: "" };
    linktext = type2.text;
    if (typeof linktext !== "undefined") {
      edge.text = sanitizeText(linktext.trim());
      if (edge.text[0] === '"' && edge.text[edge.text.length - 1] === '"') {
        edge.text = edge.text.substring(1, edge.text.length - 1);
      }
    }
    if (typeof type2 !== "undefined") {
      edge.type = type2.type;
      edge.stroke = type2.stroke;
      edge.length = type2.length;
    }
    edges.push(edge);
  };
  const addLink = function(_start, _end, type2, linktext) {
    let i, j;
    for (i = 0; i < _start.length; i++) {
      for (j = 0; j < _end.length; j++) {
        addSingleLink(_start[i], _end[j], type2, linktext);
      }
    }
  };
  const updateLinkInterpolate = function(positions, interp) {
    positions.forEach(function(pos) {
      if (pos === "default") {
        edges.defaultInterpolate = interp;
      } else {
        edges[pos].interpolate = interp;
      }
    });
  };
  const updateLink = function(positions, style) {
    positions.forEach(function(pos) {
      if (pos === "default") {
        edges.defaultStyle = style;
      } else {
        if (utils.isSubstringInArray("fill", style) === -1) {
          style.push("fill:none");
        }
        edges[pos].style = style;
      }
    });
  };
  const addClass = function(id2, style) {
    if (typeof classes$1[id2] === "undefined") {
      classes$1[id2] = { id: id2, styles: [], textStyles: [] };
    }
    if (typeof style !== "undefined") {
      if (style !== null) {
        style.forEach(function(s2) {
          if (s2.match("color")) {
            const newStyle1 = s2.replace("fill", "bgFill");
            const newStyle2 = newStyle1.replace("color", "fill");
            classes$1[id2].textStyles.push(newStyle2);
          }
          classes$1[id2].styles.push(s2);
        });
      }
    }
  };
  const setDirection$1 = function(dir) {
    direction$1 = dir;
    if (direction$1.match(/.*</)) {
      direction$1 = "RL";
    }
    if (direction$1.match(/.*\^/)) {
      direction$1 = "BT";
    }
    if (direction$1.match(/.*>/)) {
      direction$1 = "LR";
    }
    if (direction$1.match(/.*v/)) {
      direction$1 = "TB";
    }
  };
  const setClass$1 = function(ids, className) {
    ids.split(",").forEach(function(_id) {
      let id2 = _id;
      if (typeof vertices[id2] !== "undefined") {
        vertices[id2].classes.push(className);
      }
      if (typeof subGraphLookup[id2] !== "undefined") {
        subGraphLookup[id2].classes.push(className);
      }
    });
  };
  const setTooltip = function(ids, tooltip) {
    ids.split(",").forEach(function(id2) {
      if (typeof tooltip !== "undefined") {
        tooltips[version$1 === "gen-1" ? lookUpDomId(id2) : id2] = sanitizeText(tooltip);
      }
    });
  };
  const setClickFun$1 = function(id2, functionName, functionArgs) {
    let domId = lookUpDomId(id2);
    if (getConfig$1().securityLevel !== "loose") {
      return;
    }
    if (typeof functionName === "undefined") {
      return;
    }
    let argList = [];
    if (typeof functionArgs === "string") {
      argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let i = 0; i < argList.length; i++) {
        let item = argList[i].trim();
        if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
          item = item.substr(1, item.length - 2);
        }
        argList[i] = item;
      }
    }
    if (argList.length === 0) {
      argList.push(id2);
    }
    if (typeof vertices[id2] !== "undefined") {
      vertices[id2].haveCallback = true;
      funs$1.push(function() {
        const elem = document.querySelector(`[id="${domId}"]`);
        if (elem !== null) {
          elem.addEventListener(
            "click",
            function() {
              utils.runFunc(functionName, ...argList);
            },
            false
          );
        }
      });
    }
  };
  const setLink$1 = function(ids, linkStr, target) {
    ids.split(",").forEach(function(id2) {
      if (typeof vertices[id2] !== "undefined") {
        vertices[id2].link = utils.formatUrl(linkStr, config);
        vertices[id2].linkTarget = target;
      }
    });
    setClass$1(ids, "clickable");
  };
  const getTooltip = function(id2) {
    return tooltips[id2];
  };
  const setClickEvent$1 = function(ids, functionName, functionArgs) {
    ids.split(",").forEach(function(id2) {
      setClickFun$1(id2, functionName, functionArgs);
    });
    setClass$1(ids, "clickable");
  };
  const bindFunctions$1 = function(element) {
    funs$1.forEach(function(fun) {
      fun(element);
    });
  };
  const getDirection$1 = function() {
    return direction$1.trim();
  };
  const getVertices = function() {
    return vertices;
  };
  const getEdges = function() {
    return edges;
  };
  const getClasses$4 = function() {
    return classes$1;
  };
  const setupToolTips = function(element) {
    let tooltipElem = select(".mermaidTooltip");
    if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
      tooltipElem = select("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
    }
    const svg2 = select(element).select("svg");
    const nodes = svg2.selectAll("g.node");
    nodes.on("mouseover", function() {
      const el = select(this);
      const title2 = el.attr("title");
      if (title2 === null) {
        return;
      }
      const rect2 = this.getBoundingClientRect();
      tooltipElem.transition().duration(200).style("opacity", ".9");
      tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
      tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
      el.classed("hover", true);
    }).on("mouseout", function() {
      tooltipElem.transition().duration(500).style("opacity", 0);
      const el = select(this);
      el.classed("hover", false);
    });
  };
  funs$1.push(setupToolTips);
  const clear$6 = function(ver = "gen-1") {
    vertices = {};
    classes$1 = {};
    edges = [];
    funs$1 = [setupToolTips];
    subGraphs = [];
    subGraphLookup = {};
    subCount = 0;
    tooltips = [];
    firstGraphFlag = true;
    version$1 = ver;
    clear$g();
  };
  const setGen = (ver) => {
    version$1 = ver || "gen-1";
  };
  const defaultStyle = function() {
    return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
  };
  const addSubGraph = function(_id, list2, _title) {
    let id2 = _id.trim();
    let title2 = _title.trim();
    if (id2 === title2 && title2.match(/\s/)) {
      id2 = void 0;
    }
    function uniq(a2) {
      const prims = { boolean: {}, number: {}, string: {} };
      const objs = [];
      let dir2;
      const nodeList2 = a2.filter(function(item) {
        const type2 = typeof item;
        if (item.stmt && item.stmt === "dir") {
          dir2 = item.value;
          return false;
        }
        if (item.trim() === "") {
          return false;
        }
        if (type2 in prims) {
          return prims[type2].hasOwnProperty(item) ? false : prims[type2][item] = true;
        } else {
          return objs.indexOf(item) >= 0 ? false : objs.push(item);
        }
      });
      return { nodeList: nodeList2, dir: dir2 };
    }
    let nodeList = [];
    const { nodeList: nl, dir } = uniq(nodeList.concat.apply(nodeList, list2));
    nodeList = nl;
    if (version$1 === "gen-1") {
      for (let i = 0; i < nodeList.length; i++) {
        nodeList[i] = lookUpDomId(nodeList[i]);
      }
    }
    id2 = id2 || "subGraph" + subCount;
    title2 = title2 || "";
    title2 = sanitizeText(title2);
    subCount = subCount + 1;
    const subGraph = { id: id2, nodes: nodeList, title: title2.trim(), classes: [], dir };
    log$3.info("Adding", subGraph.id, subGraph.nodes, subGraph.dir);
    subGraph.nodes = makeUniq(subGraph, subGraphs).nodes;
    subGraphs.push(subGraph);
    subGraphLookup[id2] = subGraph;
    return id2;
  };
  const getPosForId = function(id2) {
    for (let i = 0; i < subGraphs.length; i++) {
      if (subGraphs[i].id === id2) {
        return i;
      }
    }
    return -1;
  };
  let secCount = -1;
  const posCrossRef = [];
  const indexNodes2 = function(id2, pos) {
    const nodes = subGraphs[pos].nodes;
    secCount = secCount + 1;
    if (secCount > 2e3) {
      return;
    }
    posCrossRef[secCount] = pos;
    if (subGraphs[pos].id === id2) {
      return {
        result: true,
        count: 0
      };
    }
    let count2 = 0;
    let posCount = 1;
    while (count2 < nodes.length) {
      const childPos = getPosForId(nodes[count2]);
      if (childPos >= 0) {
        const res = indexNodes2(id2, childPos);
        if (res.result) {
          return {
            result: true,
            count: posCount + res.count
          };
        } else {
          posCount = posCount + res.count;
        }
      }
      count2 = count2 + 1;
    }
    return {
      result: false,
      count: posCount
    };
  };
  const getDepthFirstPos = function(pos) {
    return posCrossRef[pos];
  };
  const indexNodes = function() {
    secCount = -1;
    if (subGraphs.length > 0) {
      indexNodes2("none", subGraphs.length - 1);
    }
  };
  const getSubGraphs = function() {
    return subGraphs;
  };
  const firstGraph = () => {
    if (firstGraphFlag) {
      firstGraphFlag = false;
      return true;
    }
    return false;
  };
  const destructStartLink = (_str) => {
    let str = _str.trim();
    let type2 = "arrow_open";
    switch (str[0]) {
      case "<":
        type2 = "arrow_point";
        str = str.slice(1);
        break;
      case "x":
        type2 = "arrow_cross";
        str = str.slice(1);
        break;
      case "o":
        type2 = "arrow_circle";
        str = str.slice(1);
        break;
    }
    let stroke = "normal";
    if (str.indexOf("=") !== -1) {
      stroke = "thick";
    }
    if (str.indexOf(".") !== -1) {
      stroke = "dotted";
    }
    return { type: type2, stroke };
  };
  const countChar = (char2, str) => {
    const length2 = str.length;
    let count2 = 0;
    for (let i = 0; i < length2; ++i) {
      if (str[i] === char2) {
        ++count2;
      }
    }
    return count2;
  };
  const destructEndLink = (_str) => {
    const str = _str.trim();
    let line2 = str.slice(0, -1);
    let type2 = "arrow_open";
    switch (str.slice(-1)) {
      case "x":
        type2 = "arrow_cross";
        if (str[0] === "x") {
          type2 = "double_" + type2;
          line2 = line2.slice(1);
        }
        break;
      case ">":
        type2 = "arrow_point";
        if (str[0] === "<") {
          type2 = "double_" + type2;
          line2 = line2.slice(1);
        }
        break;
      case "o":
        type2 = "arrow_circle";
        if (str[0] === "o") {
          type2 = "double_" + type2;
          line2 = line2.slice(1);
        }
        break;
    }
    let stroke = "normal";
    let length2 = line2.length - 1;
    if (line2[0] === "=") {
      stroke = "thick";
    }
    if (line2[0] === "~") {
      stroke = "invisible";
    }
    let dots = countChar(".", line2);
    if (dots) {
      stroke = "dotted";
      length2 = dots;
    }
    return { type: type2, stroke, length: length2 };
  };
  const destructLink = (_str, _startStr) => {
    const info2 = destructEndLink(_str);
    let startInfo;
    if (_startStr) {
      startInfo = destructStartLink(_startStr);
      if (startInfo.stroke !== info2.stroke) {
        return { type: "INVALID", stroke: "INVALID" };
      }
      if (startInfo.type === "arrow_open") {
        startInfo.type = info2.type;
      } else {
        if (startInfo.type !== info2.type)
          return { type: "INVALID", stroke: "INVALID" };
        startInfo.type = "double_" + startInfo.type;
      }
      if (startInfo.type === "double_arrow") {
        startInfo.type = "double_arrow_point";
      }
      startInfo.length = info2.length;
      return startInfo;
    }
    return info2;
  };
  const exists = (allSgs, _id) => {
    let res = false;
    allSgs.forEach((sg) => {
      const pos = sg.nodes.indexOf(_id);
      if (pos >= 0) {
        res = true;
      }
    });
    return res;
  };
  const makeUniq = (sg, allSubgraphs) => {
    const res = [];
    sg.nodes.forEach((_id, pos) => {
      if (!exists(allSubgraphs, _id)) {
        res.push(sg.nodes[pos]);
      }
    });
    return { nodes: res };
  };
  const flowDb = {
    parseDirective: parseDirective$7,
    defaultConfig: () => defaultConfig.flowchart,
    setAccTitle,
    getAccTitle,
    getAccDescription,
    setAccDescription,
    addVertex,
    lookUpDomId,
    addLink,
    updateLinkInterpolate,
    updateLink,
    addClass,
    setDirection: setDirection$1,
    setClass: setClass$1,
    setTooltip,
    getTooltip,
    setClickEvent: setClickEvent$1,
    setLink: setLink$1,
    bindFunctions: bindFunctions$1,
    getDirection: getDirection$1,
    getVertices,
    getEdges,
    getClasses: getClasses$4,
    clear: clear$6,
    setGen,
    defaultStyle,
    addSubGraph,
    getDepthFirstPos,
    indexNodes,
    getSubGraphs,
    destructLink,
    lex: {
      firstGraph
    },
    exists,
    makeUniq
  };
  var graphlib;
  if (typeof commonjsRequire === "function") {
    try {
      graphlib = graphlib$1;
    } catch (e) {
    }
  }
  if (!graphlib) {
    graphlib = window.graphlib;
  }
  var graphlib_1 = graphlib;
  var dagre;
  if (typeof commonjsRequire === "function") {
    try {
      dagre = requireDagre();
    } catch (e) {
    }
  }
  if (!dagre) {
    dagre = window.dagre;
  }
  var dagre_1 = dagre;
  var intersectNode_1 = intersectNode;
  function intersectNode(node2, point2) {
    return node2.intersect(point2);
  }
  var intersectEllipse_1 = intersectEllipse$1;
  function intersectEllipse$1(node2, rx, ry, point2) {
    var cx = node2.x;
    var cy = node2.y;
    var px = cx - point2.x;
    var py = cy - point2.y;
    var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
    var dx = Math.abs(rx * ry * px / det);
    if (point2.x < cx) {
      dx = -dx;
    }
    var dy = Math.abs(rx * ry * py / det);
    if (point2.y < cy) {
      dy = -dy;
    }
    return { x: cx + dx, y: cy + dy };
  }
  var intersectEllipse = intersectEllipse_1;
  var intersectCircle_1 = intersectCircle;
  function intersectCircle(node2, rx, point2) {
    return intersectEllipse(node2, rx, rx, point2);
  }
  var intersectLine_1 = intersectLine$1;
  function intersectLine$1(p1, p2, q1, q2) {
    var a1, a2, b12, b22, c1, c2;
    var r1, r2, r3, r4;
    var denom, offset, num;
    var x2, y2;
    a1 = p2.y - p1.y;
    b12 = p1.x - p2.x;
    c1 = p2.x * p1.y - p1.x * p2.y;
    r3 = a1 * q1.x + b12 * q1.y + c1;
    r4 = a1 * q2.x + b12 * q2.y + c1;
    if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
      return;
    }
    a2 = q2.y - q1.y;
    b22 = q1.x - q2.x;
    c2 = q2.x * q1.y - q1.x * q2.y;
    r1 = a2 * p1.x + b22 * p1.y + c2;
    r2 = a2 * p2.x + b22 * p2.y + c2;
    if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
      return;
    }
    denom = a1 * b22 - a2 * b12;
    if (denom === 0) {
      return;
    }
    offset = Math.abs(denom / 2);
    num = b12 * c2 - b22 * c1;
    x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    num = a2 * c1 - a1 * c2;
    y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
    return { x: x2, y: y2 };
  }
  function sameSign(r1, r2) {
    return r1 * r2 > 0;
  }
  var intersectLine = intersectLine_1;
  var intersectPolygon_1 = intersectPolygon;
  function intersectPolygon(node2, polyPoints, point2) {
    var x12 = node2.x;
    var y12 = node2.y;
    var intersections = [];
    var minX = Number.POSITIVE_INFINITY;
    var minY = Number.POSITIVE_INFINITY;
    polyPoints.forEach(function(entry) {
      minX = Math.min(minX, entry.x);
      minY = Math.min(minY, entry.y);
    });
    var left2 = x12 - node2.width / 2 - minX;
    var top2 = y12 - node2.height / 2 - minY;
    for (var i = 0; i < polyPoints.length; i++) {
      var p1 = polyPoints[i];
      var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
      var intersect2 = intersectLine(
        node2,
        point2,
        { x: left2 + p1.x, y: top2 + p1.y },
        { x: left2 + p2.x, y: top2 + p2.y }
      );
      if (intersect2) {
        intersections.push(intersect2);
      }
    }
    if (!intersections.length) {
      console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", node2);
      return node2;
    }
    if (intersections.length > 1) {
      intersections.sort(function(p, q) {
        var pdx = p.x - point2.x;
        var pdy = p.y - point2.y;
        var distp = Math.sqrt(pdx * pdx + pdy * pdy);
        var qdx = q.x - point2.x;
        var qdy = q.y - point2.y;
        var distq = Math.sqrt(qdx * qdx + qdy * qdy);
        return distp < distq ? -1 : distp === distq ? 0 : 1;
      });
    }
    return intersections[0];
  }
  var intersectRect_1 = intersectRect;
  function intersectRect(node2, point2) {
    var x2 = node2.x;
    var y2 = node2.y;
    var dx = point2.x - x2;
    var dy = point2.y - y2;
    var w2 = node2.width / 2;
    var h = node2.height / 2;
    var sx, sy;
    if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
      if (dy < 0) {
        h = -h;
      }
      sx = dy === 0 ? 0 : h * dx / dy;
      sy = h;
    } else {
      if (dx < 0) {
        w2 = -w2;
      }
      sx = w2;
      sy = dx === 0 ? 0 : w2 * dy / dx;
    }
    return { x: x2 + sx, y: y2 + sy };
  }
  var intersect = {
    node: intersectNode_1,
    circle: intersectCircle_1,
    ellipse: intersectEllipse_1,
    polygon: intersectPolygon_1,
    rect: intersectRect_1
  };
  var lodash;
  if (typeof commonjsRequire === "function") {
    try {
      lodash = {
        defaults: requireDefaults(),
        each: requireEach(),
        isFunction: isFunction_1,
        isPlainObject: requireIsPlainObject(),
        pick: requirePick(),
        has: requireHas(),
        range: requireRange(),
        uniqueId: requireUniqueId()
      };
    } catch (e) {
    }
  }
  if (!lodash) {
    lodash = window._;
  }
  var lodash_1 = lodash;
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(src);
  var d3$1;
  if (!d3$1) {
    if (typeof commonjsRequire === "function") {
      try {
        d3$1 = require$$0;
      } catch (e) {
      }
    }
  }
  if (!d3$1) {
    d3$1 = window.d3;
  }
  var d3_1 = d3$1;
  var _$1 = lodash_1;
  var util$1 = {
    isSubgraph,
    edgeToId,
    applyStyle,
    applyClass,
    applyTransition
  };
  function isSubgraph(g, v) {
    return !!g.children(v).length;
  }
  function edgeToId(e) {
    return escapeId(e.v) + ":" + escapeId(e.w) + ":" + escapeId(e.name);
  }
  var ID_DELIM = /:/g;
  function escapeId(str) {
    return str ? String(str).replace(ID_DELIM, "\\:") : "";
  }
  function applyStyle(dom, styleFn) {
    if (styleFn) {
      dom.attr("style", styleFn);
    }
  }
  function applyClass(dom, classFn, otherClasses) {
    if (classFn) {
      dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
    }
  }
  function applyTransition(selection2, g) {
    var graph2 = g.graph();
    if (_$1.isPlainObject(graph2)) {
      var transition2 = graph2.transition;
      if (_$1.isFunction(transition2)) {
        return transition2(selection2);
      }
    }
    return selection2;
  }
  var addTextLabel_1;
  var hasRequiredAddTextLabel;
  function requireAddTextLabel() {
    if (hasRequiredAddTextLabel)
      return addTextLabel_1;
    hasRequiredAddTextLabel = 1;
    var util2 = util$1;
    addTextLabel_1 = addTextLabel;
    function addTextLabel(root2, node2) {
      var domNode = root2.append("text");
      var lines = processEscapeSequences(node2.label).split("\n");
      for (var i = 0; i < lines.length; i++) {
        domNode.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(lines[i]);
      }
      util2.applyStyle(domNode, node2.labelStyle);
      return domNode;
    }
    function processEscapeSequences(text2) {
      var newText = "";
      var escaped = false;
      var ch;
      for (var i = 0; i < text2.length; ++i) {
        ch = text2[i];
        if (escaped) {
          switch (ch) {
            case "n":
              newText += "\n";
              break;
            default:
              newText += ch;
          }
          escaped = false;
        } else if (ch === "\\") {
          escaped = true;
        } else {
          newText += ch;
        }
      }
      return newText;
    }
    return addTextLabel_1;
  }
  var util = util$1;
  var addHtmlLabel_1 = addHtmlLabel;
  function addHtmlLabel(root2, node2) {
    var fo = root2.append("foreignObject").attr("width", "100000");
    var div = fo.append("xhtml:div");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    var label = node2.label;
    switch (typeof label) {
      case "function":
        div.insert(label);
        break;
      case "object":
        div.insert(function() {
          return label;
        });
        break;
      default:
        div.html(label);
    }
    util.applyStyle(div, node2.labelStyle);
    div.style("display", "inline-block");
    div.style("white-space", "nowrap");
    var client = div.node().getBoundingClientRect();
    fo.attr("width", client.width).attr("height", client.height);
    return fo;
  }
  var addSvgLabel;
  var hasRequiredAddSvgLabel;
  function requireAddSvgLabel() {
    if (hasRequiredAddSvgLabel)
      return addSvgLabel;
    hasRequiredAddSvgLabel = 1;
    var util2 = util$1;
    addSvgLabel = addSVGLabel;
    function addSVGLabel(root2, node2) {
      var domNode = root2;
      domNode.node().appendChild(node2.label);
      util2.applyStyle(domNode, node2.labelStyle);
      return domNode;
    }
    return addSvgLabel;
  }
  var addLabel_1;
  var hasRequiredAddLabel;
  function requireAddLabel() {
    if (hasRequiredAddLabel)
      return addLabel_1;
    hasRequiredAddLabel = 1;
    var addTextLabel = requireAddTextLabel();
    var addHtmlLabel2 = addHtmlLabel_1;
    var addSVGLabel = requireAddSvgLabel();
    addLabel_1 = addLabel;
    function addLabel(root2, node2, location2) {
      var label = node2.label;
      var labelSvg = root2.append("g");
      if (node2.labelType === "svg") {
        addSVGLabel(labelSvg, node2);
      } else if (typeof label !== "string" || node2.labelType === "html") {
        addHtmlLabel2(labelSvg, node2);
      } else {
        addTextLabel(labelSvg, node2);
      }
      var labelBBox = labelSvg.node().getBBox();
      var y2;
      switch (location2) {
        case "top":
          y2 = -node2.height / 2;
          break;
        case "bottom":
          y2 = node2.height / 2 - labelBBox.height;
          break;
        default:
          y2 = -labelBBox.height / 2;
      }
      labelSvg.attr(
        "transform",
        "translate(" + -labelBBox.width / 2 + "," + y2 + ")"
      );
      return labelSvg;
    }
    return addLabel_1;
  }
  var createNodes_1;
  var hasRequiredCreateNodes;
  function requireCreateNodes() {
    if (hasRequiredCreateNodes)
      return createNodes_1;
    hasRequiredCreateNodes = 1;
    var _2 = lodash_1;
    var addLabel = requireAddLabel();
    var util2 = util$1;
    var d32 = d3_1;
    createNodes_1 = createNodes;
    function createNodes(selection2, g, shapes2) {
      var simpleNodes = g.nodes().filter(function(v) {
        return !util2.isSubgraph(g, v);
      });
      var svgNodes = selection2.selectAll("g.node").data(simpleNodes, function(v) {
        return v;
      }).classed("update", true);
      svgNodes.exit().remove();
      svgNodes.enter().append("g").attr("class", "node").style("opacity", 0);
      svgNodes = selection2.selectAll("g.node");
      svgNodes.each(function(v) {
        var node2 = g.node(v);
        var thisGroup = d32.select(this);
        util2.applyClass(
          thisGroup,
          node2["class"],
          (thisGroup.classed("update") ? "update " : "") + "node"
        );
        thisGroup.select("g.label").remove();
        var labelGroup = thisGroup.append("g").attr("class", "label");
        var labelDom = addLabel(labelGroup, node2);
        var shape = shapes2[node2.shape];
        var bbox = _2.pick(labelDom.node().getBBox(), "width", "height");
        node2.elem = this;
        if (node2.id) {
          thisGroup.attr("id", node2.id);
        }
        if (node2.labelId) {
          labelGroup.attr("id", node2.labelId);
        }
        if (_2.has(node2, "width")) {
          bbox.width = node2.width;
        }
        if (_2.has(node2, "height")) {
          bbox.height = node2.height;
        }
        bbox.width += node2.paddingLeft + node2.paddingRight;
        bbox.height += node2.paddingTop + node2.paddingBottom;
        labelGroup.attr("transform", "translate(" + (node2.paddingLeft - node2.paddingRight) / 2 + "," + (node2.paddingTop - node2.paddingBottom) / 2 + ")");
        var root2 = d32.select(this);
        root2.select(".label-container").remove();
        var shapeSvg = shape(root2, bbox, node2).classed("label-container", true);
        util2.applyStyle(shapeSvg, node2.style);
        var shapeBBox = shapeSvg.node().getBBox();
        node2.width = shapeBBox.width;
        node2.height = shapeBBox.height;
      });
      var exitSelection;
      if (svgNodes.exit) {
        exitSelection = svgNodes.exit();
      } else {
        exitSelection = svgNodes.selectAll(null);
      }
      util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
      return svgNodes;
    }
    return createNodes_1;
  }
  var createClusters_1;
  var hasRequiredCreateClusters;
  function requireCreateClusters() {
    if (hasRequiredCreateClusters)
      return createClusters_1;
    hasRequiredCreateClusters = 1;
    var util2 = util$1;
    var d32 = d3_1;
    var addLabel = requireAddLabel();
    createClusters_1 = createClusters;
    function createClusters(selection2, g) {
      var clusters = g.nodes().filter(function(v) {
        return util2.isSubgraph(g, v);
      });
      var svgClusters = selection2.selectAll("g.cluster").data(clusters, function(v) {
        return v;
      });
      svgClusters.selectAll("*").remove();
      svgClusters.enter().append("g").attr("class", "cluster").attr("id", function(v) {
        var node2 = g.node(v);
        return node2.id;
      }).style("opacity", 0);
      svgClusters = selection2.selectAll("g.cluster");
      util2.applyTransition(svgClusters, g).style("opacity", 1);
      svgClusters.each(function(v) {
        var node2 = g.node(v);
        var thisGroup = d32.select(this);
        d32.select(this).append("rect");
        var labelGroup = thisGroup.append("g").attr("class", "label");
        addLabel(labelGroup, node2, node2.clusterLabelPos);
      });
      svgClusters.selectAll("rect").each(function(c2) {
        var node2 = g.node(c2);
        var domCluster = d32.select(this);
        util2.applyStyle(domCluster, node2.style);
      });
      var exitSelection;
      if (svgClusters.exit) {
        exitSelection = svgClusters.exit();
      } else {
        exitSelection = svgClusters.selectAll(null);
      }
      util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
      return svgClusters;
    }
    return createClusters_1;
  }
  var createEdgeLabels_1;
  var hasRequiredCreateEdgeLabels;
  function requireCreateEdgeLabels() {
    if (hasRequiredCreateEdgeLabels)
      return createEdgeLabels_1;
    hasRequiredCreateEdgeLabels = 1;
    var _2 = lodash_1;
    var addLabel = requireAddLabel();
    var util2 = util$1;
    var d32 = d3_1;
    createEdgeLabels_1 = createEdgeLabels;
    function createEdgeLabels(selection2, g) {
      var svgEdgeLabels = selection2.selectAll("g.edgeLabel").data(g.edges(), function(e) {
        return util2.edgeToId(e);
      }).classed("update", true);
      svgEdgeLabels.exit().remove();
      svgEdgeLabels.enter().append("g").classed("edgeLabel", true).style("opacity", 0);
      svgEdgeLabels = selection2.selectAll("g.edgeLabel");
      svgEdgeLabels.each(function(e) {
        var root2 = d32.select(this);
        root2.select(".label").remove();
        var edge = g.edge(e);
        var label = addLabel(root2, g.edge(e), 0, 0).classed("label", true);
        var bbox = label.node().getBBox();
        if (edge.labelId) {
          label.attr("id", edge.labelId);
        }
        if (!_2.has(edge, "width")) {
          edge.width = bbox.width;
        }
        if (!_2.has(edge, "height")) {
          edge.height = bbox.height;
        }
      });
      var exitSelection;
      if (svgEdgeLabels.exit) {
        exitSelection = svgEdgeLabels.exit();
      } else {
        exitSelection = svgEdgeLabels.selectAll(null);
      }
      util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
      return svgEdgeLabels;
    }
    return createEdgeLabels_1;
  }
  var createEdgePaths_1;
  var hasRequiredCreateEdgePaths;
  function requireCreateEdgePaths() {
    if (hasRequiredCreateEdgePaths)
      return createEdgePaths_1;
    hasRequiredCreateEdgePaths = 1;
    var _2 = lodash_1;
    var intersectNode2 = intersectNode_1;
    var util2 = util$1;
    var d32 = d3_1;
    createEdgePaths_1 = createEdgePaths;
    function createEdgePaths(selection2, g, arrows2) {
      var previousPaths = selection2.selectAll("g.edgePath").data(g.edges(), function(e) {
        return util2.edgeToId(e);
      }).classed("update", true);
      var newPaths = enter(previousPaths, g);
      exit(previousPaths, g);
      var svgPaths = previousPaths.merge !== void 0 ? previousPaths.merge(newPaths) : previousPaths;
      util2.applyTransition(svgPaths, g).style("opacity", 1);
      svgPaths.each(function(e) {
        var domEdge = d32.select(this);
        var edge = g.edge(e);
        edge.elem = this;
        if (edge.id) {
          domEdge.attr("id", edge.id);
        }
        util2.applyClass(
          domEdge,
          edge["class"],
          (domEdge.classed("update") ? "update " : "") + "edgePath"
        );
      });
      svgPaths.selectAll("path.path").each(function(e) {
        var edge = g.edge(e);
        edge.arrowheadId = _2.uniqueId("arrowhead");
        var domEdge = d32.select(this).attr("marker-end", function() {
          return "url(" + makeFragmentRef(location.href, edge.arrowheadId) + ")";
        }).style("fill", "none");
        util2.applyTransition(domEdge, g).attr("d", function(e3) {
          return calcPoints(g, e3);
        });
        util2.applyStyle(domEdge, edge.style);
      });
      svgPaths.selectAll("defs *").remove();
      svgPaths.selectAll("defs").each(function(e) {
        var edge = g.edge(e);
        var arrowhead = arrows2[edge.arrowhead];
        arrowhead(d32.select(this), edge.arrowheadId, edge, "arrowhead");
      });
      return svgPaths;
    }
    function makeFragmentRef(url, fragmentId) {
      var baseUrl = url.split("#")[0];
      return baseUrl + "#" + fragmentId;
    }
    function calcPoints(g, e) {
      var edge = g.edge(e);
      var tail = g.node(e.v);
      var head2 = g.node(e.w);
      var points = edge.points.slice(1, edge.points.length - 1);
      points.unshift(intersectNode2(tail, points[0]));
      points.push(intersectNode2(head2, points[points.length - 1]));
      return createLine(edge, points);
    }
    function createLine(edge, points) {
      var line2 = (d32.line || d32.svg.line)().x(function(d) {
        return d.x;
      }).y(function(d) {
        return d.y;
      });
      (line2.curve || line2.interpolate)(edge.curve);
      return line2(points);
    }
    function getCoords(elem) {
      var bbox = elem.getBBox();
      var matrix = elem.ownerSVGElement.getScreenCTM().inverse().multiply(elem.getScreenCTM()).translate(bbox.width / 2, bbox.height / 2);
      return { x: matrix.e, y: matrix.f };
    }
    function enter(svgPaths, g) {
      var svgPathsEnter = svgPaths.enter().append("g").attr("class", "edgePath").style("opacity", 0);
      svgPathsEnter.append("path").attr("class", "path").attr("d", function(e) {
        var edge = g.edge(e);
        var sourceElem = g.node(e.v).elem;
        var points = _2.range(edge.points.length).map(function() {
          return getCoords(sourceElem);
        });
        return createLine(edge, points);
      });
      svgPathsEnter.append("defs");
      return svgPathsEnter;
    }
    function exit(svgPaths, g) {
      var svgPathExit = svgPaths.exit();
      util2.applyTransition(svgPathExit, g).style("opacity", 0).remove();
    }
    return createEdgePaths_1;
  }
  var positionNodes_1;
  var hasRequiredPositionNodes;
  function requirePositionNodes() {
    if (hasRequiredPositionNodes)
      return positionNodes_1;
    hasRequiredPositionNodes = 1;
    var util2 = util$1;
    var d32 = d3_1;
    positionNodes_1 = positionNodes;
    function positionNodes(selection2, g) {
      var created = selection2.filter(function() {
        return !d32.select(this).classed("update");
      });
      function translate(v) {
        var node2 = g.node(v);
        return "translate(" + node2.x + "," + node2.y + ")";
      }
      created.attr("transform", translate);
      util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
    }
    return positionNodes_1;
  }
  var positionEdgeLabels_1;
  var hasRequiredPositionEdgeLabels;
  function requirePositionEdgeLabels() {
    if (hasRequiredPositionEdgeLabels)
      return positionEdgeLabels_1;
    hasRequiredPositionEdgeLabels = 1;
    var util2 = util$1;
    var d32 = d3_1;
    var _2 = lodash_1;
    positionEdgeLabels_1 = positionEdgeLabels;
    function positionEdgeLabels(selection2, g) {
      var created = selection2.filter(function() {
        return !d32.select(this).classed("update");
      });
      function translate(e) {
        var edge = g.edge(e);
        return _2.has(edge, "x") ? "translate(" + edge.x + "," + edge.y + ")" : "";
      }
      created.attr("transform", translate);
      util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
    }
    return positionEdgeLabels_1;
  }
  var positionClusters_1;
  var hasRequiredPositionClusters;
  function requirePositionClusters() {
    if (hasRequiredPositionClusters)
      return positionClusters_1;
    hasRequiredPositionClusters = 1;
    var util2 = util$1;
    var d32 = d3_1;
    positionClusters_1 = positionClusters;
    function positionClusters(selection2, g) {
      var created = selection2.filter(function() {
        return !d32.select(this).classed("update");
      });
      function translate(v) {
        var node2 = g.node(v);
        return "translate(" + node2.x + "," + node2.y + ")";
      }
      created.attr("transform", translate);
      util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
      util2.applyTransition(created.selectAll("rect"), g).attr("width", function(v) {
        return g.node(v).width;
      }).attr("height", function(v) {
        return g.node(v).height;
      }).attr("x", function(v) {
        var node2 = g.node(v);
        return -node2.width / 2;
      }).attr("y", function(v) {
        var node2 = g.node(v);
        return -node2.height / 2;
      });
    }
    return positionClusters_1;
  }
  var shapes;
  var hasRequiredShapes;
  function requireShapes() {
    if (hasRequiredShapes)
      return shapes;
    hasRequiredShapes = 1;
    var intersectRect2 = intersectRect_1;
    var intersectEllipse2 = intersectEllipse_1;
    var intersectCircle2 = intersectCircle_1;
    var intersectPolygon2 = intersectPolygon_1;
    shapes = {
      rect: rect2,
      ellipse,
      circle: circle2,
      diamond: diamond3
    };
    function rect2(parent, bbox, node2) {
      var shapeSvg = parent.insert("rect", ":first-child").attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("width", bbox.width).attr("height", bbox.height);
      node2.intersect = function(point2) {
        return intersectRect2(node2, point2);
      };
      return shapeSvg;
    }
    function ellipse(parent, bbox, node2) {
      var rx = bbox.width / 2;
      var ry = bbox.height / 2;
      var shapeSvg = parent.insert("ellipse", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("rx", rx).attr("ry", ry);
      node2.intersect = function(point2) {
        return intersectEllipse2(node2, rx, ry, point2);
      };
      return shapeSvg;
    }
    function circle2(parent, bbox, node2) {
      var r = Math.max(bbox.width, bbox.height) / 2;
      var shapeSvg = parent.insert("circle", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("r", r);
      node2.intersect = function(point2) {
        return intersectCircle2(node2, r, point2);
      };
      return shapeSvg;
    }
    function diamond3(parent, bbox, node2) {
      var w2 = bbox.width * Math.SQRT2 / 2;
      var h = bbox.height * Math.SQRT2 / 2;
      var points = [
        { x: 0, y: -h },
        { x: -w2, y: 0 },
        { x: 0, y: h },
        { x: w2, y: 0 }
      ];
      var shapeSvg = parent.insert("polygon", ":first-child").attr("points", points.map(function(p) {
        return p.x + "," + p.y;
      }).join(" "));
      node2.intersect = function(p) {
        return intersectPolygon2(node2, points, p);
      };
      return shapeSvg;
    }
    return shapes;
  }
  var arrows;
  var hasRequiredArrows;
  function requireArrows() {
    if (hasRequiredArrows)
      return arrows;
    hasRequiredArrows = 1;
    var util2 = util$1;
    arrows = {
      "default": normal2,
      "normal": normal2,
      "vee": vee,
      "undirected": undirected
    };
    function normal2(parent, id2, edge, type2) {
      var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
      var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
      util2.applyStyle(path2, edge[type2 + "Style"]);
      if (edge[type2 + "Class"]) {
        path2.attr("class", edge[type2 + "Class"]);
      }
    }
    function vee(parent, id2, edge, type2) {
      var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
      var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
      util2.applyStyle(path2, edge[type2 + "Style"]);
      if (edge[type2 + "Class"]) {
        path2.attr("class", edge[type2 + "Class"]);
      }
    }
    function undirected(parent, id2, edge, type2) {
      var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
      var path2 = marker.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
      util2.applyStyle(path2, edge[type2 + "Style"]);
      if (edge[type2 + "Class"]) {
        path2.attr("class", edge[type2 + "Class"]);
      }
    }
    return arrows;
  }
  var _ = lodash_1;
  var d3 = d3_1;
  var layout = dagre_1.layout;
  var render_1 = render$1;
  function render$1() {
    var createNodes = requireCreateNodes();
    var createClusters = requireCreateClusters();
    var createEdgeLabels = requireCreateEdgeLabels();
    var createEdgePaths = requireCreateEdgePaths();
    var positionNodes = requirePositionNodes();
    var positionEdgeLabels = requirePositionEdgeLabels();
    var positionClusters = requirePositionClusters();
    var shapes2 = requireShapes();
    var arrows2 = requireArrows();
    var fn = function(svg2, g) {
      preProcessGraph(g);
      var outputGroup = createOrSelectGroup(svg2, "output");
      var clustersGroup = createOrSelectGroup(outputGroup, "clusters");
      var edgePathsGroup = createOrSelectGroup(outputGroup, "edgePaths");
      var edgeLabels2 = createEdgeLabels(createOrSelectGroup(outputGroup, "edgeLabels"), g);
      var nodes = createNodes(createOrSelectGroup(outputGroup, "nodes"), g, shapes2);
      layout(g);
      positionNodes(nodes, g);
      positionEdgeLabels(edgeLabels2, g);
      createEdgePaths(edgePathsGroup, g, arrows2);
      var clusters = createClusters(clustersGroup, g);
      positionClusters(clusters, g);
      postProcessGraph(g);
    };
    fn.createNodes = function(value) {
      if (!arguments.length)
        return createNodes;
      createNodes = value;
      return fn;
    };
    fn.createClusters = function(value) {
      if (!arguments.length)
        return createClusters;
      createClusters = value;
      return fn;
    };
    fn.createEdgeLabels = function(value) {
      if (!arguments.length)
        return createEdgeLabels;
      createEdgeLabels = value;
      return fn;
    };
    fn.createEdgePaths = function(value) {
      if (!arguments.length)
        return createEdgePaths;
      createEdgePaths = value;
      return fn;
    };
    fn.shapes = function(value) {
      if (!arguments.length)
        return shapes2;
      shapes2 = value;
      return fn;
    };
    fn.arrows = function(value) {
      if (!arguments.length)
        return arrows2;
      arrows2 = value;
      return fn;
    };
    return fn;
  }
  var NODE_DEFAULT_ATTRS = {
    paddingLeft: 10,
    paddingRight: 10,
    paddingTop: 10,
    paddingBottom: 10,
    rx: 0,
    ry: 0,
    shape: "rect"
  };
  var EDGE_DEFAULT_ATTRS = {
    arrowhead: "normal",
    curve: d3.curveLinear
  };
  function preProcessGraph(g) {
    g.nodes().forEach(function(v) {
      var node2 = g.node(v);
      if (!_.has(node2, "label") && !g.children(v).length) {
        node2.label = v;
      }
      if (_.has(node2, "paddingX")) {
        _.defaults(node2, {
          paddingLeft: node2.paddingX,
          paddingRight: node2.paddingX
        });
      }
      if (_.has(node2, "paddingY")) {
        _.defaults(node2, {
          paddingTop: node2.paddingY,
          paddingBottom: node2.paddingY
        });
      }
      if (_.has(node2, "padding")) {
        _.defaults(node2, {
          paddingLeft: node2.padding,
          paddingRight: node2.padding,
          paddingTop: node2.padding,
          paddingBottom: node2.padding
        });
      }
      _.defaults(node2, NODE_DEFAULT_ATTRS);
      _.each(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(k2) {
        node2[k2] = Number(node2[k2]);
      });
      if (_.has(node2, "width")) {
        node2._prevWidth = node2.width;
      }
      if (_.has(node2, "height")) {
        node2._prevHeight = node2.height;
      }
    });
    g.edges().forEach(function(e) {
      var edge = g.edge(e);
      if (!_.has(edge, "label")) {
        edge.label = "";
      }
      _.defaults(edge, EDGE_DEFAULT_ATTRS);
    });
  }
  function postProcessGraph(g) {
    _.each(g.nodes(), function(v) {
      var node2 = g.node(v);
      if (_.has(node2, "_prevWidth")) {
        node2.width = node2._prevWidth;
      } else {
        delete node2.width;
      }
      if (_.has(node2, "_prevHeight")) {
        node2.height = node2._prevHeight;
      } else {
        delete node2.height;
      }
      delete node2._prevWidth;
      delete node2._prevHeight;
    });
  }
  function createOrSelectGroup(root2, name2) {
    var selection2 = root2.select("g." + name2);
    if (selection2.empty()) {
      selection2 = root2.append("g").attr("class", name2);
    }
    return selection2;
  }
  var version = "0.6.4";
  /**
   * @license
   * Copyright (c) 2012-2013 Chris Pettitt
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var dagreD3 = {
    graphlib: graphlib_1,
    dagre: dagre_1,
    intersect,
    render: render_1,
    util: util$1,
    version
  };
  function question(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const s2 = (w2 + h) * 0.9;
    const points = [
      { x: s2 / 2, y: 0 },
      { x: s2, y: -s2 / 2 },
      { x: s2 / 2, y: -s2 },
      { x: 0, y: -s2 / 2 }
    ];
    const shapeSvg = insertPolygonShape(parent, s2, s2, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function hexagon(parent, bbox, node2) {
    const f = 4;
    const h = bbox.height;
    const m2 = h / f;
    const w2 = bbox.width + 2 * m2;
    const points = [
      { x: m2, y: 0 },
      { x: w2 - m2, y: 0 },
      { x: w2, y: -h / 2 },
      { x: w2 - m2, y: -h },
      { x: m2, y: -h },
      { x: 0, y: -h / 2 }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function rect_left_inv_arrow(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: -h / 2, y: 0 },
      { x: w2, y: 0 },
      { x: w2, y: -h },
      { x: -h / 2, y: -h },
      { x: 0, y: -h / 2 }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function lean_right(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: -2 * h / 6, y: 0 },
      { x: w2 - h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: -h },
      { x: h / 6, y: -h }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function lean_left(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: 2 * h / 6, y: 0 },
      { x: w2 + h / 6, y: 0 },
      { x: w2 - 2 * h / 6, y: -h },
      { x: -h / 6, y: -h }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function trapezoid(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: -2 * h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: 0 },
      { x: w2 - h / 6, y: -h },
      { x: h / 6, y: -h }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function inv_trapezoid(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: h / 6, y: 0 },
      { x: w2 - h / 6, y: 0 },
      { x: w2 + 2 * h / 6, y: -h },
      { x: -2 * h / 6, y: -h }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function rect_right_inv_arrow(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: 0, y: 0 },
      { x: w2 + h / 2, y: 0 },
      { x: w2, y: -h / 2 },
      { x: w2 + h / 2, y: -h },
      { x: 0, y: -h }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function stadium(parent, bbox, node2) {
    const h = bbox.height;
    const w2 = bbox.width + h / 4;
    const shapeSvg = parent.insert("rect", ":first-child").attr("rx", h / 2).attr("ry", h / 2).attr("x", -w2 / 2).attr("y", -h / 2).attr("width", w2).attr("height", h);
    node2.intersect = function(point2) {
      return dagreD3.intersect.rect(node2, point2);
    };
    return shapeSvg;
  }
  function subroutine(parent, bbox, node2) {
    const w2 = bbox.width;
    const h = bbox.height;
    const points = [
      { x: 0, y: 0 },
      { x: w2, y: 0 },
      { x: w2, y: -h },
      { x: 0, y: -h },
      { x: 0, y: 0 },
      { x: -8, y: 0 },
      { x: w2 + 8, y: 0 },
      { x: w2 + 8, y: -h },
      { x: -8, y: -h },
      { x: -8, y: 0 }
    ];
    const shapeSvg = insertPolygonShape(parent, w2, h, points);
    node2.intersect = function(point2) {
      return dagreD3.intersect.polygon(node2, points, point2);
    };
    return shapeSvg;
  }
  function cylinder(parent, bbox, node2) {
    const w2 = bbox.width;
    const rx = w2 / 2;
    const ry = rx / (2.5 + w2 / 50);
    const h = bbox.height + ry;
    const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h;
    const shapeSvg = parent.attr("label-offset-y", ry).insert("path", ":first-child").attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h / 2 + ry) + ")");
    node2.intersect = function(point2) {
      const pos = dagreD3.intersect.rect(node2, point2);
      const x2 = pos.x - node2.x;
      if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
        let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
        if (y2 != 0)
          y2 = Math.sqrt(y2);
        y2 = ry - y2;
        if (point2.y - node2.y > 0)
          y2 = -y2;
        pos.y += y2;
      }
      return pos;
    };
    return shapeSvg;
  }
  function addToRender(render2) {
    render2.shapes().question = question;
    render2.shapes().hexagon = hexagon;
    render2.shapes().stadium = stadium;
    render2.shapes().subroutine = subroutine;
    render2.shapes().cylinder = cylinder;
    render2.shapes().rect_left_inv_arrow = rect_left_inv_arrow;
    render2.shapes().lean_right = lean_right;
    render2.shapes().lean_left = lean_left;
    render2.shapes().trapezoid = trapezoid;
    render2.shapes().inv_trapezoid = inv_trapezoid;
    render2.shapes().rect_right_inv_arrow = rect_right_inv_arrow;
  }
  function addToRenderV2(addShape) {
    addShape({ question });
    addShape({ hexagon });
    addShape({ stadium });
    addShape({ subroutine });
    addShape({ cylinder });
    addShape({ rect_left_inv_arrow });
    addShape({ lean_right });
    addShape({ lean_left });
    addShape({ trapezoid });
    addShape({ inv_trapezoid });
    addShape({ rect_right_inv_arrow });
  }
  function insertPolygonShape(parent, w2, h, points) {
    return parent.insert("polygon", ":first-child").attr(
      "points",
      points.map(function(d) {
        return d.x + "," + d.y;
      }).join(" ")
    ).attr("transform", "translate(" + -w2 / 2 + "," + h / 2 + ")");
  }
  const flowChartShapes = {
    addToRender,
    addToRenderV2
  };
  const conf$8 = {};
  const setConf$7 = function(cnf) {
    const keys = Object.keys(cnf);
    for (let i = 0; i < keys.length; i++) {
      conf$8[keys[i]] = cnf[keys[i]];
    }
  };
  const addVertices$1 = function(vert, g, svgId, root2, _doc, diagObj) {
    const svg2 = !root2 ? select(`[id="${svgId}"]`) : root2.select(`[id="${svgId}"]`);
    const doc = !_doc ? document : _doc;
    const keys = Object.keys(vert);
    keys.forEach(function(id2) {
      const vertex = vert[id2];
      let classStr = "default";
      if (vertex.classes.length > 0) {
        classStr = vertex.classes.join(" ");
      }
      const styles = getStylesFromArray(vertex.styles);
      let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
      let vertexNode;
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        const node2 = {
          label: vertexText.replace(
            /fa[lrsb]?:fa-[\w-]+/g,
            (s2) => `<i class='${s2.replace(":", " ")}'></i>`
          )
        };
        vertexNode = addHtmlLabel_1(svg2, node2).node();
        vertexNode.parentNode.removeChild(vertexNode);
      } else {
        const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
        svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
        const rows = vertexText.split(common.lineBreakRegex);
        for (let j = 0; j < rows.length; j++) {
          const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
          tspan.setAttribute("dy", "1em");
          tspan.setAttribute("x", "1");
          tspan.textContent = rows[j];
          svgLabel.appendChild(tspan);
        }
        vertexNode = svgLabel;
      }
      let radious = 0;
      let _shape = "";
      switch (vertex.type) {
        case "round":
          radious = 5;
          _shape = "rect";
          break;
        case "square":
          _shape = "rect";
          break;
        case "diamond":
          _shape = "question";
          break;
        case "hexagon":
          _shape = "hexagon";
          break;
        case "odd":
          _shape = "rect_left_inv_arrow";
          break;
        case "lean_right":
          _shape = "lean_right";
          break;
        case "lean_left":
          _shape = "lean_left";
          break;
        case "trapezoid":
          _shape = "trapezoid";
          break;
        case "inv_trapezoid":
          _shape = "inv_trapezoid";
          break;
        case "odd_right":
          _shape = "rect_left_inv_arrow";
          break;
        case "circle":
          _shape = "circle";
          break;
        case "ellipse":
          _shape = "ellipse";
          break;
        case "stadium":
          _shape = "stadium";
          break;
        case "subroutine":
          _shape = "subroutine";
          break;
        case "cylinder":
          _shape = "cylinder";
          break;
        case "group":
          _shape = "rect";
          break;
        default:
          _shape = "rect";
      }
      log$3.warn("Adding node", vertex.id, vertex.domId);
      g.setNode(diagObj.db.lookUpDomId(vertex.id), {
        labelType: "svg",
        labelStyle: styles.labelStyle,
        shape: _shape,
        label: vertexNode,
        rx: radious,
        ry: radious,
        class: classStr,
        style: styles.style,
        id: diagObj.db.lookUpDomId(vertex.id)
      });
    });
  };
  const addEdges$1 = function(edges2, g, diagObj) {
    let cnt2 = 0;
    let defaultStyle2;
    let defaultLabelStyle;
    if (typeof edges2.defaultStyle !== "undefined") {
      const defaultStyles = getStylesFromArray(edges2.defaultStyle);
      defaultStyle2 = defaultStyles.style;
      defaultLabelStyle = defaultStyles.labelStyle;
    }
    edges2.forEach(function(edge) {
      cnt2++;
      var linkId = "L-" + edge.start + "-" + edge.end;
      var linkNameStart = "LS-" + edge.start;
      var linkNameEnd = "LE-" + edge.end;
      const edgeData = {};
      if (edge.type === "arrow_open") {
        edgeData.arrowhead = "none";
      } else {
        edgeData.arrowhead = "normal";
      }
      let style = "";
      let labelStyle = "";
      if (typeof edge.style !== "undefined") {
        const styles = getStylesFromArray(edge.style);
        style = styles.style;
        labelStyle = styles.labelStyle;
      } else {
        switch (edge.stroke) {
          case "normal":
            style = "fill:none";
            if (typeof defaultStyle2 !== "undefined") {
              style = defaultStyle2;
            }
            if (typeof defaultLabelStyle !== "undefined") {
              labelStyle = defaultLabelStyle;
            }
            break;
          case "dotted":
            style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
            break;
          case "thick":
            style = " stroke-width: 3.5px;fill:none";
            break;
        }
      }
      edgeData.style = style;
      edgeData.labelStyle = labelStyle;
      if (typeof edge.interpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);
      } else if (typeof edges2.defaultInterpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear);
      } else {
        edgeData.curve = interpolateToCurve(conf$8.curve, curveLinear);
      }
      if (typeof edge.text === "undefined") {
        if (typeof edge.style !== "undefined") {
          edgeData.arrowheadStyle = "fill: #333";
        }
      } else {
        edgeData.arrowheadStyle = "fill: #333";
        edgeData.labelpos = "c";
        if (evaluate(getConfig$1().flowchart.htmlLabels)) {
          edgeData.labelType = "html";
          edgeData.label = `<span id="L-${linkId}" class="edgeLabel L-${linkNameStart}' L-${linkNameEnd}" style="${edgeData.labelStyle}">${edge.text.replace(
            /fa[lrsb]?:fa-[\w-]+/g,
            (s2) => `<i class='${s2.replace(":", " ")}'></i>`
          )}</span>`;
        } else {
          edgeData.labelType = "text";
          edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
          if (typeof edge.style === "undefined") {
            edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
          }
          edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
        }
      }
      edgeData.id = linkId;
      edgeData.class = linkNameStart + " " + linkNameEnd;
      edgeData.minlen = edge.length || 1;
      g.setEdge(diagObj.db.lookUpDomId(edge.start), diagObj.db.lookUpDomId(edge.end), edgeData, cnt2);
    });
  };
  const getClasses$3 = function(text2, diagObj) {
    log$3.info("Extracting classes");
    diagObj.db.clear();
    try {
      diagObj.parse(text2);
      return diagObj.db.getClasses();
    } catch (e) {
      return;
    }
  };
  const draw$a = function(text2, id2, _version, diagObj) {
    log$3.info("Drawing flowchart");
    diagObj.db.clear();
    const { securityLevel, flowchart: conf2 } = getConfig$1();
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    try {
      diagObj.parser.parse(text2);
    } catch (err) {
      log$3.debug("Parsing failed");
    }
    let dir = diagObj.db.getDirection();
    if (typeof dir === "undefined") {
      dir = "TD";
    }
    const nodeSpacing = conf2.nodeSpacing || 50;
    const rankSpacing = conf2.rankSpacing || 50;
    const g = new graphlib$1.Graph({
      multigraph: true,
      compound: true
    }).setGraph({
      rankdir: dir,
      nodesep: nodeSpacing,
      ranksep: rankSpacing,
      marginx: 8,
      marginy: 8
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    let subG;
    const subGraphs2 = diagObj.db.getSubGraphs();
    for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
      subG = subGraphs2[i2];
      diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes);
    }
    const vert = diagObj.db.getVertices();
    log$3.warn("Get vertices", vert);
    const edges2 = diagObj.db.getEdges();
    let i = 0;
    for (i = subGraphs2.length - 1; i >= 0; i--) {
      subG = subGraphs2[i];
      selectAll("cluster").append("text");
      for (let j = 0; j < subG.nodes.length; j++) {
        log$3.warn(
          "Setting subgraph",
          subG.nodes[j],
          diagObj.db.lookUpDomId(subG.nodes[j]),
          diagObj.db.lookUpDomId(subG.id)
        );
        g.setParent(diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));
      }
    }
    addVertices$1(vert, g, id2, root2, doc, diagObj);
    addEdges$1(edges2, g, diagObj);
    const Render = dagreD3.render;
    const render2 = new Render();
    flowChartShapes.addToRender(render2);
    render2.arrows().none = function normal2(parent, id3, edge, type2) {
      const marker = parent.append("marker").attr("id", id3).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
      const path2 = marker.append("path").attr("d", "M 0 0 L 0 0 L 0 0 z");
      dagreD3.util.applyStyle(path2, edge[type2 + "Style"]);
    };
    render2.arrows().normal = function normal2(parent, id3) {
      const marker = parent.append("marker").attr("id", id3).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
      marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowheadPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    };
    const svg2 = root2.select(`[id="${id2}"]`);
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
    const element = root2.select("#" + id2 + " g");
    render2(element, g);
    element.selectAll("g.node").attr("title", function() {
      return diagObj.db.getTooltip(this.id);
    });
    diagObj.db.indexNodes("subGraph" + i);
    for (i = 0; i < subGraphs2.length; i++) {
      subG = subGraphs2[i];
      if (subG.title !== "undefined") {
        const clusterRects = doc.querySelectorAll(
          "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"] rect'
        );
        const clusterEl = doc.querySelectorAll(
          "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"]'
        );
        const xPos = clusterRects[0].x.baseVal.value;
        const yPos = clusterRects[0].y.baseVal.value;
        const _width = clusterRects[0].width.baseVal.value;
        const cluster2 = select(clusterEl[0]);
        const te = cluster2.select(".label");
        te.attr("transform", `translate(${xPos + _width / 2}, ${yPos + 14})`);
        te.attr("id", id2 + "Text");
        for (let j = 0; j < subG.classes.length; j++) {
          clusterEl[0].classList.add(subG.classes[j]);
        }
      }
    }
    if (!conf2.htmlLabels) {
      const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
      for (let k2 = 0; k2 < labels.length; k2++) {
        const label = labels[k2];
        const dim = label.getBBox();
        const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect2.setAttribute("rx", 0);
        rect2.setAttribute("ry", 0);
        rect2.setAttribute("width", dim.width);
        rect2.setAttribute("height", dim.height);
        label.insertBefore(rect2, label.firstChild);
      }
    }
    setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
    const keys = Object.keys(vert);
    keys.forEach(function(key) {
      const vertex = vert[key];
      if (vertex.link) {
        const node2 = root2.select("#" + id2 + ' [id="' + diagObj.db.lookUpDomId(key) + '"]');
        if (node2) {
          const link2 = doc.createElementNS("http://www.w3.org/2000/svg", "a");
          link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
          link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
          link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
          if (securityLevel === "sandbox") {
            link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
          } else if (vertex.linkTarget) {
            link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
          }
          const linkNode = node2.insert(function() {
            return link2;
          }, ":first-child");
          const shape = node2.select(".label-container");
          if (shape) {
            linkNode.append(function() {
              return shape.node();
            });
          }
          const label = node2.select(".label");
          if (label) {
            linkNode.append(function() {
              return label.node();
            });
          }
        }
      }
    });
  };
  const flowRenderer = {
    setConf: setConf$7,
    addVertices: addVertices$1,
    addEdges: addEdges$1,
    getClasses: getClasses$3,
    draw: draw$a
  };
  const conf$7 = {};
  const setConf$6 = function(cnf) {
    const keys = Object.keys(cnf);
    for (let i = 0; i < keys.length; i++) {
      conf$7[keys[i]] = cnf[keys[i]];
    }
  };
  const addVertices = function(vert, g, svgId, root2, doc, diagObj) {
    const svg2 = root2.select(`[id="${svgId}"]`);
    const keys = Object.keys(vert);
    keys.forEach(function(id2) {
      const vertex = vert[id2];
      let classStr = "default";
      if (vertex.classes.length > 0) {
        classStr = vertex.classes.join(" ");
      }
      const styles = getStylesFromArray(vertex.styles);
      let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
      let vertexNode;
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        const node2 = {
          label: vertexText.replace(
            /fa[lrsb]?:fa-[\w-]+/g,
            (s2) => `<i class='${s2.replace(":", " ")}'></i>`
          )
        };
        vertexNode = addHtmlLabel_1(svg2, node2).node();
        vertexNode.parentNode.removeChild(vertexNode);
      } else {
        const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
        svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
        const rows = vertexText.split(common.lineBreakRegex);
        for (let j = 0; j < rows.length; j++) {
          const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
          tspan.setAttribute("dy", "1em");
          tspan.setAttribute("x", "1");
          tspan.textContent = rows[j];
          svgLabel.appendChild(tspan);
        }
        vertexNode = svgLabel;
      }
      let radious = 0;
      let _shape = "";
      switch (vertex.type) {
        case "round":
          radious = 5;
          _shape = "rect";
          break;
        case "square":
          _shape = "rect";
          break;
        case "diamond":
          _shape = "question";
          break;
        case "hexagon":
          _shape = "hexagon";
          break;
        case "odd":
          _shape = "rect_left_inv_arrow";
          break;
        case "lean_right":
          _shape = "lean_right";
          break;
        case "lean_left":
          _shape = "lean_left";
          break;
        case "trapezoid":
          _shape = "trapezoid";
          break;
        case "inv_trapezoid":
          _shape = "inv_trapezoid";
          break;
        case "odd_right":
          _shape = "rect_left_inv_arrow";
          break;
        case "circle":
          _shape = "circle";
          break;
        case "ellipse":
          _shape = "ellipse";
          break;
        case "stadium":
          _shape = "stadium";
          break;
        case "subroutine":
          _shape = "subroutine";
          break;
        case "cylinder":
          _shape = "cylinder";
          break;
        case "group":
          _shape = "rect";
          break;
        case "doublecircle":
          _shape = "doublecircle";
          break;
        default:
          _shape = "rect";
      }
      g.setNode(vertex.id, {
        labelStyle: styles.labelStyle,
        shape: _shape,
        labelText: vertexText,
        rx: radious,
        ry: radious,
        class: classStr,
        style: styles.style,
        id: vertex.id,
        link: vertex.link,
        linkTarget: vertex.linkTarget,
        tooltip: diagObj.db.getTooltip(vertex.id) || "",
        domId: diagObj.db.lookUpDomId(vertex.id),
        haveCallback: vertex.haveCallback,
        width: vertex.type === "group" ? 500 : void 0,
        dir: vertex.dir,
        type: vertex.type,
        props: vertex.props,
        padding: getConfig$1().flowchart.padding
      });
      log$3.info("setNode", {
        labelStyle: styles.labelStyle,
        shape: _shape,
        labelText: vertexText,
        rx: radious,
        ry: radious,
        class: classStr,
        style: styles.style,
        id: vertex.id,
        domId: diagObj.db.lookUpDomId(vertex.id),
        width: vertex.type === "group" ? 500 : void 0,
        type: vertex.type,
        dir: vertex.dir,
        props: vertex.props,
        padding: getConfig$1().flowchart.padding
      });
    });
  };
  const addEdges = function(edges2, g, diagObj) {
    log$3.info("abc78 edges = ", edges2);
    let cnt2 = 0;
    let linkIdCnt = {};
    let defaultStyle2;
    let defaultLabelStyle;
    if (typeof edges2.defaultStyle !== "undefined") {
      const defaultStyles = getStylesFromArray(edges2.defaultStyle);
      defaultStyle2 = defaultStyles.style;
      defaultLabelStyle = defaultStyles.labelStyle;
    }
    edges2.forEach(function(edge) {
      cnt2++;
      var linkIdBase = "L-" + edge.start + "-" + edge.end;
      if (typeof linkIdCnt[linkIdBase] === "undefined") {
        linkIdCnt[linkIdBase] = 0;
        log$3.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
      } else {
        linkIdCnt[linkIdBase]++;
        log$3.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
      }
      let linkId = linkIdBase + "-" + linkIdCnt[linkIdBase];
      log$3.info("abc78 new link id to be used is", linkIdBase, linkId, linkIdCnt[linkIdBase]);
      var linkNameStart = "LS-" + edge.start;
      var linkNameEnd = "LE-" + edge.end;
      const edgeData = { style: "", labelStyle: "" };
      edgeData.minlen = edge.length || 1;
      if (edge.type === "arrow_open") {
        edgeData.arrowhead = "none";
      } else {
        edgeData.arrowhead = "normal";
      }
      edgeData.arrowTypeStart = "arrow_open";
      edgeData.arrowTypeEnd = "arrow_open";
      switch (edge.type) {
        case "double_arrow_cross":
          edgeData.arrowTypeStart = "arrow_cross";
        case "arrow_cross":
          edgeData.arrowTypeEnd = "arrow_cross";
          break;
        case "double_arrow_point":
          edgeData.arrowTypeStart = "arrow_point";
        case "arrow_point":
          edgeData.arrowTypeEnd = "arrow_point";
          break;
        case "double_arrow_circle":
          edgeData.arrowTypeStart = "arrow_circle";
        case "arrow_circle":
          edgeData.arrowTypeEnd = "arrow_circle";
          break;
      }
      let style = "";
      let labelStyle = "";
      switch (edge.stroke) {
        case "normal":
          style = "fill:none;";
          if (typeof defaultStyle2 !== "undefined") {
            style = defaultStyle2;
          }
          if (typeof defaultLabelStyle !== "undefined") {
            labelStyle = defaultLabelStyle;
          }
          edgeData.thickness = "normal";
          edgeData.pattern = "solid";
          break;
        case "dotted":
          edgeData.thickness = "normal";
          edgeData.pattern = "dotted";
          edgeData.style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
          break;
        case "thick":
          edgeData.thickness = "thick";
          edgeData.pattern = "solid";
          edgeData.style = "stroke-width: 3.5px;fill:none;";
          break;
        case "invisible":
          edgeData.thickness = "invisible";
          edgeData.pattern = "solid";
          edgeData.style = "stroke-width: 0;fill:none;";
          break;
      }
      if (typeof edge.style !== "undefined") {
        const styles = getStylesFromArray(edge.style);
        style = styles.style;
        labelStyle = styles.labelStyle;
      }
      edgeData.style = edgeData.style += style;
      edgeData.labelStyle = edgeData.labelStyle += labelStyle;
      if (typeof edge.interpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear);
      } else if (typeof edges2.defaultInterpolate !== "undefined") {
        edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear);
      } else {
        edgeData.curve = interpolateToCurve(conf$7.curve, curveLinear);
      }
      if (typeof edge.text === "undefined") {
        if (typeof edge.style !== "undefined") {
          edgeData.arrowheadStyle = "fill: #333";
        }
      } else {
        edgeData.arrowheadStyle = "fill: #333";
        edgeData.labelpos = "c";
      }
      edgeData.labelType = "text";
      edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
      if (typeof edge.style === "undefined") {
        edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none;";
      }
      edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
      edgeData.id = linkId;
      edgeData.classes = "flowchart-link " + linkNameStart + " " + linkNameEnd;
      g.setEdge(edge.start, edge.end, edgeData, cnt2);
    });
  };
  const getClasses$2 = function(text2, diagObj) {
    log$3.info("Extracting classes");
    diagObj.db.clear();
    try {
      diagObj.parse(text2);
      return diagObj.db.getClasses();
    } catch (e) {
      return;
    }
  };
  const draw$9 = function(text2, id2, _version, diagObj) {
    log$3.info("Drawing flowchart");
    diagObj.db.clear();
    flowDb.setGen("gen-2");
    diagObj.parser.parse(text2);
    let dir = diagObj.db.getDirection();
    if (typeof dir === "undefined") {
      dir = "TD";
    }
    const { securityLevel, flowchart: conf2 } = getConfig$1();
    const nodeSpacing = conf2.nodeSpacing || 50;
    const rankSpacing = conf2.rankSpacing || 50;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    const g = new graphlib$1.Graph({
      multigraph: true,
      compound: true
    }).setGraph({
      rankdir: dir,
      nodesep: nodeSpacing,
      ranksep: rankSpacing,
      marginx: 0,
      marginy: 0
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    let subG;
    const subGraphs2 = diagObj.db.getSubGraphs();
    log$3.info("Subgraphs - ", subGraphs2);
    for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
      subG = subGraphs2[i2];
      log$3.info("Subgraph - ", subG);
      diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes, subG.dir);
    }
    const vert = diagObj.db.getVertices();
    const edges2 = diagObj.db.getEdges();
    log$3.info(edges2);
    let i = 0;
    for (i = subGraphs2.length - 1; i >= 0; i--) {
      subG = subGraphs2[i];
      selectAll("cluster").append("text");
      for (let j = 0; j < subG.nodes.length; j++) {
        log$3.info("Setting up subgraphs", subG.nodes[j], subG.id);
        g.setParent(subG.nodes[j], subG.id);
      }
    }
    addVertices(vert, g, id2, root2, doc, diagObj);
    addEdges(edges2, g);
    const svg2 = root2.select(`[id="${id2}"]`);
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
    const element = root2.select("#" + id2 + " g");
    render$2(element, g, ["point", "circle", "cross"], "flowchart", id2);
    setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
    diagObj.db.indexNodes("subGraph" + i);
    if (!conf2.htmlLabels) {
      const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
      for (let k2 = 0; k2 < labels.length; k2++) {
        const label = labels[k2];
        const dim = label.getBBox();
        const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect2.setAttribute("rx", 0);
        rect2.setAttribute("ry", 0);
        rect2.setAttribute("width", dim.width);
        rect2.setAttribute("height", dim.height);
        label.insertBefore(rect2, label.firstChild);
      }
    }
    const keys = Object.keys(vert);
    keys.forEach(function(key) {
      const vertex = vert[key];
      if (vertex.link) {
        const node2 = select("#" + id2 + ' [id="' + key + '"]');
        if (node2) {
          const link2 = doc.createElementNS("http://www.w3.org/2000/svg", "a");
          link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
          link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
          link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
          if (securityLevel === "sandbox") {
            link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
          } else if (vertex.linkTarget) {
            link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
          }
          const linkNode = node2.insert(function() {
            return link2;
          }, ":first-child");
          const shape = node2.select(".label-container");
          if (shape) {
            linkNode.append(function() {
              return shape.node();
            });
          }
          const label = node2.select(".label");
          if (label) {
            linkNode.append(function() {
              return label.node();
            });
          }
        }
      }
    });
  };
  const flowRendererV2 = {
    setConf: setConf$6,
    addVertices,
    addEdges,
    getClasses: getClasses$2,
    draw: draw$9
  };
  var parser$6 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 24], $Vd = [1, 25], $Ve = [1, 26], $Vf = [1, 28], $Vg = [1, 30], $Vh = [1, 33], $Vi = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "directive": 4, "gantt": 5, "document": 6, "EOF": 7, "line": 8, "SPACE": 9, "statement": 10, "NL": 11, "dateFormat": 12, "inclusiveEndDates": 13, "topAxis": 14, "axisFormat": 15, "excludes": 16, "includes": 17, "todayMarker": 18, "title": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "clickStatement": 26, "taskTxt": 27, "taskData": 28, "openDirective": 29, "typeDirective": 30, "closeDirective": 31, ":": 32, "argDirective": 33, "click": 34, "callbackname": 35, "callbackargs": 36, "href": 37, "clickStatementDebug": 38, "open_directive": 39, "type_directive": 40, "arg_directive": 41, "close_directive": 42, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 5: "gantt", 7: "EOF", 9: "SPACE", 11: "NL", 12: "dateFormat", 13: "inclusiveEndDates", 14: "topAxis", 15: "axisFormat", 16: "excludes", 17: "includes", 18: "todayMarker", 19: "title", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "taskTxt", 28: "taskData", 32: ":", 34: "click", 35: "callbackname", 36: "callbackargs", 37: "href", 39: "open_directive", 40: "type_directive", 41: "arg_directive", 42: "close_directive" },
      productions_: [0, [3, 2], [3, 3], [6, 0], [6, 2], [8, 2], [8, 1], [8, 1], [8, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 2], [10, 1], [4, 4], [4, 6], [26, 2], [26, 3], [26, 3], [26, 4], [26, 3], [26, 4], [26, 2], [38, 2], [38, 3], [38, 3], [38, 4], [38, 3], [38, 4], [38, 2], [29, 1], [30, 1], [33, 1], [31, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 2:
            return $$[$0 - 1];
          case 3:
            this.$ = [];
            break;
          case 4:
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
            break;
          case 5:
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
          case 8:
            this.$ = [];
            break;
          case 9:
            yy.setDateFormat($$[$0].substr(11));
            this.$ = $$[$0].substr(11);
            break;
          case 10:
            yy.enableInclusiveEndDates();
            this.$ = $$[$0].substr(18);
            break;
          case 11:
            yy.TopAxis();
            this.$ = $$[$0].substr(8);
            break;
          case 12:
            yy.setAxisFormat($$[$0].substr(11));
            this.$ = $$[$0].substr(11);
            break;
          case 13:
            yy.setExcludes($$[$0].substr(9));
            this.$ = $$[$0].substr(9);
            break;
          case 14:
            yy.setIncludes($$[$0].substr(9));
            this.$ = $$[$0].substr(9);
            break;
          case 15:
            yy.setTodayMarker($$[$0].substr(12));
            this.$ = $$[$0].substr(12);
            break;
          case 16:
            yy.setDiagramTitle($$[$0].substr(6));
            this.$ = $$[$0].substr(6);
            break;
          case 17:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 18:
          case 19:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 20:
            yy.addSection($$[$0].substr(8));
            this.$ = $$[$0].substr(8);
            break;
          case 22:
            yy.addTask($$[$0 - 1], $$[$0]);
            this.$ = "task";
            break;
          case 26:
            this.$ = $$[$0 - 1];
            yy.setClickEvent($$[$0 - 1], $$[$0], null);
            break;
          case 27:
            this.$ = $$[$0 - 2];
            yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break;
          case 28:
            this.$ = $$[$0 - 2];
            yy.setClickEvent($$[$0 - 2], $$[$0 - 1], null);
            yy.setLink($$[$0 - 2], $$[$0]);
            break;
          case 29:
            this.$ = $$[$0 - 3];
            yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
            yy.setLink($$[$0 - 3], $$[$0]);
            break;
          case 30:
            this.$ = $$[$0 - 2];
            yy.setClickEvent($$[$0 - 2], $$[$0], null);
            yy.setLink($$[$0 - 2], $$[$0 - 1]);
            break;
          case 31:
            this.$ = $$[$0 - 3];
            yy.setClickEvent($$[$0 - 3], $$[$0 - 1], $$[$0]);
            yy.setLink($$[$0 - 3], $$[$0 - 2]);
            break;
          case 32:
            this.$ = $$[$0 - 1];
            yy.setLink($$[$0 - 1], $$[$0]);
            break;
          case 33:
          case 39:
            this.$ = $$[$0 - 1] + " " + $$[$0];
            break;
          case 34:
          case 35:
          case 37:
            this.$ = $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
            break;
          case 36:
          case 38:
            this.$ = $$[$0 - 3] + " " + $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
            break;
          case 40:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 41:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 42:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 43:
            yy.parseDirective("}%%", "close_directive", "gantt");
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: $V0, 29: 4, 39: $V1 }, { 1: [3] }, { 3: 6, 4: 2, 5: $V0, 29: 4, 39: $V1 }, o($V2, [2, 3], { 6: 7 }), { 30: 8, 40: [1, 9] }, { 40: [2, 40] }, { 1: [2, 1] }, { 4: 29, 7: [1, 10], 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, { 31: 31, 32: [1, 32], 42: $Vh }, o([32, 42], [2, 41]), o($V2, [2, 8], { 1: [2, 2] }), o($V2, [2, 4]), { 4: 29, 10: 34, 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 9]), o($V2, [2, 10]), o($V2, [2, 11]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 14]), o($V2, [2, 15]), o($V2, [2, 16]), { 21: [1, 35] }, { 23: [1, 36] }, o($V2, [2, 19]), o($V2, [2, 20]), o($V2, [2, 21]), { 28: [1, 37] }, o($V2, [2, 23]), { 35: [1, 38], 37: [1, 39] }, { 11: [1, 40] }, { 33: 41, 41: [1, 42] }, { 11: [2, 43] }, o($V2, [2, 5]), o($V2, [2, 17]), o($V2, [2, 18]), o($V2, [2, 22]), o($V2, [2, 26], { 36: [1, 43], 37: [1, 44] }), o($V2, [2, 32], { 35: [1, 45] }), o($Vi, [2, 24]), { 31: 46, 42: $Vh }, { 42: [2, 42] }, o($V2, [2, 27], { 37: [1, 47] }), o($V2, [2, 28]), o($V2, [2, 30], { 36: [1, 48] }), { 11: [1, 49] }, o($V2, [2, 29]), o($V2, [2, 31]), o($Vi, [2, 25])],
      defaultActions: { 5: [2, 40], 6: [2, 1], 33: [2, 43], 42: [2, 42] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 39;
            case 1:
              this.begin("type_directive");
              return 40;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 32;
            case 3:
              this.popState();
              this.popState();
              return 42;
            case 4:
              return 41;
            case 5:
              this.begin("acc_title");
              return 20;
            case 6:
              this.popState();
              return "acc_title_value";
            case 7:
              this.begin("acc_descr");
              return 22;
            case 8:
              this.popState();
              return "acc_descr_value";
            case 9:
              this.begin("acc_descr_multiline");
              break;
            case 10:
              this.popState();
              break;
            case 11:
              return "acc_descr_multiline_value";
            case 12:
              break;
            case 13:
              break;
            case 14:
              break;
            case 15:
              return 11;
            case 16:
              break;
            case 17:
              break;
            case 18:
              break;
            case 19:
              this.begin("href");
              break;
            case 20:
              this.popState();
              break;
            case 21:
              return 37;
            case 22:
              this.begin("callbackname");
              break;
            case 23:
              this.popState();
              break;
            case 24:
              this.popState();
              this.begin("callbackargs");
              break;
            case 25:
              return 35;
            case 26:
              this.popState();
              break;
            case 27:
              return 36;
            case 28:
              this.begin("click");
              break;
            case 29:
              this.popState();
              break;
            case 30:
              return 34;
            case 31:
              return 5;
            case 32:
              return 12;
            case 33:
              return 13;
            case 34:
              return 14;
            case 35:
              return 15;
            case 36:
              return 17;
            case 37:
              return 16;
            case 38:
              return 18;
            case 39:
              return "date";
            case 40:
              return 19;
            case 41:
              return "accDescription";
            case 42:
              return 25;
            case 43:
              return 27;
            case 44:
              return 28;
            case 45:
              return 32;
            case 46:
              return 7;
            case 47:
              return "INVALID";
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [26, 27], "inclusive": false }, "callbackname": { "rules": [23, 24, 25], "inclusive": false }, "href": { "rules": [20, 21], "inclusive": false }, "click": { "rules": [29, 30], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 22, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$6.parser = parser$6;
  const ganttDetector = (txt) => {
    return txt.match(/^\s*gantt/) !== null;
  };
  let dateFormat = "";
  let axisFormat = "";
  let todayMarker = "";
  let includes = [];
  let excludes = [];
  let links = {};
  let sections$2 = [];
  let tasks$1 = [];
  let currentSection$1 = "";
  const tags = ["active", "done", "crit", "milestone"];
  let funs = [];
  let inclusiveEndDates = false;
  let topAxis = false;
  let lastOrder = 0;
  const parseDirective$6 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const clear$5 = function() {
    sections$2 = [];
    tasks$1 = [];
    currentSection$1 = "";
    funs = [];
    taskCnt = 0;
    lastTask = void 0;
    lastTaskID = void 0;
    rawTasks$1 = [];
    dateFormat = "";
    axisFormat = "";
    todayMarker = "";
    includes = [];
    excludes = [];
    inclusiveEndDates = false;
    topAxis = false;
    lastOrder = 0;
    links = {};
    clear$g();
  };
  const setAxisFormat = function(txt) {
    axisFormat = txt;
  };
  const getAxisFormat = function() {
    return axisFormat;
  };
  const setTodayMarker = function(txt) {
    todayMarker = txt;
  };
  const getTodayMarker = function() {
    return todayMarker;
  };
  const setDateFormat = function(txt) {
    dateFormat = txt;
  };
  const enableInclusiveEndDates = function() {
    inclusiveEndDates = true;
  };
  const endDatesAreInclusive = function() {
    return inclusiveEndDates;
  };
  const enableTopAxis = function() {
    topAxis = true;
  };
  const topAxisEnabled = function() {
    return topAxis;
  };
  const getDateFormat = function() {
    return dateFormat;
  };
  const setIncludes = function(txt) {
    includes = txt.toLowerCase().split(/[\s,]+/);
  };
  const getIncludes = function() {
    return includes;
  };
  const setExcludes = function(txt) {
    excludes = txt.toLowerCase().split(/[\s,]+/);
  };
  const getExcludes = function() {
    return excludes;
  };
  const getLinks = function() {
    return links;
  };
  const addSection$2 = function(txt) {
    currentSection$1 = txt;
    sections$2.push(txt);
  };
  const getSections$2 = function() {
    return sections$2;
  };
  const getTasks$1 = function() {
    let allItemsPricessed = compileTasks$1();
    const maxDepth2 = 10;
    let iterationCount = 0;
    while (!allItemsPricessed && iterationCount < maxDepth2) {
      allItemsPricessed = compileTasks$1();
      iterationCount++;
    }
    tasks$1 = rawTasks$1;
    return tasks$1;
  };
  const isInvalidDate = function(date2, dateFormat2, excludes2, includes2) {
    if (includes2.indexOf(date2.format(dateFormat2.trim())) >= 0) {
      return false;
    }
    if (date2.isoWeekday() >= 6 && excludes2.indexOf("weekends") >= 0) {
      return true;
    }
    if (excludes2.indexOf(date2.format("dddd").toLowerCase()) >= 0) {
      return true;
    }
    return excludes2.indexOf(date2.format(dateFormat2.trim())) >= 0;
  };
  const checkTaskDates = function(task, dateFormat2, excludes2, includes2) {
    if (!excludes2.length || task.manualEndTime)
      return;
    let startTime = moment(task.startTime, dateFormat2, true);
    startTime.add(1, "d");
    let endTime = moment(task.endTime, dateFormat2, true);
    let renderEndTime = fixTaskDates(startTime, endTime, dateFormat2, excludes2, includes2);
    task.endTime = endTime.toDate();
    task.renderEndTime = renderEndTime;
  };
  const fixTaskDates = function(startTime, endTime, dateFormat2, excludes2, includes2) {
    let invalid = false;
    let renderEndTime = null;
    while (startTime <= endTime) {
      if (!invalid) {
        renderEndTime = endTime.toDate();
      }
      invalid = isInvalidDate(startTime, dateFormat2, excludes2, includes2);
      if (invalid) {
        endTime.add(1, "d");
      }
      startTime.add(1, "d");
    }
    return renderEndTime;
  };
  const getStartDate = function(prevTime, dateFormat2, str) {
    str = str.trim();
    const re2 = /^after\s+([\d\w- ]+)/;
    const afterStatement = re2.exec(str.trim());
    if (afterStatement !== null) {
      let latestEndingTask = null;
      afterStatement[1].split(" ").forEach(function(id2) {
        let task = findTaskById(id2);
        if (typeof task !== "undefined") {
          if (!latestEndingTask) {
            latestEndingTask = task;
          } else {
            if (task.endTime > latestEndingTask.endTime) {
              latestEndingTask = task;
            }
          }
        }
      });
      if (!latestEndingTask) {
        const dt = new Date();
        dt.setHours(0, 0, 0, 0);
        return dt;
      } else {
        return latestEndingTask.endTime;
      }
    }
    let mDate = moment(str, dateFormat2.trim(), true);
    if (mDate.isValid()) {
      return mDate.toDate();
    } else {
      log$3.debug("Invalid date:" + str);
      log$3.debug("With date format:" + dateFormat2.trim());
      const d = new Date(str);
      if (typeof d === "undefined" || isNaN(d.getTime())) {
        throw new Error("Invalid date:" + str);
      }
      return d;
    }
  };
  const parseDuration = function(str) {
    const statement = /^(\d+(?:\.\d+)?)([yMwdhms]|ms)$/.exec(str.trim());
    if (statement !== null) {
      return moment.duration(Number.parseFloat(statement[1]), statement[2]);
    }
    return moment.duration.invalid();
  };
  const getEndDate = function(prevTime, dateFormat2, str, inclusive) {
    inclusive = inclusive || false;
    str = str.trim();
    let mDate = moment(str, dateFormat2.trim(), true);
    if (mDate.isValid()) {
      if (inclusive) {
        mDate.add(1, "d");
      }
      return mDate.toDate();
    }
    const endTime = moment(prevTime);
    const duration = parseDuration(str);
    if (duration.isValid()) {
      endTime.add(duration);
    }
    return endTime.toDate();
  };
  let taskCnt = 0;
  const parseId = function(idStr) {
    if (typeof idStr === "undefined") {
      taskCnt = taskCnt + 1;
      return "task" + taskCnt;
    }
    return idStr;
  };
  const compileData = function(prevTask, dataStr) {
    let ds;
    if (dataStr.substr(0, 1) === ":") {
      ds = dataStr.substr(1, dataStr.length);
    } else {
      ds = dataStr;
    }
    const data = ds.split(",");
    const task = {};
    getTaskTags(data, task, tags);
    for (let i = 0; i < data.length; i++) {
      data[i] = data[i].trim();
    }
    let endTimeData = "";
    switch (data.length) {
      case 1:
        task.id = parseId();
        task.startTime = prevTask.endTime;
        endTimeData = data[0];
        break;
      case 2:
        task.id = parseId();
        task.startTime = getStartDate(void 0, dateFormat, data[0]);
        endTimeData = data[1];
        break;
      case 3:
        task.id = parseId(data[0]);
        task.startTime = getStartDate(void 0, dateFormat, data[1]);
        endTimeData = data[2];
        break;
    }
    if (endTimeData) {
      task.endTime = getEndDate(task.startTime, dateFormat, endTimeData, inclusiveEndDates);
      task.manualEndTime = moment(endTimeData, "YYYY-MM-DD", true).isValid();
      checkTaskDates(task, dateFormat, excludes, includes);
    }
    return task;
  };
  const parseData = function(prevTaskId, dataStr) {
    let ds;
    if (dataStr.substr(0, 1) === ":") {
      ds = dataStr.substr(1, dataStr.length);
    } else {
      ds = dataStr;
    }
    const data = ds.split(",");
    const task = {};
    getTaskTags(data, task, tags);
    for (let i = 0; i < data.length; i++) {
      data[i] = data[i].trim();
    }
    switch (data.length) {
      case 1:
        task.id = parseId();
        task.startTime = {
          type: "prevTaskEnd",
          id: prevTaskId
        };
        task.endTime = {
          data: data[0]
        };
        break;
      case 2:
        task.id = parseId();
        task.startTime = {
          type: "getStartDate",
          startData: data[0]
        };
        task.endTime = {
          data: data[1]
        };
        break;
      case 3:
        task.id = parseId(data[0]);
        task.startTime = {
          type: "getStartDate",
          startData: data[1]
        };
        task.endTime = {
          data: data[2]
        };
        break;
    }
    return task;
  };
  let lastTask;
  let lastTaskID;
  let rawTasks$1 = [];
  const taskDb = {};
  const addTask$1 = function(descr, data) {
    const rawTask = {
      section: currentSection$1,
      type: currentSection$1,
      processed: false,
      manualEndTime: false,
      renderEndTime: null,
      raw: { data },
      task: descr,
      classes: []
    };
    const taskInfo = parseData(lastTaskID, data);
    rawTask.raw.startTime = taskInfo.startTime;
    rawTask.raw.endTime = taskInfo.endTime;
    rawTask.id = taskInfo.id;
    rawTask.prevTaskId = lastTaskID;
    rawTask.active = taskInfo.active;
    rawTask.done = taskInfo.done;
    rawTask.crit = taskInfo.crit;
    rawTask.milestone = taskInfo.milestone;
    rawTask.order = lastOrder;
    lastOrder++;
    const pos = rawTasks$1.push(rawTask);
    lastTaskID = rawTask.id;
    taskDb[rawTask.id] = pos - 1;
  };
  const findTaskById = function(id2) {
    const pos = taskDb[id2];
    return rawTasks$1[pos];
  };
  const addTaskOrg$1 = function(descr, data) {
    const newTask = {
      section: currentSection$1,
      type: currentSection$1,
      description: descr,
      task: descr,
      classes: []
    };
    const taskInfo = compileData(lastTask, data);
    newTask.startTime = taskInfo.startTime;
    newTask.endTime = taskInfo.endTime;
    newTask.id = taskInfo.id;
    newTask.active = taskInfo.active;
    newTask.done = taskInfo.done;
    newTask.crit = taskInfo.crit;
    newTask.milestone = taskInfo.milestone;
    lastTask = newTask;
    tasks$1.push(newTask);
  };
  const compileTasks$1 = function() {
    const compileTask = function(pos) {
      const task = rawTasks$1[pos];
      let startTime = "";
      switch (rawTasks$1[pos].raw.startTime.type) {
        case "prevTaskEnd": {
          const prevTask = findTaskById(task.prevTaskId);
          task.startTime = prevTask.endTime;
          break;
        }
        case "getStartDate":
          startTime = getStartDate(void 0, dateFormat, rawTasks$1[pos].raw.startTime.startData);
          if (startTime) {
            rawTasks$1[pos].startTime = startTime;
          }
          break;
      }
      if (rawTasks$1[pos].startTime) {
        rawTasks$1[pos].endTime = getEndDate(
          rawTasks$1[pos].startTime,
          dateFormat,
          rawTasks$1[pos].raw.endTime.data,
          inclusiveEndDates
        );
        if (rawTasks$1[pos].endTime) {
          rawTasks$1[pos].processed = true;
          rawTasks$1[pos].manualEndTime = moment(
            rawTasks$1[pos].raw.endTime.data,
            "YYYY-MM-DD",
            true
          ).isValid();
          checkTaskDates(rawTasks$1[pos], dateFormat, excludes, includes);
        }
      }
      return rawTasks$1[pos].processed;
    };
    let allProcessed = true;
    for (let i = 0; i < rawTasks$1.length; i++) {
      compileTask(i);
      allProcessed = allProcessed && rawTasks$1[i].processed;
    }
    return allProcessed;
  };
  const setLink = function(ids, _linkStr) {
    let linkStr = _linkStr;
    if (getConfig$1().securityLevel !== "loose") {
      linkStr = sanitizeUrl_1(_linkStr);
    }
    ids.split(",").forEach(function(id2) {
      let rawTask = findTaskById(id2);
      if (typeof rawTask !== "undefined") {
        pushFun(id2, () => {
          window.open(linkStr, "_self");
        });
        links[id2] = linkStr;
      }
    });
    setClass(ids, "clickable");
  };
  const setClass = function(ids, className) {
    ids.split(",").forEach(function(id2) {
      let rawTask = findTaskById(id2);
      if (typeof rawTask !== "undefined") {
        rawTask.classes.push(className);
      }
    });
  };
  const setClickFun = function(id2, functionName, functionArgs) {
    if (getConfig$1().securityLevel !== "loose") {
      return;
    }
    if (typeof functionName === "undefined") {
      return;
    }
    let argList = [];
    if (typeof functionArgs === "string") {
      argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let i = 0; i < argList.length; i++) {
        let item = argList[i].trim();
        if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
          item = item.substr(1, item.length - 2);
        }
        argList[i] = item;
      }
    }
    if (argList.length === 0) {
      argList.push(id2);
    }
    let rawTask = findTaskById(id2);
    if (typeof rawTask !== "undefined") {
      pushFun(id2, () => {
        utils.runFunc(functionName, ...argList);
      });
    }
  };
  const pushFun = function(id2, callbackFunction) {
    funs.push(function() {
      const elem = document.querySelector(`[id="${id2}"]`);
      if (elem !== null) {
        elem.addEventListener("click", function() {
          callbackFunction();
        });
      }
    });
    funs.push(function() {
      const elem = document.querySelector(`[id="${id2}-text"]`);
      if (elem !== null) {
        elem.addEventListener("click", function() {
          callbackFunction();
        });
      }
    });
  };
  const setClickEvent = function(ids, functionName, functionArgs) {
    ids.split(",").forEach(function(id2) {
      setClickFun(id2, functionName, functionArgs);
    });
    setClass(ids, "clickable");
  };
  const bindFunctions = function(element) {
    funs.forEach(function(fun) {
      fun(element);
    });
  };
  const ganttDb = {
    parseDirective: parseDirective$6,
    getConfig: () => getConfig$1().gantt,
    clear: clear$5,
    setDateFormat,
    getDateFormat,
    enableInclusiveEndDates,
    endDatesAreInclusive,
    enableTopAxis,
    topAxisEnabled,
    setAxisFormat,
    getAxisFormat,
    setTodayMarker,
    getTodayMarker,
    setAccTitle,
    getAccTitle,
    setDiagramTitle,
    getDiagramTitle,
    setAccDescription,
    getAccDescription,
    addSection: addSection$2,
    getSections: getSections$2,
    getTasks: getTasks$1,
    addTask: addTask$1,
    findTaskById,
    addTaskOrg: addTaskOrg$1,
    setIncludes,
    getIncludes,
    setExcludes,
    getExcludes,
    setClickEvent,
    setLink,
    getLinks,
    bindFunctions,
    parseDuration,
    isInvalidDate
  };
  function getTaskTags(data, task, tags2) {
    let matchFound = true;
    while (matchFound) {
      matchFound = false;
      tags2.forEach(function(t) {
        const pattern = "^\\s*" + t + "\\s*$";
        const regex = new RegExp(pattern);
        if (data[0].match(regex)) {
          task[t] = true;
          data.shift(1);
          matchFound = true;
        }
      });
    }
  }
  const setConf$5 = function() {
    log$3.debug("Something is calling, setConf, remove the call");
  };
  let w;
  const draw$8 = function(text2, id2, version2, diagObj) {
    const conf2 = getConfig$1().gantt;
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    const elem = doc.getElementById(id2);
    w = elem.parentElement.offsetWidth;
    if (typeof w === "undefined") {
      w = 1200;
    }
    if (typeof conf2.useWidth !== "undefined") {
      w = conf2.useWidth;
    }
    const taskArray = diagObj.db.getTasks();
    const h = taskArray.length * (conf2.barHeight + conf2.barGap) + 2 * conf2.topPadding;
    elem.setAttribute("viewBox", "0 0 " + w + " " + h);
    const svg2 = root2.select(`[id="${id2}"]`);
    const timeScale = time().domain([
      min$2(taskArray, function(d) {
        return d.startTime;
      }),
      max$3(taskArray, function(d) {
        return d.endTime;
      })
    ]).rangeRound([0, w - conf2.leftPadding - conf2.rightPadding]);
    let categories = [];
    for (let i = 0; i < taskArray.length; i++) {
      categories.push(taskArray[i].type);
    }
    const catsUnfiltered = categories;
    categories = checkUnique(categories);
    function taskCompare(a2, b) {
      const taskA = a2.startTime;
      const taskB = b.startTime;
      let result = 0;
      if (taskA > taskB) {
        result = 1;
      } else if (taskA < taskB) {
        result = -1;
      }
      return result;
    }
    taskArray.sort(taskCompare);
    makeGant(taskArray, w, h);
    configureSvgSize(svg2, h, w, conf2.useMaxWidth);
    svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", w / 2).attr("y", conf2.titleTopMargin).attr("class", "titleText");
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
    function makeGant(tasks2, pageWidth, pageHeight) {
      const barHeight = conf2.barHeight;
      const gap = barHeight + conf2.barGap;
      const topPadding = conf2.topPadding;
      const leftPadding = conf2.leftPadding;
      const colorScale = linear().domain([0, categories.length]).range(["#00B9FA", "#F95002"]).interpolate(interpolateHcl);
      drawExcludeDays(
        gap,
        topPadding,
        leftPadding,
        pageWidth,
        pageHeight,
        tasks2,
        diagObj.db.getExcludes(),
        diagObj.db.getIncludes()
      );
      makeGrid(leftPadding, topPadding, pageWidth, pageHeight);
      drawRects(tasks2, gap, topPadding, leftPadding, barHeight, colorScale, pageWidth);
      vertLabels(gap, topPadding);
      drawToday(leftPadding, topPadding, pageWidth, pageHeight);
    }
    function drawRects(theArray, theGap, theTopPad, theSidePad, theBarHeight, theColorScale, w2) {
      svg2.append("g").selectAll("rect").data(theArray).enter().append("rect").attr("x", 0).attr("y", function(d, i) {
        i = d.order;
        return i * theGap + theTopPad - 2;
      }).attr("width", function() {
        return w2 - conf2.rightPadding / 2;
      }).attr("height", theGap).attr("class", function(d) {
        for (let i = 0; i < categories.length; i++) {
          if (d.type === categories[i]) {
            return "section section" + i % conf2.numberSectionStyles;
          }
        }
        return "section section0";
      });
      const rectangles = svg2.append("g").selectAll("rect").data(theArray).enter();
      const links2 = diagObj.db.getLinks();
      rectangles.append("rect").attr("id", function(d) {
        return d.id;
      }).attr("rx", 3).attr("ry", 3).attr("x", function(d) {
        if (d.milestone) {
          return timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
        }
        return timeScale(d.startTime) + theSidePad;
      }).attr("y", function(d, i) {
        i = d.order;
        return i * theGap + theTopPad;
      }).attr("width", function(d) {
        if (d.milestone) {
          return theBarHeight;
        }
        return timeScale(d.renderEndTime || d.endTime) - timeScale(d.startTime);
      }).attr("height", theBarHeight).attr("transform-origin", function(d, i) {
        i = d.order;
        return (timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime))).toString() + "px " + (i * theGap + theTopPad + 0.5 * theBarHeight).toString() + "px";
      }).attr("class", function(d) {
        const res = "task";
        let classStr = "";
        if (d.classes.length > 0) {
          classStr = d.classes.join(" ");
        }
        let secNum = 0;
        for (let i = 0; i < categories.length; i++) {
          if (d.type === categories[i]) {
            secNum = i % conf2.numberSectionStyles;
          }
        }
        let taskClass = "";
        if (d.active) {
          if (d.crit) {
            taskClass += " activeCrit";
          } else {
            taskClass = " active";
          }
        } else if (d.done) {
          if (d.crit) {
            taskClass = " doneCrit";
          } else {
            taskClass = " done";
          }
        } else {
          if (d.crit) {
            taskClass += " crit";
          }
        }
        if (taskClass.length === 0) {
          taskClass = " task";
        }
        if (d.milestone) {
          taskClass = " milestone " + taskClass;
        }
        taskClass += secNum;
        taskClass += " " + classStr;
        return res + taskClass;
      });
      rectangles.append("text").attr("id", function(d) {
        return d.id + "-text";
      }).text(function(d) {
        return d.task;
      }).attr("font-size", conf2.fontSize).attr("x", function(d) {
        let startX = timeScale(d.startTime);
        let endX = timeScale(d.renderEndTime || d.endTime);
        if (d.milestone) {
          startX += 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
        }
        if (d.milestone) {
          endX = startX + theBarHeight;
        }
        const textWidth = this.getBBox().width;
        if (textWidth > endX - startX) {
          if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
            return startX + theSidePad - 5;
          } else {
            return endX + theSidePad + 5;
          }
        } else {
          return (endX - startX) / 2 + startX + theSidePad;
        }
      }).attr("y", function(d, i) {
        i = d.order;
        return i * theGap + conf2.barHeight / 2 + (conf2.fontSize / 2 - 2) + theTopPad;
      }).attr("text-height", theBarHeight).attr("class", function(d) {
        const startX = timeScale(d.startTime);
        let endX = timeScale(d.endTime);
        if (d.milestone) {
          endX = startX + theBarHeight;
        }
        const textWidth = this.getBBox().width;
        let classStr = "";
        if (d.classes.length > 0) {
          classStr = d.classes.join(" ");
        }
        let secNum = 0;
        for (let i = 0; i < categories.length; i++) {
          if (d.type === categories[i]) {
            secNum = i % conf2.numberSectionStyles;
          }
        }
        let taskType = "";
        if (d.active) {
          if (d.crit) {
            taskType = "activeCritText" + secNum;
          } else {
            taskType = "activeText" + secNum;
          }
        }
        if (d.done) {
          if (d.crit) {
            taskType = taskType + " doneCritText" + secNum;
          } else {
            taskType = taskType + " doneText" + secNum;
          }
        } else {
          if (d.crit) {
            taskType = taskType + " critText" + secNum;
          }
        }
        if (d.milestone) {
          taskType += " milestoneText";
        }
        if (textWidth > endX - startX) {
          if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
            return classStr + " taskTextOutsideLeft taskTextOutside" + secNum + " " + taskType;
          } else {
            return classStr + " taskTextOutsideRight taskTextOutside" + secNum + " " + taskType + " width-" + textWidth;
          }
        } else {
          return classStr + " taskText taskText" + secNum + " " + taskType + " width-" + textWidth;
        }
      });
      const securityLevel2 = getConfig$1().securityLevel;
      if (securityLevel2 === "sandbox") {
        let sandboxElement2;
        sandboxElement2 = select("#i" + id2);
        const doc2 = sandboxElement2.nodes()[0].contentDocument;
        rectangles.filter(function(d) {
          return typeof links2[d.id] !== "undefined";
        }).each(function(o) {
          var taskRect = doc2.querySelector("#" + o.id);
          var taskText = doc2.querySelector("#" + o.id + "-text");
          const oldParent = taskRect.parentNode;
          var Link = doc2.createElement("a");
          Link.setAttribute("xlink:href", links2[o.id]);
          Link.setAttribute("target", "_top");
          oldParent.appendChild(Link);
          Link.appendChild(taskRect);
          Link.appendChild(taskText);
        });
      }
    }
    function drawExcludeDays(theGap, theTopPad, theSidePad, w2, h2, tasks2, excludes2, includes2) {
      const minTime = tasks2.reduce(
        (min2, { startTime }) => min2 ? Math.min(min2, startTime) : startTime,
        0
      );
      const maxTime = tasks2.reduce((max2, { endTime }) => max2 ? Math.max(max2, endTime) : endTime, 0);
      const dateFormat2 = diagObj.db.getDateFormat();
      if (!minTime || !maxTime)
        return;
      const excludeRanges = [];
      let range2 = null;
      let d = moment(minTime);
      while (d.valueOf() <= maxTime) {
        if (diagObj.db.isInvalidDate(d, dateFormat2, excludes2, includes2)) {
          if (!range2) {
            range2 = {
              start: d.clone(),
              end: d.clone()
            };
          } else {
            range2.end = d.clone();
          }
        } else {
          if (range2) {
            excludeRanges.push(range2);
            range2 = null;
          }
        }
        d.add(1, "d");
      }
      const rectangles = svg2.append("g").selectAll("rect").data(excludeRanges).enter();
      rectangles.append("rect").attr("id", function(d2) {
        return "exclude-" + d2.start.format("YYYY-MM-DD");
      }).attr("x", function(d2) {
        return timeScale(d2.start) + theSidePad;
      }).attr("y", conf2.gridLineStartPadding).attr("width", function(d2) {
        const renderEnd = d2.end.clone().add(1, "day");
        return timeScale(renderEnd) - timeScale(d2.start);
      }).attr("height", h2 - theTopPad - conf2.gridLineStartPadding).attr("transform-origin", function(d2, i) {
        return (timeScale(d2.start) + theSidePad + 0.5 * (timeScale(d2.end) - timeScale(d2.start))).toString() + "px " + (i * theGap + 0.5 * h2).toString() + "px";
      }).attr("class", "exclude-range");
    }
    function makeGrid(theSidePad, theTopPad, w2, h2) {
      let bottomXAxis = axisBottom(timeScale).tickSize(-h2 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
      svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + (h2 - 50) + ")").call(bottomXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em");
      if (diagObj.db.topAxisEnabled() || conf2.topAxis) {
        let topXAxis = axisTop(timeScale).tickSize(-h2 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
        svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + theTopPad + ")").call(topXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
      }
    }
    function vertLabels(theGap, theTopPad) {
      const numOccurances = [];
      let prevGap = 0;
      for (let i = 0; i < categories.length; i++) {
        numOccurances[i] = [categories[i], getCount(categories[i], catsUnfiltered)];
      }
      svg2.append("g").selectAll("text").data(numOccurances).enter().append(function(d) {
        const rows = d[0].split(common.lineBreakRegex);
        const dy = -(rows.length - 1) / 2;
        const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
        svgLabel.setAttribute("dy", dy + "em");
        for (let j = 0; j < rows.length; j++) {
          const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tspan.setAttribute("alignment-baseline", "central");
          tspan.setAttribute("x", "10");
          if (j > 0)
            tspan.setAttribute("dy", "1em");
          tspan.textContent = rows[j];
          svgLabel.appendChild(tspan);
        }
        return svgLabel;
      }).attr("x", 10).attr("y", function(d, i) {
        if (i > 0) {
          for (let j = 0; j < i; j++) {
            prevGap += numOccurances[i - 1][1];
            return d[1] * theGap / 2 + prevGap * theGap + theTopPad;
          }
        } else {
          return d[1] * theGap / 2 + theTopPad;
        }
      }).attr("font-size", conf2.sectionFontSize).attr("font-size", conf2.sectionFontSize).attr("class", function(d) {
        for (let i = 0; i < categories.length; i++) {
          if (d[0] === categories[i]) {
            return "sectionTitle sectionTitle" + i % conf2.numberSectionStyles;
          }
        }
        return "sectionTitle";
      });
    }
    function drawToday(theSidePad, theTopPad, w2, h2) {
      const todayMarker2 = diagObj.db.getTodayMarker();
      if (todayMarker2 === "off") {
        return;
      }
      const todayG = svg2.append("g").attr("class", "today");
      const today = new Date();
      const todayLine = todayG.append("line");
      todayLine.attr("x1", timeScale(today) + theSidePad).attr("x2", timeScale(today) + theSidePad).attr("y1", conf2.titleTopMargin).attr("y2", h2 - conf2.titleTopMargin).attr("class", "today");
      if (todayMarker2 !== "") {
        todayLine.attr("style", todayMarker2.replace(/,/g, ";"));
      }
    }
    function checkUnique(arr) {
      const hash = {};
      const result = [];
      for (let i = 0, l = arr.length; i < l; ++i) {
        if (!Object.prototype.hasOwnProperty.call(hash, arr[i])) {
          hash[arr[i]] = true;
          result.push(arr[i]);
        }
      }
      return result;
    }
    function getCounts(arr) {
      let i = arr.length;
      const obj = {};
      while (i) {
        obj[arr[--i]] = (obj[arr[i]] || 0) + 1;
      }
      return obj;
    }
    function getCount(word, arr) {
      return getCounts(arr)[word] || 0;
    }
  };
  const ganttRenderer = {
    setConf: setConf$5,
    draw: draw$8
  };
  var parser$5 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [6, 9, 10];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "info": 4, "document": 5, "EOF": 6, "line": 7, "statement": 8, "NL": 9, "showInfo": 10, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "info", 6: "EOF", 9: "NL", 10: "showInfo" },
      productions_: [0, [3, 3], [5, 0], [5, 2], [7, 1], [7, 1], [8, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        $$.length - 1;
        switch (yystate) {
          case 1:
            return yy;
          case 4:
            break;
          case 6:
            yy.setInfo(true);
            break;
        }
      },
      table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, o($V0, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: 6, 9: [1, 7], 10: [1, 8] }, { 1: [2, 1] }, o($V0, [2, 3]), o($V0, [2, 4]), o($V0, [2, 5]), o($V0, [2, 6])],
      defaultActions: { 4: [2, 1] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              return 4;
            case 1:
              return 9;
            case 2:
              return "space";
            case 3:
              return 10;
            case 4:
              return 6;
            case 5:
              return "TXT";
          }
        },
        rules: [/^(?:info\b)/i, /^(?:[\s\n\r]+)/i, /^(?:[\s]+)/i, /^(?:showInfo\b)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$5.parser = parser$5;
  var message = "";
  var info = false;
  const setMessage = (txt) => {
    log$3.debug("Setting message to: " + txt);
    message = txt;
  };
  const getMessage = () => {
    return message;
  };
  const setInfo = (inf) => {
    info = inf;
  };
  const getInfo = () => {
    return info;
  };
  const infoDb = {
    setMessage,
    getMessage,
    setInfo,
    getInfo,
    clear: clear$g
  };
  const draw$7 = (text2, id2, version2, diagObj) => {
    try {
      log$3.debug("Rendering info diagram\n" + text2);
      const securityLevel = getConfig$1().securityLevel;
      let sandboxElement;
      if (securityLevel === "sandbox") {
        sandboxElement = select("#i" + id2);
      }
      const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
      const svg2 = root2.select("#" + id2);
      const g = svg2.append("g");
      g.append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", "32px").style("text-anchor", "middle").text("v " + version2);
      svg2.attr("height", 100);
      svg2.attr("width", 400);
    } catch (e) {
      log$3.error("Error while rendering info diagram");
      log$3.error(e.message);
    }
  };
  const infoRenderer = {
    draw: draw$7
  };
  const infoDetector = (txt) => {
    return txt.match(/^\s*info/) !== null;
  };
  var parser$4 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 4], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 9], $V5 = [1, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V6 = [2, 5], $V7 = [1, 6, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V8 = [26, 27, 28], $V9 = [2, 8], $Va = [1, 18], $Vb = [1, 19], $Vc = [1, 20], $Vd = [1, 21], $Ve = [1, 22], $Vf = [1, 23], $Vg = [1, 28], $Vh = [6, 26, 27, 28, 29];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "PIE": 6, "document": 7, "showData": 8, "line": 9, "statement": 10, "txt": 11, "value": 12, "title": 13, "title_value": 14, "acc_title": 15, "acc_title_value": 16, "acc_descr": 17, "acc_descr_value": 18, "acc_descr_multiline_value": 19, "section": 20, "openDirective": 21, "typeDirective": 22, "closeDirective": 23, ":": 24, "argDirective": 25, "NEWLINE": 26, ";": 27, "EOF": 28, "open_directive": 29, "type_directive": 30, "arg_directive": 31, "close_directive": 32, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 6: "PIE", 8: "showData", 11: "txt", 12: "value", 13: "title", 14: "title_value", 15: "acc_title", 16: "acc_title_value", 17: "acc_descr", 18: "acc_descr_value", 19: "acc_descr_multiline_value", 20: "section", 24: ":", 26: "NEWLINE", 27: ";", 28: "EOF", 29: "open_directive", 30: "type_directive", 31: "arg_directive", 32: "close_directive" },
      productions_: [0, [3, 2], [3, 2], [3, 2], [3, 3], [7, 0], [7, 2], [9, 2], [10, 0], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [5, 3], [5, 5], [4, 1], [4, 1], [4, 1], [21, 1], [22, 1], [25, 1], [23, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 4:
            yy.setShowData(true);
            break;
          case 7:
            this.$ = $$[$0 - 1];
            break;
          case 9:
            yy.addSection($$[$0 - 1], yy.cleanupValue($$[$0]));
            break;
          case 10:
            this.$ = $$[$0].trim();
            yy.setDiagramTitle(this.$);
            break;
          case 11:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 12:
          case 13:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 14:
            yy.addSection($$[$0].substr(8));
            this.$ = $$[$0].substr(8);
            break;
          case 21:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 22:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 23:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 24:
            yy.parseDirective("}%%", "close_directive", "pie");
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, o($V5, $V6, { 7: 12, 8: [1, 13] }), o($V7, [2, 18]), o($V7, [2, 19]), o($V7, [2, 20]), { 22: 14, 30: [1, 15] }, { 30: [2, 21] }, { 1: [2, 1] }, { 1: [2, 2] }, o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 3], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($V5, $V6, { 7: 25 }), { 23: 26, 24: [1, 27], 32: $Vg }, o([24, 32], [2, 22]), o($V5, [2, 6]), { 4: 29, 26: $V1, 27: $V2, 28: $V3 }, { 12: [1, 30] }, { 14: [1, 31] }, { 16: [1, 32] }, { 18: [1, 33] }, o($V8, [2, 13]), o($V8, [2, 14]), o($V8, [2, 15]), o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 4], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($Vh, [2, 16]), { 25: 34, 31: [1, 35] }, o($Vh, [2, 24]), o($V5, [2, 7]), o($V8, [2, 9]), o($V8, [2, 10]), o($V8, [2, 11]), o($V8, [2, 12]), { 23: 36, 32: $Vg }, { 32: [2, 23] }, o($Vh, [2, 17])],
      defaultActions: { 9: [2, 21], 10: [2, 1], 11: [2, 2], 35: [2, 23] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 29;
            case 1:
              this.begin("type_directive");
              return 30;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 24;
            case 3:
              this.popState();
              this.popState();
              return 32;
            case 4:
              return 31;
            case 5:
              break;
            case 6:
              break;
            case 7:
              return 26;
            case 8:
              break;
            case 9:
              break;
            case 10:
              this.begin("title");
              return 13;
            case 11:
              this.popState();
              return "title_value";
            case 12:
              this.begin("acc_title");
              return 15;
            case 13:
              this.popState();
              return "acc_title_value";
            case 14:
              this.begin("acc_descr");
              return 17;
            case 15:
              this.popState();
              return "acc_descr_value";
            case 16:
              this.begin("acc_descr_multiline");
              break;
            case 17:
              this.popState();
              break;
            case 18:
              return "acc_descr_multiline_value";
            case 19:
              this.begin("string");
              break;
            case 20:
              this.popState();
              break;
            case 21:
              return "txt";
            case 22:
              return 6;
            case 23:
              return 8;
            case 24:
              return "value";
            case 25:
              return 28;
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:[\s]+)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:pie\b)/i, /^(?:showData\b)/i, /^(?::[\s]*[\d]+(?:\.[\d]+)?)/i, /^(?:$)/i],
        conditions: { "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "title": { "rules": [11], "inclusive": false }, "string": { "rules": [20, 21], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 12, 14, 16, 19, 22, 23, 24, 25], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$4.parser = parser$4;
  const pieDetector = (txt) => {
    return txt.match(/^\s*pie/) !== null;
  };
  let sections$1 = {};
  let showData = false;
  const parseDirective$5 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const addSection$1 = function(id2, value) {
    id2 = common.sanitizeText(id2, getConfig$1());
    if (typeof sections$1[id2] === "undefined") {
      sections$1[id2] = value;
      log$3.debug("Added new section :", id2);
    }
  };
  const getSections$1 = () => sections$1;
  const setShowData = function(toggle) {
    showData = toggle;
  };
  const getShowData = function() {
    return showData;
  };
  const cleanupValue = function(value) {
    if (value.substring(0, 1) === ":") {
      value = value.substring(1).trim();
      return Number(value.trim());
    } else {
      return Number(value.trim());
    }
  };
  const clear$4 = function() {
    sections$1 = {};
    showData = false;
    clear$g();
  };
  const pieDb = {
    parseDirective: parseDirective$5,
    getConfig: () => getConfig$1().pie,
    addSection: addSection$1,
    getSections: getSections$1,
    cleanupValue,
    clear: clear$4,
    setAccTitle,
    getAccTitle,
    setDiagramTitle,
    getDiagramTitle,
    setShowData,
    getShowData,
    getAccDescription,
    setAccDescription
  };
  let conf$6 = getConfig$1();
  let width;
  const height = 450;
  const draw$6 = (txt, id2, _version, diagObj) => {
    try {
      conf$6 = getConfig$1();
      log$3.debug("Rendering info diagram\n" + txt);
      const securityLevel = getConfig$1().securityLevel;
      let sandboxElement;
      if (securityLevel === "sandbox") {
        sandboxElement = select("#i" + id2);
      }
      const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
      const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
      diagObj.db.clear();
      diagObj.parser.parse(txt);
      log$3.debug("Parsed info diagram");
      const elem = doc.getElementById(id2);
      width = elem.parentElement.offsetWidth;
      if (typeof width === "undefined") {
        width = 1200;
      }
      if (typeof conf$6.useWidth !== "undefined") {
        width = conf$6.useWidth;
      }
      if (typeof conf$6.pie.useWidth !== "undefined") {
        width = conf$6.pie.useWidth;
      }
      const diagram = root2.select("#" + id2);
      configureSvgSize(diagram, height, width, conf$6.pie.useMaxWidth);
      addSVGAccessibilityFields(diagObj.db, diagram, id2);
      elem.setAttribute("viewBox", "0 0 " + width + " " + height);
      var margin = 40;
      var legendRectSize = 18;
      var legendSpacing = 4;
      var radius = Math.min(width, height) / 2 - margin;
      var svg2 = diagram.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
      var data = diagObj.db.getSections();
      var sum2 = 0;
      Object.keys(data).forEach(function(key) {
        sum2 += data[key];
      });
      const themeVariables = conf$6.themeVariables;
      var myGeneratedColors = [
        themeVariables.pie1,
        themeVariables.pie2,
        themeVariables.pie3,
        themeVariables.pie4,
        themeVariables.pie5,
        themeVariables.pie6,
        themeVariables.pie7,
        themeVariables.pie8,
        themeVariables.pie9,
        themeVariables.pie10,
        themeVariables.pie11,
        themeVariables.pie12
      ];
      var color2 = ordinal().range(myGeneratedColors);
      var pie = d3pie().value(function(d) {
        return d[1];
      });
      var dataReady = pie(Object.entries(data));
      var arcGenerator = d3arc().innerRadius(0).outerRadius(radius);
      svg2.selectAll("mySlices").data(dataReady).enter().append("path").attr("d", arcGenerator).attr("fill", function(d) {
        return color2(d.data[0]);
      }).attr("class", "pieCircle");
      svg2.selectAll("mySlices").data(dataReady).enter().append("text").text(function(d) {
        return (d.data[1] / sum2 * 100).toFixed(0) + "%";
      }).attr("transform", function(d) {
        return "translate(" + arcGenerator.centroid(d) + ")";
      }).style("text-anchor", "middle").attr("class", "slice");
      svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", 0).attr("y", -(height - 50) / 2).attr("class", "pieTitleText");
      var legend = svg2.selectAll(".legend").data(color2.domain()).enter().append("g").attr("class", "legend").attr("transform", function(d, i) {
        var height2 = legendRectSize + legendSpacing;
        var offset = height2 * color2.domain().length / 2;
        var horz = 12 * legendRectSize;
        var vert = i * height2 - offset;
        return "translate(" + horz + "," + vert + ")";
      });
      legend.append("rect").attr("width", legendRectSize).attr("height", legendRectSize).style("fill", color2).style("stroke", color2);
      legend.data(dataReady).append("text").attr("x", legendRectSize + legendSpacing).attr("y", legendRectSize - legendSpacing).text(function(d) {
        if (diagObj.db.getShowData() || conf$6.showData || conf$6.pie.showData) {
          return d.data[0] + " [" + d.data[1] + "]";
        } else {
          return d.data[0];
        }
      });
    } catch (e) {
      log$3.error("Error while rendering info diagram");
      log$3.error(e);
    }
  };
  const pieRenderer = {
    draw: draw$6
  };
  var parser$3 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 8], $V5 = [5, 6, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], $V6 = [1, 22], $V7 = [2, 13], $V8 = [1, 26], $V9 = [1, 27], $Va = [1, 28], $Vb = [1, 29], $Vc = [1, 30], $Vd = [1, 31], $Ve = [1, 24], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 36], $Vi = [71, 72], $Vj = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 60, 62, 71, 72], $Vk = [1, 56], $Vl = [1, 57], $Vm = [1, 58], $Vn = [1, 59], $Vo = [1, 60], $Vp = [1, 61], $Vq = [1, 62], $Vr = [62, 63], $Vs = [1, 74], $Vt = [1, 70], $Vu = [1, 71], $Vv = [1, 72], $Vw = [1, 73], $Vx = [1, 75], $Vy = [1, 79], $Vz = [1, 80], $VA = [1, 77], $VB = [1, 78], $VC = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "directive": 4, "NEWLINE": 5, "RD": 6, "diagram": 7, "EOF": 8, "openDirective": 9, "typeDirective": 10, "closeDirective": 11, ":": 12, "argDirective": 13, "acc_title": 14, "acc_title_value": 15, "acc_descr": 16, "acc_descr_value": 17, "acc_descr_multiline_value": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "requirementDef": 23, "elementDef": 24, "relationshipDef": 25, "requirementType": 26, "requirementName": 27, "STRUCT_START": 28, "requirementBody": 29, "ID": 30, "COLONSEP": 31, "id": 32, "TEXT": 33, "text": 34, "RISK": 35, "riskLevel": 36, "VERIFYMTHD": 37, "verifyType": 38, "STRUCT_STOP": 39, "REQUIREMENT": 40, "FUNCTIONAL_REQUIREMENT": 41, "INTERFACE_REQUIREMENT": 42, "PERFORMANCE_REQUIREMENT": 43, "PHYSICAL_REQUIREMENT": 44, "DESIGN_CONSTRAINT": 45, "LOW_RISK": 46, "MED_RISK": 47, "HIGH_RISK": 48, "VERIFY_ANALYSIS": 49, "VERIFY_DEMONSTRATION": 50, "VERIFY_INSPECTION": 51, "VERIFY_TEST": 52, "ELEMENT": 53, "elementName": 54, "elementBody": 55, "TYPE": 56, "type": 57, "DOCREF": 58, "ref": 59, "END_ARROW_L": 60, "relationship": 61, "LINE": 62, "END_ARROW_R": 63, "CONTAINS": 64, "COPIES": 65, "DERIVES": 66, "SATISFIES": 67, "VERIFIES": 68, "REFINES": 69, "TRACES": 70, "unqString": 71, "qString": 72, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 12: ":", 14: "acc_title", 15: "acc_title_value", 16: "acc_descr", 17: "acc_descr_value", 18: "acc_descr_multiline_value", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 28: "STRUCT_START", 30: "ID", 31: "COLONSEP", 33: "TEXT", 35: "RISK", 37: "VERIFYMTHD", 39: "STRUCT_STOP", 40: "REQUIREMENT", 41: "FUNCTIONAL_REQUIREMENT", 42: "INTERFACE_REQUIREMENT", 43: "PERFORMANCE_REQUIREMENT", 44: "PHYSICAL_REQUIREMENT", 45: "DESIGN_CONSTRAINT", 46: "LOW_RISK", 47: "MED_RISK", 48: "HIGH_RISK", 49: "VERIFY_ANALYSIS", 50: "VERIFY_DEMONSTRATION", 51: "VERIFY_INSPECTION", 52: "VERIFY_TEST", 53: "ELEMENT", 56: "TYPE", 58: "DOCREF", 60: "END_ARROW_L", 62: "LINE", 63: "END_ARROW_R", 64: "CONTAINS", 65: "COPIES", 66: "DERIVES", 67: "SATISFIES", 68: "VERIFIES", 69: "REFINES", 70: "TRACES", 71: "unqString", 72: "qString" },
      productions_: [0, [3, 3], [3, 2], [3, 4], [4, 3], [4, 5], [4, 2], [4, 2], [4, 1], [9, 1], [10, 1], [13, 1], [11, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [23, 5], [29, 5], [29, 5], [29, 5], [29, 5], [29, 2], [29, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [36, 1], [36, 1], [36, 1], [38, 1], [38, 1], [38, 1], [38, 1], [24, 5], [55, 5], [55, 5], [55, 2], [55, 1], [25, 5], [25, 5], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [27, 1], [27, 1], [32, 1], [32, 1], [34, 1], [34, 1], [54, 1], [54, 1], [57, 1], [57, 1], [59, 1], [59, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 6:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 7:
          case 8:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 9:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 10:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 11:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 12:
            yy.parseDirective("}%%", "close_directive", "pie");
            break;
          case 13:
            this.$ = [];
            break;
          case 19:
            yy.addRequirement($$[$0 - 3], $$[$0 - 4]);
            break;
          case 20:
            yy.setNewReqId($$[$0 - 2]);
            break;
          case 21:
            yy.setNewReqText($$[$0 - 2]);
            break;
          case 22:
            yy.setNewReqRisk($$[$0 - 2]);
            break;
          case 23:
            yy.setNewReqVerifyMethod($$[$0 - 2]);
            break;
          case 26:
            this.$ = yy.RequirementType.REQUIREMENT;
            break;
          case 27:
            this.$ = yy.RequirementType.FUNCTIONAL_REQUIREMENT;
            break;
          case 28:
            this.$ = yy.RequirementType.INTERFACE_REQUIREMENT;
            break;
          case 29:
            this.$ = yy.RequirementType.PERFORMANCE_REQUIREMENT;
            break;
          case 30:
            this.$ = yy.RequirementType.PHYSICAL_REQUIREMENT;
            break;
          case 31:
            this.$ = yy.RequirementType.DESIGN_CONSTRAINT;
            break;
          case 32:
            this.$ = yy.RiskLevel.LOW_RISK;
            break;
          case 33:
            this.$ = yy.RiskLevel.MED_RISK;
            break;
          case 34:
            this.$ = yy.RiskLevel.HIGH_RISK;
            break;
          case 35:
            this.$ = yy.VerifyType.VERIFY_ANALYSIS;
            break;
          case 36:
            this.$ = yy.VerifyType.VERIFY_DEMONSTRATION;
            break;
          case 37:
            this.$ = yy.VerifyType.VERIFY_INSPECTION;
            break;
          case 38:
            this.$ = yy.VerifyType.VERIFY_TEST;
            break;
          case 39:
            yy.addElement($$[$0 - 3]);
            break;
          case 40:
            yy.setNewElementType($$[$0 - 2]);
            break;
          case 41:
            yy.setNewElementDocRef($$[$0 - 2]);
            break;
          case 44:
            yy.addRelationship($$[$0 - 2], $$[$0], $$[$0 - 4]);
            break;
          case 45:
            yy.addRelationship($$[$0 - 2], $$[$0 - 4], $$[$0]);
            break;
          case 46:
            this.$ = yy.Relationships.CONTAINS;
            break;
          case 47:
            this.$ = yy.Relationships.COPIES;
            break;
          case 48:
            this.$ = yy.Relationships.DERIVES;
            break;
          case 49:
            this.$ = yy.Relationships.SATISFIES;
            break;
          case 50:
            this.$ = yy.Relationships.VERIFIES;
            break;
          case 51:
            this.$ = yy.Relationships.REFINES;
            break;
          case 52:
            this.$ = yy.Relationships.TRACES;
            break;
        }
      },
      table: [{ 3: 1, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: [1, 9], 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 5: [1, 11] }, { 10: 12, 20: [1, 13] }, { 15: [1, 14] }, { 17: [1, 15] }, o($V5, [2, 8]), { 20: [2, 9] }, { 3: 16, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [2, 2] }, { 4: 21, 5: $V6, 7: 17, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 11: 34, 12: [1, 35], 22: $Vh }, o([12, 22], [2, 10]), o($V5, [2, 6]), o($V5, [2, 7]), { 1: [2, 1] }, { 8: [1, 37] }, { 4: 21, 5: $V6, 7: 38, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 39, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 40, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 41, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 42, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 27: 43, 71: [1, 44], 72: [1, 45] }, { 54: 46, 71: [1, 47], 72: [1, 48] }, { 60: [1, 49], 62: [1, 50] }, o($Vi, [2, 26]), o($Vi, [2, 27]), o($Vi, [2, 28]), o($Vi, [2, 29]), o($Vi, [2, 30]), o($Vi, [2, 31]), o($Vj, [2, 55]), o($Vj, [2, 56]), o($V5, [2, 4]), { 13: 51, 21: [1, 52] }, o($V5, [2, 12]), { 1: [2, 3] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 8: [2, 17] }, { 8: [2, 18] }, { 28: [1, 53] }, { 28: [2, 53] }, { 28: [2, 54] }, { 28: [1, 54] }, { 28: [2, 59] }, { 28: [2, 60] }, { 61: 55, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 61: 63, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 11: 64, 22: $Vh }, { 22: [2, 11] }, { 5: [1, 65] }, { 5: [1, 66] }, { 62: [1, 67] }, o($Vr, [2, 46]), o($Vr, [2, 47]), o($Vr, [2, 48]), o($Vr, [2, 49]), o($Vr, [2, 50]), o($Vr, [2, 51]), o($Vr, [2, 52]), { 63: [1, 68] }, o($V5, [2, 5]), { 5: $Vs, 29: 69, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 76, 56: $VA, 58: $VB }, { 32: 81, 71: $Vf, 72: $Vg }, { 32: 82, 71: $Vf, 72: $Vg }, o($VC, [2, 19]), { 31: [1, 83] }, { 31: [1, 84] }, { 31: [1, 85] }, { 31: [1, 86] }, { 5: $Vs, 29: 87, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, o($VC, [2, 25]), o($VC, [2, 39]), { 31: [1, 88] }, { 31: [1, 89] }, { 5: $Vy, 39: $Vz, 55: 90, 56: $VA, 58: $VB }, o($VC, [2, 43]), o($VC, [2, 44]), o($VC, [2, 45]), { 32: 91, 71: $Vf, 72: $Vg }, { 34: 92, 71: [1, 93], 72: [1, 94] }, { 36: 95, 46: [1, 96], 47: [1, 97], 48: [1, 98] }, { 38: 99, 49: [1, 100], 50: [1, 101], 51: [1, 102], 52: [1, 103] }, o($VC, [2, 24]), { 57: 104, 71: [1, 105], 72: [1, 106] }, { 59: 107, 71: [1, 108], 72: [1, 109] }, o($VC, [2, 42]), { 5: [1, 110] }, { 5: [1, 111] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [1, 112] }, { 5: [2, 32] }, { 5: [2, 33] }, { 5: [2, 34] }, { 5: [1, 113] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [2, 38] }, { 5: [1, 114] }, { 5: [2, 61] }, { 5: [2, 62] }, { 5: [1, 115] }, { 5: [2, 63] }, { 5: [2, 64] }, { 5: $Vs, 29: 116, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 117, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 118, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 119, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 120, 56: $VA, 58: $VB }, { 5: $Vy, 39: $Vz, 55: 121, 56: $VA, 58: $VB }, o($VC, [2, 20]), o($VC, [2, 21]), o($VC, [2, 22]), o($VC, [2, 23]), o($VC, [2, 40]), o($VC, [2, 41])],
      defaultActions: { 8: [2, 9], 10: [2, 2], 16: [2, 1], 37: [2, 3], 38: [2, 14], 39: [2, 15], 40: [2, 16], 41: [2, 17], 42: [2, 18], 44: [2, 53], 45: [2, 54], 47: [2, 59], 48: [2, 60], 52: [2, 11], 93: [2, 57], 94: [2, 58], 96: [2, 32], 97: [2, 33], 98: [2, 34], 100: [2, 35], 101: [2, 36], 102: [2, 37], 103: [2, 38], 105: [2, 61], 106: [2, 62], 108: [2, 63], 109: [2, 64] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 19;
            case 1:
              this.begin("type_directive");
              return 20;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 12;
            case 3:
              this.popState();
              this.popState();
              return 22;
            case 4:
              return 21;
            case 5:
              return "title";
            case 6:
              this.begin("acc_title");
              return 14;
            case 7:
              this.popState();
              return "acc_title_value";
            case 8:
              this.begin("acc_descr");
              return 16;
            case 9:
              this.popState();
              return "acc_descr_value";
            case 10:
              this.begin("acc_descr_multiline");
              break;
            case 11:
              this.popState();
              break;
            case 12:
              return "acc_descr_multiline_value";
            case 13:
              return 5;
            case 14:
              break;
            case 15:
              break;
            case 16:
              break;
            case 17:
              return 8;
            case 18:
              return 6;
            case 19:
              return 28;
            case 20:
              return 39;
            case 21:
              return 31;
            case 22:
              return 30;
            case 23:
              return 33;
            case 24:
              return 35;
            case 25:
              return 37;
            case 26:
              return 40;
            case 27:
              return 41;
            case 28:
              return 42;
            case 29:
              return 43;
            case 30:
              return 44;
            case 31:
              return 45;
            case 32:
              return 46;
            case 33:
              return 47;
            case 34:
              return 48;
            case 35:
              return 49;
            case 36:
              return 50;
            case 37:
              return 51;
            case 38:
              return 52;
            case 39:
              return 53;
            case 40:
              return 64;
            case 41:
              return 65;
            case 42:
              return 66;
            case 43:
              return 67;
            case 44:
              return 68;
            case 45:
              return 69;
            case 46:
              return 70;
            case 47:
              return 56;
            case 48:
              return 58;
            case 49:
              return 60;
            case 50:
              return 63;
            case 51:
              return 62;
            case 52:
              this.begin("string");
              break;
            case 53:
              this.popState();
              break;
            case 54:
              return "qString";
            case 55:
              yy_.yytext = yy_.yytext.trim();
              return 71;
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
        conditions: { "acc_descr_multiline": { "rules": [11, 12], "inclusive": false }, "acc_descr": { "rules": [9], "inclusive": false }, "acc_title": { "rules": [7], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "unqString": { "rules": [], "inclusive": false }, "token": { "rules": [], "inclusive": false }, "string": { "rules": [53, 54], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$3.parser = parser$3;
  const requirementDetector = (txt) => {
    return txt.match(/^\s*requirement(Diagram)?/) !== null;
  };
  let relations = [];
  let latestRequirement = {};
  let requirements = {};
  let latestElement = {};
  let elements = {};
  const RequirementType = {
    REQUIREMENT: "Requirement",
    FUNCTIONAL_REQUIREMENT: "Functional Requirement",
    INTERFACE_REQUIREMENT: "Interface Requirement",
    PERFORMANCE_REQUIREMENT: "Performance Requirement",
    PHYSICAL_REQUIREMENT: "Physical Requirement",
    DESIGN_CONSTRAINT: "Design Constraint"
  };
  const RiskLevel = {
    LOW_RISK: "Low",
    MED_RISK: "Medium",
    HIGH_RISK: "High"
  };
  const VerifyType = {
    VERIFY_ANALYSIS: "Analysis",
    VERIFY_DEMONSTRATION: "Demonstration",
    VERIFY_INSPECTION: "Inspection",
    VERIFY_TEST: "Test"
  };
  const Relationships = {
    CONTAINS: "contains",
    COPIES: "copies",
    DERIVES: "derives",
    SATISFIES: "satisfies",
    VERIFIES: "verifies",
    REFINES: "refines",
    TRACES: "traces"
  };
  const parseDirective$4 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const addRequirement = (name2, type2) => {
    if (typeof requirements[name2] === "undefined") {
      requirements[name2] = {
        name: name2,
        type: type2,
        id: latestRequirement.id,
        text: latestRequirement.text,
        risk: latestRequirement.risk,
        verifyMethod: latestRequirement.verifyMethod
      };
    }
    latestRequirement = {};
    return requirements[name2];
  };
  const getRequirements = () => requirements;
  const setNewReqId = (id2) => {
    if (typeof latestRequirement != "undefined") {
      latestRequirement.id = id2;
    }
  };
  const setNewReqText = (text2) => {
    if (typeof latestRequirement != "undefined") {
      latestRequirement.text = text2;
    }
  };
  const setNewReqRisk = (risk) => {
    if (typeof latestRequirement != "undefined") {
      latestRequirement.risk = risk;
    }
  };
  const setNewReqVerifyMethod = (verifyMethod) => {
    if (typeof latestRequirement != "undefined") {
      latestRequirement.verifyMethod = verifyMethod;
    }
  };
  const addElement = (name2) => {
    if (typeof elements[name2] === "undefined") {
      elements[name2] = {
        name: name2,
        type: latestElement.type,
        docRef: latestElement.docRef
      };
      log$3.info("Added new requirement: ", name2);
    }
    latestElement = {};
    return elements[name2];
  };
  const getElements = () => elements;
  const setNewElementType = (type2) => {
    if (typeof latestElement != "undefined") {
      latestElement.type = type2;
    }
  };
  const setNewElementDocRef = (docRef) => {
    if (typeof latestElement != "undefined") {
      latestElement.docRef = docRef;
    }
  };
  const addRelationship = (type2, src2, dst) => {
    relations.push({
      type: type2,
      src: src2,
      dst
    });
  };
  const getRelationships = () => relations;
  const clear$3 = () => {
    relations = [];
    latestRequirement = {};
    requirements = {};
    latestElement = {};
    elements = {};
    clear$g();
  };
  const requirementDb = {
    RequirementType,
    RiskLevel,
    VerifyType,
    Relationships,
    parseDirective: parseDirective$4,
    getConfig: () => getConfig$1().req,
    addRequirement,
    getRequirements,
    setNewReqId,
    setNewReqText,
    setNewReqRisk,
    setNewReqVerifyMethod,
    setAccTitle,
    getAccTitle,
    setAccDescription,
    getAccDescription,
    addElement,
    getElements,
    setNewElementType,
    setNewElementDocRef,
    addRelationship,
    getRelationships,
    clear: clear$3
  };
  const ReqMarkers = {
    CONTAINS: "contains",
    ARROW: "arrow"
  };
  const insertLineEndings = (parentNode, conf2) => {
    let containsNode = parentNode.append("defs").append("marker").attr("id", ReqMarkers.CONTAINS + "_line_ending").attr("refX", 0).attr("refY", conf2.line_height / 2).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("g");
    containsNode.append("circle").attr("cx", conf2.line_height / 2).attr("cy", conf2.line_height / 2).attr("r", conf2.line_height / 2).attr("fill", "none");
    containsNode.append("line").attr("x1", 0).attr("x2", conf2.line_height).attr("y1", conf2.line_height / 2).attr("y2", conf2.line_height / 2).attr("stroke-width", 1);
    containsNode.append("line").attr("y1", 0).attr("y2", conf2.line_height).attr("x1", conf2.line_height / 2).attr("x2", conf2.line_height / 2).attr("stroke-width", 1);
    parentNode.append("defs").append("marker").attr("id", ReqMarkers.ARROW + "_line_ending").attr("refX", conf2.line_height).attr("refY", 0.5 * conf2.line_height).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("path").attr(
      "d",
      `M0,0
      L${conf2.line_height},${conf2.line_height / 2}
      M${conf2.line_height},${conf2.line_height / 2}
      L0,${conf2.line_height}`
    ).attr("stroke-width", 1);
  };
  const markers = {
    ReqMarkers,
    insertLineEndings
  };
  let conf$5 = {};
  let relCnt = 0;
  const newRectNode = (parentNode, id2) => {
    return parentNode.insert("rect", "#" + id2).attr("class", "req reqBox").attr("x", 0).attr("y", 0).attr("width", conf$5.rect_min_width + "px").attr("height", conf$5.rect_min_height + "px");
  };
  const newTitleNode = (parentNode, id2, txts) => {
    let x2 = conf$5.rect_min_width / 2;
    let title2 = parentNode.append("text").attr("class", "req reqLabel reqTitle").attr("id", id2).attr("x", x2).attr("y", conf$5.rect_padding).attr("dominant-baseline", "hanging");
    let i = 0;
    txts.forEach((textStr) => {
      if (i == 0) {
        title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", 0).text(textStr);
      } else {
        title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", conf$5.line_height * 0.75).text(textStr);
      }
      i++;
    });
    let yPadding = 1.5 * conf$5.rect_padding;
    let linePadding = i * conf$5.line_height * 0.75;
    let totalY = yPadding + linePadding;
    parentNode.append("line").attr("class", "req-title-line").attr("x1", "0").attr("x2", conf$5.rect_min_width).attr("y1", totalY).attr("y2", totalY);
    return {
      titleNode: title2,
      y: totalY
    };
  };
  const newBodyNode = (parentNode, id2, txts, yStart) => {
    let body = parentNode.append("text").attr("class", "req reqLabel").attr("id", id2).attr("x", conf$5.rect_padding).attr("y", yStart).attr("dominant-baseline", "hanging");
    let currentRow = 0;
    const charLimit = 30;
    let wrappedTxts = [];
    txts.forEach((textStr) => {
      let currentTextLen = textStr.length;
      while (currentTextLen > charLimit && currentRow < 3) {
        let firstPart = textStr.substring(0, charLimit);
        textStr = textStr.substring(charLimit, textStr.length);
        currentTextLen = textStr.length;
        wrappedTxts[wrappedTxts.length] = firstPart;
        currentRow++;
      }
      if (currentRow == 3) {
        let lastStr = wrappedTxts[wrappedTxts.length - 1];
        wrappedTxts[wrappedTxts.length - 1] = lastStr.substring(0, lastStr.length - 4) + "...";
      } else {
        wrappedTxts[wrappedTxts.length] = textStr;
      }
      currentRow = 0;
    });
    wrappedTxts.forEach((textStr) => {
      body.append("tspan").attr("x", conf$5.rect_padding).attr("dy", conf$5.line_height).text(textStr);
    });
    return body;
  };
  const addEdgeLabel = (parentNode, svgPath, conf2, txt) => {
    const len = svgPath.node().getTotalLength();
    const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
    const labelId = "rel" + relCnt;
    relCnt++;
    const labelNode = parentNode.append("text").attr("class", "req relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(txt);
    const labelBBox = labelNode.node().getBBox();
    parentNode.insert("rect", "#" + labelId).attr("class", "req reqLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
  };
  const drawRelationshipFromLayout = function(svg2, rel, g, insert, diagObj) {
    const edge = g.edge(elementString(rel.src), elementString(rel.dst));
    const lineFunction = line$1().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    });
    const svgPath = svg2.insert("path", "#" + insert).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("fill", "none");
    if (rel.type == diagObj.db.Relationships.CONTAINS) {
      svgPath.attr(
        "marker-start",
        "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + rel.type + "_line_ending)"
      );
    } else {
      svgPath.attr("stroke-dasharray", "10,7");
      svgPath.attr(
        "marker-end",
        "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + markers.ReqMarkers.ARROW + "_line_ending)"
      );
    }
    addEdgeLabel(svg2, svgPath, conf$5, `<<${rel.type}>>`);
    return;
  };
  const drawReqs = (reqs, graph2, svgNode2) => {
    Object.keys(reqs).forEach((reqName) => {
      let req = reqs[reqName];
      reqName = elementString(reqName);
      log$3.info("Added new requirement: ", reqName);
      const groupNode = svgNode2.append("g").attr("id", reqName);
      const textId = "req-" + reqName;
      const rectNode = newRectNode(groupNode, textId);
      let titleNodeInfo = newTitleNode(groupNode, reqName + "_title", [
        `<<${req.type}>>`,
        `${req.name}`
      ]);
      newBodyNode(
        groupNode,
        reqName + "_body",
        [
          `Id: ${req.id}`,
          `Text: ${req.text}`,
          `Risk: ${req.risk}`,
          `Verification: ${req.verifyMethod}`
        ],
        titleNodeInfo.y
      );
      const rectBBox = rectNode.node().getBBox();
      graph2.setNode(reqName, {
        width: rectBBox.width,
        height: rectBBox.height,
        shape: "rect",
        id: reqName
      });
    });
  };
  const drawElements = (els, graph2, svgNode2) => {
    Object.keys(els).forEach((elName) => {
      let el = els[elName];
      const id2 = elementString(elName);
      const groupNode = svgNode2.append("g").attr("id", id2);
      const textId = "element-" + id2;
      const rectNode = newRectNode(groupNode, textId);
      let titleNodeInfo = newTitleNode(groupNode, textId + "_title", [`<<Element>>`, `${elName}`]);
      newBodyNode(
        groupNode,
        textId + "_body",
        [`Type: ${el.type || "Not Specified"}`, `Doc Ref: ${el.docRef || "None"}`],
        titleNodeInfo.y
      );
      const rectBBox = rectNode.node().getBBox();
      graph2.setNode(id2, {
        width: rectBBox.width,
        height: rectBBox.height,
        shape: "rect",
        id: id2
      });
    });
  };
  const addRelationships = (relationships2, g) => {
    relationships2.forEach(function(r) {
      let src2 = elementString(r.src);
      let dst = elementString(r.dst);
      g.setEdge(src2, dst, { relationship: r });
    });
    return relationships2;
  };
  const adjustEntities = function(svgNode2, graph2) {
    graph2.nodes().forEach(function(v) {
      if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
        svgNode2.select("#" + v);
        svgNode2.select("#" + v).attr(
          "transform",
          "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
        );
      }
    });
    return;
  };
  const elementString = (str) => {
    return str.replace(/\s/g, "").replace(/\./g, "_");
  };
  const draw$5 = (text2, id2, _version, diagObj) => {
    conf$5 = getConfig$1().requirement;
    diagObj.db.clear();
    diagObj.parser.parse(text2);
    const securityLevel = conf$5.securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const svg2 = root2.select(`[id='${id2}']`);
    markers.insertLineEndings(svg2, conf$5);
    const g = new graphlib$1.Graph({
      multigraph: false,
      compound: false,
      directed: true
    }).setGraph({
      rankdir: conf$5.layoutDirection,
      marginx: 20,
      marginy: 20,
      nodesep: 100,
      edgesep: 100,
      ranksep: 100
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    let requirements2 = diagObj.db.getRequirements();
    let elements2 = diagObj.db.getElements();
    let relationships2 = diagObj.db.getRelationships();
    drawReqs(requirements2, g, svg2);
    drawElements(elements2, g, svg2);
    addRelationships(relationships2, g);
    dagreExports.layout(g);
    adjustEntities(svg2, g);
    relationships2.forEach(function(rel) {
      drawRelationshipFromLayout(svg2, rel, g, id2, diagObj);
    });
    const padding2 = conf$5.rect_padding;
    const svgBounds = svg2.node().getBBox();
    const width2 = svgBounds.width + padding2 * 2;
    const height2 = svgBounds.height + padding2 * 2;
    configureSvgSize(svg2, height2, width2, conf$5.useMaxWidth);
    svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
    addSVGAccessibilityFields(diagObj.db, svg2, id2);
  };
  const requirementRenderer = {
    draw: draw$5
  };
  var parser$2 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 18], $V8 = [1, 19], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 29], $Vd = [1, 30], $Ve = [1, 31], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 34], $Vi = [1, 35], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [1, 39], $Vn = [1, 40], $Vo = [1, 43], $Vp = [1, 44], $Vq = [1, 45], $Vr = [1, 46], $Vs = [1, 47], $Vt = [1, 48], $Vu = [1, 51], $Vv = [1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79], $Vw = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $Vx = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 52, 53, 58, 59, 60, 61, 69, 79], $Vy = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 51, 53, 58, 59, 60, 61, 69, 79], $Vz = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 53, 58, 59, 60, 61, 69, 79], $VA = [67, 68, 69], $VB = [1, 121], $VC = [1, 4, 5, 7, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "SPACE": 4, "NEWLINE": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "openDirective": 11, "typeDirective": 12, "closeDirective": 13, ":": 14, "argDirective": 15, "participant": 16, "actor": 17, "AS": 18, "restOfLine": 19, "participant_actor": 20, "signal": 21, "autonumber": 22, "NUM": 23, "off": 24, "activate": 25, "deactivate": 26, "note_statement": 27, "links_statement": 28, "link_statement": 29, "properties_statement": 30, "details_statement": 31, "title": 32, "legacy_title": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "loop": 39, "end": 40, "rect": 41, "opt": 42, "alt": 43, "else_sections": 44, "par": 45, "par_sections": 46, "critical": 47, "option_sections": 48, "break": 49, "option": 50, "and": 51, "else": 52, "note": 53, "placement": 54, "text2": 55, "over": 56, "actor_pair": 57, "links": 58, "link": 59, "properties": 60, "details": 61, "spaceList": 62, ",": 63, "left_of": 64, "right_of": 65, "signaltype": 66, "+": 67, "-": 68, "ACTOR": 69, "SOLID_OPEN_ARROW": 70, "DOTTED_OPEN_ARROW": 71, "SOLID_ARROW": 72, "DOTTED_ARROW": 73, "SOLID_CROSS": 74, "DOTTED_CROSS": 75, "SOLID_POINT": 76, "DOTTED_POINT": 77, "TXT": 78, "open_directive": 79, "type_directive": 80, "arg_directive": 81, "close_directive": 82, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 7: "SD", 14: ":", 16: "participant", 18: "AS", 19: "restOfLine", 20: "participant_actor", 22: "autonumber", 23: "NUM", 24: "off", 25: "activate", 26: "deactivate", 32: "title", 33: "legacy_title", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 39: "loop", 40: "end", 41: "rect", 42: "opt", 43: "alt", 45: "par", 47: "critical", 49: "break", 50: "option", 51: "and", 52: "else", 53: "note", 56: "over", 58: "links", 59: "link", 60: "properties", 61: "details", 63: ",", 64: "left_of", 65: "right_of", 67: "+", 68: "-", 69: "ACTOR", 70: "SOLID_OPEN_ARROW", 71: "DOTTED_OPEN_ARROW", 72: "SOLID_ARROW", 73: "DOTTED_ARROW", 74: "SOLID_CROSS", 75: "DOTTED_CROSS", 76: "SOLID_POINT", 77: "DOTTED_POINT", 78: "TXT", 79: "open_directive", 80: "type_directive", 81: "arg_directive", 82: "close_directive" },
      productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [6, 4], [6, 6], [10, 5], [10, 3], [10, 5], [10, 3], [10, 2], [10, 4], [10, 3], [10, 3], [10, 2], [10, 3], [10, 3], [10, 2], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 1], [48, 1], [48, 4], [46, 1], [46, 4], [44, 1], [44, 4], [27, 4], [27, 4], [28, 3], [29, 3], [30, 3], [31, 3], [62, 2], [62, 1], [57, 3], [57, 1], [54, 1], [54, 1], [21, 5], [21, 5], [21, 4], [17, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [55, 1], [11, 1], [12, 1], [15, 1], [13, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 4:
            yy.apply($$[$0]);
            return $$[$0];
          case 5:
            this.$ = [];
            break;
          case 6:
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
            break;
          case 7:
          case 8:
            this.$ = $$[$0];
            break;
          case 9:
            this.$ = [];
            break;
          case 12:
            $$[$0 - 3].type = "addParticipant";
            $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
            this.$ = $$[$0 - 3];
            break;
          case 13:
            $$[$0 - 1].type = "addParticipant";
            this.$ = $$[$0 - 1];
            break;
          case 14:
            $$[$0 - 3].type = "addActor";
            $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
            this.$ = $$[$0 - 3];
            break;
          case 15:
            $$[$0 - 1].type = "addActor";
            this.$ = $$[$0 - 1];
            break;
          case 17:
            this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 2]), sequenceIndexStep: Number($$[$0 - 1]), sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
            break;
          case 18:
            this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 1]), sequenceIndexStep: 1, sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
            break;
          case 19:
            this.$ = { type: "sequenceIndex", sequenceVisible: false, signalType: yy.LINETYPE.AUTONUMBER };
            break;
          case 20:
            this.$ = { type: "sequenceIndex", sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
            break;
          case 21:
            this.$ = { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] };
            break;
          case 22:
            this.$ = { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 1] };
            break;
          case 28:
            yy.setDiagramTitle($$[$0].substring(6));
            this.$ = $$[$0].substring(6);
            break;
          case 29:
            yy.setDiagramTitle($$[$0].substring(7));
            this.$ = $$[$0].substring(7);
            break;
          case 30:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 31:
          case 32:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 33:
            $$[$0 - 1].unshift({ type: "loopStart", loopText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.LOOP_START });
            $$[$0 - 1].push({ type: "loopEnd", loopText: $$[$0 - 2], signalType: yy.LINETYPE.LOOP_END });
            this.$ = $$[$0 - 1];
            break;
          case 34:
            $$[$0 - 1].unshift({ type: "rectStart", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_START });
            $$[$0 - 1].push({ type: "rectEnd", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_END });
            this.$ = $$[$0 - 1];
            break;
          case 35:
            $$[$0 - 1].unshift({ type: "optStart", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_START });
            $$[$0 - 1].push({ type: "optEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_END });
            this.$ = $$[$0 - 1];
            break;
          case 36:
            $$[$0 - 1].unshift({ type: "altStart", altText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.ALT_START });
            $$[$0 - 1].push({ type: "altEnd", signalType: yy.LINETYPE.ALT_END });
            this.$ = $$[$0 - 1];
            break;
          case 37:
            $$[$0 - 1].unshift({ type: "parStart", parText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.PAR_START });
            $$[$0 - 1].push({ type: "parEnd", signalType: yy.LINETYPE.PAR_END });
            this.$ = $$[$0 - 1];
            break;
          case 38:
            $$[$0 - 1].unshift({ type: "criticalStart", criticalText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.CRITICAL_START });
            $$[$0 - 1].push({ type: "criticalEnd", signalType: yy.LINETYPE.CRITICAL_END });
            this.$ = $$[$0 - 1];
            break;
          case 39:
            $$[$0 - 1].unshift({ type: "breakStart", breakText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_START });
            $$[$0 - 1].push({ type: "breakEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_END });
            this.$ = $$[$0 - 1];
            break;
          case 42:
            this.$ = $$[$0 - 3].concat([{ type: "option", optionText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.CRITICAL_OPTION }, $$[$0]]);
            break;
          case 44:
            this.$ = $$[$0 - 3].concat([{ type: "and", parText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.PAR_AND }, $$[$0]]);
            break;
          case 46:
            this.$ = $$[$0 - 3].concat([{ type: "else", altText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.ALT_ELSE }, $$[$0]]);
            break;
          case 47:
            this.$ = [$$[$0 - 1], { type: "addNote", placement: $$[$0 - 2], actor: $$[$0 - 1].actor, text: $$[$0] }];
            break;
          case 48:
            $$[$0 - 2] = [].concat($$[$0 - 1], $$[$0 - 1]).slice(0, 2);
            $$[$0 - 2][0] = $$[$0 - 2][0].actor;
            $$[$0 - 2][1] = $$[$0 - 2][1].actor;
            this.$ = [$$[$0 - 1], { type: "addNote", placement: yy.PLACEMENT.OVER, actor: $$[$0 - 2].slice(0, 2), text: $$[$0] }];
            break;
          case 49:
            this.$ = [$$[$0 - 1], { type: "addLinks", actor: $$[$0 - 1].actor, text: $$[$0] }];
            break;
          case 50:
            this.$ = [$$[$0 - 1], { type: "addALink", actor: $$[$0 - 1].actor, text: $$[$0] }];
            break;
          case 51:
            this.$ = [$$[$0 - 1], { type: "addProperties", actor: $$[$0 - 1].actor, text: $$[$0] }];
            break;
          case 52:
            this.$ = [$$[$0 - 1], { type: "addDetails", actor: $$[$0 - 1].actor, text: $$[$0] }];
            break;
          case 55:
            this.$ = [$$[$0 - 2], $$[$0]];
            break;
          case 56:
            this.$ = $$[$0];
            break;
          case 57:
            this.$ = yy.PLACEMENT.LEFTOF;
            break;
          case 58:
            this.$ = yy.PLACEMENT.RIGHTOF;
            break;
          case 59:
            this.$ = [
              $$[$0 - 4],
              $$[$0 - 1],
              { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
              { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] }
            ];
            break;
          case 60:
            this.$ = [
              $$[$0 - 4],
              $$[$0 - 1],
              { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
              { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 4] }
            ];
            break;
          case 61:
            this.$ = [$$[$0 - 3], $$[$0 - 1], { type: "addMessage", from: $$[$0 - 3].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 2], msg: $$[$0] }];
            break;
          case 62:
            this.$ = { type: "addParticipant", actor: $$[$0] };
            break;
          case 63:
            this.$ = yy.LINETYPE.SOLID_OPEN;
            break;
          case 64:
            this.$ = yy.LINETYPE.DOTTED_OPEN;
            break;
          case 65:
            this.$ = yy.LINETYPE.SOLID;
            break;
          case 66:
            this.$ = yy.LINETYPE.DOTTED;
            break;
          case 67:
            this.$ = yy.LINETYPE.SOLID_CROSS;
            break;
          case 68:
            this.$ = yy.LINETYPE.DOTTED_CROSS;
            break;
          case 69:
            this.$ = yy.LINETYPE.SOLID_POINT;
            break;
          case 70:
            this.$ = yy.LINETYPE.DOTTED_POINT;
            break;
          case 71:
            this.$ = yy.parseMessage($$[$0].trim().substring(1));
            break;
          case 72:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 73:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 74:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 75:
            yy.parseDirective("}%%", "close_directive", "sequence");
            break;
        }
      },
      table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, o([1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $V4, { 8: 11 }), { 12: 12, 80: [1, 13] }, { 80: [2, 72] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 13: 49, 14: [1, 50], 82: $Vu }, o([14, 82], [2, 73]), o($Vv, [2, 6]), { 6: 41, 10: 52, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, o($Vv, [2, 8]), o($Vv, [2, 9]), { 17: 53, 69: $Vt }, { 17: 54, 69: $Vt }, { 5: [1, 55] }, { 5: [1, 58], 23: [1, 56], 24: [1, 57] }, { 17: 59, 69: $Vt }, { 17: 60, 69: $Vt }, { 5: [1, 61] }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, o($Vv, [2, 28]), o($Vv, [2, 29]), { 35: [1, 66] }, { 37: [1, 67] }, o($Vv, [2, 32]), { 19: [1, 68] }, { 19: [1, 69] }, { 19: [1, 70] }, { 19: [1, 71] }, { 19: [1, 72] }, { 19: [1, 73] }, { 19: [1, 74] }, o($Vv, [2, 40]), { 66: 75, 70: [1, 76], 71: [1, 77], 72: [1, 78], 73: [1, 79], 74: [1, 80], 75: [1, 81], 76: [1, 82], 77: [1, 83] }, { 54: 84, 56: [1, 85], 64: [1, 86], 65: [1, 87] }, { 17: 88, 69: $Vt }, { 17: 89, 69: $Vt }, { 17: 90, 69: $Vt }, { 17: 91, 69: $Vt }, o([5, 18, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78], [2, 62]), { 5: [1, 92] }, { 15: 93, 81: [1, 94] }, { 5: [2, 75] }, o($Vv, [2, 7]), { 5: [1, 96], 18: [1, 95] }, { 5: [1, 98], 18: [1, 97] }, o($Vv, [2, 16]), { 5: [1, 100], 23: [1, 99] }, { 5: [1, 101] }, o($Vv, [2, 20]), { 5: [1, 102] }, { 5: [1, 103] }, o($Vv, [2, 23]), o($Vv, [2, 24]), o($Vv, [2, 25]), o($Vv, [2, 26]), o($Vv, [2, 27]), o($Vv, [2, 30]), o($Vv, [2, 31]), o($Vw, $V4, { 8: 104 }), o($Vw, $V4, { 8: 105 }), o($Vw, $V4, { 8: 106 }), o($Vx, $V4, { 44: 107, 8: 108 }), o($Vy, $V4, { 46: 109, 8: 110 }), o($Vz, $V4, { 48: 111, 8: 112 }), o($Vw, $V4, { 8: 113 }), { 17: 116, 67: [1, 114], 68: [1, 115], 69: $Vt }, o($VA, [2, 63]), o($VA, [2, 64]), o($VA, [2, 65]), o($VA, [2, 66]), o($VA, [2, 67]), o($VA, [2, 68]), o($VA, [2, 69]), o($VA, [2, 70]), { 17: 117, 69: $Vt }, { 17: 119, 57: 118, 69: $Vt }, { 69: [2, 57] }, { 69: [2, 58] }, { 55: 120, 78: $VB }, { 55: 122, 78: $VB }, { 55: 123, 78: $VB }, { 55: 124, 78: $VB }, o($VC, [2, 10]), { 13: 125, 82: $Vu }, { 82: [2, 74] }, { 19: [1, 126] }, o($Vv, [2, 13]), { 19: [1, 127] }, o($Vv, [2, 15]), { 5: [1, 128] }, o($Vv, [2, 18]), o($Vv, [2, 19]), o($Vv, [2, 21]), o($Vv, [2, 22]), { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 129], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 130], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 131], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 132] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 45], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 52: [1, 133], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 134] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 43], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 51: [1, 135], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 136] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 41], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 50: [1, 137], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 138], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 17: 139, 69: $Vt }, { 17: 140, 69: $Vt }, { 55: 141, 78: $VB }, { 55: 142, 78: $VB }, { 55: 143, 78: $VB }, { 63: [1, 144], 78: [2, 56] }, { 5: [2, 49] }, { 5: [2, 71] }, { 5: [2, 50] }, { 5: [2, 51] }, { 5: [2, 52] }, { 5: [1, 145] }, { 5: [1, 146] }, { 5: [1, 147] }, o($Vv, [2, 17]), o($Vv, [2, 33]), o($Vv, [2, 34]), o($Vv, [2, 35]), o($Vv, [2, 36]), { 19: [1, 148] }, o($Vv, [2, 37]), { 19: [1, 149] }, o($Vv, [2, 38]), { 19: [1, 150] }, o($Vv, [2, 39]), { 55: 151, 78: $VB }, { 55: 152, 78: $VB }, { 5: [2, 61] }, { 5: [2, 47] }, { 5: [2, 48] }, { 17: 153, 69: $Vt }, o($VC, [2, 11]), o($Vv, [2, 12]), o($Vv, [2, 14]), o($Vx, $V4, { 8: 108, 44: 154 }), o($Vy, $V4, { 8: 110, 46: 155 }), o($Vz, $V4, { 8: 112, 48: 156 }), { 5: [2, 59] }, { 5: [2, 60] }, { 78: [2, 55] }, { 40: [2, 46] }, { 40: [2, 44] }, { 40: [2, 42] }],
      defaultActions: { 7: [2, 72], 8: [2, 1], 9: [2, 2], 10: [2, 3], 51: [2, 75], 86: [2, 57], 87: [2, 58], 94: [2, 74], 120: [2, 49], 121: [2, 71], 122: [2, 50], 123: [2, 51], 124: [2, 52], 141: [2, 61], 142: [2, 47], 143: [2, 48], 151: [2, 59], 152: [2, 60], 153: [2, 55], 154: [2, 46], 155: [2, 44], 156: [2, 42] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 79;
            case 1:
              this.begin("type_directive");
              return 80;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 14;
            case 3:
              this.popState();
              this.popState();
              return 82;
            case 4:
              return 81;
            case 5:
              return 5;
            case 6:
              break;
            case 7:
              break;
            case 8:
              break;
            case 9:
              break;
            case 10:
              break;
            case 11:
              return 23;
            case 12:
              this.begin("ID");
              return 16;
            case 13:
              this.begin("ID");
              return 20;
            case 14:
              yy_.yytext = yy_.yytext.trim();
              this.begin("ALIAS");
              return 69;
            case 15:
              this.popState();
              this.popState();
              this.begin("LINE");
              return 18;
            case 16:
              this.popState();
              this.popState();
              return 5;
            case 17:
              this.begin("LINE");
              return 39;
            case 18:
              this.begin("LINE");
              return 41;
            case 19:
              this.begin("LINE");
              return 42;
            case 20:
              this.begin("LINE");
              return 43;
            case 21:
              this.begin("LINE");
              return 52;
            case 22:
              this.begin("LINE");
              return 45;
            case 23:
              this.begin("LINE");
              return 51;
            case 24:
              this.begin("LINE");
              return 47;
            case 25:
              this.begin("LINE");
              return 50;
            case 26:
              this.begin("LINE");
              return 49;
            case 27:
              this.popState();
              return 19;
            case 28:
              return 40;
            case 29:
              return 64;
            case 30:
              return 65;
            case 31:
              return 58;
            case 32:
              return 59;
            case 33:
              return 60;
            case 34:
              return 61;
            case 35:
              return 56;
            case 36:
              return 53;
            case 37:
              this.begin("ID");
              return 25;
            case 38:
              this.begin("ID");
              return 26;
            case 39:
              return 32;
            case 40:
              return 33;
            case 41:
              this.begin("acc_title");
              return 34;
            case 42:
              this.popState();
              return "acc_title_value";
            case 43:
              this.begin("acc_descr");
              return 36;
            case 44:
              this.popState();
              return "acc_descr_value";
            case 45:
              this.begin("acc_descr_multiline");
              break;
            case 46:
              this.popState();
              break;
            case 47:
              return "acc_descr_multiline_value";
            case 48:
              return 7;
            case 49:
              return 22;
            case 50:
              return 24;
            case 51:
              return 63;
            case 52:
              return 5;
            case 53:
              yy_.yytext = yy_.yytext.trim();
              return 69;
            case 54:
              return 72;
            case 55:
              return 73;
            case 56:
              return 70;
            case 57:
              return 71;
            case 58:
              return 74;
            case 59:
              return 75;
            case 60:
              return 76;
            case 61:
              return 77;
            case 62:
              return 78;
            case 63:
              return 67;
            case 64:
              return 68;
            case 65:
              return 5;
            case 66:
              return "INVALID";
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:[^\->:\n,;]+?([\-]*[^\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]+)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { "acc_descr_multiline": { "rules": [46, 47], "inclusive": false }, "acc_descr": { "rules": [44], "inclusive": false }, "acc_title": { "rules": [42], "inclusive": false }, "open_directive": { "rules": [1, 8], "inclusive": false }, "type_directive": { "rules": [2, 3, 8], "inclusive": false }, "arg_directive": { "rules": [3, 4, 8], "inclusive": false }, "ID": { "rules": [7, 8, 14], "inclusive": false }, "ALIAS": { "rules": [7, 8, 15, 16], "inclusive": false }, "LINE": { "rules": [7, 8, 27], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 9, 10, 11, 12, 13, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 45, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$2.parser = parser$2;
  const sequenceDetector = (txt) => {
    return txt.match(/^\s*sequenceDiagram/) !== null;
  };
  let prevActor = void 0;
  let actors$1 = {};
  let messages = [];
  let sequenceNumbersEnabled = false;
  let wrapEnabled;
  const parseDirective$3 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const addActor = function(id2, name2, description2, type2) {
    const old = actors$1[id2];
    if (old && name2 === old.name && description2 == null)
      return;
    if (description2 == null || description2.text == null) {
      description2 = { text: name2, wrap: null, type: type2 };
    }
    if (type2 == null || description2.text == null) {
      description2 = { text: name2, wrap: null, type: type2 };
    }
    actors$1[id2] = {
      name: name2,
      description: description2.text,
      wrap: description2.wrap === void 0 && autoWrap() || !!description2.wrap,
      prevActor,
      links: {},
      properties: {},
      actorCnt: null,
      rectData: null,
      type: type2 || "participant"
    };
    if (prevActor && actors$1[prevActor]) {
      actors$1[prevActor].nextActor = id2;
    }
    prevActor = id2;
  };
  const activationCount = (part) => {
    let i;
    let count2 = 0;
    for (i = 0; i < messages.length; i++) {
      if (messages[i].type === LINETYPE.ACTIVE_START) {
        if (messages[i].from.actor === part) {
          count2++;
        }
      }
      if (messages[i].type === LINETYPE.ACTIVE_END) {
        if (messages[i].from.actor === part) {
          count2--;
        }
      }
    }
    return count2;
  };
  const addMessage = function(idFrom, idTo, message2, answer) {
    messages.push({
      from: idFrom,
      to: idTo,
      message: message2.text,
      wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
      answer
    });
  };
  const addSignal = function(idFrom, idTo, message2 = { text: void 0, wrap: void 0 }, messageType) {
    if (messageType === LINETYPE.ACTIVE_END) {
      const cnt2 = activationCount(idFrom.actor);
      if (cnt2 < 1) {
        let error = new Error("Trying to inactivate an inactive participant (" + idFrom.actor + ")");
        error.hash = {
          text: "->>-",
          token: "->>-",
          line: "1",
          loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
          expected: ["'ACTIVE_PARTICIPANT'"]
        };
        throw error;
      }
    }
    messages.push({
      from: idFrom,
      to: idTo,
      message: message2.text,
      wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
      type: messageType
    });
    return true;
  };
  const getMessages = function() {
    return messages;
  };
  const getActors$1 = function() {
    return actors$1;
  };
  const getActor = function(id2) {
    return actors$1[id2];
  };
  const getActorKeys = function() {
    return Object.keys(actors$1);
  };
  const enableSequenceNumbers = function() {
    sequenceNumbersEnabled = true;
  };
  const disableSequenceNumbers = function() {
    sequenceNumbersEnabled = false;
  };
  const showSequenceNumbers = () => sequenceNumbersEnabled;
  const setWrap = function(wrapSetting) {
    wrapEnabled = wrapSetting;
  };
  const autoWrap = () => {
    if (typeof wrapEnabled !== "undefined") {
      return wrapEnabled;
    }
    return getConfig$1().sequence.wrap;
  };
  const clear$2 = function() {
    actors$1 = {};
    messages = [];
    sequenceNumbersEnabled = false;
    clear$g();
  };
  const parseMessage = function(str) {
    const _str = str.trim();
    const message2 = {
      text: _str.replace(/^[:]?(?:no)?wrap:/, "").trim(),
      wrap: _str.match(/^[:]?wrap:/) !== null ? true : _str.match(/^[:]?nowrap:/) !== null ? false : void 0
    };
    log$3.debug("parseMessage:", message2);
    return message2;
  };
  const LINETYPE = {
    SOLID: 0,
    DOTTED: 1,
    NOTE: 2,
    SOLID_CROSS: 3,
    DOTTED_CROSS: 4,
    SOLID_OPEN: 5,
    DOTTED_OPEN: 6,
    LOOP_START: 10,
    LOOP_END: 11,
    ALT_START: 12,
    ALT_ELSE: 13,
    ALT_END: 14,
    OPT_START: 15,
    OPT_END: 16,
    ACTIVE_START: 17,
    ACTIVE_END: 18,
    PAR_START: 19,
    PAR_AND: 20,
    PAR_END: 21,
    RECT_START: 22,
    RECT_END: 23,
    SOLID_POINT: 24,
    DOTTED_POINT: 25,
    AUTONUMBER: 26,
    CRITICAL_START: 27,
    CRITICAL_OPTION: 28,
    CRITICAL_END: 29,
    BREAK_START: 30,
    BREAK_END: 31
  };
  const ARROWTYPE = {
    FILLED: 0,
    OPEN: 1
  };
  const PLACEMENT = {
    LEFTOF: 0,
    RIGHTOF: 1,
    OVER: 2
  };
  const addNote = function(actor, placement, message2) {
    ({
      actor,
      placement,
      message: message2.text,
      wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap
    });
    const actors2 = [].concat(actor, actor);
    messages.push({
      from: actors2[0],
      to: actors2[1],
      message: message2.text,
      wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
      type: LINETYPE.NOTE,
      placement
    });
  };
  const addLinks = function(actorId, text2) {
    const actor = getActor(actorId);
    try {
      let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
      sanitizedText = sanitizedText.replace(/&amp;/g, "&");
      sanitizedText = sanitizedText.replace(/&equals;/g, "=");
      const links2 = JSON.parse(sanitizedText);
      insertLinks(actor, links2);
    } catch (e) {
      log$3.error("error while parsing actor link text", e);
    }
  };
  const addALink = function(actorId, text2) {
    const actor = getActor(actorId);
    try {
      const links2 = {};
      let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
      var sep = sanitizedText.indexOf("@");
      sanitizedText = sanitizedText.replace(/&amp;/g, "&");
      sanitizedText = sanitizedText.replace(/&equals;/g, "=");
      var label = sanitizedText.slice(0, sep - 1).trim();
      var link2 = sanitizedText.slice(sep + 1).trim();
      links2[label] = link2;
      insertLinks(actor, links2);
    } catch (e) {
      log$3.error("error while parsing actor link text", e);
    }
  };
  function insertLinks(actor, links2) {
    if (actor.links == null) {
      actor.links = links2;
    } else {
      for (let key in links2) {
        actor.links[key] = links2[key];
      }
    }
  }
  const addProperties = function(actorId, text2) {
    const actor = getActor(actorId);
    try {
      let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
      const properties = JSON.parse(sanitizedText);
      insertProperties(actor, properties);
    } catch (e) {
      log$3.error("error while parsing actor properties text", e);
    }
  };
  function insertProperties(actor, properties) {
    if (actor.properties == null) {
      actor.properties = properties;
    } else {
      for (let key in properties) {
        actor.properties[key] = properties[key];
      }
    }
  }
  const addDetails = function(actorId, text2) {
    const actor = getActor(actorId);
    const elem = document.getElementById(text2.text);
    try {
      const text3 = elem.innerHTML;
      const details = JSON.parse(text3);
      if (details["properties"]) {
        insertProperties(actor, details["properties"]);
      }
      if (details["links"]) {
        insertLinks(actor, details["links"]);
      }
    } catch (e) {
      log$3.error("error while parsing actor details text", e);
    }
  };
  const getActorProperty = function(actor, key) {
    if (typeof actor !== "undefined" && typeof actor.properties !== "undefined") {
      return actor.properties[key];
    }
    return void 0;
  };
  const apply = function(param) {
    if (param instanceof Array) {
      param.forEach(function(item) {
        apply(item);
      });
    } else {
      switch (param.type) {
        case "sequenceIndex":
          messages.push({
            from: void 0,
            to: void 0,
            message: {
              start: param.sequenceIndex,
              step: param.sequenceIndexStep,
              visible: param.sequenceVisible
            },
            wrap: false,
            type: param.signalType
          });
          break;
        case "addParticipant":
          addActor(param.actor, param.actor, param.description, "participant");
          break;
        case "addActor":
          addActor(param.actor, param.actor, param.description, "actor");
          break;
        case "activeStart":
          addSignal(param.actor, void 0, void 0, param.signalType);
          break;
        case "activeEnd":
          addSignal(param.actor, void 0, void 0, param.signalType);
          break;
        case "addNote":
          addNote(param.actor, param.placement, param.text);
          break;
        case "addLinks":
          addLinks(param.actor, param.text);
          break;
        case "addALink":
          addALink(param.actor, param.text);
          break;
        case "addProperties":
          addProperties(param.actor, param.text);
          break;
        case "addDetails":
          addDetails(param.actor, param.text);
          break;
        case "addMessage":
          addSignal(param.from, param.to, param.msg, param.signalType);
          break;
        case "loopStart":
          addSignal(void 0, void 0, param.loopText, param.signalType);
          break;
        case "loopEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "rectStart":
          addSignal(void 0, void 0, param.color, param.signalType);
          break;
        case "rectEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "optStart":
          addSignal(void 0, void 0, param.optText, param.signalType);
          break;
        case "optEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "altStart":
          addSignal(void 0, void 0, param.altText, param.signalType);
          break;
        case "else":
          addSignal(void 0, void 0, param.altText, param.signalType);
          break;
        case "altEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "setAccTitle":
          setAccTitle(param.text);
          break;
        case "parStart":
          addSignal(void 0, void 0, param.parText, param.signalType);
          break;
        case "and":
          addSignal(void 0, void 0, param.parText, param.signalType);
          break;
        case "parEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "criticalStart":
          addSignal(void 0, void 0, param.criticalText, param.signalType);
          break;
        case "option":
          addSignal(void 0, void 0, param.optionText, param.signalType);
          break;
        case "criticalEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
        case "breakStart":
          addSignal(void 0, void 0, param.breakText, param.signalType);
          break;
        case "breakEnd":
          addSignal(void 0, void 0, void 0, param.signalType);
          break;
      }
    }
  };
  const sequenceDb = {
    addActor,
    addMessage,
    addSignal,
    addLinks,
    addDetails,
    addProperties,
    autoWrap,
    setWrap,
    enableSequenceNumbers,
    disableSequenceNumbers,
    showSequenceNumbers,
    getMessages,
    getActors: getActors$1,
    getActor,
    getActorKeys,
    getActorProperty,
    getAccTitle,
    getDiagramTitle,
    setDiagramTitle,
    parseDirective: parseDirective$3,
    getConfig: () => getConfig$1().sequence,
    clear: clear$2,
    parseMessage,
    LINETYPE,
    ARROWTYPE,
    PLACEMENT,
    addNote,
    setAccTitle,
    apply,
    setAccDescription,
    getAccDescription
  };
  let interactionFunctions = [];
  const addFunction = (func) => {
    interactionFunctions.push(func);
  };
  const attachFunctions = () => {
    interactionFunctions.forEach((f) => {
      f();
    });
    interactionFunctions = [];
  };
  const drawRect$1 = function(elem, rectData) {
    const rectElem = elem.append("rect");
    rectElem.attr("x", rectData.x);
    rectElem.attr("y", rectData.y);
    rectElem.attr("fill", rectData.fill);
    rectElem.attr("stroke", rectData.stroke);
    rectElem.attr("width", rectData.width);
    rectElem.attr("height", rectData.height);
    rectElem.attr("rx", rectData.rx);
    rectElem.attr("ry", rectData.ry);
    if (typeof rectData.class !== "undefined") {
      rectElem.attr("class", rectData.class);
    }
    return rectElem;
  };
  const addPopupInteraction = (id2, actorCnt2) => {
    addFunction(() => {
      const arr = document.querySelectorAll(id2);
      if (arr.length === 0)
        return;
      arr[0].addEventListener("mouseover", function() {
        popupMenuUpFunc("actor" + actorCnt2 + "_popup");
      });
      arr[0].addEventListener("mouseout", function() {
        popupMenuDownFunc("actor" + actorCnt2 + "_popup");
      });
    });
  };
  const drawPopup = function(elem, actor, minMenuWidth, textAttrs, forceMenus) {
    if (actor.links === void 0 || actor.links === null || Object.keys(actor.links).length === 0) {
      return { height: 0, width: 0 };
    }
    const links2 = actor.links;
    const actorCnt2 = actor.actorCnt;
    const rectData = actor.rectData;
    var displayValue = "none";
    if (forceMenus) {
      displayValue = "block !important";
    }
    const g = elem.append("g");
    g.attr("id", "actor" + actorCnt2 + "_popup");
    g.attr("class", "actorPopupMenu");
    g.attr("display", displayValue);
    addPopupInteraction("#actor" + actorCnt2 + "_popup", actorCnt2);
    var actorClass = "";
    if (typeof rectData.class !== "undefined") {
      actorClass = " " + rectData.class;
    }
    let menuWidth = rectData.width > minMenuWidth ? rectData.width : minMenuWidth;
    const rectElem = g.append("rect");
    rectElem.attr("class", "actorPopupMenuPanel" + actorClass);
    rectElem.attr("x", rectData.x);
    rectElem.attr("y", rectData.height);
    rectElem.attr("fill", rectData.fill);
    rectElem.attr("stroke", rectData.stroke);
    rectElem.attr("width", menuWidth);
    rectElem.attr("height", rectData.height);
    rectElem.attr("rx", rectData.rx);
    rectElem.attr("ry", rectData.ry);
    if (links2 != null) {
      var linkY = 20;
      for (let key in links2) {
        var linkElem = g.append("a");
        var sanitizedLink = sanitizeUrl_1(links2[key]);
        linkElem.attr("xlink:href", sanitizedLink);
        linkElem.attr("target", "_blank");
        _drawMenuItemTextCandidateFunc(textAttrs)(
          key,
          linkElem,
          rectData.x + 10,
          rectData.height + linkY,
          menuWidth,
          20,
          { class: "actor" },
          textAttrs
        );
        linkY += 30;
      }
    }
    rectElem.attr("height", linkY);
    return { height: rectData.height + linkY, width: menuWidth };
  };
  const drawImage = function(elem, x2, y2, link2) {
    const imageElem = elem.append("image");
    imageElem.attr("x", x2);
    imageElem.attr("y", y2);
    var sanitizedLink = sanitizeUrl_1(link2);
    imageElem.attr("xlink:href", sanitizedLink);
  };
  const drawEmbeddedImage = function(elem, x2, y2, link2) {
    const imageElem = elem.append("use");
    imageElem.attr("x", x2);
    imageElem.attr("y", y2);
    var sanitizedLink = sanitizeUrl_1(link2);
    imageElem.attr("xlink:href", "#" + sanitizedLink);
  };
  const popupMenu = function(popid) {
    return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'block'; }";
  };
  const popdownMenu = function(popid) {
    return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'none'; }";
  };
  const popupMenuUpFunc = function(popupId) {
    var pu = document.getElementById(popupId);
    if (pu != null) {
      pu.style.display = "block";
    }
  };
  const popupMenuDownFunc = function(popupId) {
    var pu = document.getElementById(popupId);
    if (pu != null) {
      pu.style.display = "none";
    }
  };
  const drawText$1 = function(elem, textData) {
    let prevTextHeight = 0, textHeight = 0;
    const lines = textData.text.split(common.lineBreakRegex);
    let textElems = [];
    let dy = 0;
    let yfunc = () => textData.y;
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      switch (textData.valign) {
        case "top":
        case "start":
          yfunc = () => Math.round(textData.y + textData.textMargin);
          break;
        case "middle":
        case "center":
          yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
          break;
        case "bottom":
        case "end":
          yfunc = () => Math.round(
            textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
          );
          break;
      }
    }
    if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
      switch (textData.anchor) {
        case "left":
        case "start":
          textData.x = Math.round(textData.x + textData.textMargin);
          textData.anchor = "start";
          textData.dominantBaseline = "middle";
          textData.alignmentBaseline = "middle";
          break;
        case "middle":
        case "center":
          textData.x = Math.round(textData.x + textData.width / 2);
          textData.anchor = "middle";
          textData.dominantBaseline = "middle";
          textData.alignmentBaseline = "middle";
          break;
        case "right":
        case "end":
          textData.x = Math.round(textData.x + textData.width - textData.textMargin);
          textData.anchor = "end";
          textData.dominantBaseline = "middle";
          textData.alignmentBaseline = "middle";
          break;
      }
    }
    for (let i = 0; i < lines.length; i++) {
      let line2 = lines[i];
      if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
        dy = i * textData.fontSize;
      }
      const textElem = elem.append("text");
      textElem.attr("x", textData.x);
      textElem.attr("y", yfunc());
      if (typeof textData.anchor !== "undefined") {
        textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
      }
      if (typeof textData.fontFamily !== "undefined") {
        textElem.style("font-family", textData.fontFamily);
      }
      if (typeof textData.fontSize !== "undefined") {
        textElem.style("font-size", textData.fontSize);
      }
      if (typeof textData.fontWeight !== "undefined") {
        textElem.style("font-weight", textData.fontWeight);
      }
      if (typeof textData.fill !== "undefined") {
        textElem.attr("fill", textData.fill);
      }
      if (typeof textData.class !== "undefined") {
        textElem.attr("class", textData.class);
      }
      if (typeof textData.dy !== "undefined") {
        textElem.attr("dy", textData.dy);
      } else if (dy !== 0) {
        textElem.attr("dy", dy);
      }
      if (textData.tspan) {
        const span = textElem.append("tspan");
        span.attr("x", textData.x);
        if (typeof textData.fill !== "undefined") {
          span.attr("fill", textData.fill);
        }
        span.text(line2);
      } else {
        textElem.text(line2);
      }
      if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
        textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
        prevTextHeight = textHeight;
      }
      textElems.push(textElem);
    }
    return textElems;
  };
  const drawLabel$1 = function(elem, txtObject) {
    function genPoints(x2, y2, width2, height2, cut) {
      return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
    }
    const polygon = elem.append("polygon");
    polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
    polygon.attr("class", "labelBox");
    txtObject.y = txtObject.y + txtObject.height / 2;
    drawText$1(elem, txtObject);
    return polygon;
  };
  let actorCnt = -1;
  const fixLifeLineHeights = (diagram, bounds2) => {
    if (!diagram.selectAll)
      return;
    diagram.selectAll(".actor-line").attr("class", "200").attr("y2", bounds2 - 55);
  };
  const drawActorTypeParticipant = function(elem, actor, conf2) {
    const center2 = actor.x + actor.width / 2;
    const boxpluslineGroup = elem.append("g");
    var g = boxpluslineGroup;
    if (actor.y === 0) {
      actorCnt++;
      g.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 5).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
      g = boxpluslineGroup.append("g");
      actor.actorCnt = actorCnt;
      if (actor.links != null) {
        g.attr("id", "root-" + actorCnt);
        addPopupInteraction("#root-" + actorCnt, actorCnt);
      }
    }
    const rect2 = getNoteRect$1();
    var cssclass = "actor";
    if (actor.properties != null && actor.properties["class"]) {
      cssclass = actor.properties["class"];
    } else {
      rect2.fill = "#eaeaea";
    }
    rect2.x = actor.x;
    rect2.y = actor.y;
    rect2.width = actor.width;
    rect2.height = actor.height;
    rect2.class = cssclass;
    rect2.rx = 3;
    rect2.ry = 3;
    const rectElem = drawRect$1(g, rect2);
    actor.rectData = rect2;
    if (actor.properties != null && actor.properties["icon"]) {
      const iconSrc = actor.properties["icon"].trim();
      if (iconSrc.charAt(0) === "@") {
        drawEmbeddedImage(g, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc.substr(1));
      } else {
        drawImage(g, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc);
      }
    }
    _drawTextCandidateFunc$1(conf2)(
      actor.description,
      g,
      rect2.x,
      rect2.y,
      rect2.width,
      rect2.height,
      { class: "actor" },
      conf2
    );
    let height2 = actor.height;
    if (rectElem.node) {
      const bounds2 = rectElem.node().getBBox();
      actor.height = bounds2.height;
      height2 = bounds2.height;
    }
    return height2;
  };
  const drawActorTypeActor = function(elem, actor, conf2) {
    const center2 = actor.x + actor.width / 2;
    if (actor.y === 0) {
      actorCnt++;
      elem.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 80).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
    }
    const actElem = elem.append("g");
    actElem.attr("class", "actor-man");
    const rect2 = getNoteRect$1();
    rect2.x = actor.x;
    rect2.y = actor.y;
    rect2.fill = "#eaeaea";
    rect2.width = actor.width;
    rect2.height = actor.height;
    rect2.class = "actor";
    rect2.rx = 3;
    rect2.ry = 3;
    actElem.append("line").attr("id", "actor-man-torso" + actorCnt).attr("x1", center2).attr("y1", actor.y + 25).attr("x2", center2).attr("y2", actor.y + 45);
    actElem.append("line").attr("id", "actor-man-arms" + actorCnt).attr("x1", center2 - 18).attr("y1", actor.y + 33).attr("x2", center2 + 18).attr("y2", actor.y + 33);
    actElem.append("line").attr("x1", center2 - 18).attr("y1", actor.y + 60).attr("x2", center2).attr("y2", actor.y + 45);
    actElem.append("line").attr("x1", center2).attr("y1", actor.y + 45).attr("x2", center2 + 16).attr("y2", actor.y + 60);
    const circle2 = actElem.append("circle");
    circle2.attr("cx", actor.x + actor.width / 2);
    circle2.attr("cy", actor.y + 10);
    circle2.attr("r", 15);
    circle2.attr("width", actor.width);
    circle2.attr("height", actor.height);
    const bounds2 = actElem.node().getBBox();
    actor.height = bounds2.height;
    _drawTextCandidateFunc$1(conf2)(
      actor.description,
      actElem,
      rect2.x,
      rect2.y + 35,
      rect2.width,
      rect2.height,
      { class: "actor" },
      conf2
    );
    return actor.height;
  };
  const drawActor = function(elem, actor, conf2) {
    switch (actor.type) {
      case "actor":
        return drawActorTypeActor(elem, actor, conf2);
      case "participant":
        return drawActorTypeParticipant(elem, actor, conf2);
    }
  };
  const anchorElement = function(elem) {
    return elem.append("g");
  };
  const drawActivation = function(elem, bounds2, verticalPos, conf2, actorActivations2) {
    const rect2 = getNoteRect$1();
    const g = bounds2.anchored;
    rect2.x = bounds2.startx;
    rect2.y = bounds2.starty;
    rect2.class = "activation" + actorActivations2 % 3;
    rect2.width = bounds2.stopx - bounds2.startx;
    rect2.height = verticalPos - bounds2.starty;
    drawRect$1(g, rect2);
  };
  const drawLoop = function(elem, loopModel, labelText, conf2) {
    const {
      boxMargin,
      boxTextMargin,
      labelBoxHeight,
      labelBoxWidth,
      messageFontFamily: fontFamily,
      messageFontSize: fontSize,
      messageFontWeight: fontWeight
    } = conf2;
    const g = elem.append("g");
    const drawLoopLine = function(startx, starty, stopx, stopy) {
      return g.append("line").attr("x1", startx).attr("y1", starty).attr("x2", stopx).attr("y2", stopy).attr("class", "loopLine");
    };
    drawLoopLine(loopModel.startx, loopModel.starty, loopModel.stopx, loopModel.starty);
    drawLoopLine(loopModel.stopx, loopModel.starty, loopModel.stopx, loopModel.stopy);
    drawLoopLine(loopModel.startx, loopModel.stopy, loopModel.stopx, loopModel.stopy);
    drawLoopLine(loopModel.startx, loopModel.starty, loopModel.startx, loopModel.stopy);
    if (typeof loopModel.sections !== "undefined") {
      loopModel.sections.forEach(function(item) {
        drawLoopLine(loopModel.startx, item.y, loopModel.stopx, item.y).style(
          "stroke-dasharray",
          "3, 3"
        );
      });
    }
    let txt = getTextObj$1();
    txt.text = labelText;
    txt.x = loopModel.startx;
    txt.y = loopModel.starty;
    txt.fontFamily = fontFamily;
    txt.fontSize = fontSize;
    txt.fontWeight = fontWeight;
    txt.anchor = "middle";
    txt.valign = "middle";
    txt.tspan = false;
    txt.width = labelBoxWidth || 50;
    txt.height = labelBoxHeight || 20;
    txt.textMargin = boxTextMargin;
    txt.class = "labelText";
    drawLabel$1(g, txt);
    txt = getTextObj$1();
    txt.text = loopModel.title;
    txt.x = loopModel.startx + labelBoxWidth / 2 + (loopModel.stopx - loopModel.startx) / 2;
    txt.y = loopModel.starty + boxMargin + boxTextMargin;
    txt.anchor = "middle";
    txt.valign = "middle";
    txt.textMargin = boxTextMargin;
    txt.class = "loopText";
    txt.fontFamily = fontFamily;
    txt.fontSize = fontSize;
    txt.fontWeight = fontWeight;
    txt.wrap = true;
    let textElem = drawText$1(g, txt);
    if (typeof loopModel.sectionTitles !== "undefined") {
      loopModel.sectionTitles.forEach(function(item, idx) {
        if (item.message) {
          txt.text = item.message;
          txt.x = loopModel.startx + (loopModel.stopx - loopModel.startx) / 2;
          txt.y = loopModel.sections[idx].y + boxMargin + boxTextMargin;
          txt.class = "loopText";
          txt.anchor = "middle";
          txt.valign = "middle";
          txt.tspan = false;
          txt.fontFamily = fontFamily;
          txt.fontSize = fontSize;
          txt.fontWeight = fontWeight;
          txt.wrap = loopModel.wrap;
          textElem = drawText$1(g, txt);
          let sectionHeight = Math.round(
            textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
          );
          loopModel.sections[idx].height += sectionHeight - (boxMargin + boxTextMargin);
        }
      });
    }
    loopModel.height = Math.round(loopModel.stopy - loopModel.starty);
    return g;
  };
  const drawBackgroundRect$1 = function(elem, bounds2) {
    const rectElem = drawRect$1(elem, {
      x: bounds2.startx,
      y: bounds2.starty,
      width: bounds2.stopx - bounds2.startx,
      height: bounds2.stopy - bounds2.starty,
      fill: bounds2.fill,
      class: "rect"
    });
    rectElem.lower();
  };
  const insertDatabaseIcon = function(elem) {
    elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
    );
  };
  const insertComputerIcon = function(elem) {
    elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
    );
  };
  const insertClockIcon = function(elem) {
    elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
      "d",
      "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
    );
  };
  const insertArrowHead = function(elem) {
    elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
  };
  const insertArrowFilledHead = function(elem) {
    elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
  };
  const insertSequenceNumber = function(elem) {
    elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
  };
  const insertArrowCrossHead = function(elem) {
    const defs = elem.append("defs");
    const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
    marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
    marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
  };
  const getTextObj$1 = function() {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      anchor: void 0,
      style: "#666",
      width: void 0,
      height: void 0,
      textMargin: 0,
      rx: 0,
      ry: 0,
      tspan: true,
      valign: void 0
    };
  };
  const getNoteRect$1 = function() {
    return {
      x: 0,
      y: 0,
      fill: "#EDF2AE",
      stroke: "#666",
      width: 100,
      anchor: "start",
      height: 100,
      rx: 0,
      ry: 0
    };
  };
  const _drawTextCandidateFunc$1 = function() {
    function byText(content, g, x2, y2, width2, height2, textAttrs) {
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content);
      _setTextAttrs(text2, textAttrs);
    }
    function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
      let _actorFontSize = actorFontSize && actorFontSize.replace ? actorFontSize.replace("px", "") : actorFontSize;
      const lines = content.split(common.lineBreakRegex);
      for (let i = 0; i < lines.length; i++) {
        const dy = i * _actorFontSize - _actorFontSize * (lines.length - 1) / 2;
        const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
        text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
        text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
        _setTextAttrs(text2, textAttrs);
      }
    }
    function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const s2 = g.append("switch");
      const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
      const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
      text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
      byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
      _setTextAttrs(text2, textAttrs);
    }
    function _setTextAttrs(toText, fromTextAttrsDict) {
      for (const key in fromTextAttrsDict) {
        if (fromTextAttrsDict.hasOwnProperty(key)) {
          toText.attr(key, fromTextAttrsDict[key]);
        }
      }
    }
    return function(conf2) {
      return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
    };
  }();
  const _drawMenuItemTextCandidateFunc = function() {
    function byText(content, g, x2, y2, width2, height2, textAttrs) {
      const text2 = g.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").text(content);
      _setTextAttrs(text2, textAttrs);
    }
    function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
      const lines = content.split(common.lineBreakRegex);
      for (let i = 0; i < lines.length; i++) {
        const dy = i * actorFontSize - actorFontSize * (lines.length - 1) / 2;
        const text2 = g.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
        text2.append("tspan").attr("x", x2).attr("dy", dy).text(lines[i]);
        text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
        _setTextAttrs(text2, textAttrs);
      }
    }
    function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const s2 = g.append("switch");
      const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
      const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
      text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
      byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
      _setTextAttrs(text2, textAttrs);
    }
    function _setTextAttrs(toText, fromTextAttrsDict) {
      for (const key in fromTextAttrsDict) {
        if (fromTextAttrsDict.hasOwnProperty(key)) {
          toText.attr(key, fromTextAttrsDict[key]);
        }
      }
    }
    return function(conf2) {
      return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
    };
  }();
  const svgDraw$1 = {
    drawRect: drawRect$1,
    drawText: drawText$1,
    drawLabel: drawLabel$1,
    drawActor,
    drawPopup,
    drawImage,
    drawEmbeddedImage,
    anchorElement,
    drawActivation,
    drawLoop,
    drawBackgroundRect: drawBackgroundRect$1,
    insertArrowHead,
    insertArrowFilledHead,
    insertSequenceNumber,
    insertArrowCrossHead,
    insertDatabaseIcon,
    insertComputerIcon,
    insertClockIcon,
    getTextObj: getTextObj$1,
    getNoteRect: getNoteRect$1,
    popupMenu,
    popdownMenu,
    fixLifeLineHeights,
    sanitizeUrl: sanitizeUrl_1
  };
  let conf$4 = {};
  const bounds$1 = {
    data: {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    },
    verticalPos: 0,
    sequenceItems: [],
    activations: [],
    models: {
      getHeight: function() {
        return Math.max.apply(
          null,
          this.actors.length === 0 ? [0] : this.actors.map((actor) => actor.height || 0)
        ) + (this.loops.length === 0 ? 0 : this.loops.map((it) => it.height || 0).reduce((acc, h) => acc + h)) + (this.messages.length === 0 ? 0 : this.messages.map((it) => it.height || 0).reduce((acc, h) => acc + h)) + (this.notes.length === 0 ? 0 : this.notes.map((it) => it.height || 0).reduce((acc, h) => acc + h));
      },
      clear: function() {
        this.actors = [];
        this.loops = [];
        this.messages = [];
        this.notes = [];
      },
      addActor: function(actorModel) {
        this.actors.push(actorModel);
      },
      addLoop: function(loopModel) {
        this.loops.push(loopModel);
      },
      addMessage: function(msgModel) {
        this.messages.push(msgModel);
      },
      addNote: function(noteModel) {
        this.notes.push(noteModel);
      },
      lastActor: function() {
        return this.actors[this.actors.length - 1];
      },
      lastLoop: function() {
        return this.loops[this.loops.length - 1];
      },
      lastMessage: function() {
        return this.messages[this.messages.length - 1];
      },
      lastNote: function() {
        return this.notes[this.notes.length - 1];
      },
      actors: [],
      loops: [],
      messages: [],
      notes: []
    },
    init: function() {
      this.sequenceItems = [];
      this.activations = [];
      this.models.clear();
      this.data = {
        startx: void 0,
        stopx: void 0,
        starty: void 0,
        stopy: void 0
      };
      this.verticalPos = 0;
      setConf$4(getConfig$1());
    },
    updateVal: function(obj, key, val, fun) {
      if (typeof obj[key] === "undefined") {
        obj[key] = val;
      } else {
        obj[key] = fun(val, obj[key]);
      }
    },
    updateBounds: function(startx, starty, stopx, stopy) {
      const _self = this;
      let cnt2 = 0;
      function updateFn(type2) {
        return function updateItemBounds(item) {
          cnt2++;
          const n = _self.sequenceItems.length - cnt2 + 1;
          _self.updateVal(item, "starty", starty - n * conf$4.boxMargin, Math.min);
          _self.updateVal(item, "stopy", stopy + n * conf$4.boxMargin, Math.max);
          _self.updateVal(bounds$1.data, "startx", startx - n * conf$4.boxMargin, Math.min);
          _self.updateVal(bounds$1.data, "stopx", stopx + n * conf$4.boxMargin, Math.max);
          if (!(type2 === "activation")) {
            _self.updateVal(item, "startx", startx - n * conf$4.boxMargin, Math.min);
            _self.updateVal(item, "stopx", stopx + n * conf$4.boxMargin, Math.max);
            _self.updateVal(bounds$1.data, "starty", starty - n * conf$4.boxMargin, Math.min);
            _self.updateVal(bounds$1.data, "stopy", stopy + n * conf$4.boxMargin, Math.max);
          }
        };
      }
      this.sequenceItems.forEach(updateFn());
      this.activations.forEach(updateFn("activation"));
    },
    insert: function(startx, starty, stopx, stopy) {
      const _startx = Math.min(startx, stopx);
      const _stopx = Math.max(startx, stopx);
      const _starty = Math.min(starty, stopy);
      const _stopy = Math.max(starty, stopy);
      this.updateVal(bounds$1.data, "startx", _startx, Math.min);
      this.updateVal(bounds$1.data, "starty", _starty, Math.min);
      this.updateVal(bounds$1.data, "stopx", _stopx, Math.max);
      this.updateVal(bounds$1.data, "stopy", _stopy, Math.max);
      this.updateBounds(_startx, _starty, _stopx, _stopy);
    },
    newActivation: function(message2, diagram, actors2) {
      const actorRect = actors2[message2.from.actor];
      const stackedSize = actorActivations(message2.from.actor).length || 0;
      const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
      this.activations.push({
        startx: x2,
        starty: this.verticalPos + 2,
        stopx: x2 + conf$4.activationWidth,
        stopy: void 0,
        actor: message2.from.actor,
        anchored: svgDraw$1.anchorElement(diagram)
      });
    },
    endActivation: function(message2) {
      const lastActorActivationIdx = this.activations.map(function(activation) {
        return activation.actor;
      }).lastIndexOf(message2.from.actor);
      return this.activations.splice(lastActorActivationIdx, 1)[0];
    },
    createLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
      return {
        startx: void 0,
        starty: this.verticalPos,
        stopx: void 0,
        stopy: void 0,
        title: title2.message,
        wrap: title2.wrap,
        width: title2.width,
        height: 0,
        fill
      };
    },
    newLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
      this.sequenceItems.push(this.createLoop(title2, fill));
    },
    endLoop: function() {
      return this.sequenceItems.pop();
    },
    addSectionToLoop: function(message2) {
      const loop = this.sequenceItems.pop();
      loop.sections = loop.sections || [];
      loop.sectionTitles = loop.sectionTitles || [];
      loop.sections.push({ y: bounds$1.getVerticalPos(), height: 0 });
      loop.sectionTitles.push(message2);
      this.sequenceItems.push(loop);
    },
    bumpVerticalPos: function(bump) {
      this.verticalPos = this.verticalPos + bump;
      this.data.stopy = this.verticalPos;
    },
    getVerticalPos: function() {
      return this.verticalPos;
    },
    getBounds: function() {
      return { bounds: this.data, models: this.models };
    }
  };
  const drawNote$1 = function(elem, noteModel) {
    bounds$1.bumpVerticalPos(conf$4.boxMargin);
    noteModel.height = conf$4.boxMargin;
    noteModel.starty = bounds$1.getVerticalPos();
    const rect2 = svgDraw$1.getNoteRect();
    rect2.x = noteModel.startx;
    rect2.y = noteModel.starty;
    rect2.width = noteModel.width || conf$4.width;
    rect2.class = "note";
    const g = elem.append("g");
    const rectElem = svgDraw$1.drawRect(g, rect2);
    const textObj = svgDraw$1.getTextObj();
    textObj.x = noteModel.startx;
    textObj.y = noteModel.starty;
    textObj.width = rect2.width;
    textObj.dy = "1em";
    textObj.text = noteModel.message;
    textObj.class = "noteText";
    textObj.fontFamily = conf$4.noteFontFamily;
    textObj.fontSize = conf$4.noteFontSize;
    textObj.fontWeight = conf$4.noteFontWeight;
    textObj.anchor = conf$4.noteAlign;
    textObj.textMargin = conf$4.noteMargin;
    textObj.valign = "center";
    const textElem = drawText$1(g, textObj);
    const textHeight = Math.round(
      textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
    );
    rectElem.attr("height", textHeight + 2 * conf$4.noteMargin);
    noteModel.height += textHeight + 2 * conf$4.noteMargin;
    bounds$1.bumpVerticalPos(textHeight + 2 * conf$4.noteMargin);
    noteModel.stopy = noteModel.starty + textHeight + 2 * conf$4.noteMargin;
    noteModel.stopx = noteModel.startx + rect2.width;
    bounds$1.insert(noteModel.startx, noteModel.starty, noteModel.stopx, noteModel.stopy);
    bounds$1.models.addNote(noteModel);
  };
  const messageFont = (cnf) => {
    return {
      fontFamily: cnf.messageFontFamily,
      fontSize: cnf.messageFontSize,
      fontWeight: cnf.messageFontWeight
    };
  };
  const noteFont = (cnf) => {
    return {
      fontFamily: cnf.noteFontFamily,
      fontSize: cnf.noteFontSize,
      fontWeight: cnf.noteFontWeight
    };
  };
  const actorFont = (cnf) => {
    return {
      fontFamily: cnf.actorFontFamily,
      fontSize: cnf.actorFontSize,
      fontWeight: cnf.actorFontWeight
    };
  };
  const boundMessage = function(diagram, msgModel) {
    bounds$1.bumpVerticalPos(10);
    const { startx, stopx, message: message2 } = msgModel;
    const lines = common.splitBreaks(message2).length;
    const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
    const lineHeight = textDims.height / lines;
    msgModel.height += lineHeight;
    bounds$1.bumpVerticalPos(lineHeight);
    let lineStarty;
    let totalOffset = textDims.height - 10;
    const textWidth = textDims.width;
    if (startx === stopx) {
      lineStarty = bounds$1.getVerticalPos() + totalOffset;
      if (!conf$4.rightAngles) {
        totalOffset += conf$4.boxMargin;
        lineStarty = bounds$1.getVerticalPos() + totalOffset;
      }
      totalOffset += 30;
      const dx = Math.max(textWidth / 2, conf$4.width / 2);
      bounds$1.insert(
        startx - dx,
        bounds$1.getVerticalPos() - 10 + totalOffset,
        stopx + dx,
        bounds$1.getVerticalPos() + 30 + totalOffset
      );
    } else {
      totalOffset += conf$4.boxMargin;
      lineStarty = bounds$1.getVerticalPos() + totalOffset;
      bounds$1.insert(startx, lineStarty - 10, stopx, lineStarty);
    }
    bounds$1.bumpVerticalPos(totalOffset);
    msgModel.height += totalOffset;
    msgModel.stopy = msgModel.starty + msgModel.height;
    bounds$1.insert(msgModel.fromBounds, msgModel.starty, msgModel.toBounds, msgModel.stopy);
    return lineStarty;
  };
  const drawMessage = function(diagram, msgModel, lineStarty, diagObj) {
    const { startx, stopx, starty, message: message2, type: type2, sequenceIndex, sequenceVisible } = msgModel;
    const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
    const textObj = svgDraw$1.getTextObj();
    textObj.x = startx;
    textObj.y = starty + 10;
    textObj.width = stopx - startx;
    textObj.class = "messageText";
    textObj.dy = "1em";
    textObj.text = message2;
    textObj.fontFamily = conf$4.messageFontFamily;
    textObj.fontSize = conf$4.messageFontSize;
    textObj.fontWeight = conf$4.messageFontWeight;
    textObj.anchor = conf$4.messageAlign;
    textObj.valign = "center";
    textObj.textMargin = conf$4.wrapPadding;
    textObj.tspan = false;
    drawText$1(diagram, textObj);
    const textWidth = textDims.width;
    let line2;
    if (startx === stopx) {
      if (conf$4.rightAngles) {
        line2 = diagram.append("path").attr(
          "d",
          `M  ${startx},${lineStarty} H ${startx + Math.max(conf$4.width / 2, textWidth / 2)} V ${lineStarty + 25} H ${startx}`
        );
      } else {
        line2 = diagram.append("path").attr(
          "d",
          "M " + startx + "," + lineStarty + " C " + (startx + 60) + "," + (lineStarty - 10) + " " + (startx + 60) + "," + (lineStarty + 30) + " " + startx + "," + (lineStarty + 20)
        );
      }
    } else {
      line2 = diagram.append("line");
      line2.attr("x1", startx);
      line2.attr("y1", lineStarty);
      line2.attr("x2", stopx);
      line2.attr("y2", lineStarty);
    }
    if (type2 === diagObj.db.LINETYPE.DOTTED || type2 === diagObj.db.LINETYPE.DOTTED_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_POINT || type2 === diagObj.db.LINETYPE.DOTTED_OPEN) {
      line2.style("stroke-dasharray", "3, 3");
      line2.attr("class", "messageLine1");
    } else {
      line2.attr("class", "messageLine0");
    }
    let url = "";
    if (conf$4.arrowMarkerAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replace(/\(/g, "\\(");
      url = url.replace(/\)/g, "\\)");
    }
    line2.attr("stroke-width", 2);
    line2.attr("stroke", "none");
    line2.style("fill", "none");
    if (type2 === diagObj.db.LINETYPE.SOLID || type2 === diagObj.db.LINETYPE.DOTTED) {
      line2.attr("marker-end", "url(" + url + "#arrowhead)");
    }
    if (type2 === diagObj.db.LINETYPE.SOLID_POINT || type2 === diagObj.db.LINETYPE.DOTTED_POINT) {
      line2.attr("marker-end", "url(" + url + "#filled-head)");
    }
    if (type2 === diagObj.db.LINETYPE.SOLID_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_CROSS) {
      line2.attr("marker-end", "url(" + url + "#crosshead)");
    }
    if (sequenceVisible || conf$4.showSequenceNumbers) {
      line2.attr("marker-start", "url(" + url + "#sequencenumber)");
      diagram.append("text").attr("x", startx).attr("y", lineStarty + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(sequenceIndex);
    }
  };
  const drawActors = function(diagram, actors2, actorKeys, verticalPos, configuration, messages2) {
    if (configuration.hideUnusedParticipants === true) {
      const newActors = /* @__PURE__ */ new Set();
      messages2.forEach((message2) => {
        newActors.add(message2.from);
        newActors.add(message2.to);
      });
      actorKeys = actorKeys.filter((actorKey) => newActors.has(actorKey));
    }
    let prevWidth = 0;
    let prevMargin = 0;
    let maxHeight = 0;
    for (let i = 0; i < actorKeys.length; i++) {
      const actor = actors2[actorKeys[i]];
      actor.width = actor.width || conf$4.width;
      actor.height = Math.max(actor.height || conf$4.height, conf$4.height);
      actor.margin = actor.margin || conf$4.actorMargin;
      actor.x = prevWidth + prevMargin;
      actor.y = verticalPos;
      const height2 = svgDraw$1.drawActor(diagram, actor, conf$4);
      maxHeight = Math.max(maxHeight, height2);
      bounds$1.insert(actor.x, verticalPos, actor.x + actor.width, actor.height);
      prevWidth += actor.width;
      prevMargin += actor.margin;
      bounds$1.models.addActor(actor);
    }
    bounds$1.bumpVerticalPos(maxHeight);
  };
  const drawActorsPopup = function(diagram, actors2, actorKeys, doc) {
    let maxHeight = 0;
    let maxWidth = 0;
    for (let i = 0; i < actorKeys.length; i++) {
      const actor = actors2[actorKeys[i]];
      const minMenuWidth = getRequiredPopupWidth(actor);
      const menuDimensions = svgDraw$1.drawPopup(
        diagram,
        actor,
        minMenuWidth,
        conf$4,
        conf$4.forceMenus,
        doc
      );
      if (menuDimensions.height > maxHeight) {
        maxHeight = menuDimensions.height;
      }
      if (menuDimensions.width + actor.x > maxWidth) {
        maxWidth = menuDimensions.width + actor.x;
      }
    }
    return { maxHeight, maxWidth };
  };
  const setConf$4 = function(cnf) {
    assignWithDepth(conf$4, cnf);
    if (cnf.fontFamily) {
      conf$4.actorFontFamily = conf$4.noteFontFamily = conf$4.messageFontFamily = cnf.fontFamily;
    }
    if (cnf.fontSize) {
      conf$4.actorFontSize = conf$4.noteFontSize = conf$4.messageFontSize = cnf.fontSize;
    }
    if (cnf.fontWeight) {
      conf$4.actorFontWeight = conf$4.noteFontWeight = conf$4.messageFontWeight = cnf.fontWeight;
    }
  };
  const actorActivations = function(actor) {
    return bounds$1.activations.filter(function(activation) {
      return activation.actor === actor;
    });
  };
  const activationBounds = function(actor, actors2) {
    const actorObj = actors2[actor];
    const activations = actorActivations(actor);
    const left2 = activations.reduce(function(acc, activation) {
      return Math.min(acc, activation.startx);
    }, actorObj.x + actorObj.width / 2);
    const right2 = activations.reduce(function(acc, activation) {
      return Math.max(acc, activation.stopx);
    }, actorObj.x + actorObj.width / 2);
    return [left2, right2];
  };
  function adjustLoopHeightForWrap(loopWidths, msg, preMargin, postMargin, addLoopFn) {
    bounds$1.bumpVerticalPos(preMargin);
    let heightAdjust = postMargin;
    if (msg.id && msg.message && loopWidths[msg.id]) {
      const loopWidth = loopWidths[msg.id].width;
      const textConf = messageFont(conf$4);
      msg.message = utils.wrapLabel(`[${msg.message}]`, loopWidth - 2 * conf$4.wrapPadding, textConf);
      msg.width = loopWidth;
      msg.wrap = true;
      const textDims = utils.calculateTextDimensions(msg.message, textConf);
      const totalOffset = Math.max(textDims.height, conf$4.labelBoxHeight);
      heightAdjust = postMargin + totalOffset;
      log$3.debug(`${totalOffset} - ${msg.message}`);
    }
    addLoopFn(msg);
    bounds$1.bumpVerticalPos(heightAdjust);
  }
  const draw$4 = function(_text, id2, _version, diagObj) {
    const { securityLevel, sequence } = getConfig$1();
    conf$4 = sequence;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    bounds$1.init();
    log$3.debug(diagObj.db);
    const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select(`[id="${id2}"]`);
    const actors2 = diagObj.db.getActors();
    const actorKeys = diagObj.db.getActorKeys();
    const messages2 = diagObj.db.getMessages();
    const title2 = diagObj.db.getDiagramTitle();
    const maxMessageWidthPerActor = getMaxMessageWidthPerActor(actors2, messages2, diagObj);
    conf$4.height = calculateActorMargins(actors2, maxMessageWidthPerActor);
    svgDraw$1.insertComputerIcon(diagram);
    svgDraw$1.insertDatabaseIcon(diagram);
    svgDraw$1.insertClockIcon(diagram);
    drawActors(diagram, actors2, actorKeys, 0, conf$4, messages2);
    const loopWidths = calculateLoopBounds(messages2, actors2, maxMessageWidthPerActor, diagObj);
    svgDraw$1.insertArrowHead(diagram);
    svgDraw$1.insertArrowCrossHead(diagram);
    svgDraw$1.insertArrowFilledHead(diagram);
    svgDraw$1.insertSequenceNumber(diagram);
    function activeEnd(msg, verticalPos) {
      const activationData = bounds$1.endActivation(msg);
      if (activationData.starty + 18 > verticalPos) {
        activationData.starty = verticalPos - 6;
        verticalPos += 12;
      }
      svgDraw$1.drawActivation(
        diagram,
        activationData,
        verticalPos,
        conf$4,
        actorActivations(msg.from.actor).length
      );
      bounds$1.insert(activationData.startx, verticalPos - 10, activationData.stopx, verticalPos);
    }
    let sequenceIndex = 1;
    let sequenceIndexStep = 1;
    const messagesToDraw = [];
    messages2.forEach(function(msg) {
      let loopModel, noteModel, msgModel;
      switch (msg.type) {
        case diagObj.db.LINETYPE.NOTE:
          noteModel = msg.noteModel;
          drawNote$1(diagram, noteModel);
          break;
        case diagObj.db.LINETYPE.ACTIVE_START:
          bounds$1.newActivation(msg, diagram, actors2);
          break;
        case diagObj.db.LINETYPE.ACTIVE_END:
          activeEnd(msg, bounds$1.getVerticalPos());
          break;
        case diagObj.db.LINETYPE.LOOP_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.LOOP_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "loop", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        case diagObj.db.LINETYPE.RECT_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin,
            (message2) => bounds$1.newLoop(void 0, message2.message)
          );
          break;
        case diagObj.db.LINETYPE.RECT_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawBackgroundRect(diagram, loopModel);
          bounds$1.models.addLoop(loopModel);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          break;
        case diagObj.db.LINETYPE.OPT_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.OPT_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "opt", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        case diagObj.db.LINETYPE.ALT_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.ALT_ELSE:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin + conf$4.boxTextMargin,
            conf$4.boxMargin,
            (message2) => bounds$1.addSectionToLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.ALT_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "alt", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        case diagObj.db.LINETYPE.PAR_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.PAR_AND:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin + conf$4.boxTextMargin,
            conf$4.boxMargin,
            (message2) => bounds$1.addSectionToLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.PAR_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "par", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        case diagObj.db.LINETYPE.AUTONUMBER:
          sequenceIndex = msg.message.start || sequenceIndex;
          sequenceIndexStep = msg.message.step || sequenceIndexStep;
          if (msg.message.visible)
            diagObj.db.enableSequenceNumbers();
          else
            diagObj.db.disableSequenceNumbers();
          break;
        case diagObj.db.LINETYPE.CRITICAL_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.CRITICAL_OPTION:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin + conf$4.boxTextMargin,
            conf$4.boxMargin,
            (message2) => bounds$1.addSectionToLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.CRITICAL_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "critical", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        case diagObj.db.LINETYPE.BREAK_START:
          adjustLoopHeightForWrap(
            loopWidths,
            msg,
            conf$4.boxMargin,
            conf$4.boxMargin + conf$4.boxTextMargin,
            (message2) => bounds$1.newLoop(message2)
          );
          break;
        case diagObj.db.LINETYPE.BREAK_END:
          loopModel = bounds$1.endLoop();
          svgDraw$1.drawLoop(diagram, loopModel, "break", conf$4);
          bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
          bounds$1.models.addLoop(loopModel);
          break;
        default:
          try {
            msgModel = msg.msgModel;
            msgModel.starty = bounds$1.getVerticalPos();
            msgModel.sequenceIndex = sequenceIndex;
            msgModel.sequenceVisible = diagObj.db.showSequenceNumbers();
            const lineStarty = boundMessage(diagram, msgModel);
            messagesToDraw.push({ messageModel: msgModel, lineStarty });
            bounds$1.models.addMessage(msgModel);
          } catch (e) {
            log$3.error("error while drawing message", e);
          }
      }
      if ([
        diagObj.db.LINETYPE.SOLID_OPEN,
        diagObj.db.LINETYPE.DOTTED_OPEN,
        diagObj.db.LINETYPE.SOLID,
        diagObj.db.LINETYPE.DOTTED,
        diagObj.db.LINETYPE.SOLID_CROSS,
        diagObj.db.LINETYPE.DOTTED_CROSS,
        diagObj.db.LINETYPE.SOLID_POINT,
        diagObj.db.LINETYPE.DOTTED_POINT
      ].includes(msg.type)) {
        sequenceIndex = sequenceIndex + sequenceIndexStep;
      }
    });
    messagesToDraw.forEach((e) => drawMessage(diagram, e.messageModel, e.lineStarty, diagObj));
    if (conf$4.mirrorActors) {
      bounds$1.bumpVerticalPos(conf$4.boxMargin * 2);
      drawActors(diagram, actors2, actorKeys, bounds$1.getVerticalPos(), conf$4, messages2);
      bounds$1.bumpVerticalPos(conf$4.boxMargin);
      fixLifeLineHeights(diagram, bounds$1.getVerticalPos());
    }
    const requiredBoxSize = drawActorsPopup(diagram, actors2, actorKeys, doc);
    const { bounds: box } = bounds$1.getBounds();
    log$3.debug("For line height fix Querying: #" + id2 + " .actor-line");
    const actorLines = selectAll("#" + id2 + " .actor-line");
    actorLines.attr("y2", box.stopy);
    let boxHeight = box.stopy - box.starty;
    if (boxHeight < requiredBoxSize.maxHeight) {
      boxHeight = requiredBoxSize.maxHeight;
    }
    let height2 = boxHeight + 2 * conf$4.diagramMarginY;
    if (conf$4.mirrorActors) {
      height2 = height2 - conf$4.boxMargin + conf$4.bottomMarginAdj;
    }
    let boxWidth = box.stopx - box.startx;
    if (boxWidth < requiredBoxSize.maxWidth) {
      boxWidth = requiredBoxSize.maxWidth;
    }
    const width2 = boxWidth + 2 * conf$4.diagramMarginX;
    if (title2) {
      diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 2 * conf$4.diagramMarginX).attr("y", -25);
    }
    configureSvgSize(diagram, height2, width2, conf$4.useMaxWidth);
    const extraVertForTitle = title2 ? 40 : 0;
    diagram.attr(
      "viewBox",
      box.startx - conf$4.diagramMarginX + " -" + (conf$4.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
    );
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
    log$3.debug(`models:`, bounds$1.models);
  };
  const getMaxMessageWidthPerActor = function(actors2, messages2, diagObj) {
    const maxMessageWidthPerActor = {};
    messages2.forEach(function(msg) {
      if (actors2[msg.to] && actors2[msg.from]) {
        const actor = actors2[msg.to];
        if (msg.placement === diagObj.db.PLACEMENT.LEFTOF && !actor.prevActor) {
          return;
        }
        if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF && !actor.nextActor) {
          return;
        }
        const isNote = msg.placement !== void 0;
        const isMessage = !isNote;
        const textFont = isNote ? noteFont(conf$4) : messageFont(conf$4);
        const wrappedMessage = msg.wrap ? utils.wrapLabel(msg.message, conf$4.width - 2 * conf$4.wrapPadding, textFont) : msg.message;
        const messageDimensions = utils.calculateTextDimensions(wrappedMessage, textFont);
        const messageWidth = messageDimensions.width + 2 * conf$4.wrapPadding;
        if (isMessage && msg.from === actor.nextActor) {
          maxMessageWidthPerActor[msg.to] = Math.max(
            maxMessageWidthPerActor[msg.to] || 0,
            messageWidth
          );
        } else if (isMessage && msg.from === actor.prevActor) {
          maxMessageWidthPerActor[msg.from] = Math.max(
            maxMessageWidthPerActor[msg.from] || 0,
            messageWidth
          );
        } else if (isMessage && msg.from === msg.to) {
          maxMessageWidthPerActor[msg.from] = Math.max(
            maxMessageWidthPerActor[msg.from] || 0,
            messageWidth / 2
          );
          maxMessageWidthPerActor[msg.to] = Math.max(
            maxMessageWidthPerActor[msg.to] || 0,
            messageWidth / 2
          );
        } else if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
          maxMessageWidthPerActor[msg.from] = Math.max(
            maxMessageWidthPerActor[msg.from] || 0,
            messageWidth
          );
        } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
          maxMessageWidthPerActor[actor.prevActor] = Math.max(
            maxMessageWidthPerActor[actor.prevActor] || 0,
            messageWidth
          );
        } else if (msg.placement === diagObj.db.PLACEMENT.OVER) {
          if (actor.prevActor) {
            maxMessageWidthPerActor[actor.prevActor] = Math.max(
              maxMessageWidthPerActor[actor.prevActor] || 0,
              messageWidth / 2
            );
          }
          if (actor.nextActor) {
            maxMessageWidthPerActor[msg.from] = Math.max(
              maxMessageWidthPerActor[msg.from] || 0,
              messageWidth / 2
            );
          }
        }
      }
    });
    log$3.debug("maxMessageWidthPerActor:", maxMessageWidthPerActor);
    return maxMessageWidthPerActor;
  };
  const getRequiredPopupWidth = function(actor) {
    let requiredPopupWidth = 0;
    const textFont = actorFont(conf$4);
    for (const key in actor.links) {
      const labelDimensions = utils.calculateTextDimensions(key, textFont);
      const labelWidth = labelDimensions.width + 2 * conf$4.wrapPadding + 2 * conf$4.boxMargin;
      if (requiredPopupWidth < labelWidth) {
        requiredPopupWidth = labelWidth;
      }
    }
    return requiredPopupWidth;
  };
  const calculateActorMargins = function(actors2, actorToMessageWidth) {
    let maxHeight = 0;
    Object.keys(actors2).forEach((prop) => {
      const actor = actors2[prop];
      if (actor.wrap) {
        actor.description = utils.wrapLabel(
          actor.description,
          conf$4.width - 2 * conf$4.wrapPadding,
          actorFont(conf$4)
        );
      }
      const actDims = utils.calculateTextDimensions(actor.description, actorFont(conf$4));
      actor.width = actor.wrap ? conf$4.width : Math.max(conf$4.width, actDims.width + 2 * conf$4.wrapPadding);
      actor.height = actor.wrap ? Math.max(actDims.height, conf$4.height) : conf$4.height;
      maxHeight = Math.max(maxHeight, actor.height);
    });
    for (const actorKey in actorToMessageWidth) {
      const actor = actors2[actorKey];
      if (!actor) {
        continue;
      }
      const nextActor = actors2[actor.nextActor];
      if (!nextActor) {
        continue;
      }
      const messageWidth = actorToMessageWidth[actorKey];
      const actorWidth = messageWidth + conf$4.actorMargin - actor.width / 2 - nextActor.width / 2;
      actor.margin = Math.max(actorWidth, conf$4.actorMargin);
    }
    return Math.max(maxHeight, conf$4.height);
  };
  const buildNoteModel = function(msg, actors2, diagObj) {
    const startx = actors2[msg.from].x;
    const stopx = actors2[msg.to].x;
    const shouldWrap = msg.wrap && msg.message;
    let textDimensions = utils.calculateTextDimensions(
      shouldWrap ? utils.wrapLabel(msg.message, conf$4.width, noteFont(conf$4)) : msg.message,
      noteFont(conf$4)
    );
    const noteModel = {
      width: shouldWrap ? conf$4.width : Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin),
      height: 0,
      startx: actors2[msg.from].x,
      stopx: 0,
      starty: 0,
      stopy: 0,
      message: msg.message
    };
    if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
      noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width) : Math.max(
        actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
        textDimensions.width + 2 * conf$4.noteMargin
      );
      noteModel.startx = startx + (actors2[msg.from].width + conf$4.actorMargin) / 2;
    } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
      noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin) : Math.max(
        actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
        textDimensions.width + 2 * conf$4.noteMargin
      );
      noteModel.startx = startx - noteModel.width + (actors2[msg.from].width - conf$4.actorMargin) / 2;
    } else if (msg.to === msg.from) {
      textDimensions = utils.calculateTextDimensions(
        shouldWrap ? utils.wrapLabel(msg.message, Math.max(conf$4.width, actors2[msg.from].width), noteFont(conf$4)) : msg.message,
        noteFont(conf$4)
      );
      noteModel.width = shouldWrap ? Math.max(conf$4.width, actors2[msg.from].width) : Math.max(actors2[msg.from].width, conf$4.width, textDimensions.width + 2 * conf$4.noteMargin);
      noteModel.startx = startx + (actors2[msg.from].width - noteModel.width) / 2;
    } else {
      noteModel.width = Math.abs(startx + actors2[msg.from].width / 2 - (stopx + actors2[msg.to].width / 2)) + conf$4.actorMargin;
      noteModel.startx = startx < stopx ? startx + actors2[msg.from].width / 2 - conf$4.actorMargin / 2 : stopx + actors2[msg.to].width / 2 - conf$4.actorMargin / 2;
    }
    if (shouldWrap) {
      noteModel.message = utils.wrapLabel(
        msg.message,
        noteModel.width - 2 * conf$4.wrapPadding,
        noteFont(conf$4)
      );
    }
    log$3.debug(
      `NM:[${noteModel.startx},${noteModel.stopx},${noteModel.starty},${noteModel.stopy}:${noteModel.width},${noteModel.height}=${msg.message}]`
    );
    return noteModel;
  };
  const buildMessageModel = function(msg, actors2, diagObj) {
    let process = false;
    if ([
      diagObj.db.LINETYPE.SOLID_OPEN,
      diagObj.db.LINETYPE.DOTTED_OPEN,
      diagObj.db.LINETYPE.SOLID,
      diagObj.db.LINETYPE.DOTTED,
      diagObj.db.LINETYPE.SOLID_CROSS,
      diagObj.db.LINETYPE.DOTTED_CROSS,
      diagObj.db.LINETYPE.SOLID_POINT,
      diagObj.db.LINETYPE.DOTTED_POINT
    ].includes(msg.type)) {
      process = true;
    }
    if (!process) {
      return {};
    }
    const fromBounds = activationBounds(msg.from, actors2);
    const toBounds = activationBounds(msg.to, actors2);
    const fromIdx = fromBounds[0] <= toBounds[0] ? 1 : 0;
    const toIdx = fromBounds[0] < toBounds[0] ? 0 : 1;
    const allBounds = fromBounds.concat(toBounds);
    const boundedWidth = Math.abs(toBounds[toIdx] - fromBounds[fromIdx]);
    if (msg.wrap && msg.message) {
      msg.message = utils.wrapLabel(
        msg.message,
        Math.max(boundedWidth + 2 * conf$4.wrapPadding, conf$4.width),
        messageFont(conf$4)
      );
    }
    const msgDims = utils.calculateTextDimensions(msg.message, messageFont(conf$4));
    return {
      width: Math.max(
        msg.wrap ? 0 : msgDims.width + 2 * conf$4.wrapPadding,
        boundedWidth + 2 * conf$4.wrapPadding,
        conf$4.width
      ),
      height: 0,
      startx: fromBounds[fromIdx],
      stopx: toBounds[toIdx],
      starty: 0,
      stopy: 0,
      message: msg.message,
      type: msg.type,
      wrap: msg.wrap,
      fromBounds: Math.min.apply(null, allBounds),
      toBounds: Math.max.apply(null, allBounds)
    };
  };
  const calculateLoopBounds = function(messages2, actors2, _maxWidthPerActor, diagObj) {
    const loops = {};
    const stack2 = [];
    let current, noteModel, msgModel;
    messages2.forEach(function(msg) {
      msg.id = utils.random({ length: 10 });
      switch (msg.type) {
        case diagObj.db.LINETYPE.LOOP_START:
        case diagObj.db.LINETYPE.ALT_START:
        case diagObj.db.LINETYPE.OPT_START:
        case diagObj.db.LINETYPE.PAR_START:
        case diagObj.db.LINETYPE.CRITICAL_START:
        case diagObj.db.LINETYPE.BREAK_START:
          stack2.push({
            id: msg.id,
            msg: msg.message,
            from: Number.MAX_SAFE_INTEGER,
            to: Number.MIN_SAFE_INTEGER,
            width: 0
          });
          break;
        case diagObj.db.LINETYPE.ALT_ELSE:
        case diagObj.db.LINETYPE.PAR_AND:
        case diagObj.db.LINETYPE.CRITICAL_OPTION:
          if (msg.message) {
            current = stack2.pop();
            loops[current.id] = current;
            loops[msg.id] = current;
            stack2.push(current);
          }
          break;
        case diagObj.db.LINETYPE.LOOP_END:
        case diagObj.db.LINETYPE.ALT_END:
        case diagObj.db.LINETYPE.OPT_END:
        case diagObj.db.LINETYPE.PAR_END:
        case diagObj.db.LINETYPE.CRITICAL_END:
        case diagObj.db.LINETYPE.BREAK_END:
          current = stack2.pop();
          loops[current.id] = current;
          break;
        case diagObj.db.LINETYPE.ACTIVE_START:
          {
            const actorRect = actors2[msg.from ? msg.from.actor : msg.to.actor];
            const stackedSize = actorActivations(msg.from ? msg.from.actor : msg.to.actor).length;
            const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
            const toAdd = {
              startx: x2,
              stopx: x2 + conf$4.activationWidth,
              actor: msg.from.actor,
              enabled: true
            };
            bounds$1.activations.push(toAdd);
          }
          break;
        case diagObj.db.LINETYPE.ACTIVE_END:
          {
            const lastActorActivationIdx = bounds$1.activations.map((a2) => a2.actor).lastIndexOf(msg.from.actor);
            delete bounds$1.activations.splice(lastActorActivationIdx, 1)[0];
          }
          break;
      }
      const isNote = msg.placement !== void 0;
      if (isNote) {
        noteModel = buildNoteModel(msg, actors2, diagObj);
        msg.noteModel = noteModel;
        stack2.forEach((stk) => {
          current = stk;
          current.from = Math.min(current.from, noteModel.startx);
          current.to = Math.max(current.to, noteModel.startx + noteModel.width);
          current.width = Math.max(current.width, Math.abs(current.from - current.to)) - conf$4.labelBoxWidth;
        });
      } else {
        msgModel = buildMessageModel(msg, actors2, diagObj);
        msg.msgModel = msgModel;
        if (msgModel.startx && msgModel.stopx && stack2.length > 0) {
          stack2.forEach((stk) => {
            current = stk;
            if (msgModel.startx === msgModel.stopx) {
              const from2 = actors2[msg.from];
              const to = actors2[msg.to];
              current.from = Math.min(
                from2.x - msgModel.width / 2,
                from2.x - from2.width / 2,
                current.from
              );
              current.to = Math.max(to.x + msgModel.width / 2, to.x + from2.width / 2, current.to);
              current.width = Math.max(current.width, Math.abs(current.to - current.from)) - conf$4.labelBoxWidth;
            } else {
              current.from = Math.min(msgModel.startx, current.from);
              current.to = Math.max(msgModel.stopx, current.to);
              current.width = Math.max(current.width, msgModel.width) - conf$4.labelBoxWidth;
            }
          });
        }
      }
    });
    bounds$1.activations = [];
    log$3.debug("Loop type widths:", loops);
    return loops;
  };
  const sequenceRenderer = {
    bounds: bounds$1,
    drawActors,
    drawActorsPopup,
    setConf: setConf$4,
    draw: draw$4
  };
  var parser$1 = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 33], $Vc = [1, 23], $Vd = [1, 24], $Ve = [1, 25], $Vf = [1, 26], $Vg = [1, 27], $Vh = [1, 30], $Vi = [1, 31], $Vj = [1, 32], $Vk = [1, 35], $Vl = [1, 36], $Vm = [1, 37], $Vn = [1, 38], $Vo = [1, 34], $Vp = [1, 41], $Vq = [1, 4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vr = [1, 4, 5, 12, 13, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vs = [1, 4, 5, 7, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vt = [4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "SPACE": 4, "NL": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "idStatement": 11, "DESCR": 12, "-->": 13, "HIDE_EMPTY": 14, "scale": 15, "WIDTH": 16, "COMPOSIT_STATE": 17, "STRUCT_START": 18, "STRUCT_STOP": 19, "STATE_DESCR": 20, "AS": 21, "ID": 22, "FORK": 23, "JOIN": 24, "CHOICE": 25, "CONCURRENT": 26, "note": 27, "notePosition": 28, "NOTE_TEXT": 29, "direction": 30, "acc_title": 31, "acc_title_value": 32, "acc_descr": 33, "acc_descr_value": 34, "acc_descr_multiline_value": 35, "openDirective": 36, "typeDirective": 37, "closeDirective": 38, ":": 39, "argDirective": 40, "direction_tb": 41, "direction_bt": 42, "direction_rl": 43, "direction_lr": 44, "eol": 45, ";": 46, "EDGE_STATE": 47, "left_of": 48, "right_of": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "SPACE", 5: "NL", 7: "SD", 12: "DESCR", 13: "-->", 14: "HIDE_EMPTY", 15: "scale", 16: "WIDTH", 17: "COMPOSIT_STATE", 18: "STRUCT_START", 19: "STRUCT_STOP", 20: "STATE_DESCR", 21: "AS", 22: "ID", 23: "FORK", 24: "JOIN", 25: "CHOICE", 26: "CONCURRENT", 27: "note", 29: "NOTE_TEXT", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 39: ":", 41: "direction_tb", 42: "direction_bt", 43: "direction_rl", 44: "direction_lr", 46: ";", 47: "EDGE_STATE", 48: "left_of", 49: "right_of", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive" },
      productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [10, 1], [10, 2], [10, 3], [10, 4], [10, 1], [10, 2], [10, 1], [10, 4], [10, 3], [10, 6], [10, 1], [10, 1], [10, 1], [10, 1], [10, 4], [10, 4], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [6, 3], [6, 5], [30, 1], [30, 1], [30, 1], [30, 1], [45, 1], [45, 1], [11, 1], [11, 1], [28, 1], [28, 1], [36, 1], [37, 1], [40, 1], [38, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 4:
            yy.setRootDoc($$[$0]);
            return $$[$0];
          case 5:
            this.$ = [];
            break;
          case 6:
            if ($$[$0] != "nl") {
              $$[$0 - 1].push($$[$0]);
              this.$ = $$[$0 - 1];
            }
            break;
          case 7:
          case 8:
            this.$ = $$[$0];
            break;
          case 9:
            this.$ = "nl";
            break;
          case 10:
            this.$ = { stmt: "state", id: $$[$0], type: "default", description: "" };
            break;
          case 11:
            this.$ = { stmt: "state", id: $$[$0 - 1], type: "default", description: yy.trimColon($$[$0]) };
            break;
          case 12:
            this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 2], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0], type: "default", description: "" } };
            break;
          case 13:
            this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 3], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0 - 1], type: "default", description: "" }, description: $$[$0].substr(1).trim() };
            break;
          case 17:
            this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: "", doc: $$[$0 - 1] };
            break;
          case 18:
            var id2 = $$[$0];
            var description2 = $$[$0 - 2].trim();
            if ($$[$0].match(":")) {
              var parts = $$[$0].split(":");
              id2 = parts[0];
              description2 = [description2, parts[1]];
            }
            this.$ = { stmt: "state", id: id2, type: "default", description: description2 };
            break;
          case 19:
            this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: $$[$0 - 5], doc: $$[$0 - 1] };
            break;
          case 20:
            this.$ = { stmt: "state", id: $$[$0], type: "fork" };
            break;
          case 21:
            this.$ = { stmt: "state", id: $$[$0], type: "join" };
            break;
          case 22:
            this.$ = { stmt: "state", id: $$[$0], type: "choice" };
            break;
          case 23:
            this.$ = { stmt: "state", id: yy.getDividerId(), type: "divider" };
            break;
          case 24:
            this.$ = { stmt: "state", id: $$[$0 - 1].trim(), note: { position: $$[$0 - 2].trim(), text: $$[$0].trim() } };
            break;
          case 28:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 29:
          case 30:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 33:
            yy.setDirection("TB");
            this.$ = { stmt: "dir", value: "TB" };
            break;
          case 34:
            yy.setDirection("BT");
            this.$ = { stmt: "dir", value: "BT" };
            break;
          case 35:
            yy.setDirection("RL");
            this.$ = { stmt: "dir", value: "RL" };
            break;
          case 36:
            yy.setDirection("LR");
            this.$ = { stmt: "dir", value: "LR" };
            break;
          case 39:
          case 40:
            this.$ = $$[$0];
            break;
          case 43:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 44:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 45:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 46:
            yy.parseDirective("}%%", "close_directive", "state");
            break;
        }
      },
      table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, o([1, 4, 5, 14, 15, 17, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $V4, { 8: 11 }), { 37: 12, 51: [1, 13] }, { 51: [2, 43] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, { 38: 39, 39: [1, 40], 53: $Vp }, o([39, 53], [2, 44]), o($Vq, [2, 6]), { 6: 28, 10: 42, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 8]), o($Vq, [2, 9]), o($Vq, [2, 10], { 12: [1, 43], 13: [1, 44] }), o($Vq, [2, 14]), { 16: [1, 45] }, o($Vq, [2, 16], { 18: [1, 46] }), { 21: [1, 47] }, o($Vq, [2, 20]), o($Vq, [2, 21]), o($Vq, [2, 22]), o($Vq, [2, 23]), { 28: 48, 29: [1, 49], 48: [1, 50], 49: [1, 51] }, o($Vq, [2, 26]), o($Vq, [2, 27]), { 32: [1, 52] }, { 34: [1, 53] }, o($Vq, [2, 30]), o($Vr, [2, 39]), o($Vr, [2, 40]), o($Vq, [2, 33]), o($Vq, [2, 34]), o($Vq, [2, 35]), o($Vq, [2, 36]), o($Vs, [2, 31]), { 40: 54, 52: [1, 55] }, o($Vs, [2, 46]), o($Vq, [2, 7]), o($Vq, [2, 11]), { 11: 56, 22: $Vb, 47: $Vo }, o($Vq, [2, 15]), o($Vt, $V4, { 8: 57 }), { 22: [1, 58] }, { 22: [1, 59] }, { 21: [1, 60] }, { 22: [2, 41] }, { 22: [2, 42] }, o($Vq, [2, 28]), o($Vq, [2, 29]), { 38: 61, 53: $Vp }, { 53: [2, 45] }, o($Vq, [2, 12], { 12: [1, 62] }), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 63], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 18], { 18: [1, 64] }), { 29: [1, 65] }, { 22: [1, 66] }, o($Vs, [2, 32]), o($Vq, [2, 13]), o($Vq, [2, 17]), o($Vt, $V4, { 8: 67 }), o($Vq, [2, 24]), o($Vq, [2, 25]), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 68], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 19])],
      defaultActions: { 7: [2, 43], 8: [2, 1], 9: [2, 2], 10: [2, 3], 50: [2, 41], 51: [2, 42], 55: [2, 45] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              return 41;
            case 1:
              return 42;
            case 2:
              return 43;
            case 3:
              return 44;
            case 4:
              this.begin("open_directive");
              return 50;
            case 5:
              this.begin("type_directive");
              return 51;
            case 6:
              this.popState();
              this.begin("arg_directive");
              return 39;
            case 7:
              this.popState();
              this.popState();
              return 53;
            case 8:
              return 52;
            case 9:
              break;
            case 10:
              break;
            case 11:
              return 5;
            case 12:
              break;
            case 13:
              break;
            case 14:
              break;
            case 15:
              break;
            case 16:
              this.pushState("SCALE");
              return 15;
            case 17:
              return 16;
            case 18:
              this.popState();
              break;
            case 19:
              this.begin("acc_title");
              return 31;
            case 20:
              this.popState();
              return "acc_title_value";
            case 21:
              this.begin("acc_descr");
              return 33;
            case 22:
              this.popState();
              return "acc_descr_value";
            case 23:
              this.begin("acc_descr_multiline");
              break;
            case 24:
              this.popState();
              break;
            case 25:
              return "acc_descr_multiline_value";
            case 26:
              this.pushState("STATE");
              break;
            case 27:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -8).trim();
              return 23;
            case 28:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -8).trim();
              return 24;
            case 29:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -10).trim();
              return 25;
            case 30:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -8).trim();
              return 23;
            case 31:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -8).trim();
              return 24;
            case 32:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -10).trim();
              return 25;
            case 33:
              return 41;
            case 34:
              return 42;
            case 35:
              return 43;
            case 36:
              return 44;
            case 37:
              this.begin("STATE_STRING");
              break;
            case 38:
              this.popState();
              this.pushState("STATE_ID");
              return "AS";
            case 39:
              this.popState();
              return "ID";
            case 40:
              this.popState();
              break;
            case 41:
              return "STATE_DESCR";
            case 42:
              return 17;
            case 43:
              this.popState();
              break;
            case 44:
              this.popState();
              this.pushState("struct");
              return 18;
            case 45:
              this.popState();
              return 19;
            case 46:
              break;
            case 47:
              this.begin("NOTE");
              return 27;
            case 48:
              this.popState();
              this.pushState("NOTE_ID");
              return 48;
            case 49:
              this.popState();
              this.pushState("NOTE_ID");
              return 49;
            case 50:
              this.popState();
              this.pushState("FLOATING_NOTE");
              break;
            case 51:
              this.popState();
              this.pushState("FLOATING_NOTE_ID");
              return "AS";
            case 52:
              break;
            case 53:
              return "NOTE_TEXT";
            case 54:
              this.popState();
              return "ID";
            case 55:
              this.popState();
              this.pushState("NOTE_TEXT");
              return 22;
            case 56:
              this.popState();
              yy_.yytext = yy_.yytext.substr(2).trim();
              return 29;
            case 57:
              this.popState();
              yy_.yytext = yy_.yytext.slice(0, -8).trim();
              return 29;
            case 58:
              return 7;
            case 59:
              return 7;
            case 60:
              return 14;
            case 61:
              return 47;
            case 62:
              return 22;
            case 63:
              yy_.yytext = yy_.yytext.trim();
              return 12;
            case 64:
              return 13;
            case 65:
              return 26;
            case 66:
              return 5;
            case 67:
              return "INVALID";
          }
        },
        rules: [/^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { "LINE": { "rules": [13, 14], "inclusive": false }, "close_directive": { "rules": [13, 14], "inclusive": false }, "arg_directive": { "rules": [7, 8, 13, 14], "inclusive": false }, "type_directive": { "rules": [6, 7, 13, 14], "inclusive": false }, "open_directive": { "rules": [5, 13, 14], "inclusive": false }, "struct": { "rules": [13, 14, 26, 33, 34, 35, 36, 45, 46, 47, 61, 62, 63, 64, 65], "inclusive": false }, "FLOATING_NOTE_ID": { "rules": [54], "inclusive": false }, "FLOATING_NOTE": { "rules": [51, 52, 53], "inclusive": false }, "NOTE_TEXT": { "rules": [56, 57], "inclusive": false }, "NOTE_ID": { "rules": [55], "inclusive": false }, "NOTE": { "rules": [48, 49, 50], "inclusive": false }, "acc_descr_multiline": { "rules": [24, 25], "inclusive": false }, "acc_descr": { "rules": [22], "inclusive": false }, "acc_title": { "rules": [20], "inclusive": false }, "SCALE": { "rules": [17, 18], "inclusive": false }, "ALIAS": { "rules": [], "inclusive": false }, "STATE_ID": { "rules": [39], "inclusive": false }, "STATE_STRING": { "rules": [40, 41], "inclusive": false }, "FORK_STATE": { "rules": [], "inclusive": false }, "STATE": { "rules": [13, 14, 27, 28, 29, 30, 31, 32, 37, 38, 42, 43, 44], "inclusive": false }, "ID": { "rules": [13, 14], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 12, 14, 15, 16, 19, 21, 23, 26, 44, 47, 58, 59, 60, 61, 62, 63, 64, 66, 67], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser$1.parser = parser$1;
  const stateDetector = (txt, config2) => {
    var _a;
    if (((_a = config2 == null ? void 0 : config2.state) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
      return false;
    return txt.match(/^\s*stateDiagram/) !== null;
  };
  const stateDetectorV2 = (text2, config2) => {
    var _a;
    if (text2.match(/^\s*stateDiagram-v2/) !== null)
      return true;
    if (text2.match(/^\s*stateDiagram/) && ((_a = config2 == null ? void 0 : config2.state) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
      return true;
    return false;
  };
  const clone = (o) => JSON.parse(JSON.stringify(o));
  let rootDoc = [];
  const parseDirective$2 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const setRootDoc = (o) => {
    log$3.info("Setting root doc", o);
    rootDoc = o;
  };
  const getRootDoc = () => rootDoc;
  const docTranslator = (parent, node2, first) => {
    if (node2.stmt === "relation") {
      docTranslator(parent, node2.state1, true);
      docTranslator(parent, node2.state2, false);
    } else {
      if (node2.stmt === "state") {
        if (node2.id === "[*]") {
          node2.id = first ? parent.id + "_start" : parent.id + "_end";
          node2.start = first;
        }
      }
      if (node2.doc) {
        const doc = [];
        let i = 0;
        let currentDoc = [];
        for (i = 0; i < node2.doc.length; i++) {
          if (node2.doc[i].type === "divider") {
            const newNode = clone(node2.doc[i]);
            newNode.doc = clone(currentDoc);
            doc.push(newNode);
            currentDoc = [];
          } else {
            currentDoc.push(node2.doc[i]);
          }
        }
        if (doc.length > 0 && currentDoc.length > 0) {
          const newNode = {
            stmt: "state",
            id: generateId$1(),
            type: "divider",
            doc: clone(currentDoc)
          };
          doc.push(clone(newNode));
          node2.doc = doc;
        }
        node2.doc.forEach((docNode) => docTranslator(node2, docNode, true));
      }
    }
  };
  const getRootDocV2 = () => {
    docTranslator({ id: "root" }, { id: "root", doc: rootDoc }, true);
    return { id: "root", doc: rootDoc };
  };
  const extract = (_doc) => {
    let doc;
    if (_doc.doc) {
      doc = _doc.doc;
    } else {
      doc = _doc;
    }
    log$3.info(doc);
    clear$1(true);
    log$3.info("Extract", doc);
    doc.forEach((item) => {
      if (item.stmt === "state") {
        addState(item.id, item.type, item.doc, item.description, item.note);
      }
      if (item.stmt === "relation") {
        addRelation(item.state1.id, item.state2.id, item.description);
      }
    });
  };
  const newDoc = () => {
    return {
      relations: [],
      states: {},
      documents: {}
    };
  };
  let documents = {
    root: newDoc()
  };
  let currentDocument = documents.root;
  let startCnt = 0;
  const addState = function(id2, type2, doc, descr, note2) {
    if (typeof currentDocument.states[id2] === "undefined") {
      currentDocument.states[id2] = {
        id: id2,
        descriptions: [],
        type: type2,
        doc,
        note: note2
      };
    } else {
      if (!currentDocument.states[id2].doc) {
        currentDocument.states[id2].doc = doc;
      }
      if (!currentDocument.states[id2].type) {
        currentDocument.states[id2].type = type2;
      }
    }
    if (descr) {
      log$3.info("Adding state ", id2, descr);
      if (typeof descr === "string")
        addDescription(id2, descr.trim());
      if (typeof descr === "object") {
        descr.forEach((des) => addDescription(id2, des.trim()));
      }
    }
    if (note2) {
      currentDocument.states[id2].note = note2;
      currentDocument.states[id2].note.text = common.sanitizeText(
        currentDocument.states[id2].note.text,
        getConfig$1()
      );
    }
  };
  const clear$1 = function(saveCommon) {
    documents = {
      root: newDoc()
    };
    currentDocument = documents.root;
    currentDocument = documents.root;
    startCnt = 0;
    classes = [];
    if (!saveCommon) {
      clear$g();
    }
  };
  const getState = function(id2) {
    return currentDocument.states[id2];
  };
  const getStates = function() {
    return currentDocument.states;
  };
  const logDocuments = function() {
    log$3.info("Documents = ", documents);
  };
  const getRelations = function() {
    return currentDocument.relations;
  };
  const addRelation = function(_id1, _id2, title2) {
    let id1 = _id1;
    let id2 = _id2;
    let type1 = "default";
    let type2 = "default";
    if (_id1 === "[*]") {
      startCnt++;
      id1 = "start" + startCnt;
      type1 = "start";
    }
    if (_id2 === "[*]") {
      id2 = "end" + startCnt;
      type2 = "end";
    }
    addState(id1, type1);
    addState(id2, type2);
    currentDocument.relations.push({
      id1,
      id2,
      title: common.sanitizeText(title2, getConfig$1())
    });
  };
  const addDescription = function(id2, _descr) {
    const theState = currentDocument.states[id2];
    let descr = _descr;
    if (descr[0] === ":") {
      descr = descr.substr(1).trim();
    }
    theState.descriptions.push(common.sanitizeText(descr, getConfig$1()));
  };
  const cleanupLabel = function(label) {
    if (label.substring(0, 1) === ":") {
      return label.substr(2).trim();
    } else {
      return label.trim();
    }
  };
  const lineType = {
    LINE: 0,
    DOTTED_LINE: 1
  };
  let dividerCnt = 0;
  const getDividerId = () => {
    dividerCnt++;
    return "divider-id-" + dividerCnt;
  };
  let classes = [];
  const getClasses$1 = () => classes;
  let direction = "TB";
  const getDirection = () => direction;
  const setDirection = (dir) => {
    direction = dir;
  };
  const relationType = {
    AGGREGATION: 0,
    EXTENSION: 1,
    COMPOSITION: 2,
    DEPENDENCY: 3
  };
  const trimColon = (str) => str && str[0] === ":" ? str.substr(1).trim() : str.trim();
  const stateDb = {
    parseDirective: parseDirective$2,
    getConfig: () => getConfig$1().state,
    addState,
    clear: clear$1,
    getState,
    getStates,
    getRelations,
    getClasses: getClasses$1,
    getDirection,
    addRelation,
    getDividerId,
    setDirection,
    cleanupLabel,
    lineType,
    relationType,
    logDocuments,
    getRootDoc,
    setRootDoc,
    getRootDocV2,
    extract,
    trimColon,
    getAccTitle,
    setAccTitle,
    getAccDescription,
    setAccDescription
  };
  const drawStartState = (g) => g.append("circle").attr("class", "start-state").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit);
  const drawDivider = (g) => g.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", getConfig$1().state.textHeight).attr("class", "divider").attr("x2", getConfig$1().state.textHeight * 2).attr("y1", 0).attr("y2", 0);
  const drawSimpleState = (g, stateDef) => {
    const state = g.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 2 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
    const classBox = state.node().getBBox();
    g.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", classBox.width + 2 * getConfig$1().state.padding).attr("height", classBox.height + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
    return state;
  };
  const drawDescrState = (g, stateDef) => {
    const addTspan2 = function(textEl, txt, isFirst2) {
      const tSpan = textEl.append("tspan").attr("x", 2 * getConfig$1().state.padding).text(txt);
      if (!isFirst2) {
        tSpan.attr("dy", getConfig$1().state.textHeight);
      }
    };
    const title2 = g.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 1.3 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.descriptions[0]);
    const titleBox = title2.node().getBBox();
    const titleHeight = titleBox.height;
    const description2 = g.append("text").attr("x", getConfig$1().state.padding).attr(
      "y",
      titleHeight + getConfig$1().state.padding * 0.4 + getConfig$1().state.dividerMargin + getConfig$1().state.textHeight
    ).attr("class", "state-description");
    let isFirst = true;
    let isSecond = true;
    stateDef.descriptions.forEach(function(descr) {
      if (!isFirst) {
        addTspan2(description2, descr, isSecond);
        isSecond = false;
      }
      isFirst = false;
    });
    const descrLine = g.append("line").attr("x1", getConfig$1().state.padding).attr("y1", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("y2", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("class", "descr-divider");
    const descrBox = description2.node().getBBox();
    const width2 = Math.max(descrBox.width, titleBox.width);
    descrLine.attr("x2", width2 + 3 * getConfig$1().state.padding);
    g.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", width2 + 2 * getConfig$1().state.padding).attr("height", descrBox.height + titleHeight + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
    return g;
  };
  const addTitleAndBox = (g, stateDef, altBkg) => {
    const pad2 = getConfig$1().state.padding;
    const dblPad = 2 * getConfig$1().state.padding;
    const orgBox = g.node().getBBox();
    const orgWidth = orgBox.width;
    const orgX = orgBox.x;
    const title2 = g.append("text").attr("x", 0).attr("y", getConfig$1().state.titleShift).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
    const titleBox = title2.node().getBBox();
    const titleWidth = titleBox.width + dblPad;
    let width2 = Math.max(titleWidth, orgWidth);
    if (width2 === orgWidth) {
      width2 = width2 + dblPad;
    }
    let startX;
    const graphBox = g.node().getBBox();
    if (stateDef.doc)
      ;
    startX = orgX - pad2;
    if (titleWidth > orgWidth) {
      startX = (orgWidth - width2) / 2 + pad2;
    }
    if (Math.abs(orgX - graphBox.x) < pad2) {
      if (titleWidth > orgWidth) {
        startX = orgX - (titleWidth - orgWidth) / 2;
      }
    }
    const lineY = 1 - getConfig$1().state.textHeight;
    g.insert("rect", ":first-child").attr("x", startX).attr("y", lineY).attr("class", altBkg ? "alt-composit" : "composit").attr("width", width2).attr(
      "height",
      graphBox.height + getConfig$1().state.textHeight + getConfig$1().state.titleShift + 1
    ).attr("rx", "0");
    title2.attr("x", startX + pad2);
    if (titleWidth <= orgWidth)
      title2.attr("x", orgX + (width2 - dblPad) / 2 - titleWidth / 2 + pad2);
    g.insert("rect", ":first-child").attr("x", startX).attr(
      "y",
      getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
    ).attr("width", width2).attr("height", getConfig$1().state.textHeight * 3).attr("rx", getConfig$1().state.radius);
    g.insert("rect", ":first-child").attr("x", startX).attr(
      "y",
      getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
    ).attr("width", width2).attr("height", graphBox.height + 3 + 2 * getConfig$1().state.textHeight).attr("rx", getConfig$1().state.radius);
    return g;
  };
  const drawEndState = (g) => {
    g.append("circle").attr("class", "end-state-outer").attr("r", getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding).attr(
      "cx",
      getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
    ).attr(
      "cy",
      getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
    );
    return g.append("circle").attr("class", "end-state-inner").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2);
  };
  const drawForkJoinState = (g, stateDef) => {
    let width2 = getConfig$1().state.forkWidth;
    let height2 = getConfig$1().state.forkHeight;
    if (stateDef.parentId) {
      let tmp = width2;
      width2 = height2;
      height2 = tmp;
    }
    return g.append("rect").style("stroke", "black").style("fill", "black").attr("width", width2).attr("height", height2).attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding);
  };
  const _drawLongText = (_text, x2, y2, g) => {
    let textHeight = 0;
    const textElem = g.append("text");
    textElem.style("text-anchor", "start");
    textElem.attr("class", "noteText");
    let text2 = _text.replace(/\r\n/g, "<br/>");
    text2 = text2.replace(/\n/g, "<br/>");
    const lines = text2.split(common.lineBreakRegex);
    let tHeight = 1.25 * getConfig$1().state.noteMargin;
    for (const line2 of lines) {
      const txt = line2.trim();
      if (txt.length > 0) {
        const span = textElem.append("tspan");
        span.text(txt);
        if (tHeight === 0) {
          const textBounds = span.node().getBBox();
          tHeight += textBounds.height;
        }
        textHeight += tHeight;
        span.attr("x", x2 + getConfig$1().state.noteMargin);
        span.attr("y", y2 + textHeight + 1.25 * getConfig$1().state.noteMargin);
      }
    }
    return { textWidth: textElem.node().getBBox().width, textHeight };
  };
  const drawNote = (text2, g) => {
    g.attr("class", "state-note");
    const note2 = g.append("rect").attr("x", 0).attr("y", getConfig$1().state.padding);
    const rectElem = g.append("g");
    const { textWidth, textHeight } = _drawLongText(text2, 0, 0, rectElem);
    note2.attr("height", textHeight + 2 * getConfig$1().state.noteMargin);
    note2.attr("width", textWidth + getConfig$1().state.noteMargin * 2);
    return note2;
  };
  const drawState = function(elem, stateDef) {
    const id2 = stateDef.id;
    const stateInfo = {
      id: id2,
      label: stateDef.id,
      width: 0,
      height: 0
    };
    const g = elem.append("g").attr("id", id2).attr("class", "stateGroup");
    if (stateDef.type === "start")
      drawStartState(g);
    if (stateDef.type === "end")
      drawEndState(g);
    if (stateDef.type === "fork" || stateDef.type === "join")
      drawForkJoinState(g, stateDef);
    if (stateDef.type === "note")
      drawNote(stateDef.note.text, g);
    if (stateDef.type === "divider")
      drawDivider(g);
    if (stateDef.type === "default" && stateDef.descriptions.length === 0)
      drawSimpleState(g, stateDef);
    if (stateDef.type === "default" && stateDef.descriptions.length > 0)
      drawDescrState(g, stateDef);
    const stateBox = g.node().getBBox();
    stateInfo.width = stateBox.width + 2 * getConfig$1().state.padding;
    stateInfo.height = stateBox.height + 2 * getConfig$1().state.padding;
    return stateInfo;
  };
  let edgeCount = 0;
  const drawEdge = function(elem, path2, relation) {
    const getRelationType = function(type2) {
      switch (type2) {
        case stateDb.relationType.AGGREGATION:
          return "aggregation";
        case stateDb.relationType.EXTENSION:
          return "extension";
        case stateDb.relationType.COMPOSITION:
          return "composition";
        case stateDb.relationType.DEPENDENCY:
          return "dependency";
      }
    };
    path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
    const lineData = path2.points;
    const lineFunction = line$1().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    }).curve(curveBasis);
    const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount).attr("class", "transition");
    let url = "";
    if (getConfig$1().state.arrowMarkerAbsolute) {
      url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
      url = url.replace(/\(/g, "\\(");
      url = url.replace(/\)/g, "\\)");
    }
    svgPath.attr(
      "marker-end",
      "url(" + url + "#" + getRelationType(stateDb.relationType.DEPENDENCY) + "End)"
    );
    if (typeof relation.title !== "undefined") {
      const label = elem.append("g").attr("class", "stateLabel");
      const { x: x2, y: y2 } = utils.calcLabelPosition(path2.points);
      const rows = common.getRows(relation.title);
      let titleHeight = 0;
      const titleRows = [];
      let maxWidth = 0;
      let minX = 0;
      for (let i = 0; i <= rows.length; i++) {
        const title2 = label.append("text").attr("text-anchor", "middle").text(rows[i]).attr("x", x2).attr("y", y2 + titleHeight);
        const boundstmp = title2.node().getBBox();
        maxWidth = Math.max(maxWidth, boundstmp.width);
        minX = Math.min(minX, boundstmp.x);
        log$3.info(boundstmp.x, x2, y2 + titleHeight);
        if (titleHeight === 0) {
          const titleBox = title2.node().getBBox();
          titleHeight = titleBox.height;
          log$3.info("Title height", titleHeight, y2);
        }
        titleRows.push(title2);
      }
      let boxHeight = titleHeight * rows.length;
      if (rows.length > 1) {
        const heightAdj = (rows.length - 1) * titleHeight * 0.5;
        titleRows.forEach((title2, i) => title2.attr("y", y2 + i * titleHeight - heightAdj));
        boxHeight = titleHeight * rows.length;
      }
      const bounds2 = label.node().getBBox();
      label.insert("rect", ":first-child").attr("class", "box").attr("x", x2 - maxWidth / 2 - getConfig$1().state.padding / 2).attr("y", y2 - boxHeight / 2 - getConfig$1().state.padding / 2 - 3.5).attr("width", maxWidth + getConfig$1().state.padding).attr("height", boxHeight + getConfig$1().state.padding);
      log$3.info(bounds2);
    }
    edgeCount++;
  };
  let conf$3;
  const transformationLog = {};
  const setConf$3 = function() {
  };
  const insertMarkers = function(elem) {
    elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
  };
  const draw$3 = function(text2, id2, _version, diagObj) {
    conf$3 = getConfig$1().state;
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    log$3.debug("Rendering diagram " + text2);
    const diagram = root2.select(`[id='${id2}']`);
    insertMarkers(diagram);
    const graph2 = new graphlib$1.Graph({
      multigraph: true,
      compound: true,
      rankdir: "RL"
    });
    graph2.setDefaultEdgeLabel(function() {
      return {};
    });
    const rootDoc2 = diagObj.db.getRootDoc();
    renderDoc(rootDoc2, diagram, void 0, false, root2, doc, diagObj);
    const padding2 = conf$3.padding;
    const bounds2 = diagram.node().getBBox();
    const width2 = bounds2.width + padding2 * 2;
    const height2 = bounds2.height + padding2 * 2;
    const svgWidth = width2 * 1.75;
    configureSvgSize(diagram, height2, svgWidth, conf$3.useMaxWidth);
    diagram.attr(
      "viewBox",
      `${bounds2.x - conf$3.padding}  ${bounds2.y - conf$3.padding} ` + width2 + " " + height2
    );
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
  };
  const getLabelWidth = (text2) => {
    return text2 ? text2.length * conf$3.fontSizeFactor : 1;
  };
  const renderDoc = (doc, diagram, parentId, altBkg, root2, domDocument, diagObj) => {
    const graph2 = new graphlib$1.Graph({
      compound: true,
      multigraph: true
    });
    let i;
    let edgeFreeDoc = true;
    for (i = 0; i < doc.length; i++) {
      if (doc[i].stmt === "relation") {
        edgeFreeDoc = false;
        break;
      }
    }
    if (parentId)
      graph2.setGraph({
        rankdir: "LR",
        multigraph: true,
        compound: true,
        ranker: "tight-tree",
        ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
        nodeSep: edgeFreeDoc ? 1 : 50,
        isMultiGraph: true
      });
    else {
      graph2.setGraph({
        rankdir: "TB",
        multigraph: true,
        compound: true,
        ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
        nodeSep: edgeFreeDoc ? 1 : 50,
        ranker: "tight-tree",
        isMultiGraph: true
      });
    }
    graph2.setDefaultEdgeLabel(function() {
      return {};
    });
    diagObj.db.extract(doc);
    const states = diagObj.db.getStates();
    const relations2 = diagObj.db.getRelations();
    const keys = Object.keys(states);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const stateDef = states[keys[i2]];
      if (parentId) {
        stateDef.parentId = parentId;
      }
      let node2;
      if (stateDef.doc) {
        let sub = diagram.append("g").attr("id", stateDef.id).attr("class", "stateGroup");
        node2 = renderDoc(stateDef.doc, sub, stateDef.id, !altBkg, root2, domDocument, diagObj);
        {
          sub = addTitleAndBox(sub, stateDef, altBkg);
          let boxBounds = sub.node().getBBox();
          node2.width = boxBounds.width;
          node2.height = boxBounds.height + conf$3.padding / 2;
          transformationLog[stateDef.id] = { y: conf$3.compositTitleSize };
        }
      } else {
        node2 = drawState(diagram, stateDef);
      }
      if (stateDef.note) {
        const noteDef = {
          descriptions: [],
          id: stateDef.id + "-note",
          note: stateDef.note,
          type: "note"
        };
        const note2 = drawState(diagram, noteDef);
        if (stateDef.note.position === "left of") {
          graph2.setNode(node2.id + "-note", note2);
          graph2.setNode(node2.id, node2);
        } else {
          graph2.setNode(node2.id, node2);
          graph2.setNode(node2.id + "-note", note2);
        }
        graph2.setParent(node2.id, node2.id + "-group");
        graph2.setParent(node2.id + "-note", node2.id + "-group");
      } else {
        graph2.setNode(node2.id, node2);
      }
    }
    log$3.debug("Count=", graph2.nodeCount(), graph2);
    let cnt2 = 0;
    relations2.forEach(function(relation) {
      cnt2++;
      log$3.debug("Setting edge", relation);
      graph2.setEdge(
        relation.id1,
        relation.id2,
        {
          relation,
          width: getLabelWidth(relation.title),
          height: conf$3.labelHeight * common.getRows(relation.title).length,
          labelpos: "c"
        },
        "id" + cnt2
      );
    });
    dagreExports.layout(graph2);
    log$3.debug("Graph after layout", graph2.nodes());
    const svgElem = diagram.node();
    graph2.nodes().forEach(function(v) {
      if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
        log$3.warn("Node " + v + ": " + JSON.stringify(graph2.node(v)));
        root2.select("#" + svgElem.id + " #" + v).attr(
          "transform",
          "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y + (transformationLog[v] ? transformationLog[v].y : 0) - graph2.node(v).height / 2) + " )"
        );
        root2.select("#" + svgElem.id + " #" + v).attr("data-x-shift", graph2.node(v).x - graph2.node(v).width / 2);
        const dividers = domDocument.querySelectorAll("#" + svgElem.id + " #" + v + " .divider");
        dividers.forEach((divider2) => {
          const parent = divider2.parentElement;
          let pWidth = 0;
          let pShift = 0;
          if (parent) {
            if (parent.parentElement)
              pWidth = parent.parentElement.getBBox().width;
            pShift = parseInt(parent.getAttribute("data-x-shift"), 10);
            if (Number.isNaN(pShift)) {
              pShift = 0;
            }
          }
          divider2.setAttribute("x1", 0 - pShift + 8);
          divider2.setAttribute("x2", pWidth - pShift - 8);
        });
      } else {
        log$3.debug("No Node " + v + ": " + JSON.stringify(graph2.node(v)));
      }
    });
    let stateBox = svgElem.getBBox();
    graph2.edges().forEach(function(e) {
      if (typeof e !== "undefined" && typeof graph2.edge(e) !== "undefined") {
        log$3.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
        drawEdge(diagram, graph2.edge(e), graph2.edge(e).relation);
      }
    });
    stateBox = svgElem.getBBox();
    const stateInfo = {
      id: parentId ? parentId : "root",
      label: parentId ? parentId : "root",
      width: 0,
      height: 0
    };
    stateInfo.width = stateBox.width + 2 * conf$3.padding;
    stateInfo.height = stateBox.height + 2 * conf$3.padding;
    log$3.debug("Doc rendered", stateInfo, graph2);
    return stateInfo;
  };
  const stateRenderer = {
    setConf: setConf$3,
    draw: draw$3
  };
  const conf$2 = {};
  const setConf$2 = function(cnf) {
    const keys = Object.keys(cnf);
    for (let i = 0; i < keys.length; i++) {
      conf$2[keys[i]] = cnf[keys[i]];
    }
  };
  let nodeDb = {};
  const getClasses = function(text2, diag) {
    log$3.trace("Extracting classes");
    diag.sb.clear();
    diag.parser.parse(text2);
    return diag.sb.getClasses();
  };
  const setupNode = (g, parent, node2, altFlag) => {
    if (node2.id !== "root") {
      let shape = "rect";
      if (node2.start === true) {
        shape = "start";
      }
      if (node2.start === false) {
        shape = "end";
      }
      if (node2.type !== "default") {
        shape = node2.type;
      }
      if (!nodeDb[node2.id]) {
        nodeDb[node2.id] = {
          id: node2.id,
          shape,
          description: common.sanitizeText(node2.id, getConfig$1()),
          classes: "statediagram-state"
        };
      }
      if (node2.description) {
        if (Array.isArray(nodeDb[node2.id].description)) {
          nodeDb[node2.id].shape = "rectWithTitle";
          nodeDb[node2.id].description.push(node2.description);
        } else {
          if (nodeDb[node2.id].description.length > 0) {
            nodeDb[node2.id].shape = "rectWithTitle";
            if (nodeDb[node2.id].description === node2.id) {
              nodeDb[node2.id].description = [node2.description];
            } else {
              nodeDb[node2.id].description = [nodeDb[node2.id].description, node2.description];
            }
          } else {
            nodeDb[node2.id].shape = "rect";
            nodeDb[node2.id].description = node2.description;
          }
        }
        nodeDb[node2.id].description = common.sanitizeTextOrArray(
          nodeDb[node2.id].description,
          getConfig$1()
        );
      }
      if (nodeDb[node2.id].description.length === 1 && nodeDb[node2.id].shape === "rectWithTitle") {
        nodeDb[node2.id].shape = "rect";
      }
      if (!nodeDb[node2.id].type && node2.doc) {
        log$3.info("Setting cluster for ", node2.id, getDir(node2));
        nodeDb[node2.id].type = "group";
        nodeDb[node2.id].dir = getDir(node2);
        nodeDb[node2.id].shape = node2.type === "divider" ? "divider" : "roundedWithTitle";
        nodeDb[node2.id].classes = nodeDb[node2.id].classes + " " + (altFlag ? "statediagram-cluster statediagram-cluster-alt" : "statediagram-cluster");
      }
      const nodeData = {
        labelStyle: "",
        shape: nodeDb[node2.id].shape,
        labelText: nodeDb[node2.id].description,
        classes: nodeDb[node2.id].classes,
        style: "",
        id: node2.id,
        dir: nodeDb[node2.id].dir,
        domId: "state-" + node2.id + "-" + cnt,
        type: nodeDb[node2.id].type,
        padding: 15
      };
      if (node2.note) {
        const noteData = {
          labelStyle: "",
          shape: "note",
          labelText: node2.note.text,
          classes: "statediagram-note",
          style: "",
          id: node2.id + "----note-" + cnt,
          domId: "state-" + node2.id + "----note-" + cnt,
          type: nodeDb[node2.id].type,
          padding: 15
        };
        const groupData = {
          labelStyle: "",
          shape: "noteGroup",
          labelText: node2.note.text,
          classes: nodeDb[node2.id].classes,
          style: "",
          id: node2.id + "----parent",
          domId: "state-" + node2.id + "----parent-" + cnt,
          type: "group",
          padding: 0
        };
        cnt++;
        g.setNode(node2.id + "----parent", groupData);
        g.setNode(noteData.id, noteData);
        g.setNode(node2.id, nodeData);
        g.setParent(node2.id, node2.id + "----parent");
        g.setParent(noteData.id, node2.id + "----parent");
        let from2 = node2.id;
        let to = noteData.id;
        if (node2.note.position === "left of") {
          from2 = noteData.id;
          to = node2.id;
        }
        g.setEdge(from2, to, {
          arrowhead: "none",
          arrowType: "",
          style: "fill:none",
          labelStyle: "",
          classes: "transition note-edge",
          arrowheadStyle: "fill: #333",
          labelpos: "c",
          labelType: "text",
          thickness: "normal"
        });
      } else {
        g.setNode(node2.id, nodeData);
      }
    }
    if (parent) {
      if (parent.id !== "root") {
        log$3.trace("Setting node ", node2.id, " to be child of its parent ", parent.id);
        g.setParent(node2.id, parent.id);
      }
    }
    if (node2.doc) {
      log$3.trace("Adding nodes children ");
      setupDoc(g, node2, node2.doc, !altFlag);
    }
  };
  let cnt = 0;
  const setupDoc = (g, parent, doc, altFlag) => {
    log$3.trace("items", doc);
    doc.forEach((item) => {
      if (item.stmt === "state" || item.stmt === "default") {
        setupNode(g, parent, item, altFlag);
      } else if (item.stmt === "relation") {
        setupNode(g, parent, item.state1, altFlag);
        setupNode(g, parent, item.state2, altFlag);
        const edgeData = {
          id: "edge" + cnt,
          arrowhead: "normal",
          arrowTypeEnd: "arrow_barb",
          style: "fill:none",
          labelStyle: "",
          label: common.sanitizeText(item.description, getConfig$1()),
          arrowheadStyle: "fill: #333",
          labelpos: "c",
          labelType: "text",
          thickness: "normal",
          classes: "transition"
        };
        let startId = item.state1.id;
        let endId = item.state2.id;
        g.setEdge(startId, endId, edgeData, cnt);
        cnt++;
      }
    });
  };
  const getDir = (nodes, defaultDir) => {
    let dir = defaultDir || "TB";
    if (nodes.doc) {
      for (let i = 0; i < nodes.doc.length; i++) {
        const node2 = nodes.doc[i];
        if (node2.stmt === "dir") {
          dir = node2.value;
        }
      }
    }
    return dir;
  };
  const draw$2 = function(text2, id2, _version, diag) {
    log$3.info("Drawing state diagram (v2)", id2);
    nodeDb = {};
    diag.db.getDirection();
    const { securityLevel, state: conf2 } = getConfig$1();
    const nodeSpacing = conf2.nodeSpacing || 50;
    const rankSpacing = conf2.rankSpacing || 50;
    log$3.info(diag.db.getRootDocV2());
    diag.db.extract(diag.db.getRootDocV2());
    log$3.info(diag.db.getRootDocV2());
    const g = new graphlib$1.Graph({
      multigraph: true,
      compound: true
    }).setGraph({
      rankdir: getDir(diag.db.getRootDocV2()),
      nodesep: nodeSpacing,
      ranksep: rankSpacing,
      marginx: 8,
      marginy: 8
    }).setDefaultEdgeLabel(function() {
      return {};
    });
    setupNode(g, void 0, diag.db.getRootDocV2(), true);
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    const svg2 = root2.select(`[id="${id2}"]`);
    const element = root2.select("#" + id2 + " g");
    render$2(element, g, ["barb"], "statediagram", id2);
    const padding2 = 8;
    const bounds2 = svg2.node().getBBox();
    const width2 = bounds2.width + padding2 * 2;
    const height2 = bounds2.height + padding2 * 2;
    svg2.attr("class", "statediagram");
    const svgBounds = svg2.node().getBBox();
    configureSvgSize(svg2, height2, width2, conf2.useMaxWidth);
    const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`;
    log$3.debug(`viewBox ${vBox}`);
    svg2.attr("viewBox", vBox);
    const labels = document.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
    addSVGAccessibilityFields(diag.db, svg2, id2);
  };
  const stateRendererV2 = {
    setConf: setConf$2,
    getClasses,
    draw: draw$2
  };
  var parser = function() {
    var o = function(k2, v, o2, l) {
      for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
        ;
      return o2;
    }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 17, 18, 20, 22, 23, 24, 26], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 24], $Va = [4, 6, 9, 11, 17, 18, 20, 22, 23, 24, 26];
    var parser2 = {
      trace: function trace() {
      },
      yy: {},
      symbols_: { "error": 2, "start": 3, "journey": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "title": 17, "acc_title": 18, "acc_title_value": 19, "acc_descr": 20, "acc_descr_value": 21, "acc_descr_multiline_value": 22, "section": 23, "taskName": 24, "taskData": 25, "open_directive": 26, "type_directive": 27, "arg_directive": 28, "close_directive": 29, "$accept": 0, "$end": 1 },
      terminals_: { 2: "error", 4: "journey", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 17: "title", 18: "acc_title", 19: "acc_title_value", 20: "acc_descr", 21: "acc_descr_value", 22: "acc_descr_multiline_value", 23: "section", 24: "taskName", 25: "taskData", 26: "open_directive", 27: "type_directive", 28: "arg_directive", 29: "close_directive" },
      productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return $$[$0 - 1];
          case 3:
            this.$ = [];
            break;
          case 4:
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
            break;
          case 5:
          case 6:
            this.$ = $$[$0];
            break;
          case 7:
          case 8:
            this.$ = [];
            break;
          case 11:
            yy.setDiagramTitle($$[$0].substr(6));
            this.$ = $$[$0].substr(6);
            break;
          case 12:
            this.$ = $$[$0].trim();
            yy.setAccTitle(this.$);
            break;
          case 13:
          case 14:
            this.$ = $$[$0].trim();
            yy.setAccDescription(this.$);
            break;
          case 15:
            yy.addSection($$[$0].substr(8));
            this.$ = $$[$0].substr(8);
            break;
          case 16:
            yy.addTask($$[$0 - 1], $$[$0]);
            this.$ = "task";
            break;
          case 18:
            yy.parseDirective("%%{", "open_directive");
            break;
          case 19:
            yy.parseDirective($$[$0], "type_directive");
            break;
          case 20:
            $$[$0] = $$[$0].trim().replace(/'/g, '"');
            yy.parseDirective($$[$0], "arg_directive");
            break;
          case 21:
            yy.parseDirective("}%%", "close_directive", "journey");
            break;
        }
      },
      table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 13: 8, 27: [1, 9] }, { 27: [2, 18] }, { 6: [1, 10], 7: 21, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, { 1: [2, 2] }, { 14: 22, 15: [1, 23], 29: $V9 }, o([15, 29], [2, 19]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 21, 10: 25, 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), { 19: [1, 26] }, { 21: [1, 27] }, o($V2, [2, 14]), o($V2, [2, 15]), { 25: [1, 28] }, o($V2, [2, 17]), { 11: [1, 29] }, { 16: 30, 28: [1, 31] }, { 11: [2, 21] }, o($V2, [2, 5]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 16]), o($Va, [2, 9]), { 14: 32, 29: $V9 }, { 29: [2, 20] }, { 11: [1, 33] }, o($Va, [2, 10])],
      defaultActions: { 5: [2, 18], 7: [2, 2], 24: [2, 21], 31: [2, 20] },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse2(input) {
        var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer2 = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k2 in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
            sharedState.yy[k2] = this.yy[k2];
          }
        }
        lexer2.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer2;
        sharedState.yy.parser = this;
        if (typeof lexer2.yylloc == "undefined") {
          lexer2.yylloc = {};
        }
        var yyloc = lexer2.yylloc;
        lstack.push(yyloc);
        var ranges2 = lexer2.options && lexer2.options.ranges;
        if (typeof sharedState.yy.parseError === "function") {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token2;
          token2 = tstack.pop() || lexer2.lex() || EOF2;
          if (typeof token2 !== "number") {
            if (token2 instanceof Array) {
              tstack = token2;
              token2 = tstack.pop();
            }
            token2 = self2.symbols_[token2] || token2;
          }
          return token2;
        }
        var symbol, state, action, r, yyval = {}, p, len, newState, expected;
        while (true) {
          state = stack2[stack2.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == "undefined") {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
            var errStr = "";
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer2.showPosition) {
              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF2 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer2.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer2.yylineno,
              loc: yyloc,
              expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
            case 1:
              stack2.push(symbol);
              vstack.push(lexer2.yytext);
              lstack.push(lexer2.yylloc);
              stack2.push(action[1]);
              symbol = null;
              {
                yyleng = lexer2.yyleng;
                yytext = lexer2.yytext;
                yylineno = lexer2.yylineno;
                yyloc = lexer2.yylloc;
              }
              break;
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges2) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
              ].concat(args));
              if (typeof r !== "undefined") {
                return r;
              }
              if (len) {
                stack2 = stack2.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack2.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
              stack2.push(newState);
              break;
            case 3:
              return true;
          }
        }
        return true;
      }
    };
    var lexer = function() {
      var lexer2 = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = "";
          this.conditionStack = ["INITIAL"];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this;
        },
        input: function() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch;
        },
        unput: function(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this;
        },
        more: function() {
          this._more = true;
          return this;
        },
        reject: function() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
          return this;
        },
        less: function(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function() {
          var next2 = this.match;
          if (next2.length < 20) {
            next2 += this._input.substr(0, 20 - next2.length);
          }
          return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function() {
          var pre = this.pastInput();
          var c2 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c2 + "^";
        },
        test_match: function(match, indexed_rule) {
          var token2, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
          if (this.done && this._input) {
            this.done = false;
          }
          if (token2) {
            return token2;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            return false;
          }
          return false;
        },
        next: function() {
          if (this.done) {
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token2, match, tempMatch, index2;
          if (!this._more) {
            this.yytext = "";
            this.match = "";
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index2 = i;
              if (this.options.backtrack_lexer) {
                token2 = this.test_match(tempMatch, rules[i]);
                if (token2 !== false) {
                  return token2;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token2 = this.test_match(match, rules[index2]);
            if (token2 !== false) {
              return token2;
            }
            return false;
          }
          if (this._input === "") {
            return this.EOF;
          } else {
            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
              text: "",
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions["INITIAL"].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return "INITIAL";
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: { "case-insensitive": true },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              this.begin("open_directive");
              return 26;
            case 1:
              this.begin("type_directive");
              return 27;
            case 2:
              this.popState();
              this.begin("arg_directive");
              return 15;
            case 3:
              this.popState();
              this.popState();
              return 29;
            case 4:
              return 28;
            case 5:
              break;
            case 6:
              break;
            case 7:
              return 11;
            case 8:
              break;
            case 9:
              break;
            case 10:
              return 4;
            case 11:
              return 17;
            case 12:
              this.begin("acc_title");
              return 18;
            case 13:
              this.popState();
              return "acc_title_value";
            case 14:
              this.begin("acc_descr");
              return 20;
            case 15:
              this.popState();
              return "acc_descr_value";
            case 16:
              this.begin("acc_descr_multiline");
              break;
            case 17:
              this.popState();
              break;
            case 18:
              return "acc_descr_multiline_value";
            case 19:
              return 23;
            case 20:
              return 24;
            case 21:
              return 25;
            case 22:
              return 15;
            case 23:
              return 6;
            case 24:
              return "INVALID";
          }
        },
        rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
        conditions: { "open_directive": { "rules": [1], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 19, 20, 21, 22, 23, 24], "inclusive": true } }
      };
      return lexer2;
    }();
    parser2.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser2;
    parser2.Parser = Parser;
    return new Parser();
  }();
  parser.parser = parser;
  const journeyDetector = (txt) => {
    return txt.match(/^\s*journey/) !== null;
  };
  let currentSection = "";
  const sections = [];
  const tasks = [];
  const rawTasks = [];
  const parseDirective$1 = function(statement, context, type2) {
    mermaidAPI.parseDirective(this, statement, context, type2);
  };
  const clear = function() {
    sections.length = 0;
    tasks.length = 0;
    currentSection = "";
    rawTasks.length = 0;
    clear$g();
  };
  const addSection = function(txt) {
    currentSection = txt;
    sections.push(txt);
  };
  const getSections = function() {
    return sections;
  };
  const getTasks = function() {
    let allItemsProcessed = compileTasks();
    const maxDepth2 = 100;
    let iterationCount = 0;
    while (!allItemsProcessed && iterationCount < maxDepth2) {
      allItemsProcessed = compileTasks();
      iterationCount++;
    }
    tasks.push(...rawTasks);
    return tasks;
  };
  const updateActors = function() {
    const tempActors = [];
    tasks.forEach((task) => {
      if (task.people) {
        tempActors.push(...task.people);
      }
    });
    const unique2 = new Set(tempActors);
    return [...unique2].sort();
  };
  const addTask = function(descr, taskData) {
    const pieces = taskData.substr(1).split(":");
    let score2 = 0;
    let peeps = [];
    if (pieces.length === 1) {
      score2 = Number(pieces[0]);
      peeps = [];
    } else {
      score2 = Number(pieces[0]);
      peeps = pieces[1].split(",");
    }
    const peopleList = peeps.map((s2) => s2.trim());
    const rawTask = {
      section: currentSection,
      type: currentSection,
      people: peopleList,
      task: descr,
      score: score2
    };
    rawTasks.push(rawTask);
  };
  const addTaskOrg = function(descr) {
    const newTask = {
      section: currentSection,
      type: currentSection,
      description: descr,
      task: descr,
      classes: []
    };
    tasks.push(newTask);
  };
  const compileTasks = function() {
    const compileTask = function(pos) {
      return rawTasks[pos].processed;
    };
    let allProcessed = true;
    for (let i = 0; i < rawTasks.length; i++) {
      compileTask(i);
      allProcessed = allProcessed && rawTasks[i].processed;
    }
    return allProcessed;
  };
  const getActors = function() {
    return updateActors();
  };
  const journeyDb = {
    parseDirective: parseDirective$1,
    getConfig: () => getConfig$1().journey,
    clear,
    setDiagramTitle,
    getDiagramTitle,
    setAccTitle,
    getAccTitle,
    setAccDescription,
    getAccDescription,
    addSection,
    getSections,
    getTasks,
    addTask,
    addTaskOrg,
    getActors
  };
  const drawRect = function(elem, rectData) {
    const rectElem = elem.append("rect");
    rectElem.attr("x", rectData.x);
    rectElem.attr("y", rectData.y);
    rectElem.attr("fill", rectData.fill);
    rectElem.attr("stroke", rectData.stroke);
    rectElem.attr("width", rectData.width);
    rectElem.attr("height", rectData.height);
    rectElem.attr("rx", rectData.rx);
    rectElem.attr("ry", rectData.ry);
    if (typeof rectData.class !== "undefined") {
      rectElem.attr("class", rectData.class);
    }
    return rectElem;
  };
  const drawFace = function(element, faceData) {
    const radius = 15;
    const circleElement = element.append("circle").attr("cx", faceData.cx).attr("cy", faceData.cy).attr("class", "face").attr("r", radius).attr("stroke-width", 2).attr("overflow", "visible");
    const face = element.append("g");
    face.append("circle").attr("cx", faceData.cx - radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
    face.append("circle").attr("cx", faceData.cx + radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
    function smile(face2) {
      const arc = d3arc().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
      face2.append("path").attr("class", "mouth").attr("d", arc).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 2) + ")");
    }
    function sad(face2) {
      const arc = d3arc().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
      face2.append("path").attr("class", "mouth").attr("d", arc).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 7) + ")");
    }
    function ambivalent(face2) {
      face2.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", faceData.cx - 5).attr("y1", faceData.cy + 7).attr("x2", faceData.cx + 5).attr("y2", faceData.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
    }
    if (faceData.score > 3) {
      smile(face);
    } else if (faceData.score < 3) {
      sad(face);
    } else {
      ambivalent(face);
    }
    return circleElement;
  };
  const drawCircle = function(element, circleData) {
    const circleElement = element.append("circle");
    circleElement.attr("cx", circleData.cx);
    circleElement.attr("cy", circleData.cy);
    circleElement.attr("class", "actor-" + circleData.pos);
    circleElement.attr("fill", circleData.fill);
    circleElement.attr("stroke", circleData.stroke);
    circleElement.attr("r", circleData.r);
    if (typeof circleElement.class !== "undefined") {
      circleElement.attr("class", circleElement.class);
    }
    if (typeof circleData.title !== "undefined") {
      circleElement.append("title").text(circleData.title);
    }
    return circleElement;
  };
  const drawText = function(elem, textData) {
    const nText = textData.text.replace(/<br\s*\/?>/gi, " ");
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", textData.y);
    textElem.attr("class", "legend");
    textElem.style("text-anchor", textData.anchor);
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    const span = textElem.append("tspan");
    span.attr("x", textData.x + textData.textMargin * 2);
    span.text(nText);
    return textElem;
  };
  const drawLabel = function(elem, txtObject) {
    function genPoints(x2, y2, width2, height2, cut) {
      return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
    }
    const polygon = elem.append("polygon");
    polygon.attr("points", genPoints(txtObject.x, txtObject.y, 50, 20, 7));
    polygon.attr("class", "labelBox");
    txtObject.y = txtObject.y + txtObject.labelMargin;
    txtObject.x = txtObject.x + 0.5 * txtObject.labelMargin;
    drawText(elem, txtObject);
  };
  const drawSection = function(elem, section, conf2) {
    const g = elem.append("g");
    const rect2 = getNoteRect();
    rect2.x = section.x;
    rect2.y = section.y;
    rect2.fill = section.fill;
    rect2.width = conf2.width;
    rect2.height = conf2.height;
    rect2.class = "journey-section section-type-" + section.num;
    rect2.rx = 3;
    rect2.ry = 3;
    drawRect(g, rect2);
    _drawTextCandidateFunc(conf2)(
      section.text,
      g,
      rect2.x,
      rect2.y,
      rect2.width,
      rect2.height,
      { class: "journey-section section-type-" + section.num },
      conf2,
      section.colour
    );
  };
  let taskCount = -1;
  const drawTask = function(elem, task, conf2) {
    const center2 = task.x + conf2.width / 2;
    const g = elem.append("g");
    taskCount++;
    const maxHeight = 300 + 5 * 30;
    g.append("line").attr("id", "task" + taskCount).attr("x1", center2).attr("y1", task.y).attr("x2", center2).attr("y2", maxHeight).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666");
    drawFace(g, {
      cx: center2,
      cy: 300 + (5 - task.score) * 30,
      score: task.score
    });
    const rect2 = getNoteRect();
    rect2.x = task.x;
    rect2.y = task.y;
    rect2.fill = task.fill;
    rect2.width = conf2.width;
    rect2.height = conf2.height;
    rect2.class = "task task-type-" + task.num;
    rect2.rx = 3;
    rect2.ry = 3;
    drawRect(g, rect2);
    let xPos = task.x + 14;
    task.people.forEach((person) => {
      const colour = task.actors[person].color;
      const circle2 = {
        cx: xPos,
        cy: task.y,
        r: 7,
        fill: colour,
        stroke: "#000",
        title: person,
        pos: task.actors[person].position
      };
      drawCircle(g, circle2);
      xPos += 10;
    });
    _drawTextCandidateFunc(conf2)(
      task.task,
      g,
      rect2.x,
      rect2.y,
      rect2.width,
      rect2.height,
      { class: "task" },
      conf2,
      task.colour
    );
  };
  const drawBackgroundRect = function(elem, bounds2) {
    const rectElem = drawRect(elem, {
      x: bounds2.startx,
      y: bounds2.starty,
      width: bounds2.stopx - bounds2.startx,
      height: bounds2.stopy - bounds2.starty,
      fill: bounds2.fill,
      class: "rect"
    });
    rectElem.lower();
  };
  const getTextObj = function() {
    return {
      x: 0,
      y: 0,
      fill: void 0,
      "text-anchor": "start",
      width: 100,
      height: 100,
      textMargin: 0,
      rx: 0,
      ry: 0
    };
  };
  const getNoteRect = function() {
    return {
      x: 0,
      y: 0,
      width: 100,
      anchor: "start",
      height: 100,
      rx: 0,
      ry: 0
    };
  };
  const _drawTextCandidateFunc = function() {
    function byText(content, g, x2, y2, width2, height2, textAttrs, colour) {
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("font-color", colour).style("text-anchor", "middle").text(content);
      _setTextAttrs(text2, textAttrs);
    }
    function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2, colour) {
      const { taskFontSize, taskFontFamily } = conf2;
      const lines = content.split(/<br\s*\/?>/gi);
      for (let i = 0; i < lines.length; i++) {
        const dy = i * taskFontSize - taskFontSize * (lines.length - 1) / 2;
        const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).attr("fill", colour).style("text-anchor", "middle").style("font-size", taskFontSize).style("font-family", taskFontFamily);
        text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
        text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
        _setTextAttrs(text2, textAttrs);
      }
    }
    function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
      const body = g.append("switch");
      const f = body.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2).attr("position", "fixed");
      const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
      text2.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
      byTspan(content, body, x2, y2, width2, height2, textAttrs, conf2);
      _setTextAttrs(text2, textAttrs);
    }
    function _setTextAttrs(toText, fromTextAttrsDict) {
      for (const key in fromTextAttrsDict) {
        if (key in fromTextAttrsDict) {
          toText.attr(key, fromTextAttrsDict[key]);
        }
      }
    }
    return function(conf2) {
      return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
    };
  }();
  const initGraphics = function(graphics) {
    graphics.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
  };
  const svgDraw = {
    drawRect,
    drawCircle,
    drawSection,
    drawText,
    drawLabel,
    drawTask,
    drawBackgroundRect,
    getTextObj,
    getNoteRect,
    initGraphics
  };
  const setConf$1 = function(cnf) {
    const keys = Object.keys(cnf);
    keys.forEach(function(key) {
      conf$1[key] = cnf[key];
    });
  };
  const actors = {};
  function drawActorLegend(diagram) {
    const conf2 = getConfig$1().journey;
    let yPos = 60;
    Object.keys(actors).forEach((person) => {
      const colour = actors[person].color;
      const circleData = {
        cx: 20,
        cy: yPos,
        r: 7,
        fill: colour,
        stroke: "#000",
        pos: actors[person].position
      };
      svgDraw.drawCircle(diagram, circleData);
      const labelData = {
        x: 40,
        y: yPos + 7,
        fill: "#666",
        text: person,
        textMargin: conf2.boxTextMargin | 5
      };
      svgDraw.drawText(diagram, labelData);
      yPos += 20;
    });
  }
  const conf$1 = getConfig$1().journey;
  const LEFT_MARGIN = conf$1.leftMargin;
  const draw$1 = function(text2, id2, version2, diagObj) {
    const conf2 = getConfig$1().journey;
    diagObj.db.clear();
    diagObj.parser.parse(text2 + "\n");
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select(sandboxElement.nodes()[0].contentDocument.body) : select("body");
    bounds.init();
    const diagram = root2.select("#" + id2);
    svgDraw.initGraphics(diagram);
    const tasks2 = diagObj.db.getTasks();
    const title2 = diagObj.db.getDiagramTitle();
    const actorNames = diagObj.db.getActors();
    for (const member in actors)
      delete actors[member];
    let actorPos = 0;
    actorNames.forEach((actorName) => {
      actors[actorName] = {
        color: conf2.actorColours[actorPos % conf2.actorColours.length],
        position: actorPos
      };
      actorPos++;
    });
    drawActorLegend(diagram);
    bounds.insert(0, 0, LEFT_MARGIN, Object.keys(actors).length * 50);
    drawTasks(diagram, tasks2, 0);
    const box = bounds.getBounds();
    if (title2) {
      diagram.append("text").text(title2).attr("x", LEFT_MARGIN).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 25);
    }
    const height2 = box.stopy - box.starty + 2 * conf2.diagramMarginY;
    const width2 = LEFT_MARGIN + box.stopx + 2 * conf2.diagramMarginX;
    configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
    diagram.append("line").attr("x1", LEFT_MARGIN).attr("y1", conf2.height * 4).attr("x2", width2 - LEFT_MARGIN - 4).attr("y2", conf2.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
    const extraVertForTitle = title2 ? 70 : 0;
    diagram.attr("viewBox", `${box.startx} -25 ${width2} ${height2 + extraVertForTitle}`);
    diagram.attr("preserveAspectRatio", "xMinYMin meet");
    diagram.attr("height", height2 + extraVertForTitle + 25);
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
  };
  const bounds = {
    data: {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    },
    verticalPos: 0,
    sequenceItems: [],
    init: function() {
      this.sequenceItems = [];
      this.data = {
        startx: void 0,
        stopx: void 0,
        starty: void 0,
        stopy: void 0
      };
      this.verticalPos = 0;
    },
    updateVal: function(obj, key, val, fun) {
      if (typeof obj[key] === "undefined") {
        obj[key] = val;
      } else {
        obj[key] = fun(val, obj[key]);
      }
    },
    updateBounds: function(startx, starty, stopx, stopy) {
      const conf2 = getConfig$1().journey;
      const _self = this;
      let cnt2 = 0;
      function updateFn(type2) {
        return function updateItemBounds(item) {
          cnt2++;
          const n = _self.sequenceItems.length - cnt2 + 1;
          _self.updateVal(item, "starty", starty - n * conf2.boxMargin, Math.min);
          _self.updateVal(item, "stopy", stopy + n * conf2.boxMargin, Math.max);
          _self.updateVal(bounds.data, "startx", startx - n * conf2.boxMargin, Math.min);
          _self.updateVal(bounds.data, "stopx", stopx + n * conf2.boxMargin, Math.max);
          if (!(type2 === "activation")) {
            _self.updateVal(item, "startx", startx - n * conf2.boxMargin, Math.min);
            _self.updateVal(item, "stopx", stopx + n * conf2.boxMargin, Math.max);
            _self.updateVal(bounds.data, "starty", starty - n * conf2.boxMargin, Math.min);
            _self.updateVal(bounds.data, "stopy", stopy + n * conf2.boxMargin, Math.max);
          }
        };
      }
      this.sequenceItems.forEach(updateFn());
    },
    insert: function(startx, starty, stopx, stopy) {
      const _startx = Math.min(startx, stopx);
      const _stopx = Math.max(startx, stopx);
      const _starty = Math.min(starty, stopy);
      const _stopy = Math.max(starty, stopy);
      this.updateVal(bounds.data, "startx", _startx, Math.min);
      this.updateVal(bounds.data, "starty", _starty, Math.min);
      this.updateVal(bounds.data, "stopx", _stopx, Math.max);
      this.updateVal(bounds.data, "stopy", _stopy, Math.max);
      this.updateBounds(_startx, _starty, _stopx, _stopy);
    },
    bumpVerticalPos: function(bump) {
      this.verticalPos = this.verticalPos + bump;
      this.data.stopy = this.verticalPos;
    },
    getVerticalPos: function() {
      return this.verticalPos;
    },
    getBounds: function() {
      return this.data;
    }
  };
  const fills = conf$1.sectionFills;
  const textColours = conf$1.sectionColours;
  const drawTasks = function(diagram, tasks2, verticalPos) {
    const conf2 = getConfig$1().journey;
    let lastSection = "";
    const sectionVHeight = conf2.height * 2 + conf2.diagramMarginY;
    const taskPos = verticalPos + sectionVHeight;
    let sectionNumber = 0;
    let fill = "#CCC";
    let colour = "black";
    let num = 0;
    for (let i = 0; i < tasks2.length; i++) {
      const task = tasks2[i];
      if (lastSection !== task.section) {
        fill = fills[sectionNumber % fills.length];
        num = sectionNumber % fills.length;
        colour = textColours[sectionNumber % textColours.length];
        const section = {
          x: i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN,
          y: 50,
          text: task.section,
          fill,
          num,
          colour
        };
        svgDraw.drawSection(diagram, section, conf2);
        lastSection = task.section;
        sectionNumber++;
      }
      const taskActors = task.people.reduce((acc, actorName) => {
        if (actors[actorName]) {
          acc[actorName] = actors[actorName];
        }
        return acc;
      }, {});
      task.x = i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN;
      task.y = taskPos;
      task.width = conf2.diagramMarginX;
      task.height = conf2.diagramMarginY;
      task.colour = colour;
      task.fill = fill;
      task.num = num;
      task.actors = taskActors;
      svgDraw.drawTask(diagram, task, conf2);
      bounds.insert(task.x, task.y, task.x + task.width + conf2.taskMargin, 300 + 5 * 30);
    }
  };
  const journeyRenderer = {
    setConf: setConf$1,
    draw: draw$1
  };
  let conf = {};
  const setConf = function(cnf) {
    conf = { ...conf, ...cnf };
  };
  const draw = (text2, id2, mermaidVersion) => {
    try {
      log$3.debug("Renering svg for syntax error\n");
      const svg2 = select("#" + id2);
      const g = svg2.append("g");
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
      );
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
      );
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
      );
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
      );
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
      );
      g.append("path").attr("class", "error-icon").attr(
        "d",
        "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
      );
      g.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in graph");
      g.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text("mermaid version " + mermaidVersion);
      svg2.attr("height", 100);
      svg2.attr("width", 500);
      svg2.attr("viewBox", "768 0 912 512");
    } catch (e) {
      log$3.error("Error while rendering info diagram");
      log$3.error(getErrorMessage(e));
    }
  };
  const errorRenderer = {
    setConf,
    draw
  };
  let hasLoadedDiagrams = false;
  const addDiagrams = () => {
    if (hasLoadedDiagrams) {
      return;
    }
    hasLoadedDiagrams = true;
    registerDiagram(
      "error",
      {
        db: {
          clear: () => {
          }
        },
        styles: getStyles$b,
        renderer: errorRenderer,
        parser: {
          parser: { yy: {} },
          parse: () => {
          }
        },
        init: () => {
        }
      },
      (text2) => text2.toLowerCase().trim() === "error"
    );
    registerDiagram(
      "c4",
      {
        parser: parser$a,
        db: c4Db,
        renderer: c4Renderer,
        styles: getStyles$2,
        init: (cnf) => {
          c4Renderer.setConf(cnf.c4);
        }
      },
      c4Detector
    );
    registerDiagram(
      "class",
      {
        parser: parser$9,
        db: classDb,
        renderer: classRenderer,
        styles: getStyles$d,
        init: (cnf) => {
          if (!cnf.class) {
            cnf.class = {};
          }
          cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          classDb.clear();
        }
      },
      classDetector
    );
    registerDiagram(
      "classDiagram",
      {
        parser: parser$9,
        db: classDb,
        renderer: classRendererV2,
        styles: getStyles$d,
        init: (cnf) => {
          if (!cnf.class) {
            cnf.class = {};
          }
          cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          classDb.clear();
        }
      },
      classDetectorV2
    );
    registerDiagram(
      "er",
      {
        parser: parser$8,
        db: erDb,
        renderer: erRenderer,
        styles: getStyles$c
      },
      erDetector
    );
    registerDiagram(
      "gantt",
      {
        parser: parser$6,
        db: ganttDb,
        renderer: ganttRenderer,
        styles: getStyles$9
      },
      ganttDetector
    );
    registerDiagram(
      "info",
      {
        parser: parser$5,
        db: infoDb,
        renderer: infoRenderer,
        styles: getStyles$8
      },
      infoDetector
    );
    registerDiagram(
      "pie",
      {
        parser: parser$4,
        db: pieDb,
        renderer: pieRenderer,
        styles: getStyles$7
      },
      pieDetector
    );
    registerDiagram(
      "requirement",
      {
        parser: parser$3,
        db: requirementDb,
        renderer: requirementRenderer,
        styles: getStyles$6
      },
      requirementDetector
    );
    registerDiagram(
      "sequence",
      {
        parser: parser$2,
        db: sequenceDb,
        renderer: sequenceRenderer,
        styles: getStyles$5,
        init: (cnf) => {
          if (!cnf.sequence) {
            cnf.sequence = {};
          }
          cnf.sequence.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          if ("sequenceDiagram" in cnf) {
            throw new Error(
              "`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config."
            );
          }
          sequenceDb.setWrap(cnf.wrap);
          sequenceRenderer.setConf(cnf.sequence);
        }
      },
      sequenceDetector
    );
    registerDiagram(
      "state",
      {
        parser: parser$1,
        db: stateDb,
        renderer: stateRenderer,
        styles: getStyles$4,
        init: (cnf) => {
          if (!cnf.state) {
            cnf.state = {};
          }
          cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          stateDb.clear();
        }
      },
      stateDetector
    );
    registerDiagram(
      "stateDiagram",
      {
        parser: parser$1,
        db: stateDb,
        renderer: stateRendererV2,
        styles: getStyles$4,
        init: (cnf) => {
          if (!cnf.state) {
            cnf.state = {};
          }
          cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          stateDb.clear();
        }
      },
      stateDetectorV2
    );
    registerDiagram(
      "journey",
      {
        parser,
        db: journeyDb,
        renderer: journeyRenderer,
        styles: getStyles$3,
        init: (cnf) => {
          journeyRenderer.setConf(cnf.journey);
          journeyDb.clear();
        }
      },
      journeyDetector
    );
    registerDiagram(
      "flowchart",
      {
        parser: parser$7,
        db: flowDb,
        renderer: flowRendererV2,
        styles: getStyles$a,
        init: (cnf) => {
          if (!cnf.flowchart) {
            cnf.flowchart = {};
          }
          cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          flowRenderer.setConf(cnf.flowchart);
          flowDb.clear();
          flowDb.setGen("gen-1");
        }
      },
      flowDetector
    );
    registerDiagram(
      "flowchart-v2",
      {
        parser: parser$7,
        db: flowDb,
        renderer: flowRendererV2,
        styles: getStyles$a,
        init: (cnf) => {
          if (!cnf.flowchart) {
            cnf.flowchart = {};
          }
          cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
          setConfig({ flowchart: { arrowMarkerAbsolute: cnf.arrowMarkerAbsolute } });
          flowRendererV2.setConf(cnf.flowchart);
          flowDb.clear();
          flowDb.setGen("gen-2");
        }
      },
      flowDetectorV2
    );
    registerDiagram(
      "gitGraph",
      { parser: parser$b, db: gitGraphDb, renderer: gitGraphRenderer, styles: getStyles },
      gitGraphDetector
    );
  };
  class Diagram {
    constructor(txt, parseError) {
      __publicField(this, "type", "graph");
      __publicField(this, "parser");
      __publicField(this, "renderer");
      __publicField(this, "db");
      __publicField(this, "detectTypeFailed", false);
      var _a, _b;
      this.txt = txt;
      const cnf = getConfig$1();
      this.txt = txt;
      try {
        this.type = detectType(txt, cnf);
      } catch (e) {
        this.handleError(e, parseError);
        this.type = "error";
        this.detectTypeFailed = true;
      }
      const diagram = getDiagram(this.type);
      log$3.debug("Type " + this.type);
      this.db = diagram.db;
      (_b = (_a = this.db).clear) == null ? void 0 : _b.call(_a);
      this.renderer = diagram.renderer;
      this.parser = diagram.parser;
      this.parser.parser.yy = this.db;
      if (diagram.init) {
        diagram.init(cnf);
        log$3.debug("Initialized diagram " + this.type, cnf);
      }
      this.txt += "\n";
      this.parse(this.txt, parseError);
    }
    parse(text2, parseError) {
      if (this.detectTypeFailed) {
        return false;
      }
      try {
        text2 = text2 + "\n";
        this.db.clear();
        this.parser.parse(text2);
        return true;
      } catch (error) {
        this.handleError(error, parseError);
      }
      return false;
    }
    handleError(error, parseError) {
      if (parseError) {
        if (isDetailedError(error)) {
          parseError(error.str, error.hash);
        } else {
          parseError(error);
        }
      } else {
        throw error;
      }
    }
    getParser() {
      return this.parser;
    }
    getType() {
      return this.type;
    }
  }
  const getDiagramFromText = (txt, parseError) => {
    const type2 = detectType(txt, getConfig$1());
    try {
      getDiagram(type2);
      return new Diagram(txt, parseError);
    } catch (error) {
      if (!(error instanceof DiagramNotFoundError)) {
        log$3.error(error);
        throw error;
      }
      const loader = getDiagramLoader(type2);
      if (!loader) {
        throw new Error(`Loader for ${type2} not found.`);
      }
      return loader().then(({ diagram }) => {
        registerDiagram(type2, diagram, void 0, diagram.injectUtils);
        return new Diagram(txt, parseError);
      });
    }
  };
  function parse$1(text2, parseError) {
    addDiagrams();
    const diagram = new Diagram(text2, parseError);
    return diagram.parse(text2, parseError);
  }
  async function parseAsync$1(text2, parseError) {
    addDiagrams();
    const diagram = await getDiagramFromText(text2, parseError);
    return diagram.parse(text2, parseError);
  }
  const encodeEntities = function(text2) {
    let txt = text2;
    txt = txt.replace(/style.*:\S*#.*;/g, function(s2) {
      const innerTxt = s2.substring(0, s2.length - 1);
      return innerTxt;
    });
    txt = txt.replace(/classDef.*:\S*#.*;/g, function(s2) {
      const innerTxt = s2.substring(0, s2.length - 1);
      return innerTxt;
    });
    txt = txt.replace(/#\w+;/g, function(s2) {
      const innerTxt = s2.substring(1, s2.length - 1);
      const isInt = /^\+?\d+$/.test(innerTxt);
      if (isInt) {
        return "\uFB02\xB0\xB0" + innerTxt + "\xB6\xDF";
      } else {
        return "\uFB02\xB0" + innerTxt + "\xB6\xDF";
      }
    });
    return txt;
  };
  const decodeEntities = function(text2) {
    let txt = text2;
    txt = txt.replace(/ﬂ°°/g, function() {
      return "&#";
    });
    txt = txt.replace(/ﬂ°/g, function() {
      return "&";
    });
    txt = txt.replace(/¶ß/g, function() {
      return ";";
    });
    return txt;
  };
  const render = function(id2, text2, cb, container) {
    var _a;
    addDiagrams();
    reset();
    text2 = text2.replace(/\r\n?/g, "\n");
    const graphInit = utils.detectInit(text2);
    if (graphInit) {
      directiveSanitizer(graphInit);
      addDirective(graphInit);
    }
    const cnf = getConfig$1();
    log$3.debug(cnf);
    if (text2.length > cnf.maxTextSize) {
      text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
    }
    let root2 = select("body");
    if (typeof container !== "undefined") {
      if (container) {
        container.innerHTML = "";
      }
      if (cnf.securityLevel === "sandbox") {
        const iframe = select(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
        root2 = select(iframe.nodes()[0].contentDocument.body);
        root2.node().style.margin = 0;
      } else {
        root2 = select(container);
      }
      root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
    } else {
      const existingSvg = document.getElementById(id2);
      if (existingSvg) {
        existingSvg.remove();
      }
      let element2;
      if (cnf.securityLevel === "sandbox") {
        element2 = document.querySelector("#i" + id2);
      } else {
        element2 = document.querySelector("#d" + id2);
      }
      if (element2) {
        element2.remove();
      }
      if (cnf.securityLevel === "sandbox") {
        const iframe = select("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
        root2 = select(iframe.nodes()[0].contentDocument.body);
        root2.node().style.margin = 0;
      } else {
        root2 = select("body");
      }
      root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
    }
    text2 = encodeEntities(text2);
    let diag;
    let parseEncounteredException;
    try {
      diag = getDiagramFromText(text2);
      if ("then" in diag) {
        throw new Error("Diagram is a promise");
      }
    } catch (error) {
      diag = new Diagram("error");
      parseEncounteredException = error;
    }
    const element = root2.select("#d" + id2).node();
    const graphType = diag.type;
    const svg2 = element.firstChild;
    const firstChild = svg2.firstChild;
    let userStyles = "";
    if (cnf.themeCSS !== void 0) {
      userStyles += `
${cnf.themeCSS}`;
    }
    if (cnf.fontFamily !== void 0) {
      userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
    }
    if (cnf.altFontFamily !== void 0) {
      userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
    }
    if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
      const classes2 = flowRenderer.getClasses(text2, diag);
      const htmlLabels = cnf.htmlLabels || ((_a = cnf.flowchart) == null ? void 0 : _a.htmlLabels);
      for (const className in classes2) {
        if (htmlLabels) {
          userStyles += `
.${className} > * { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} span { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
        } else {
          userStyles += `
.${className} path { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} rect { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} polygon { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} ellipse { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} circle { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          if (classes2[className].textStyles) {
            userStyles += `
.${className} tspan { ${classes2[className].textStyles.join(
              " !important; "
            )} !important; }`;
          }
        }
      }
    }
    const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
    const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
    const style1 = document.createElement("style");
    style1.innerHTML = `#${id2} ` + rules;
    svg2.insertBefore(style1, firstChild);
    try {
      diag.renderer.draw(text2, id2, pkg.version, diag);
    } catch (e) {
      errorRenderer.draw(text2, id2, pkg.version);
      throw e;
    }
    root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
    let svgCode = root2.select("#d" + id2).node().innerHTML;
    log$3.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
    if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
      svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
    }
    svgCode = decodeEntities(svgCode);
    svgCode = svgCode.replace(/<br>/g, "<br/>");
    if (cnf.securityLevel === "sandbox") {
      const svgEl = root2.select("#d" + id2 + " svg").node();
      const width2 = "100%";
      let height2 = "100%";
      if (svgEl) {
        height2 = svgEl.viewBox.baseVal.height + "px";
      }
      svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
        '<body style="margin:0">' + svgCode + "</body>"
      )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
    } else {
      if (cnf.securityLevel !== "loose") {
        svgCode = purify.sanitize(svgCode, {
          ADD_TAGS: ["foreignobject"],
          ADD_ATTR: ["dominant-baseline"]
        });
      }
    }
    if (typeof cb !== "undefined") {
      switch (graphType) {
        case "flowchart":
        case "flowchart-v2":
          cb(svgCode, flowDb.bindFunctions);
          break;
        case "gantt":
          cb(svgCode, ganttDb.bindFunctions);
          break;
        case "class":
        case "classDiagram":
          cb(svgCode, classDb.bindFunctions);
          break;
        default:
          cb(svgCode);
      }
    } else {
      log$3.debug("CB = undefined!");
    }
    attachFunctions();
    const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
    const node2 = select(tmpElementSelector).node();
    if (node2 && "remove" in node2) {
      node2.remove();
    }
    if (parseEncounteredException) {
      throw parseEncounteredException;
    }
    return svgCode;
  };
  const renderAsync$1 = async function(id2, text2, cb, container) {
    var _a;
    addDiagrams();
    reset();
    text2 = text2.replace(/\r\n?/g, "\n");
    const graphInit = utils.detectInit(text2);
    if (graphInit) {
      directiveSanitizer(graphInit);
      addDirective(graphInit);
    }
    const cnf = getConfig$1();
    log$3.debug(cnf);
    if (text2.length > cnf.maxTextSize) {
      text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
    }
    let root2 = select("body");
    if (typeof container !== "undefined") {
      if (container) {
        container.innerHTML = "";
      }
      if (cnf.securityLevel === "sandbox") {
        const iframe = select(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
        root2 = select(iframe.nodes()[0].contentDocument.body);
        root2.node().style.margin = 0;
      } else {
        root2 = select(container);
      }
      root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
    } else {
      const existingSvg = document.getElementById(id2);
      if (existingSvg) {
        existingSvg.remove();
      }
      let element2;
      if (cnf.securityLevel === "sandbox") {
        element2 = document.querySelector("#i" + id2);
      } else {
        element2 = document.querySelector("#d" + id2);
      }
      if (element2) {
        element2.remove();
      }
      if (cnf.securityLevel === "sandbox") {
        const iframe = select("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
        root2 = select(iframe.nodes()[0].contentDocument.body);
        root2.node().style.margin = 0;
      } else {
        root2 = select("body");
      }
      root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
    }
    text2 = encodeEntities(text2);
    let diag;
    let parseEncounteredException;
    try {
      diag = await getDiagramFromText(text2);
    } catch (error) {
      diag = new Diagram("error");
      parseEncounteredException = error;
    }
    const element = root2.select("#d" + id2).node();
    const graphType = diag.type;
    const svg2 = element.firstChild;
    const firstChild = svg2.firstChild;
    let userStyles = "";
    if (cnf.themeCSS !== void 0) {
      userStyles += `
${cnf.themeCSS}`;
    }
    if (cnf.fontFamily !== void 0) {
      userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
    }
    if (cnf.altFontFamily !== void 0) {
      userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
    }
    if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
      const classes2 = flowRenderer.getClasses(text2, diag);
      const htmlLabels = cnf.htmlLabels || ((_a = cnf.flowchart) == null ? void 0 : _a.htmlLabels);
      for (const className in classes2) {
        if (htmlLabels) {
          userStyles += `
.${className} > * { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} span { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
        } else {
          userStyles += `
.${className} path { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} rect { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} polygon { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} ellipse { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          userStyles += `
.${className} circle { ${classes2[className].styles.join(
            " !important; "
          )} !important; }`;
          if (classes2[className].textStyles) {
            userStyles += `
.${className} tspan { ${classes2[className].textStyles.join(
              " !important; "
            )} !important; }`;
          }
        }
      }
    }
    const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
    const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
    const style1 = document.createElement("style");
    style1.innerHTML = `#${id2} ` + rules;
    svg2.insertBefore(style1, firstChild);
    try {
      await diag.renderer.draw(text2, id2, pkg.version, diag);
    } catch (e) {
      errorRenderer.draw(text2, id2, pkg.version);
      throw e;
    }
    root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
    let svgCode = root2.select("#d" + id2).node().innerHTML;
    log$3.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
    if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
      svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
    }
    svgCode = decodeEntities(svgCode);
    svgCode = svgCode.replace(/<br>/g, "<br/>");
    if (cnf.securityLevel === "sandbox") {
      const svgEl = root2.select("#d" + id2 + " svg").node();
      const width2 = "100%";
      let height2 = "100%";
      if (svgEl) {
        height2 = svgEl.viewBox.baseVal.height + "px";
      }
      svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
        '<body style="margin:0">' + svgCode + "</body>"
      )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
    } else {
      if (cnf.securityLevel !== "loose") {
        svgCode = purify.sanitize(svgCode, {
          ADD_TAGS: ["foreignobject"],
          ADD_ATTR: ["dominant-baseline"]
        });
      }
    }
    if (typeof cb !== "undefined") {
      switch (graphType) {
        case "flowchart":
        case "flowchart-v2":
          cb(svgCode, flowDb.bindFunctions);
          break;
        case "gantt":
          cb(svgCode, ganttDb.bindFunctions);
          break;
        case "class":
        case "classDiagram":
          cb(svgCode, classDb.bindFunctions);
          break;
        default:
          cb(svgCode);
      }
    } else {
      log$3.debug("CB = undefined!");
    }
    attachFunctions();
    const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
    const node2 = select(tmpElementSelector).node();
    if (node2 && "remove" in node2) {
      node2.remove();
    }
    if (parseEncounteredException) {
      throw parseEncounteredException;
    }
    return svgCode;
  };
  let currentDirective = {};
  const parseDirective = function(p, statement, context, type2) {
    try {
      if (statement !== void 0) {
        statement = statement.trim();
        switch (context) {
          case "open_directive":
            currentDirective = {};
            break;
          case "type_directive":
            if (!currentDirective)
              throw new Error("currentDirective is undefined");
            currentDirective.type = statement.toLowerCase();
            break;
          case "arg_directive":
            if (!currentDirective)
              throw new Error("currentDirective is undefined");
            currentDirective.args = JSON.parse(statement);
            break;
          case "close_directive":
            handleDirective(p, currentDirective, type2);
            currentDirective = void 0;
            break;
        }
      }
    } catch (error) {
      log$3.error(
        `Error while rendering sequenceDiagram directive: ${statement} jison context: ${context}`
      );
      log$3.error(error.message);
    }
  };
  const handleDirective = function(p, directive2, type2) {
    log$3.debug(`Directive type=${directive2.type} with args:`, directive2.args);
    switch (directive2.type) {
      case "init":
      case "initialize": {
        ["config"].forEach((prop) => {
          if (typeof directive2.args[prop] !== "undefined") {
            if (type2 === "flowchart-v2") {
              type2 = "flowchart";
            }
            directive2.args[type2] = directive2.args[prop];
            delete directive2.args[prop];
          }
        });
        log$3.debug("sanitize in handleDirective", directive2.args);
        directiveSanitizer(directive2.args);
        log$3.debug("sanitize in handleDirective (done)", directive2.args);
        addDirective(directive2.args);
        break;
      }
      case "wrap":
      case "nowrap":
        if (p && p["setWrap"]) {
          p.setWrap(directive2.type === "wrap");
        }
        break;
      case "themeCss":
        log$3.warn("themeCss encountered");
        break;
      default:
        log$3.warn(
          `Unhandled directive: source: '%%{${directive2.type}: ${JSON.stringify(
            directive2.args ? directive2.args : {}
          )}}%%`,
          directive2
        );
        break;
    }
  };
  function initialize$1(options2 = {}) {
    if (options2.fontFamily) {
      if (!options2.themeVariables) {
        options2.themeVariables = {};
      }
      options2.themeVariables.fontFamily = options2.fontFamily;
    }
    saveConfigFromInitialize(options2);
    if ((options2 == null ? void 0 : options2.theme) && options2.theme in theme) {
      options2.themeVariables = theme[options2.theme].getThemeVariables(
        options2.themeVariables
      );
    } else if (options2) {
      options2.themeVariables = theme.default.getThemeVariables(options2.themeVariables);
    }
    const config2 = typeof options2 === "object" ? setSiteConfig(options2) : getSiteConfig();
    setLogLevel$1(config2.logLevel);
    addDiagrams();
  }
  const mermaidAPI = Object.freeze({
    render,
    renderAsync: renderAsync$1,
    parse: parse$1,
    parseAsync: parseAsync$1,
    parseDirective,
    initialize: initialize$1,
    getConfig: getConfig$1,
    setConfig,
    getSiteConfig,
    updateSiteConfig,
    reset: () => {
      reset();
    },
    globalReset: () => {
      reset(defaultConfig);
    },
    defaultConfig
  });
  setLogLevel$1(getConfig$1().logLevel);
  reset(getConfig$1());
  const init = async function(config2, nodes, callback) {
    try {
      const conf2 = mermaidAPI.getConfig();
      if ((conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) && conf2.lazyLoadedDiagrams.length > 0) {
        await initThrowsErrorsAsync(config2, nodes, callback);
      } else {
        initThrowsErrors(config2, nodes, callback);
      }
    } catch (e) {
      log$3.warn("Syntax Error rendering");
      if (isDetailedError(e)) {
        log$3.warn(e.str);
      }
      if (mermaid.parseError) {
        mermaid.parseError(e);
      }
    }
  };
  const handleError = (error, errors, parseError) => {
    log$3.warn(error);
    if (isDetailedError(error)) {
      if (parseError) {
        parseError(error.str, error.hash);
      }
      errors.push({ ...error, message: error.str, error });
    } else {
      if (parseError) {
        parseError(error);
      }
      if (error instanceof Error) {
        errors.push({
          str: error.message,
          message: error.message,
          hash: error.name,
          error
        });
      }
    }
  };
  const initThrowsErrors = function(config2, nodes, callback) {
    const conf2 = mermaidAPI.getConfig();
    if (config2) {
      mermaid.sequenceConfig = config2;
    }
    log$3.debug(`${!callback ? "No " : ""}Callback function found`);
    let nodesToProcess;
    if (typeof nodes === "undefined") {
      nodesToProcess = document.querySelectorAll(".mermaid");
    } else if (typeof nodes === "string") {
      nodesToProcess = document.querySelectorAll(nodes);
    } else if (nodes instanceof HTMLElement) {
      nodesToProcess = [nodes];
    } else if (nodes instanceof NodeList) {
      nodesToProcess = nodes;
    } else {
      throw new Error("Invalid argument nodes for mermaid.init");
    }
    log$3.debug(`Found ${nodesToProcess.length} diagrams`);
    if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
      log$3.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
      mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
    }
    const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
    let txt;
    const errors = [];
    for (const element of Array.from(nodesToProcess)) {
      log$3.info("Rendering diagram: " + element.id);
      /*! Check if previously processed */
      if (element.getAttribute("data-processed")) {
        continue;
      }
      element.setAttribute("data-processed", "true");
      const id2 = `mermaid-${idGenerator.next()}`;
      txt = element.innerHTML;
      txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
      const init2 = utils.detectInit(txt);
      if (init2) {
        log$3.debug("Detected early reinit: ", init2);
      }
      try {
        mermaidAPI.render(
          id2,
          txt,
          (svgCode, bindFunctions2) => {
            element.innerHTML = svgCode;
            if (typeof callback !== "undefined") {
              callback(id2);
            }
            if (bindFunctions2)
              bindFunctions2(element);
          },
          element
        );
      } catch (error) {
        handleError(error, errors, mermaid.parseError);
      }
    }
    if (errors.length > 0) {
      throw errors[0];
    }
  };
  let lazyLoadingPromise = void 0;
  const registerLazyLoadedDiagrams = async (conf2) => {
    var _a;
    if (lazyLoadingPromise === void 0) {
      lazyLoadingPromise = Promise.allSettled(
        ((_a = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) != null ? _a : []).map(async (diagram) => {
          const { id: id2, detector, loadDiagram } = await import(diagram);
          addDetector(id2, detector, loadDiagram);
        })
      );
    }
    return await lazyLoadingPromise;
  };
  let loadingPromise = void 0;
  const loadExternalDiagrams = async (conf2) => {
    var _a, _b;
    if (loadingPromise === void 0) {
      log$3.debug(`Loading ${(_a = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) == null ? void 0 : _a.length} external diagrams`);
      loadingPromise = Promise.allSettled(
        ((_b = conf2 == null ? void 0 : conf2.lazyLoadedDiagrams) != null ? _b : []).map(async (url) => {
          const { id: id2, detector, loadDiagram } = await import(url);
          const { diagram } = await loadDiagram();
          registerDiagram(id2, diagram, detector, diagram.injectUtils);
        })
      );
    }
    await loadingPromise;
  };
  const initThrowsErrorsAsync = async function(config2, nodes, callback) {
    const conf2 = mermaidAPI.getConfig();
    const registerLazyLoadedDiagramsErrors = [];
    for (const registerResult of await registerLazyLoadedDiagrams(conf2)) {
      if (registerResult.status == "rejected") {
        registerLazyLoadedDiagramsErrors.push(registerResult.reason);
      }
    }
    if (config2) {
      mermaid.sequenceConfig = config2;
    }
    log$3.debug(`${!callback ? "No " : ""}Callback function found`);
    let nodesToProcess;
    if (typeof nodes === "undefined") {
      nodesToProcess = document.querySelectorAll(".mermaid");
    } else if (typeof nodes === "string") {
      nodesToProcess = document.querySelectorAll(nodes);
    } else if (nodes instanceof HTMLElement) {
      nodesToProcess = [nodes];
    } else if (nodes instanceof NodeList) {
      nodesToProcess = nodes;
    } else {
      throw new Error("Invalid argument nodes for mermaid.init");
    }
    log$3.debug(`Found ${nodesToProcess.length} diagrams`);
    if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
      log$3.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
      mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
    }
    const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
    let txt;
    const errors = [];
    for (const element of Array.from(nodesToProcess)) {
      log$3.info("Rendering diagram: " + element.id);
      /*! Check if previously processed */
      if (element.getAttribute("data-processed")) {
        continue;
      }
      element.setAttribute("data-processed", "true");
      const id2 = `mermaid-${idGenerator.next()}`;
      txt = element.innerHTML;
      txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
      const init2 = utils.detectInit(txt);
      if (init2) {
        log$3.debug("Detected early reinit: ", init2);
      }
      try {
        await mermaidAPI.renderAsync(
          id2,
          txt,
          (svgCode, bindFunctions2) => {
            element.innerHTML = svgCode;
            if (typeof callback !== "undefined") {
              callback(id2);
            }
            if (bindFunctions2)
              bindFunctions2(element);
          },
          element
        );
      } catch (error) {
        handleError(error, errors, mermaid.parseError);
      }
    }
    const allErrors = [...registerLazyLoadedDiagramsErrors, ...errors];
    if (allErrors.length > 0) {
      throw allErrors[0];
    }
  };
  const initialize = function(config2) {
    mermaidAPI.initialize(config2);
  };
  const initializeAsync = async function(config2) {
    if (config2.loadExternalDiagramsAtStartup) {
      await loadExternalDiagrams(config2);
    } else {
      await registerLazyLoadedDiagrams(config2);
    }
    mermaidAPI.initialize(config2);
  };
  const contentLoaded = function() {
    if (mermaid.startOnLoad) {
      const { startOnLoad } = mermaidAPI.getConfig();
      if (startOnLoad) {
        mermaid.init();
      }
    }
  };
  if (typeof document !== "undefined") {
    /*!
     * Wait for document loaded before starting the execution
     */
    window.addEventListener("load", contentLoaded, false);
  }
  const setParseErrorHandler = function(newParseErrorHandler) {
    mermaid.parseError = newParseErrorHandler;
  };
  const parse = (txt) => {
    return mermaidAPI.parse(txt, mermaid.parseError);
  };
  const executionQueue = [];
  let executionQueueRunning = false;
  const executeQueue = async () => {
    if (executionQueueRunning) {
      return;
    }
    executionQueueRunning = true;
    while (executionQueue.length > 0) {
      const f = executionQueue.shift();
      if (f) {
        try {
          await f();
        } catch (e) {
          log$3.error("Error executing queue", e);
        }
      }
    }
    executionQueueRunning = false;
  };
  const parseAsync = (txt) => {
    return new Promise((resolve, reject) => {
      const performCall = () => new Promise((res, rej) => {
        mermaidAPI.parseAsync(txt, mermaid.parseError).then(
          (r) => {
            res(r);
            resolve(r);
          },
          (e) => {
            log$3.error("Error parsing", e);
            rej(e);
            reject(e);
          }
        );
      });
      executionQueue.push(performCall);
      executeQueue();
    });
  };
  const renderAsync = (id2, text2, cb, container) => {
    return new Promise((resolve, reject) => {
      const performCall = () => new Promise((res, rej) => {
        mermaidAPI.renderAsync(id2, text2, cb, container).then(
          (r) => {
            res(r);
            resolve(r);
          },
          (e) => {
            log$3.error("Error parsing", e);
            rej(e);
            reject(e);
          }
        );
      });
      executionQueue.push(performCall);
      executeQueue();
    });
  };
  const mermaid = {
    startOnLoad: true,
    diagrams: {},
    mermaidAPI,
    parse,
    parseAsync,
    render: mermaidAPI.render,
    renderAsync,
    init,
    initThrowsErrors,
    initThrowsErrorsAsync,
    initialize,
    initializeAsync,
    parseError: void 0,
    contentLoaded,
    setParseErrorHandler
  };
  return mermaid;
});
